
FirstProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000030  00800200  00001ef2  00001f86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001ef2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001895  00800230  00800230  00001fb6  2**0
                  ALLOC
  3 .stab         000008a0  00000000  00000000  00001fb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  00002858  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00002a08  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000254b  00000000  00000000  00002b68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a34  00000000  00000000  000050b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000efb  00000000  00000000  00005ae7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000824  00000000  00000000  000069e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f7d  00000000  00000000  00007208  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000023af  00000000  00000000  00008185  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  0000a534  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      34:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      68:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      6c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      70:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      74:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      78:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      7c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      80:	0c 94 d8 05 	jmp	0xbb0	; 0xbb0 <__vector_32>
      84:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      88:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      8c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      90:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      94:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      98:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      9c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      ac:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      bc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      cc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      dc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      e0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 ef       	ldi	r30, 0xF2	; 242
      fc:	fe e1       	ldi	r31, 0x1E	; 30
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a0 33       	cpi	r26, 0x30	; 48
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
     10e:	1b be       	out	0x3b, r1	; 59

00000110 <__do_clear_bss>:
     110:	1a e1       	ldi	r17, 0x1A	; 26
     112:	a0 e3       	ldi	r26, 0x30	; 48
     114:	b2 e0       	ldi	r27, 0x02	; 2
     116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
     118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
     11a:	a5 3c       	cpi	r26, 0xC5	; 197
     11c:	b1 07       	cpc	r27, r17
     11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
     120:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <main>
     124:	0c 94 77 0f 	jmp	0x1eee	; 0x1eee <_exit>

00000128 <__bad_interrupt>:
     128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <vIO_init>:
* return: void
*--------------------------------------------------------*/
void vIO_init(void)
{
	// Set PortB as all outputs
	DDRB = 0xFF;
     12c:	8f ef       	ldi	r24, 0xFF	; 255
     12e:	84 b9       	out	0x04, r24	; 4
	// Turn LEDs off
	PORTB = 0xFF;
     130:	85 b9       	out	0x05, r24	; 5
     132:	08 95       	ret

00000134 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     134:	af 92       	push	r10
     136:	bf 92       	push	r11
     138:	cf 92       	push	r12
     13a:	df 92       	push	r13
     13c:	ef 92       	push	r14
     13e:	ff 92       	push	r15
     140:	0f 93       	push	r16
     142:	1f 93       	push	r17
     144:	cf 93       	push	r28
     146:	df 93       	push	r29
     148:	6c 01       	movw	r12, r24
     14a:	e6 2e       	mov	r14, r22
     14c:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     14e:	8a e1       	ldi	r24, 0x1A	; 26
     150:	90 e0       	ldi	r25, 0x00	; 0
     152:	0e 94 64 03 	call	0x6c8	; 0x6c8 <pvPortMalloc>
     156:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     158:	00 97       	sbiw	r24, 0x00	; 0
     15a:	09 f4       	brne	.+2      	; 0x15e <xCoRoutineCreate+0x2a>
     15c:	62 c0       	rjmp	.+196    	; 0x222 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     15e:	80 91 30 02 	lds	r24, 0x0230
     162:	90 91 31 02 	lds	r25, 0x0231
     166:	00 97       	sbiw	r24, 0x00	; 0
     168:	39 f5       	brne	.+78     	; 0x1b8 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     16a:	10 93 31 02 	sts	0x0231, r17
     16e:	00 93 30 02 	sts	0x0230, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     172:	c3 e3       	ldi	r28, 0x33	; 51
     174:	d2 e0       	ldi	r29, 0x02	; 2
     176:	ce 01       	movw	r24, r28
     178:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
     17c:	ce 01       	movw	r24, r28
     17e:	09 96       	adiw	r24, 0x09	; 9
     180:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     184:	c5 e4       	ldi	r28, 0x45	; 69
     186:	d2 e0       	ldi	r29, 0x02	; 2
     188:	ce 01       	movw	r24, r28
     18a:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     18e:	0f 2e       	mov	r0, r31
     190:	fe e4       	ldi	r31, 0x4E	; 78
     192:	af 2e       	mov	r10, r31
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	bf 2e       	mov	r11, r31
     198:	f0 2d       	mov	r31, r0
     19a:	c5 01       	movw	r24, r10
     19c:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     1a0:	87 e5       	ldi	r24, 0x57	; 87
     1a2:	92 e0       	ldi	r25, 0x02	; 2
     1a4:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1a8:	d0 93 61 02 	sts	0x0261, r29
     1ac:	c0 93 60 02 	sts	0x0260, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1b0:	b0 92 63 02 	sts	0x0263, r11
     1b4:	a0 92 62 02 	sts	0x0262, r10
     1b8:	ce 2d       	mov	r28, r14
     1ba:	e1 10       	cpse	r14, r1
     1bc:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1be:	f8 01       	movw	r30, r16
     1c0:	11 8e       	std	Z+25, r1	; 0x19
     1c2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1c4:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1c6:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1c8:	c1 92       	st	Z+, r12
     1ca:	d1 92       	st	Z+, r13
     1cc:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1ce:	cf 01       	movw	r24, r30
     1d0:	0e 94 aa 03 	call	0x754	; 0x754 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1d4:	c8 01       	movw	r24, r16
     1d6:	0c 96       	adiw	r24, 0x0c	; 12
     1d8:	0e 94 aa 03 	call	0x754	; 0x754 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1dc:	f8 01       	movw	r30, r16
     1de:	11 87       	std	Z+9, r17	; 0x09
     1e0:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1e2:	13 8b       	std	Z+19, r17	; 0x13
     1e4:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1e6:	84 e0       	ldi	r24, 0x04	; 4
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	8c 1b       	sub	r24, r28
     1ec:	91 09       	sbc	r25, r1
     1ee:	95 87       	std	Z+13, r25	; 0x0d
     1f0:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1f2:	86 89       	ldd	r24, Z+22	; 0x16
     1f4:	90 91 32 02 	lds	r25, 0x0232
     1f8:	98 17       	cp	r25, r24
     1fa:	10 f4       	brcc	.+4      	; 0x200 <xCoRoutineCreate+0xcc>
     1fc:	80 93 32 02 	sts	0x0232, r24
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	9c 01       	movw	r18, r24
     204:	22 0f       	add	r18, r18
     206:	33 1f       	adc	r19, r19
     208:	22 0f       	add	r18, r18
     20a:	33 1f       	adc	r19, r19
     20c:	22 0f       	add	r18, r18
     20e:	33 1f       	adc	r19, r19
     210:	82 0f       	add	r24, r18
     212:	93 1f       	adc	r25, r19
     214:	8d 5c       	subi	r24, 0xCD	; 205
     216:	9d 4f       	sbci	r25, 0xFD	; 253
     218:	b7 01       	movw	r22, r14
     21a:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>

		xReturn = pdPASS;
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	01 c0       	rjmp	.+2      	; 0x224 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     222:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     224:	df 91       	pop	r29
     226:	cf 91       	pop	r28
     228:	1f 91       	pop	r17
     22a:	0f 91       	pop	r16
     22c:	ff 90       	pop	r15
     22e:	ef 90       	pop	r14
     230:	df 90       	pop	r13
     232:	cf 90       	pop	r12
     234:	bf 90       	pop	r11
     236:	af 90       	pop	r10
     238:	08 95       	ret

0000023a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     23a:	0f 93       	push	r16
     23c:	1f 93       	push	r17
     23e:	cf 93       	push	r28
     240:	df 93       	push	r29
     242:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     244:	c0 91 64 02 	lds	r28, 0x0264
     248:	d0 91 65 02 	lds	r29, 0x0265
     24c:	c8 0f       	add	r28, r24
     24e:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     250:	80 91 30 02 	lds	r24, 0x0230
     254:	90 91 31 02 	lds	r25, 0x0231
     258:	02 96       	adiw	r24, 0x02	; 2
     25a:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     25e:	e0 91 30 02 	lds	r30, 0x0230
     262:	f0 91 31 02 	lds	r31, 0x0231
     266:	d3 83       	std	Z+3, r29	; 0x03
     268:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     26a:	80 91 64 02 	lds	r24, 0x0264
     26e:	90 91 65 02 	lds	r25, 0x0265
     272:	c8 17       	cp	r28, r24
     274:	d9 07       	cpc	r29, r25
     276:	50 f4       	brcc	.+20     	; 0x28c <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     278:	bf 01       	movw	r22, r30
     27a:	6e 5f       	subi	r22, 0xFE	; 254
     27c:	7f 4f       	sbci	r23, 0xFF	; 255
     27e:	80 91 62 02 	lds	r24, 0x0262
     282:	90 91 63 02 	lds	r25, 0x0263
     286:	0e 94 d7 03 	call	0x7ae	; 0x7ae <vListInsert>
     28a:	09 c0       	rjmp	.+18     	; 0x29e <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     28c:	bf 01       	movw	r22, r30
     28e:	6e 5f       	subi	r22, 0xFE	; 254
     290:	7f 4f       	sbci	r23, 0xFF	; 255
     292:	80 91 60 02 	lds	r24, 0x0260
     296:	90 91 61 02 	lds	r25, 0x0261
     29a:	0e 94 d7 03 	call	0x7ae	; 0x7ae <vListInsert>
	}

	if( pxEventList )
     29e:	01 15       	cp	r16, r1
     2a0:	11 05       	cpc	r17, r1
     2a2:	49 f0       	breq	.+18     	; 0x2b6 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2a4:	60 91 30 02 	lds	r22, 0x0230
     2a8:	70 91 31 02 	lds	r23, 0x0231
     2ac:	64 5f       	subi	r22, 0xF4	; 244
     2ae:	7f 4f       	sbci	r23, 0xFF	; 255
     2b0:	c8 01       	movw	r24, r16
     2b2:	0e 94 d7 03 	call	0x7ae	; 0x7ae <vListInsert>
	}
}
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	1f 91       	pop	r17
     2bc:	0f 91       	pop	r16
     2be:	08 95       	ret

000002c0 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2c0:	cf 92       	push	r12
     2c2:	df 92       	push	r13
     2c4:	ef 92       	push	r14
     2c6:	ff 92       	push	r15
     2c8:	0f 93       	push	r16
     2ca:	1f 93       	push	r17
     2cc:	cf 93       	push	r28
     2ce:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2d0:	80 91 57 02 	lds	r24, 0x0257
     2d4:	88 23       	and	r24, r24
     2d6:	b9 f1       	breq	.+110    	; 0x346 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2d8:	0f 2e       	mov	r0, r31
     2da:	fc e5       	ldi	r31, 0x5C	; 92
     2dc:	ef 2e       	mov	r14, r31
     2de:	f2 e0       	ldi	r31, 0x02	; 2
     2e0:	ff 2e       	mov	r15, r31
     2e2:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2e4:	0f 2e       	mov	r0, r31
     2e6:	f7 e5       	ldi	r31, 0x57	; 87
     2e8:	cf 2e       	mov	r12, r31
     2ea:	f2 e0       	ldi	r31, 0x02	; 2
     2ec:	df 2e       	mov	r13, r31
     2ee:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     2f0:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2f2:	d7 01       	movw	r26, r14
     2f4:	ed 91       	ld	r30, X+
     2f6:	fc 91       	ld	r31, X
     2f8:	c6 81       	ldd	r28, Z+6	; 0x06
     2fa:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     2fc:	ce 01       	movw	r24, r28
     2fe:	0c 96       	adiw	r24, 0x0c	; 12
     300:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     304:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     306:	8e 01       	movw	r16, r28
     308:	0e 5f       	subi	r16, 0xFE	; 254
     30a:	1f 4f       	sbci	r17, 0xFF	; 255
     30c:	c8 01       	movw	r24, r16
     30e:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     312:	8e 89       	ldd	r24, Y+22	; 0x16
     314:	90 91 32 02 	lds	r25, 0x0232
     318:	98 17       	cp	r25, r24
     31a:	10 f4       	brcc	.+4      	; 0x320 <vCoRoutineSchedule+0x60>
     31c:	80 93 32 02 	sts	0x0232, r24
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	9c 01       	movw	r18, r24
     324:	22 0f       	add	r18, r18
     326:	33 1f       	adc	r19, r19
     328:	22 0f       	add	r18, r18
     32a:	33 1f       	adc	r19, r19
     32c:	22 0f       	add	r18, r18
     32e:	33 1f       	adc	r19, r19
     330:	82 0f       	add	r24, r18
     332:	93 1f       	adc	r25, r19
     334:	8d 5c       	subi	r24, 0xCD	; 205
     336:	9d 4f       	sbci	r25, 0xFD	; 253
     338:	b8 01       	movw	r22, r16
     33a:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     33e:	f6 01       	movw	r30, r12
     340:	80 81       	ld	r24, Z
     342:	88 23       	and	r24, r24
     344:	a9 f6       	brne	.-86     	; 0x2f0 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     346:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <xTaskGetTickCount>
     34a:	20 91 66 02 	lds	r18, 0x0266
     34e:	30 91 67 02 	lds	r19, 0x0267
     352:	82 1b       	sub	r24, r18
     354:	93 0b       	sbc	r25, r19
     356:	90 93 69 02 	sts	0x0269, r25
     35a:	80 93 68 02 	sts	0x0268, r24
     35e:	74 c0       	rjmp	.+232    	; 0x448 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     360:	20 91 64 02 	lds	r18, 0x0264
     364:	30 91 65 02 	lds	r19, 0x0265
     368:	2f 5f       	subi	r18, 0xFF	; 255
     36a:	3f 4f       	sbci	r19, 0xFF	; 255
     36c:	30 93 65 02 	sts	0x0265, r19
     370:	20 93 64 02 	sts	0x0264, r18
		xPassedTicks--;
     374:	01 97       	sbiw	r24, 0x01	; 1
     376:	90 93 69 02 	sts	0x0269, r25
     37a:	80 93 68 02 	sts	0x0268, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     37e:	21 15       	cp	r18, r1
     380:	31 05       	cpc	r19, r1
     382:	81 f4       	brne	.+32     	; 0x3a4 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     384:	80 91 60 02 	lds	r24, 0x0260
     388:	90 91 61 02 	lds	r25, 0x0261
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     38c:	20 91 62 02 	lds	r18, 0x0262
     390:	30 91 63 02 	lds	r19, 0x0263
     394:	30 93 61 02 	sts	0x0261, r19
     398:	20 93 60 02 	sts	0x0260, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     39c:	90 93 63 02 	sts	0x0263, r25
     3a0:	80 93 62 02 	sts	0x0262, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3a4:	e0 91 60 02 	lds	r30, 0x0260
     3a8:	f0 91 61 02 	lds	r31, 0x0261
     3ac:	80 81       	ld	r24, Z
     3ae:	88 23       	and	r24, r24
     3b0:	09 f4       	brne	.+2      	; 0x3b4 <vCoRoutineSchedule+0xf4>
     3b2:	4a c0       	rjmp	.+148    	; 0x448 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3b4:	05 80       	ldd	r0, Z+5	; 0x05
     3b6:	f6 81       	ldd	r31, Z+6	; 0x06
     3b8:	e0 2d       	mov	r30, r0
     3ba:	c6 81       	ldd	r28, Z+6	; 0x06
     3bc:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3be:	2a 81       	ldd	r18, Y+2	; 0x02
     3c0:	3b 81       	ldd	r19, Y+3	; 0x03
     3c2:	80 91 64 02 	lds	r24, 0x0264
     3c6:	90 91 65 02 	lds	r25, 0x0265
     3ca:	82 17       	cp	r24, r18
     3cc:	93 07       	cpc	r25, r19
     3ce:	78 f4       	brcc	.+30     	; 0x3ee <vCoRoutineSchedule+0x12e>
     3d0:	3b c0       	rjmp	.+118    	; 0x448 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3d2:	05 80       	ldd	r0, Z+5	; 0x05
     3d4:	f6 81       	ldd	r31, Z+6	; 0x06
     3d6:	e0 2d       	mov	r30, r0
     3d8:	c6 81       	ldd	r28, Z+6	; 0x06
     3da:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3dc:	2a 81       	ldd	r18, Y+2	; 0x02
     3de:	3b 81       	ldd	r19, Y+3	; 0x03
     3e0:	80 91 64 02 	lds	r24, 0x0264
     3e4:	90 91 65 02 	lds	r25, 0x0265
     3e8:	82 17       	cp	r24, r18
     3ea:	93 07       	cpc	r25, r19
     3ec:	68 f1       	brcs	.+90     	; 0x448 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3ee:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
     3f0:	8e 01       	movw	r16, r28
     3f2:	0e 5f       	subi	r16, 0xFE	; 254
     3f4:	1f 4f       	sbci	r17, 0xFF	; 255
     3f6:	c8 01       	movw	r24, r16
     3f8:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3fc:	8c 89       	ldd	r24, Y+20	; 0x14
     3fe:	9d 89       	ldd	r25, Y+21	; 0x15
     400:	00 97       	sbiw	r24, 0x00	; 0
     402:	21 f0       	breq	.+8      	; 0x40c <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
     404:	ce 01       	movw	r24, r28
     406:	0c 96       	adiw	r24, 0x0c	; 12
     408:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     40c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     40e:	8e 89       	ldd	r24, Y+22	; 0x16
     410:	90 91 32 02 	lds	r25, 0x0232
     414:	98 17       	cp	r25, r24
     416:	10 f4       	brcc	.+4      	; 0x41c <vCoRoutineSchedule+0x15c>
     418:	80 93 32 02 	sts	0x0232, r24
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	9c 01       	movw	r18, r24
     420:	22 0f       	add	r18, r18
     422:	33 1f       	adc	r19, r19
     424:	22 0f       	add	r18, r18
     426:	33 1f       	adc	r19, r19
     428:	22 0f       	add	r18, r18
     42a:	33 1f       	adc	r19, r19
     42c:	82 0f       	add	r24, r18
     42e:	93 1f       	adc	r25, r19
     430:	8d 5c       	subi	r24, 0xCD	; 205
     432:	9d 4f       	sbci	r25, 0xFD	; 253
     434:	b8 01       	movw	r22, r16
     436:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     43a:	e0 91 60 02 	lds	r30, 0x0260
     43e:	f0 91 61 02 	lds	r31, 0x0261
     442:	80 81       	ld	r24, Z
     444:	88 23       	and	r24, r24
     446:	29 f6       	brne	.-118    	; 0x3d2 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     448:	80 91 68 02 	lds	r24, 0x0268
     44c:	90 91 69 02 	lds	r25, 0x0269
     450:	00 97       	sbiw	r24, 0x00	; 0
     452:	09 f0       	breq	.+2      	; 0x456 <vCoRoutineSchedule+0x196>
     454:	85 cf       	rjmp	.-246    	; 0x360 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     456:	80 91 64 02 	lds	r24, 0x0264
     45a:	90 91 65 02 	lds	r25, 0x0265
     45e:	90 93 67 02 	sts	0x0267, r25
     462:	80 93 66 02 	sts	0x0266, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     466:	20 91 32 02 	lds	r18, 0x0232
     46a:	82 2f       	mov	r24, r18
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	fc 01       	movw	r30, r24
     470:	ee 0f       	add	r30, r30
     472:	ff 1f       	adc	r31, r31
     474:	ee 0f       	add	r30, r30
     476:	ff 1f       	adc	r31, r31
     478:	ee 0f       	add	r30, r30
     47a:	ff 1f       	adc	r31, r31
     47c:	e8 0f       	add	r30, r24
     47e:	f9 1f       	adc	r31, r25
     480:	ed 5c       	subi	r30, 0xCD	; 205
     482:	fd 4f       	sbci	r31, 0xFD	; 253
     484:	30 81       	ld	r19, Z
     486:	33 23       	and	r19, r19
     488:	d9 f4       	brne	.+54     	; 0x4c0 <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     48a:	22 23       	and	r18, r18
     48c:	31 f4       	brne	.+12     	; 0x49a <vCoRoutineSchedule+0x1da>
     48e:	47 c0       	rjmp	.+142    	; 0x51e <vCoRoutineSchedule+0x25e>
     490:	22 23       	and	r18, r18
     492:	19 f4       	brne	.+6      	; 0x49a <vCoRoutineSchedule+0x1da>
     494:	20 93 32 02 	sts	0x0232, r18
     498:	42 c0       	rjmp	.+132    	; 0x51e <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     49a:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     49c:	82 2f       	mov	r24, r18
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	fc 01       	movw	r30, r24
     4a2:	ee 0f       	add	r30, r30
     4a4:	ff 1f       	adc	r31, r31
     4a6:	ee 0f       	add	r30, r30
     4a8:	ff 1f       	adc	r31, r31
     4aa:	ee 0f       	add	r30, r30
     4ac:	ff 1f       	adc	r31, r31
     4ae:	e8 0f       	add	r30, r24
     4b0:	f9 1f       	adc	r31, r25
     4b2:	ed 5c       	subi	r30, 0xCD	; 205
     4b4:	fd 4f       	sbci	r31, 0xFD	; 253
     4b6:	30 81       	ld	r19, Z
     4b8:	33 23       	and	r19, r19
     4ba:	51 f3       	breq	.-44     	; 0x490 <vCoRoutineSchedule+0x1d0>
     4bc:	20 93 32 02 	sts	0x0232, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4c0:	fc 01       	movw	r30, r24
     4c2:	ee 0f       	add	r30, r30
     4c4:	ff 1f       	adc	r31, r31
     4c6:	ee 0f       	add	r30, r30
     4c8:	ff 1f       	adc	r31, r31
     4ca:	ee 0f       	add	r30, r30
     4cc:	ff 1f       	adc	r31, r31
     4ce:	8e 0f       	add	r24, r30
     4d0:	9f 1f       	adc	r25, r31
     4d2:	fc 01       	movw	r30, r24
     4d4:	ed 5c       	subi	r30, 0xCD	; 205
     4d6:	fd 4f       	sbci	r31, 0xFD	; 253
     4d8:	a1 81       	ldd	r26, Z+1	; 0x01
     4da:	b2 81       	ldd	r27, Z+2	; 0x02
     4dc:	12 96       	adiw	r26, 0x02	; 2
     4de:	0d 90       	ld	r0, X+
     4e0:	bc 91       	ld	r27, X
     4e2:	a0 2d       	mov	r26, r0
     4e4:	b2 83       	std	Z+2, r27	; 0x02
     4e6:	a1 83       	std	Z+1, r26	; 0x01
     4e8:	cf 01       	movw	r24, r30
     4ea:	03 96       	adiw	r24, 0x03	; 3
     4ec:	a8 17       	cp	r26, r24
     4ee:	b9 07       	cpc	r27, r25
     4f0:	31 f4       	brne	.+12     	; 0x4fe <vCoRoutineSchedule+0x23e>
     4f2:	12 96       	adiw	r26, 0x02	; 2
     4f4:	8d 91       	ld	r24, X+
     4f6:	9c 91       	ld	r25, X
     4f8:	13 97       	sbiw	r26, 0x03	; 3
     4fa:	92 83       	std	Z+2, r25	; 0x02
     4fc:	81 83       	std	Z+1, r24	; 0x01
     4fe:	01 80       	ldd	r0, Z+1	; 0x01
     500:	f2 81       	ldd	r31, Z+2	; 0x02
     502:	e0 2d       	mov	r30, r0
     504:	a6 81       	ldd	r26, Z+6	; 0x06
     506:	b7 81       	ldd	r27, Z+7	; 0x07
     508:	b0 93 31 02 	sts	0x0231, r27
     50c:	a0 93 30 02 	sts	0x0230, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     510:	ed 91       	ld	r30, X+
     512:	fc 91       	ld	r31, X
     514:	11 97       	sbiw	r26, 0x01	; 1
     516:	cd 01       	movw	r24, r26
     518:	57 96       	adiw	r26, 0x17	; 23
     51a:	6c 91       	ld	r22, X
     51c:	19 95       	eicall

	return;
}
     51e:	df 91       	pop	r29
     520:	cf 91       	pop	r28
     522:	1f 91       	pop	r17
     524:	0f 91       	pop	r16
     526:	ff 90       	pop	r15
     528:	ef 90       	pop	r14
     52a:	df 90       	pop	r13
     52c:	cf 90       	pop	r12
     52e:	08 95       	ret

00000530 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     530:	0f 93       	push	r16
     532:	1f 93       	push	r17
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     538:	dc 01       	movw	r26, r24
     53a:	15 96       	adiw	r26, 0x05	; 5
     53c:	ed 91       	ld	r30, X+
     53e:	fc 91       	ld	r31, X
     540:	16 97       	sbiw	r26, 0x06	; 6
     542:	06 81       	ldd	r16, Z+6	; 0x06
     544:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     546:	e8 01       	movw	r28, r16
     548:	2c 96       	adiw	r28, 0x0c	; 12
     54a:	ce 01       	movw	r24, r28
     54c:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     550:	87 e5       	ldi	r24, 0x57	; 87
     552:	92 e0       	ldi	r25, 0x02	; 2
     554:	be 01       	movw	r22, r28
     556:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     55a:	e0 91 30 02 	lds	r30, 0x0230
     55e:	f0 91 31 02 	lds	r31, 0x0231
	{
		xReturn = pdTRUE;
     562:	81 e0       	ldi	r24, 0x01	; 1
     564:	d8 01       	movw	r26, r16
     566:	56 96       	adiw	r26, 0x16	; 22
     568:	2c 91       	ld	r18, X
     56a:	56 97       	sbiw	r26, 0x16	; 22
     56c:	96 89       	ldd	r25, Z+22	; 0x16
     56e:	29 17       	cp	r18, r25
     570:	08 f4       	brcc	.+2      	; 0x574 <xCoRoutineRemoveFromEventList+0x44>
     572:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	08 95       	ret

0000057e <vTaskFunction_LEDToggle>:
*          frequency.
*
* return: void
*--------------------------------------------------------*/
void vTaskFunction_LEDToggle(void *pvLED_blink_specs)
{
     57e:	cf 93       	push	r28
     580:	df 93       	push	r29
     582:	0f 92       	push	r0
     584:	0f 92       	push	r0
     586:	cd b7       	in	r28, 0x3d	; 61
     588:	de b7       	in	r29, 0x3e	; 62
     58a:	6c 01       	movw	r12, r24
	// variable to hold ticks value of last task run
	portTickType xLastWakeTime;
	// pointer to the value that describes which LED to toggle
	uint16_t *LED_num = (unsigned char *) pvLED_blink_specs; 
	// delay value in ms corresponding to a given toggle frequency
	uint16_t LED_delay_ms = *(LED_num +1);
     58c:	fc 01       	movw	r30, r24
     58e:	02 81       	ldd	r16, Z+2	; 0x02
     590:	13 81       	ldd	r17, Z+3	; 0x03
	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
     592:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <xTaskGetTickCount>
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	for (;;)  
	{
		// toggle the LED pin
		PORTB ^= (1<<*LED_num);
		// periodically run every 'LED_delay_ms' milliseconds
		vTaskDelayUntil(&xLastWakeTime, LED_delay_ms/portTICK_RATE_MS);
     59a:	78 01       	movw	r14, r16
     59c:	f6 94       	lsr	r15
     59e:	e7 94       	ror	r14
	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
	for (;;)  
	{
		// toggle the LED pin
		PORTB ^= (1<<*LED_num);
     5a0:	01 e0       	ldi	r16, 0x01	; 1
     5a2:	10 e0       	ldi	r17, 0x00	; 0
     5a4:	25 b1       	in	r18, 0x05	; 5
     5a6:	c8 01       	movw	r24, r16
     5a8:	f6 01       	movw	r30, r12
     5aa:	00 80       	ld	r0, Z
     5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <vTaskFunction_LEDToggle+0x34>
     5ae:	88 0f       	add	r24, r24
     5b0:	99 1f       	adc	r25, r25
     5b2:	0a 94       	dec	r0
     5b4:	e2 f7       	brpl	.-8      	; 0x5ae <vTaskFunction_LEDToggle+0x30>
     5b6:	82 27       	eor	r24, r18
     5b8:	85 b9       	out	0x05, r24	; 5
		// periodically run every 'LED_delay_ms' milliseconds
		vTaskDelayUntil(&xLastWakeTime, LED_delay_ms/portTICK_RATE_MS);
     5ba:	ce 01       	movw	r24, r28
     5bc:	01 96       	adiw	r24, 0x01	; 1
     5be:	b7 01       	movw	r22, r14
     5c0:	0e 94 f3 0c 	call	0x19e6	; 0x19e6 <vTaskDelayUntil>
     5c4:	ef cf       	rjmp	.-34     	; 0x5a4 <vTaskFunction_LEDToggle+0x26>

000005c6 <main>:
//-----------------Function Prototypes-------------------//
void vTaskFunction_LEDToggle(void *pvLED_blink_specs); 

//-------------------Main Function-----------------------//
int main( void )
{  	
     5c6:	8f 92       	push	r8
     5c8:	9f 92       	push	r9
     5ca:	af 92       	push	r10
     5cc:	bf 92       	push	r11
     5ce:	cf 92       	push	r12
     5d0:	df 92       	push	r13
     5d2:	ef 92       	push	r14
     5d4:	ff 92       	push	r15
     5d6:	0f 93       	push	r16
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	60 97       	sbiw	r28, 0x10	; 16
     5e2:	0f b6       	in	r0, 0x3f	; 63
     5e4:	f8 94       	cli
     5e6:	de bf       	out	0x3e, r29	; 62
     5e8:	0f be       	out	0x3f, r0	; 63
     5ea:	cd bf       	out	0x3d, r28	; 61
    //variable definitions: arrays; element 1 is the LED
	//						position in PORTB, element 2
	//                      is the number of milliseconds
	//                      delay needed for each blink
	//                      frequency
	uint16_t LED0[2] = {0, DELAY_MS_1HZ}; 
     5ec:	1a 82       	std	Y+2, r1	; 0x02
     5ee:	19 82       	std	Y+1, r1	; 0x01
     5f0:	84 ef       	ldi	r24, 0xF4	; 244
     5f2:	91 e0       	ldi	r25, 0x01	; 1
     5f4:	9c 83       	std	Y+4, r25	; 0x04
     5f6:	8b 83       	std	Y+3, r24	; 0x03
	uint16_t LED2[2] = {2, DELAY_MS_2HZ}; 
     5f8:	82 e0       	ldi	r24, 0x02	; 2
     5fa:	90 e0       	ldi	r25, 0x00	; 0
     5fc:	9e 83       	std	Y+6, r25	; 0x06
     5fe:	8d 83       	std	Y+5, r24	; 0x05
     600:	8a ef       	ldi	r24, 0xFA	; 250
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	98 87       	std	Y+8, r25	; 0x08
     606:	8f 83       	std	Y+7, r24	; 0x07
	uint16_t LED4[2] = {4, DELAY_MS_4HZ}; 
     608:	84 e0       	ldi	r24, 0x04	; 4
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	9a 87       	std	Y+10, r25	; 0x0a
     60e:	89 87       	std	Y+9, r24	; 0x09
     610:	8d e7       	ldi	r24, 0x7D	; 125
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	9c 87       	std	Y+12, r25	; 0x0c
     616:	8b 87       	std	Y+11, r24	; 0x0b
	uint16_t LED6[2] = {6, DELAY_MS_8HZ}; 
     618:	86 e0       	ldi	r24, 0x06	; 6
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	9e 87       	std	Y+14, r25	; 0x0e
     61e:	8d 87       	std	Y+13, r24	; 0x0d
     620:	8f e3       	ldi	r24, 0x3F	; 63
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	98 8b       	std	Y+16, r25	; 0x10
     626:	8f 87       	std	Y+15, r24	; 0x0f
	
    // Function initializing PORTB as an output and setting LEDs low
	vIO_init(); 
     628:	0e 94 96 00 	call	0x12c	; 0x12c <vIO_init>


	// Four instances of the same task function created to blink the 4 LEDs
	xTaskCreate(vTaskFunction_LEDToggle, "LED0 Task", configMINIMAL_STACK_SIZE, (void *) LED0, 1, NULL );
     62c:	0f 2e       	mov	r0, r31
     62e:	ff eb       	ldi	r31, 0xBF	; 191
     630:	8f 2e       	mov	r8, r31
     632:	f2 e0       	ldi	r31, 0x02	; 2
     634:	9f 2e       	mov	r9, r31
     636:	f0 2d       	mov	r31, r0
     638:	c4 01       	movw	r24, r8
     63a:	60 e0       	ldi	r22, 0x00	; 0
     63c:	72 e0       	ldi	r23, 0x02	; 2
     63e:	45 e5       	ldi	r20, 0x55	; 85
     640:	50 e0       	ldi	r21, 0x00	; 0
     642:	9e 01       	movw	r18, r28
     644:	2f 5f       	subi	r18, 0xFF	; 255
     646:	3f 4f       	sbci	r19, 0xFF	; 255
     648:	01 e0       	ldi	r16, 0x01	; 1
     64a:	ee 24       	eor	r14, r14
     64c:	ff 24       	eor	r15, r15
     64e:	cc 24       	eor	r12, r12
     650:	dd 24       	eor	r13, r13
     652:	aa 24       	eor	r10, r10
     654:	bb 24       	eor	r11, r11
     656:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGenericCreate>
	xTaskCreate(vTaskFunction_LEDToggle, "LED2 Task", configMINIMAL_STACK_SIZE, (void *) LED2, 2, NULL );
     65a:	c4 01       	movw	r24, r8
     65c:	6a e0       	ldi	r22, 0x0A	; 10
     65e:	72 e0       	ldi	r23, 0x02	; 2
     660:	45 e5       	ldi	r20, 0x55	; 85
     662:	50 e0       	ldi	r21, 0x00	; 0
     664:	9e 01       	movw	r18, r28
     666:	2b 5f       	subi	r18, 0xFB	; 251
     668:	3f 4f       	sbci	r19, 0xFF	; 255
     66a:	02 e0       	ldi	r16, 0x02	; 2
     66c:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGenericCreate>
	xTaskCreate(vTaskFunction_LEDToggle, "LED4 Task", configMINIMAL_STACK_SIZE, (void *) LED4, 3, NULL );
     670:	c4 01       	movw	r24, r8
     672:	64 e1       	ldi	r22, 0x14	; 20
     674:	72 e0       	ldi	r23, 0x02	; 2
     676:	45 e5       	ldi	r20, 0x55	; 85
     678:	50 e0       	ldi	r21, 0x00	; 0
     67a:	9e 01       	movw	r18, r28
     67c:	27 5f       	subi	r18, 0xF7	; 247
     67e:	3f 4f       	sbci	r19, 0xFF	; 255
     680:	03 e0       	ldi	r16, 0x03	; 3
     682:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGenericCreate>
	xTaskCreate(vTaskFunction_LEDToggle, "LED6 Task", configMINIMAL_STACK_SIZE, (void *) LED6, 4, NULL );
     686:	c4 01       	movw	r24, r8
     688:	6e e1       	ldi	r22, 0x1E	; 30
     68a:	72 e0       	ldi	r23, 0x02	; 2
     68c:	45 e5       	ldi	r20, 0x55	; 85
     68e:	50 e0       	ldi	r21, 0x00	; 0
     690:	9e 01       	movw	r18, r28
     692:	23 5f       	subi	r18, 0xF3	; 243
     694:	3f 4f       	sbci	r19, 0xFF	; 255
     696:	04 e0       	ldi	r16, 0x04	; 4
     698:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGenericCreate>

    // Start the task scheduler
	vTaskStartScheduler();
     69c:	0e 94 34 0b 	call	0x1668	; 0x1668 <vTaskStartScheduler>

	return 0;
}
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	60 96       	adiw	r28, 0x10	; 16
     6a6:	0f b6       	in	r0, 0x3f	; 63
     6a8:	f8 94       	cli
     6aa:	de bf       	out	0x3e, r29	; 62
     6ac:	0f be       	out	0x3f, r0	; 63
     6ae:	cd bf       	out	0x3d, r28	; 61
     6b0:	df 91       	pop	r29
     6b2:	cf 91       	pop	r28
     6b4:	0f 91       	pop	r16
     6b6:	ff 90       	pop	r15
     6b8:	ef 90       	pop	r14
     6ba:	df 90       	pop	r13
     6bc:	cf 90       	pop	r12
     6be:	bf 90       	pop	r11
     6c0:	af 90       	pop	r10
     6c2:	9f 90       	pop	r9
     6c4:	8f 90       	pop	r8
     6c6:	08 95       	ret

000006c8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6c8:	0f 93       	push	r16
     6ca:	1f 93       	push	r17
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     6d2:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     6d6:	00 91 6a 02 	lds	r16, 0x026A
     6da:	10 91 6b 02 	lds	r17, 0x026B
     6de:	c0 0f       	add	r28, r16
     6e0:	d1 1f       	adc	r29, r17
     6e2:	88 e1       	ldi	r24, 0x18	; 24
     6e4:	c0 30       	cpi	r28, 0x00	; 0
     6e6:	d8 07       	cpc	r29, r24
     6e8:	50 f4       	brcc	.+20     	; 0x6fe <pvPortMalloc+0x36>
     6ea:	0c 17       	cp	r16, r28
     6ec:	1d 07       	cpc	r17, r29
     6ee:	50 f4       	brcc	.+20     	; 0x704 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     6f0:	04 59       	subi	r16, 0x94	; 148
     6f2:	1d 4f       	sbci	r17, 0xFD	; 253
			xNextFreeByte += xWantedSize;
     6f4:	d0 93 6b 02 	sts	0x026B, r29
     6f8:	c0 93 6a 02 	sts	0x026A, r28
     6fc:	05 c0       	rjmp	.+10     	; 0x708 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6fe:	00 e0       	ldi	r16, 0x00	; 0
     700:	10 e0       	ldi	r17, 0x00	; 0
     702:	02 c0       	rjmp	.+4      	; 0x708 <pvPortMalloc+0x40>
     704:	00 e0       	ldi	r16, 0x00	; 0
     706:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
     708:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     70c:	80 2f       	mov	r24, r16
     70e:	91 2f       	mov	r25, r17
     710:	df 91       	pop	r29
     712:	cf 91       	pop	r28
     714:	1f 91       	pop	r17
     716:	0f 91       	pop	r16
     718:	08 95       	ret

0000071a <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     71a:	08 95       	ret

0000071c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     71c:	10 92 6b 02 	sts	0x026B, r1
     720:	10 92 6a 02 	sts	0x026A, r1
}
     724:	08 95       	ret

00000726 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     726:	20 91 6a 02 	lds	r18, 0x026A
     72a:	30 91 6b 02 	lds	r19, 0x026B
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	98 e1       	ldi	r25, 0x18	; 24
     732:	82 1b       	sub	r24, r18
     734:	93 0b       	sbc	r25, r19
}
     736:	08 95       	ret

00000738 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     738:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     73a:	03 96       	adiw	r24, 0x03	; 3
     73c:	92 83       	std	Z+2, r25	; 0x02
     73e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     740:	2f ef       	ldi	r18, 0xFF	; 255
     742:	3f ef       	ldi	r19, 0xFF	; 255
     744:	34 83       	std	Z+4, r19	; 0x04
     746:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     748:	96 83       	std	Z+6, r25	; 0x06
     74a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     74c:	90 87       	std	Z+8, r25	; 0x08
     74e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     750:	10 82       	st	Z, r1
}
     752:	08 95       	ret

00000754 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     754:	fc 01       	movw	r30, r24
     756:	11 86       	std	Z+9, r1	; 0x09
     758:	10 86       	std	Z+8, r1	; 0x08
}
     75a:	08 95       	ret

0000075c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	ec 01       	movw	r28, r24
     762:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     764:	89 81       	ldd	r24, Y+1	; 0x01
     766:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     768:	dc 01       	movw	r26, r24
     76a:	12 96       	adiw	r26, 0x02	; 2
     76c:	2d 91       	ld	r18, X+
     76e:	3c 91       	ld	r19, X
     770:	13 97       	sbiw	r26, 0x03	; 3
     772:	33 83       	std	Z+3, r19	; 0x03
     774:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     776:	29 81       	ldd	r18, Y+1	; 0x01
     778:	3a 81       	ldd	r19, Y+2	; 0x02
     77a:	35 83       	std	Z+5, r19	; 0x05
     77c:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     77e:	12 96       	adiw	r26, 0x02	; 2
     780:	2d 91       	ld	r18, X+
     782:	3c 91       	ld	r19, X
     784:	13 97       	sbiw	r26, 0x03	; 3
     786:	d9 01       	movw	r26, r18
     788:	15 96       	adiw	r26, 0x05	; 5
     78a:	7c 93       	st	X, r23
     78c:	6e 93       	st	-X, r22
     78e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     790:	dc 01       	movw	r26, r24
     792:	13 96       	adiw	r26, 0x03	; 3
     794:	7c 93       	st	X, r23
     796:	6e 93       	st	-X, r22
     798:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     79a:	7a 83       	std	Y+2, r23	; 0x02
     79c:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     79e:	d1 87       	std	Z+9, r29	; 0x09
     7a0:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     7a2:	88 81       	ld	r24, Y
     7a4:	8f 5f       	subi	r24, 0xFF	; 255
     7a6:	88 83       	st	Y, r24
}
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	08 95       	ret

000007ae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	ac 01       	movw	r20, r24
     7b4:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     7b6:	28 81       	ld	r18, Y
     7b8:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     7ba:	8f ef       	ldi	r24, 0xFF	; 255
     7bc:	2f 3f       	cpi	r18, 0xFF	; 255
     7be:	38 07       	cpc	r19, r24
     7c0:	21 f4       	brne	.+8      	; 0x7ca <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     7c2:	fa 01       	movw	r30, r20
     7c4:	a7 81       	ldd	r26, Z+7	; 0x07
     7c6:	b0 85       	ldd	r27, Z+8	; 0x08
     7c8:	18 c0       	rjmp	.+48     	; 0x7fa <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     7ca:	da 01       	movw	r26, r20
     7cc:	13 96       	adiw	r26, 0x03	; 3
     7ce:	fa 01       	movw	r30, r20
     7d0:	85 81       	ldd	r24, Z+5	; 0x05
     7d2:	96 81       	ldd	r25, Z+6	; 0x06
     7d4:	fc 01       	movw	r30, r24
     7d6:	80 81       	ld	r24, Z
     7d8:	91 81       	ldd	r25, Z+1	; 0x01
     7da:	28 17       	cp	r18, r24
     7dc:	39 07       	cpc	r19, r25
     7de:	68 f0       	brcs	.+26     	; 0x7fa <vListInsert+0x4c>
     7e0:	12 96       	adiw	r26, 0x02	; 2
     7e2:	0d 90       	ld	r0, X+
     7e4:	bc 91       	ld	r27, X
     7e6:	a0 2d       	mov	r26, r0
     7e8:	12 96       	adiw	r26, 0x02	; 2
     7ea:	ed 91       	ld	r30, X+
     7ec:	fc 91       	ld	r31, X
     7ee:	13 97       	sbiw	r26, 0x03	; 3
     7f0:	80 81       	ld	r24, Z
     7f2:	91 81       	ldd	r25, Z+1	; 0x01
     7f4:	28 17       	cp	r18, r24
     7f6:	39 07       	cpc	r19, r25
     7f8:	98 f7       	brcc	.-26     	; 0x7e0 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     7fa:	12 96       	adiw	r26, 0x02	; 2
     7fc:	ed 91       	ld	r30, X+
     7fe:	fc 91       	ld	r31, X
     800:	13 97       	sbiw	r26, 0x03	; 3
     802:	fb 83       	std	Y+3, r31	; 0x03
     804:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     806:	d5 83       	std	Z+5, r29	; 0x05
     808:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     80a:	bd 83       	std	Y+5, r27	; 0x05
     80c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     80e:	13 96       	adiw	r26, 0x03	; 3
     810:	dc 93       	st	X, r29
     812:	ce 93       	st	-X, r28
     814:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     816:	59 87       	std	Y+9, r21	; 0x09
     818:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     81a:	fa 01       	movw	r30, r20
     81c:	80 81       	ld	r24, Z
     81e:	8f 5f       	subi	r24, 0xFF	; 255
     820:	80 83       	st	Z, r24
}
     822:	df 91       	pop	r29
     824:	cf 91       	pop	r28
     826:	08 95       	ret

00000828 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     828:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     82a:	a2 81       	ldd	r26, Z+2	; 0x02
     82c:	b3 81       	ldd	r27, Z+3	; 0x03
     82e:	84 81       	ldd	r24, Z+4	; 0x04
     830:	95 81       	ldd	r25, Z+5	; 0x05
     832:	15 96       	adiw	r26, 0x05	; 5
     834:	9c 93       	st	X, r25
     836:	8e 93       	st	-X, r24
     838:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     83a:	a4 81       	ldd	r26, Z+4	; 0x04
     83c:	b5 81       	ldd	r27, Z+5	; 0x05
     83e:	82 81       	ldd	r24, Z+2	; 0x02
     840:	93 81       	ldd	r25, Z+3	; 0x03
     842:	13 96       	adiw	r26, 0x03	; 3
     844:	9c 93       	st	X, r25
     846:	8e 93       	st	-X, r24
     848:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     84a:	a0 85       	ldd	r26, Z+8	; 0x08
     84c:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     84e:	11 96       	adiw	r26, 0x01	; 1
     850:	8d 91       	ld	r24, X+
     852:	9c 91       	ld	r25, X
     854:	12 97       	sbiw	r26, 0x02	; 2
     856:	8e 17       	cp	r24, r30
     858:	9f 07       	cpc	r25, r31
     85a:	31 f4       	brne	.+12     	; 0x868 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     85c:	84 81       	ldd	r24, Z+4	; 0x04
     85e:	95 81       	ldd	r25, Z+5	; 0x05
     860:	12 96       	adiw	r26, 0x02	; 2
     862:	9c 93       	st	X, r25
     864:	8e 93       	st	-X, r24
     866:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     868:	11 86       	std	Z+9, r1	; 0x09
     86a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     86c:	8c 91       	ld	r24, X
     86e:	81 50       	subi	r24, 0x01	; 1
     870:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     872:	8c 91       	ld	r24, X
}
     874:	08 95       	ret

00000876 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     876:	21 e1       	ldi	r18, 0x11	; 17
     878:	fc 01       	movw	r30, r24
     87a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     87c:	31 97       	sbiw	r30, 0x01	; 1
     87e:	32 e2       	ldi	r19, 0x22	; 34
     880:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     882:	fc 01       	movw	r30, r24
     884:	32 97       	sbiw	r30, 0x02	; 2
     886:	a3 e3       	ldi	r26, 0x33	; 51
     888:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     88a:	fc 01       	movw	r30, r24
     88c:	33 97       	sbiw	r30, 0x03	; 3
     88e:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     890:	fc 01       	movw	r30, r24
     892:	34 97       	sbiw	r30, 0x04	; 4
     894:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     896:	fc 01       	movw	r30, r24
     898:	35 97       	sbiw	r30, 0x05	; 5
     89a:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     89c:	fc 01       	movw	r30, r24
     89e:	36 97       	sbiw	r30, 0x06	; 6
     8a0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     8a2:	fc 01       	movw	r30, r24
     8a4:	37 97       	sbiw	r30, 0x07	; 7
     8a6:	60 e8       	ldi	r22, 0x80	; 128
     8a8:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     8aa:	fc 01       	movw	r30, r24
     8ac:	38 97       	sbiw	r30, 0x08	; 8
     8ae:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     8b0:	fc 01       	movw	r30, r24
     8b2:	39 97       	sbiw	r30, 0x09	; 9
     8b4:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     8b6:	fc 01       	movw	r30, r24
     8b8:	3a 97       	sbiw	r30, 0x0a	; 10
     8ba:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     8bc:	fc 01       	movw	r30, r24
     8be:	3b 97       	sbiw	r30, 0x0b	; 11
     8c0:	62 e0       	ldi	r22, 0x02	; 2
     8c2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     8c4:	fc 01       	movw	r30, r24
     8c6:	3c 97       	sbiw	r30, 0x0c	; 12
     8c8:	63 e0       	ldi	r22, 0x03	; 3
     8ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     8cc:	fc 01       	movw	r30, r24
     8ce:	3d 97       	sbiw	r30, 0x0d	; 13
     8d0:	64 e0       	ldi	r22, 0x04	; 4
     8d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     8d4:	fc 01       	movw	r30, r24
     8d6:	3e 97       	sbiw	r30, 0x0e	; 14
     8d8:	65 e0       	ldi	r22, 0x05	; 5
     8da:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     8dc:	fc 01       	movw	r30, r24
     8de:	3f 97       	sbiw	r30, 0x0f	; 15
     8e0:	66 e0       	ldi	r22, 0x06	; 6
     8e2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     8e4:	fc 01       	movw	r30, r24
     8e6:	70 97       	sbiw	r30, 0x10	; 16
     8e8:	67 e0       	ldi	r22, 0x07	; 7
     8ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     8ec:	fc 01       	movw	r30, r24
     8ee:	71 97       	sbiw	r30, 0x11	; 17
     8f0:	68 e0       	ldi	r22, 0x08	; 8
     8f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     8f4:	fc 01       	movw	r30, r24
     8f6:	72 97       	sbiw	r30, 0x12	; 18
     8f8:	69 e0       	ldi	r22, 0x09	; 9
     8fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     8fc:	fc 01       	movw	r30, r24
     8fe:	73 97       	sbiw	r30, 0x13	; 19
     900:	60 e1       	ldi	r22, 0x10	; 16
     902:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     904:	fc 01       	movw	r30, r24
     906:	74 97       	sbiw	r30, 0x14	; 20
     908:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     90a:	fc 01       	movw	r30, r24
     90c:	75 97       	sbiw	r30, 0x15	; 21
     90e:	22 e1       	ldi	r18, 0x12	; 18
     910:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     912:	fc 01       	movw	r30, r24
     914:	76 97       	sbiw	r30, 0x16	; 22
     916:	23 e1       	ldi	r18, 0x13	; 19
     918:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     91a:	fc 01       	movw	r30, r24
     91c:	77 97       	sbiw	r30, 0x17	; 23
     91e:	24 e1       	ldi	r18, 0x14	; 20
     920:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     922:	fc 01       	movw	r30, r24
     924:	78 97       	sbiw	r30, 0x18	; 24
     926:	25 e1       	ldi	r18, 0x15	; 21
     928:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     92a:	fc 01       	movw	r30, r24
     92c:	79 97       	sbiw	r30, 0x19	; 25
     92e:	26 e1       	ldi	r18, 0x16	; 22
     930:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     932:	fc 01       	movw	r30, r24
     934:	7a 97       	sbiw	r30, 0x1a	; 26
     936:	27 e1       	ldi	r18, 0x17	; 23
     938:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     93a:	fc 01       	movw	r30, r24
     93c:	7b 97       	sbiw	r30, 0x1b	; 27
     93e:	28 e1       	ldi	r18, 0x18	; 24
     940:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     942:	fc 01       	movw	r30, r24
     944:	7c 97       	sbiw	r30, 0x1c	; 28
     946:	29 e1       	ldi	r18, 0x19	; 25
     948:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     94a:	fc 01       	movw	r30, r24
     94c:	7d 97       	sbiw	r30, 0x1d	; 29
     94e:	20 e2       	ldi	r18, 0x20	; 32
     950:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     952:	fc 01       	movw	r30, r24
     954:	7e 97       	sbiw	r30, 0x1e	; 30
     956:	21 e2       	ldi	r18, 0x21	; 33
     958:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     95a:	fc 01       	movw	r30, r24
     95c:	7f 97       	sbiw	r30, 0x1f	; 31
     95e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     960:	fc 01       	movw	r30, r24
     962:	b0 97       	sbiw	r30, 0x20	; 32
     964:	23 e2       	ldi	r18, 0x23	; 35
     966:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     968:	fc 01       	movw	r30, r24
     96a:	b1 97       	sbiw	r30, 0x21	; 33
     96c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     96e:	fc 01       	movw	r30, r24
     970:	b2 97       	sbiw	r30, 0x22	; 34
     972:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     974:	fc 01       	movw	r30, r24
     976:	b3 97       	sbiw	r30, 0x23	; 35
     978:	26 e2       	ldi	r18, 0x26	; 38
     97a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     97c:	fc 01       	movw	r30, r24
     97e:	b4 97       	sbiw	r30, 0x24	; 36
     980:	27 e2       	ldi	r18, 0x27	; 39
     982:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     984:	fc 01       	movw	r30, r24
     986:	b5 97       	sbiw	r30, 0x25	; 37
     988:	28 e2       	ldi	r18, 0x28	; 40
     98a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     98c:	fc 01       	movw	r30, r24
     98e:	b6 97       	sbiw	r30, 0x26	; 38
     990:	29 e2       	ldi	r18, 0x29	; 41
     992:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     994:	fc 01       	movw	r30, r24
     996:	b7 97       	sbiw	r30, 0x27	; 39
     998:	20 e3       	ldi	r18, 0x30	; 48
     99a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     99c:	fc 01       	movw	r30, r24
     99e:	b8 97       	sbiw	r30, 0x28	; 40
     9a0:	21 e3       	ldi	r18, 0x31	; 49
     9a2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     9a4:	89 97       	sbiw	r24, 0x29	; 41
}
     9a6:	08 95       	ret

000009a8 <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	80 93 99 00 	sts	0x0099, r24

#endif

    portOCRL = ucLowByte;
     9ae:	83 ef       	ldi	r24, 0xF3	; 243
     9b0:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
     9b4:	8b e0       	ldi	r24, 0x0B	; 11
     9b6:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     9ba:	e1 e7       	ldi	r30, 0x71	; 113
     9bc:	f0 e0       	ldi	r31, 0x00	; 0
     9be:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     9c0:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
     9c2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     9c4:	a0 91 6c 1a 	lds	r26, 0x1A6C
     9c8:	b0 91 6d 1a 	lds	r27, 0x1A6D
     9cc:	cd 91       	ld	r28, X+
     9ce:	cd bf       	out	0x3d, r28	; 61
     9d0:	dd 91       	ld	r29, X+
     9d2:	de bf       	out	0x3e, r29	; 62
     9d4:	ff 91       	pop	r31
     9d6:	ef 91       	pop	r30
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	bf 91       	pop	r27
     9de:	af 91       	pop	r26
     9e0:	9f 91       	pop	r25
     9e2:	8f 91       	pop	r24
     9e4:	7f 91       	pop	r23
     9e6:	6f 91       	pop	r22
     9e8:	5f 91       	pop	r21
     9ea:	4f 91       	pop	r20
     9ec:	3f 91       	pop	r19
     9ee:	2f 91       	pop	r18
     9f0:	1f 91       	pop	r17
     9f2:	0f 91       	pop	r16
     9f4:	ff 90       	pop	r15
     9f6:	ef 90       	pop	r14
     9f8:	df 90       	pop	r13
     9fa:	cf 90       	pop	r12
     9fc:	bf 90       	pop	r11
     9fe:	af 90       	pop	r10
     a00:	9f 90       	pop	r9
     a02:	8f 90       	pop	r8
     a04:	7f 90       	pop	r7
     a06:	6f 90       	pop	r6
     a08:	5f 90       	pop	r5
     a0a:	4f 90       	pop	r4
     a0c:	3f 90       	pop	r3
     a0e:	2f 90       	pop	r2
     a10:	1f 90       	pop	r1
     a12:	0f 90       	pop	r0
     a14:	0c be       	out	0x3c, r0	; 60
     a16:	0f 90       	pop	r0
     a18:	0b be       	out	0x3b, r0	; 59
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     a20:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	08 95       	ret

00000a26 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     a26:	08 95       	ret

00000a28 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a28:	0f 92       	push	r0
     a2a:	0f b6       	in	r0, 0x3f	; 63
     a2c:	f8 94       	cli
     a2e:	0f 92       	push	r0
     a30:	0b b6       	in	r0, 0x3b	; 59
     a32:	0f 92       	push	r0
     a34:	0c b6       	in	r0, 0x3c	; 60
     a36:	0f 92       	push	r0
     a38:	1f 92       	push	r1
     a3a:	11 24       	eor	r1, r1
     a3c:	2f 92       	push	r2
     a3e:	3f 92       	push	r3
     a40:	4f 92       	push	r4
     a42:	5f 92       	push	r5
     a44:	6f 92       	push	r6
     a46:	7f 92       	push	r7
     a48:	8f 92       	push	r8
     a4a:	9f 92       	push	r9
     a4c:	af 92       	push	r10
     a4e:	bf 92       	push	r11
     a50:	cf 92       	push	r12
     a52:	df 92       	push	r13
     a54:	ef 92       	push	r14
     a56:	ff 92       	push	r15
     a58:	0f 93       	push	r16
     a5a:	1f 93       	push	r17
     a5c:	2f 93       	push	r18
     a5e:	3f 93       	push	r19
     a60:	4f 93       	push	r20
     a62:	5f 93       	push	r21
     a64:	6f 93       	push	r22
     a66:	7f 93       	push	r23
     a68:	8f 93       	push	r24
     a6a:	9f 93       	push	r25
     a6c:	af 93       	push	r26
     a6e:	bf 93       	push	r27
     a70:	cf 93       	push	r28
     a72:	df 93       	push	r29
     a74:	ef 93       	push	r30
     a76:	ff 93       	push	r31
     a78:	a0 91 6c 1a 	lds	r26, 0x1A6C
     a7c:	b0 91 6d 1a 	lds	r27, 0x1A6D
     a80:	0d b6       	in	r0, 0x3d	; 61
     a82:	0d 92       	st	X+, r0
     a84:	0e b6       	in	r0, 0x3e	; 62
     a86:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a88:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a8c:	a0 91 6c 1a 	lds	r26, 0x1A6C
     a90:	b0 91 6d 1a 	lds	r27, 0x1A6D
     a94:	cd 91       	ld	r28, X+
     a96:	cd bf       	out	0x3d, r28	; 61
     a98:	dd 91       	ld	r29, X+
     a9a:	de bf       	out	0x3e, r29	; 62
     a9c:	ff 91       	pop	r31
     a9e:	ef 91       	pop	r30
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	bf 91       	pop	r27
     aa6:	af 91       	pop	r26
     aa8:	9f 91       	pop	r25
     aaa:	8f 91       	pop	r24
     aac:	7f 91       	pop	r23
     aae:	6f 91       	pop	r22
     ab0:	5f 91       	pop	r21
     ab2:	4f 91       	pop	r20
     ab4:	3f 91       	pop	r19
     ab6:	2f 91       	pop	r18
     ab8:	1f 91       	pop	r17
     aba:	0f 91       	pop	r16
     abc:	ff 90       	pop	r15
     abe:	ef 90       	pop	r14
     ac0:	df 90       	pop	r13
     ac2:	cf 90       	pop	r12
     ac4:	bf 90       	pop	r11
     ac6:	af 90       	pop	r10
     ac8:	9f 90       	pop	r9
     aca:	8f 90       	pop	r8
     acc:	7f 90       	pop	r7
     ace:	6f 90       	pop	r6
     ad0:	5f 90       	pop	r5
     ad2:	4f 90       	pop	r4
     ad4:	3f 90       	pop	r3
     ad6:	2f 90       	pop	r2
     ad8:	1f 90       	pop	r1
     ada:	0f 90       	pop	r0
     adc:	0c be       	out	0x3c, r0	; 60
     ade:	0f 90       	pop	r0
     ae0:	0b be       	out	0x3b, r0	; 59
     ae2:	0f 90       	pop	r0
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ae8:	08 95       	ret

00000aea <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     aea:	0f 92       	push	r0
     aec:	0f b6       	in	r0, 0x3f	; 63
     aee:	f8 94       	cli
     af0:	0f 92       	push	r0
     af2:	0b b6       	in	r0, 0x3b	; 59
     af4:	0f 92       	push	r0
     af6:	0c b6       	in	r0, 0x3c	; 60
     af8:	0f 92       	push	r0
     afa:	1f 92       	push	r1
     afc:	11 24       	eor	r1, r1
     afe:	2f 92       	push	r2
     b00:	3f 92       	push	r3
     b02:	4f 92       	push	r4
     b04:	5f 92       	push	r5
     b06:	6f 92       	push	r6
     b08:	7f 92       	push	r7
     b0a:	8f 92       	push	r8
     b0c:	9f 92       	push	r9
     b0e:	af 92       	push	r10
     b10:	bf 92       	push	r11
     b12:	cf 92       	push	r12
     b14:	df 92       	push	r13
     b16:	ef 92       	push	r14
     b18:	ff 92       	push	r15
     b1a:	0f 93       	push	r16
     b1c:	1f 93       	push	r17
     b1e:	2f 93       	push	r18
     b20:	3f 93       	push	r19
     b22:	4f 93       	push	r20
     b24:	5f 93       	push	r21
     b26:	6f 93       	push	r22
     b28:	7f 93       	push	r23
     b2a:	8f 93       	push	r24
     b2c:	9f 93       	push	r25
     b2e:	af 93       	push	r26
     b30:	bf 93       	push	r27
     b32:	cf 93       	push	r28
     b34:	df 93       	push	r29
     b36:	ef 93       	push	r30
     b38:	ff 93       	push	r31
     b3a:	a0 91 6c 1a 	lds	r26, 0x1A6C
     b3e:	b0 91 6d 1a 	lds	r27, 0x1A6D
     b42:	0d b6       	in	r0, 0x3d	; 61
     b44:	0d 92       	st	X+, r0
     b46:	0e b6       	in	r0, 0x3e	; 62
     b48:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     b4a:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <vTaskIncrementTick>
	vTaskSwitchContext();
     b4e:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b52:	a0 91 6c 1a 	lds	r26, 0x1A6C
     b56:	b0 91 6d 1a 	lds	r27, 0x1A6D
     b5a:	cd 91       	ld	r28, X+
     b5c:	cd bf       	out	0x3d, r28	; 61
     b5e:	dd 91       	ld	r29, X+
     b60:	de bf       	out	0x3e, r29	; 62
     b62:	ff 91       	pop	r31
     b64:	ef 91       	pop	r30
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	bf 91       	pop	r27
     b6c:	af 91       	pop	r26
     b6e:	9f 91       	pop	r25
     b70:	8f 91       	pop	r24
     b72:	7f 91       	pop	r23
     b74:	6f 91       	pop	r22
     b76:	5f 91       	pop	r21
     b78:	4f 91       	pop	r20
     b7a:	3f 91       	pop	r19
     b7c:	2f 91       	pop	r18
     b7e:	1f 91       	pop	r17
     b80:	0f 91       	pop	r16
     b82:	ff 90       	pop	r15
     b84:	ef 90       	pop	r14
     b86:	df 90       	pop	r13
     b88:	cf 90       	pop	r12
     b8a:	bf 90       	pop	r11
     b8c:	af 90       	pop	r10
     b8e:	9f 90       	pop	r9
     b90:	8f 90       	pop	r8
     b92:	7f 90       	pop	r7
     b94:	6f 90       	pop	r6
     b96:	5f 90       	pop	r5
     b98:	4f 90       	pop	r4
     b9a:	3f 90       	pop	r3
     b9c:	2f 90       	pop	r2
     b9e:	1f 90       	pop	r1
     ba0:	0f 90       	pop	r0
     ba2:	0c be       	out	0x3c, r0	; 60
     ba4:	0f 90       	pop	r0
     ba6:	0b be       	out	0x3b, r0	; 59
     ba8:	0f 90       	pop	r0
     baa:	0f be       	out	0x3f, r0	; 63
     bac:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bae:	08 95       	ret

00000bb0 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
     bb0:	0e 94 75 05 	call	0xaea	; 0xaea <vPortYieldFromTick>
			asm volatile ( "reti" );
     bb4:	18 95       	reti

00000bb6 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     bb6:	cf 93       	push	r28
     bb8:	df 93       	push	r29
     bba:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     bbc:	cd 91       	ld	r28, X+
     bbe:	dc 91       	ld	r29, X
     bc0:	11 97       	sbiw	r26, 0x01	; 1
     bc2:	20 97       	sbiw	r28, 0x00	; 0
     bc4:	21 f1       	breq	.+72     	; 0xc0e <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     bc6:	5c 96       	adiw	r26, 0x1c	; 28
     bc8:	4c 91       	ld	r20, X
     bca:	5c 97       	sbiw	r26, 0x1c	; 28
     bcc:	16 96       	adiw	r26, 0x06	; 6
     bce:	2d 91       	ld	r18, X+
     bd0:	3c 91       	ld	r19, X
     bd2:	17 97       	sbiw	r26, 0x07	; 7
     bd4:	24 0f       	add	r18, r20
     bd6:	31 1d       	adc	r19, r1
     bd8:	17 96       	adiw	r26, 0x07	; 7
     bda:	3c 93       	st	X, r19
     bdc:	2e 93       	st	-X, r18
     bde:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     be0:	12 96       	adiw	r26, 0x02	; 2
     be2:	ed 91       	ld	r30, X+
     be4:	fc 91       	ld	r31, X
     be6:	13 97       	sbiw	r26, 0x03	; 3
     be8:	2e 17       	cp	r18, r30
     bea:	3f 07       	cpc	r19, r31
     bec:	20 f0       	brcs	.+8      	; 0xbf6 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     bee:	17 96       	adiw	r26, 0x07	; 7
     bf0:	dc 93       	st	X, r29
     bf2:	ce 93       	st	-X, r28
     bf4:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     bf6:	16 96       	adiw	r26, 0x06	; 6
     bf8:	3c 91       	ld	r19, X
     bfa:	16 97       	sbiw	r26, 0x06	; 6
     bfc:	17 96       	adiw	r26, 0x07	; 7
     bfe:	2c 91       	ld	r18, X
     c00:	86 2f       	mov	r24, r22
     c02:	97 2f       	mov	r25, r23
     c04:	63 2f       	mov	r22, r19
     c06:	72 2f       	mov	r23, r18
     c08:	50 e0       	ldi	r21, 0x00	; 0
     c0a:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <memcpy>
	}
}
     c0e:	df 91       	pop	r29
     c10:	cf 91       	pop	r28
     c12:	08 95       	ret

00000c14 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     c14:	0f 93       	push	r16
     c16:	1f 93       	push	r17
     c18:	cf 93       	push	r28
     c1a:	df 93       	push	r29
     c1c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c24:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c26:	18 16       	cp	r1, r24
     c28:	c4 f4       	brge	.+48     	; 0xc5a <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c2a:	89 89       	ldd	r24, Y+17	; 0x11
     c2c:	88 23       	and	r24, r24
     c2e:	29 f4       	brne	.+10     	; 0xc3a <prvUnlockQueue+0x26>
     c30:	14 c0       	rjmp	.+40     	; 0xc5a <prvUnlockQueue+0x46>
     c32:	89 89       	ldd	r24, Y+17	; 0x11
     c34:	88 23       	and	r24, r24
     c36:	21 f4       	brne	.+8      	; 0xc40 <prvUnlockQueue+0x2c>
     c38:	10 c0       	rjmp	.+32     	; 0xc5a <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c3a:	8e 01       	movw	r16, r28
     c3c:	0f 5e       	subi	r16, 0xEF	; 239
     c3e:	1f 4f       	sbci	r17, 0xFF	; 255
     c40:	c8 01       	movw	r24, r16
     c42:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
     c46:	88 23       	and	r24, r24
     c48:	11 f0       	breq	.+4      	; 0xc4e <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     c4a:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     c4e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c50:	81 50       	subi	r24, 0x01	; 1
     c52:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c54:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c56:	18 16       	cp	r1, r24
     c58:	64 f3       	brlt	.-40     	; 0xc32 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     c5a:	8f ef       	ldi	r24, 0xFF	; 255
     c5c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     c5e:	0f 90       	pop	r0
     c60:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     c62:	0f b6       	in	r0, 0x3f	; 63
     c64:	f8 94       	cli
     c66:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c68:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c6a:	18 16       	cp	r1, r24
     c6c:	c4 f4       	brge	.+48     	; 0xc9e <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c6e:	88 85       	ldd	r24, Y+8	; 0x08
     c70:	88 23       	and	r24, r24
     c72:	29 f4       	brne	.+10     	; 0xc7e <prvUnlockQueue+0x6a>
     c74:	14 c0       	rjmp	.+40     	; 0xc9e <prvUnlockQueue+0x8a>
     c76:	88 85       	ldd	r24, Y+8	; 0x08
     c78:	88 23       	and	r24, r24
     c7a:	21 f4       	brne	.+8      	; 0xc84 <prvUnlockQueue+0x70>
     c7c:	10 c0       	rjmp	.+32     	; 0xc9e <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c7e:	8e 01       	movw	r16, r28
     c80:	08 5f       	subi	r16, 0xF8	; 248
     c82:	1f 4f       	sbci	r17, 0xFF	; 255
     c84:	c8 01       	movw	r24, r16
     c86:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
     c8a:	88 23       	and	r24, r24
     c8c:	11 f0       	breq	.+4      	; 0xc92 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
     c8e:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     c92:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c94:	81 50       	subi	r24, 0x01	; 1
     c96:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c98:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c9a:	18 16       	cp	r1, r24
     c9c:	64 f3       	brlt	.-40     	; 0xc76 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     c9e:	8f ef       	ldi	r24, 0xFF	; 255
     ca0:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     ca2:	0f 90       	pop	r0
     ca4:	0f be       	out	0x3f, r0	; 63
}
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	08 95       	ret

00000cb0 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     cb0:	cf 93       	push	r28
     cb2:	df 93       	push	r29
     cb4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     cb6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cb8:	22 23       	and	r18, r18
     cba:	59 f4       	brne	.+22     	; 0xcd2 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     cbc:	88 81       	ld	r24, Y
     cbe:	99 81       	ldd	r25, Y+1	; 0x01
     cc0:	00 97       	sbiw	r24, 0x00	; 0
     cc2:	e1 f5       	brne	.+120    	; 0xd3c <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     cc4:	8a 81       	ldd	r24, Y+2	; 0x02
     cc6:	9b 81       	ldd	r25, Y+3	; 0x03
     cc8:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     ccc:	1b 82       	std	Y+3, r1	; 0x03
     cce:	1a 82       	std	Y+2, r1	; 0x02
     cd0:	35 c0       	rjmp	.+106    	; 0xd3c <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     cd2:	44 23       	and	r20, r20
     cd4:	b9 f4       	brne	.+46     	; 0xd04 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     cd6:	8c 81       	ldd	r24, Y+4	; 0x04
     cd8:	9d 81       	ldd	r25, Y+5	; 0x05
     cda:	42 2f       	mov	r20, r18
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ce2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ce4:	8c 81       	ldd	r24, Y+4	; 0x04
     ce6:	9d 81       	ldd	r25, Y+5	; 0x05
     ce8:	82 0f       	add	r24, r18
     cea:	91 1d       	adc	r25, r1
     cec:	9d 83       	std	Y+5, r25	; 0x05
     cee:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     cf0:	2a 81       	ldd	r18, Y+2	; 0x02
     cf2:	3b 81       	ldd	r19, Y+3	; 0x03
     cf4:	82 17       	cp	r24, r18
     cf6:	93 07       	cpc	r25, r19
     cf8:	08 f1       	brcs	.+66     	; 0xd3c <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     cfa:	88 81       	ld	r24, Y
     cfc:	99 81       	ldd	r25, Y+1	; 0x01
     cfe:	9d 83       	std	Y+5, r25	; 0x05
     d00:	8c 83       	std	Y+4, r24	; 0x04
     d02:	1c c0       	rjmp	.+56     	; 0xd3c <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d04:	8e 81       	ldd	r24, Y+6	; 0x06
     d06:	9f 81       	ldd	r25, Y+7	; 0x07
     d08:	42 2f       	mov	r20, r18
     d0a:	50 e0       	ldi	r21, 0x00	; 0
     d0c:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     d10:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d12:	50 e0       	ldi	r21, 0x00	; 0
     d14:	50 95       	com	r21
     d16:	41 95       	neg	r20
     d18:	5f 4f       	sbci	r21, 0xFF	; 255
     d1a:	8e 81       	ldd	r24, Y+6	; 0x06
     d1c:	9f 81       	ldd	r25, Y+7	; 0x07
     d1e:	84 0f       	add	r24, r20
     d20:	95 1f       	adc	r25, r21
     d22:	9f 83       	std	Y+7, r25	; 0x07
     d24:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     d26:	28 81       	ld	r18, Y
     d28:	39 81       	ldd	r19, Y+1	; 0x01
     d2a:	82 17       	cp	r24, r18
     d2c:	93 07       	cpc	r25, r19
     d2e:	30 f4       	brcc	.+12     	; 0xd3c <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d30:	8a 81       	ldd	r24, Y+2	; 0x02
     d32:	9b 81       	ldd	r25, Y+3	; 0x03
     d34:	48 0f       	add	r20, r24
     d36:	59 1f       	adc	r21, r25
     d38:	5f 83       	std	Y+7, r21	; 0x07
     d3a:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     d3c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d3e:	8f 5f       	subi	r24, 0xFF	; 255
     d40:	8a 8f       	std	Y+26, r24	; 0x1a
}
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	08 95       	ret

00000d48 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
     d48:	cf 93       	push	r28
     d4a:	df 93       	push	r29
     d4c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     d54:	48 81       	ld	r20, Y
     d56:	59 81       	ldd	r21, Y+1	; 0x01
     d58:	2b 8d       	ldd	r18, Y+27	; 0x1b
     d5a:	30 e0       	ldi	r19, 0x00	; 0
     d5c:	ec 8d       	ldd	r30, Y+28	; 0x1c
     d5e:	f0 e0       	ldi	r31, 0x00	; 0
     d60:	2e 9f       	mul	r18, r30
     d62:	c0 01       	movw	r24, r0
     d64:	2f 9f       	mul	r18, r31
     d66:	90 0d       	add	r25, r0
     d68:	3e 9f       	mul	r19, r30
     d6a:	90 0d       	add	r25, r0
     d6c:	11 24       	eor	r1, r1
     d6e:	84 0f       	add	r24, r20
     d70:	95 1f       	adc	r25, r21
     d72:	9b 83       	std	Y+3, r25	; 0x03
     d74:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     d76:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     d78:	5d 83       	std	Y+5, r21	; 0x05
     d7a:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     d7c:	c9 01       	movw	r24, r18
     d7e:	01 97       	sbiw	r24, 0x01	; 1
     d80:	e8 9f       	mul	r30, r24
     d82:	90 01       	movw	r18, r0
     d84:	e9 9f       	mul	r30, r25
     d86:	30 0d       	add	r19, r0
     d88:	f8 9f       	mul	r31, r24
     d8a:	30 0d       	add	r19, r0
     d8c:	11 24       	eor	r1, r1
     d8e:	24 0f       	add	r18, r20
     d90:	35 1f       	adc	r19, r21
     d92:	3f 83       	std	Y+7, r19	; 0x07
     d94:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     d96:	8f ef       	ldi	r24, 0xFF	; 255
     d98:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     d9a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     d9c:	66 23       	and	r22, r22
     d9e:	61 f4       	brne	.+24     	; 0xdb8 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     da0:	88 85       	ldd	r24, Y+8	; 0x08
     da2:	88 23       	and	r24, r24
     da4:	89 f0       	breq	.+34     	; 0xdc8 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     da6:	ce 01       	movw	r24, r28
     da8:	08 96       	adiw	r24, 0x08	; 8
     daa:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
     dae:	81 30       	cpi	r24, 0x01	; 1
     db0:	59 f4       	brne	.+22     	; 0xdc8 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
     db2:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
     db6:	08 c0       	rjmp	.+16     	; 0xdc8 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     db8:	ce 01       	movw	r24, r28
     dba:	08 96       	adiw	r24, 0x08	; 8
     dbc:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     dc0:	ce 01       	movw	r24, r28
     dc2:	41 96       	adiw	r24, 0x11	; 17
     dc4:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     dc8:	0f 90       	pop	r0
     dca:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     dcc:	81 e0       	ldi	r24, 0x01	; 1
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	08 95       	ret

00000dd4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     dd4:	0f 93       	push	r16
     dd6:	1f 93       	push	r17
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	18 2f       	mov	r17, r24
     dde:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     de0:	88 23       	and	r24, r24
     de2:	f9 f0       	breq	.+62     	; 0xe22 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     de4:	8f e1       	ldi	r24, 0x1F	; 31
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	0e 94 64 03 	call	0x6c8	; 0x6c8 <pvPortMalloc>
     dec:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     dee:	00 97       	sbiw	r24, 0x00	; 0
     df0:	d9 f0       	breq	.+54     	; 0xe28 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     df2:	01 9f       	mul	r16, r17
     df4:	c0 01       	movw	r24, r0
     df6:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     df8:	01 96       	adiw	r24, 0x01	; 1
     dfa:	0e 94 64 03 	call	0x6c8	; 0x6c8 <pvPortMalloc>
     dfe:	99 83       	std	Y+1, r25	; 0x01
     e00:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     e02:	00 97       	sbiw	r24, 0x00	; 0
     e04:	41 f0       	breq	.+16     	; 0xe16 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     e06:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     e08:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
     e0a:	ce 01       	movw	r24, r28
     e0c:	61 e0       	ldi	r22, 0x01	; 1
     e0e:	0e 94 a4 06 	call	0xd48	; 0xd48 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     e12:	ce 01       	movw	r24, r28
     e14:	0b c0       	rjmp	.+22     	; 0xe2c <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     e16:	ce 01       	movw	r24, r28
     e18:	0e 94 8d 03 	call	0x71a	; 0x71a <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	05 c0       	rjmp	.+10     	; 0xe2c <xQueueGenericCreate+0x58>
     e22:	80 e0       	ldi	r24, 0x00	; 0
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	02 c0       	rjmp	.+4      	; 0xe2c <xQueueGenericCreate+0x58>
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     e36:	8f 92       	push	r8
     e38:	9f 92       	push	r9
     e3a:	bf 92       	push	r11
     e3c:	cf 92       	push	r12
     e3e:	df 92       	push	r13
     e40:	ef 92       	push	r14
     e42:	ff 92       	push	r15
     e44:	0f 93       	push	r16
     e46:	1f 93       	push	r17
     e48:	cf 93       	push	r28
     e4a:	df 93       	push	r29
     e4c:	00 d0       	rcall	.+0      	; 0xe4e <xQueueGenericSend+0x18>
     e4e:	0f 92       	push	r0
     e50:	0f 92       	push	r0
     e52:	cd b7       	in	r28, 0x3d	; 61
     e54:	de b7       	in	r29, 0x3e	; 62
     e56:	8c 01       	movw	r16, r24
     e58:	4b 01       	movw	r8, r22
     e5a:	5d 83       	std	Y+5, r21	; 0x05
     e5c:	4c 83       	std	Y+4, r20	; 0x04
     e5e:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     e60:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e62:	ee 24       	eor	r14, r14
     e64:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e66:	cc 24       	eor	r12, r12
     e68:	dd 24       	eor	r13, r13
     e6a:	68 94       	set
     e6c:	c3 f8       	bld	r12, 3
     e6e:	c8 0e       	add	r12, r24
     e70:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     e72:	0f b6       	in	r0, 0x3f	; 63
     e74:	f8 94       	cli
     e76:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e78:	f8 01       	movw	r30, r16
     e7a:	92 8d       	ldd	r25, Z+26	; 0x1a
     e7c:	83 8d       	ldd	r24, Z+27	; 0x1b
     e7e:	98 17       	cp	r25, r24
     e80:	a8 f4       	brcc	.+42     	; 0xeac <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e82:	c8 01       	movw	r24, r16
     e84:	b4 01       	movw	r22, r8
     e86:	4b 2d       	mov	r20, r11
     e88:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e8c:	f8 01       	movw	r30, r16
     e8e:	81 89       	ldd	r24, Z+17	; 0x11
     e90:	88 23       	and	r24, r24
     e92:	41 f0       	breq	.+16     	; 0xea4 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     e94:	c8 01       	movw	r24, r16
     e96:	41 96       	adiw	r24, 0x11	; 17
     e98:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
     e9c:	81 30       	cpi	r24, 0x01	; 1
     e9e:	11 f4       	brne	.+4      	; 0xea4 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     ea0:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     ea4:	0f 90       	pop	r0
     ea6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	52 c0       	rjmp	.+164    	; 0xf50 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     eac:	8c 81       	ldd	r24, Y+4	; 0x04
     eae:	9d 81       	ldd	r25, Y+5	; 0x05
     eb0:	00 97       	sbiw	r24, 0x00	; 0
     eb2:	21 f4       	brne	.+8      	; 0xebc <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     eb4:	0f 90       	pop	r0
     eb6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     eb8:	80 e0       	ldi	r24, 0x00	; 0
     eba:	4a c0       	rjmp	.+148    	; 0xf50 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     ebc:	ff 20       	and	r15, r15
     ebe:	29 f4       	brne	.+10     	; 0xeca <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ec0:	ce 01       	movw	r24, r28
     ec2:	01 96       	adiw	r24, 0x01	; 1
     ec4:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     ec8:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     eca:	0f 90       	pop	r0
     ecc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ece:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ed2:	0f b6       	in	r0, 0x3f	; 63
     ed4:	f8 94       	cli
     ed6:	0f 92       	push	r0
     ed8:	f8 01       	movw	r30, r16
     eda:	85 8d       	ldd	r24, Z+29	; 0x1d
     edc:	8f 3f       	cpi	r24, 0xFF	; 255
     ede:	09 f4       	brne	.+2      	; 0xee2 <xQueueGenericSend+0xac>
     ee0:	15 8e       	std	Z+29, r1	; 0x1d
     ee2:	f8 01       	movw	r30, r16
     ee4:	86 8d       	ldd	r24, Z+30	; 0x1e
     ee6:	8f 3f       	cpi	r24, 0xFF	; 255
     ee8:	09 f4       	brne	.+2      	; 0xeec <xQueueGenericSend+0xb6>
     eea:	16 8e       	std	Z+30, r1	; 0x1e
     eec:	0f 90       	pop	r0
     eee:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ef0:	ce 01       	movw	r24, r28
     ef2:	01 96       	adiw	r24, 0x01	; 1
     ef4:	be 01       	movw	r22, r28
     ef6:	6c 5f       	subi	r22, 0xFC	; 252
     ef8:	7f 4f       	sbci	r23, 0xFF	; 255
     efa:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xTaskCheckForTimeOut>
     efe:	88 23       	and	r24, r24
     f00:	09 f5       	brne	.+66     	; 0xf44 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	f8 94       	cli
     f06:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f08:	f8 01       	movw	r30, r16
     f0a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f0c:	0f 90       	pop	r0
     f0e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     f10:	f8 01       	movw	r30, r16
     f12:	83 8d       	ldd	r24, Z+27	; 0x1b
     f14:	98 17       	cp	r25, r24
     f16:	81 f4       	brne	.+32     	; 0xf38 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f18:	6c 81       	ldd	r22, Y+4	; 0x04
     f1a:	7d 81       	ldd	r23, Y+5	; 0x05
     f1c:	c6 01       	movw	r24, r12
     f1e:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f22:	c8 01       	movw	r24, r16
     f24:	0e 94 0a 06 	call	0xc14	; 0xc14 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     f28:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
     f2c:	88 23       	and	r24, r24
     f2e:	09 f0       	breq	.+2      	; 0xf32 <xQueueGenericSend+0xfc>
     f30:	a0 cf       	rjmp	.-192    	; 0xe72 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     f32:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
     f36:	9d cf       	rjmp	.-198    	; 0xe72 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f38:	c8 01       	movw	r24, r16
     f3a:	0e 94 0a 06 	call	0xc14	; 0xc14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f3e:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
     f42:	97 cf       	rjmp	.-210    	; 0xe72 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     f44:	c8 01       	movw	r24, r16
     f46:	0e 94 0a 06 	call	0xc14	; 0xc14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f4a:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     f4e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	0f 90       	pop	r0
     f56:	0f 90       	pop	r0
     f58:	0f 90       	pop	r0
     f5a:	df 91       	pop	r29
     f5c:	cf 91       	pop	r28
     f5e:	1f 91       	pop	r17
     f60:	0f 91       	pop	r16
     f62:	ff 90       	pop	r15
     f64:	ef 90       	pop	r14
     f66:	df 90       	pop	r13
     f68:	cf 90       	pop	r12
     f6a:	bf 90       	pop	r11
     f6c:	9f 90       	pop	r9
     f6e:	8f 90       	pop	r8
     f70:	08 95       	ret

00000f72 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     f76:	8f e1       	ldi	r24, 0x1F	; 31
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	0e 94 64 03 	call	0x6c8	; 0x6c8 <pvPortMalloc>
     f7e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f80:	00 97       	sbiw	r24, 0x00	; 0
     f82:	f9 f0       	breq	.+62     	; 0xfc2 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     f84:	1b 82       	std	Y+3, r1	; 0x03
     f86:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     f88:	19 82       	std	Y+1, r1	; 0x01
     f8a:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
     f8c:	1d 82       	std	Y+5, r1	; 0x05
     f8e:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
     f90:	1f 82       	std	Y+7, r1	; 0x07
     f92:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     f94:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
     f9a:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
     f9c:	8f ef       	ldi	r24, 0xFF	; 255
     f9e:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
     fa0:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     fa2:	ce 01       	movw	r24, r28
     fa4:	08 96       	adiw	r24, 0x08	; 8
     fa6:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     faa:	ce 01       	movw	r24, r28
     fac:	41 96       	adiw	r24, 0x11	; 17
     fae:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
     fb2:	ce 01       	movw	r24, r28
     fb4:	60 e0       	ldi	r22, 0x00	; 0
     fb6:	70 e0       	ldi	r23, 0x00	; 0
     fb8:	40 e0       	ldi	r20, 0x00	; 0
     fba:	50 e0       	ldi	r21, 0x00	; 0
     fbc:	20 e0       	ldi	r18, 0x00	; 0
     fbe:	0e 94 1b 07 	call	0xe36	; 0xe36 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
     fc2:	8c 2f       	mov	r24, r28
     fc4:	9d 2f       	mov	r25, r29
     fc6:	df 91       	pop	r29
     fc8:	cf 91       	pop	r28
     fca:	08 95       	ret

00000fcc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     fcc:	0f 93       	push	r16
     fce:	1f 93       	push	r17
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
     fd4:	ec 01       	movw	r28, r24
     fd6:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     fd8:	9a 8d       	ldd	r25, Y+26	; 0x1a
     fda:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fdc:	98 17       	cp	r25, r24
     fde:	e0 f4       	brcc	.+56     	; 0x1018 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     fe0:	ce 01       	movw	r24, r28
     fe2:	42 2f       	mov	r20, r18
     fe4:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     fe8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fea:	8f 3f       	cpi	r24, 0xFF	; 255
     fec:	81 f4       	brne	.+32     	; 0x100e <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fee:	89 89       	ldd	r24, Y+17	; 0x11
     ff0:	88 23       	and	r24, r24
     ff2:	a1 f0       	breq	.+40     	; 0x101c <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ff4:	ce 01       	movw	r24, r28
     ff6:	41 96       	adiw	r24, 0x11	; 17
     ff8:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
     ffc:	88 23       	and	r24, r24
     ffe:	81 f0       	breq	.+32     	; 0x1020 <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1000:	01 15       	cp	r16, r1
    1002:	11 05       	cpc	r17, r1
    1004:	79 f0       	breq	.+30     	; 0x1024 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	f8 01       	movw	r30, r16
    100a:	80 83       	st	Z, r24
    100c:	0c c0       	rjmp	.+24     	; 0x1026 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    100e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1010:	8f 5f       	subi	r24, 0xFF	; 255
    1012:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1014:	81 e0       	ldi	r24, 0x01	; 1
    1016:	07 c0       	rjmp	.+14     	; 0x1026 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1018:	80 e0       	ldi	r24, 0x00	; 0
    101a:	05 c0       	rjmp	.+10     	; 0x1026 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    101c:	81 e0       	ldi	r24, 0x01	; 1
    101e:	03 c0       	rjmp	.+6      	; 0x1026 <xQueueGenericSendFromISR+0x5a>
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	01 c0       	rjmp	.+2      	; 0x1026 <xQueueGenericSendFromISR+0x5a>
    1024:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	1f 91       	pop	r17
    102c:	0f 91       	pop	r16
    102e:	08 95       	ret

00001030 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1030:	8f 92       	push	r8
    1032:	9f 92       	push	r9
    1034:	bf 92       	push	r11
    1036:	cf 92       	push	r12
    1038:	df 92       	push	r13
    103a:	ef 92       	push	r14
    103c:	ff 92       	push	r15
    103e:	0f 93       	push	r16
    1040:	1f 93       	push	r17
    1042:	cf 93       	push	r28
    1044:	df 93       	push	r29
    1046:	00 d0       	rcall	.+0      	; 0x1048 <xQueueGenericReceive+0x18>
    1048:	0f 92       	push	r0
    104a:	0f 92       	push	r0
    104c:	cd b7       	in	r28, 0x3d	; 61
    104e:	de b7       	in	r29, 0x3e	; 62
    1050:	8c 01       	movw	r16, r24
    1052:	4b 01       	movw	r8, r22
    1054:	5d 83       	std	Y+5, r21	; 0x05
    1056:	4c 83       	std	Y+4, r20	; 0x04
    1058:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    105a:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    105c:	ee 24       	eor	r14, r14
    105e:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1060:	0f 2e       	mov	r0, r31
    1062:	f1 e1       	ldi	r31, 0x11	; 17
    1064:	cf 2e       	mov	r12, r31
    1066:	dd 24       	eor	r13, r13
    1068:	f0 2d       	mov	r31, r0
    106a:	c8 0e       	add	r12, r24
    106c:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1074:	f8 01       	movw	r30, r16
    1076:	82 8d       	ldd	r24, Z+26	; 0x1a
    1078:	88 23       	and	r24, r24
    107a:	a1 f1       	breq	.+104    	; 0x10e4 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    107c:	e6 80       	ldd	r14, Z+6	; 0x06
    107e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1080:	c8 01       	movw	r24, r16
    1082:	b4 01       	movw	r22, r8
    1084:	0e 94 db 05 	call	0xbb6	; 0xbb6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1088:	bb 20       	and	r11, r11
    108a:	d1 f4       	brne	.+52     	; 0x10c0 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    108c:	f8 01       	movw	r30, r16
    108e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1090:	81 50       	subi	r24, 0x01	; 1
    1092:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1094:	80 81       	ld	r24, Z
    1096:	91 81       	ldd	r25, Z+1	; 0x01
    1098:	00 97       	sbiw	r24, 0x00	; 0
    109a:	29 f4       	brne	.+10     	; 0x10a6 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    109c:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGetCurrentTaskHandle>
    10a0:	f8 01       	movw	r30, r16
    10a2:	93 83       	std	Z+3, r25	; 0x03
    10a4:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10a6:	f8 01       	movw	r30, r16
    10a8:	80 85       	ldd	r24, Z+8	; 0x08
    10aa:	88 23       	and	r24, r24
    10ac:	b9 f0       	breq	.+46     	; 0x10dc <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    10ae:	c8 01       	movw	r24, r16
    10b0:	08 96       	adiw	r24, 0x08	; 8
    10b2:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
    10b6:	81 30       	cpi	r24, 0x01	; 1
    10b8:	89 f4       	brne	.+34     	; 0x10dc <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    10ba:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
    10be:	0e c0       	rjmp	.+28     	; 0x10dc <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    10c0:	f8 01       	movw	r30, r16
    10c2:	f7 82       	std	Z+7, r15	; 0x07
    10c4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10c6:	81 89       	ldd	r24, Z+17	; 0x11
    10c8:	88 23       	and	r24, r24
    10ca:	41 f0       	breq	.+16     	; 0x10dc <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10cc:	c8 01       	movw	r24, r16
    10ce:	41 96       	adiw	r24, 0x11	; 17
    10d0:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
    10d4:	88 23       	and	r24, r24
    10d6:	11 f0       	breq	.+4      	; 0x10dc <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    10d8:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    10dc:	0f 90       	pop	r0
    10de:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	5f c0       	rjmp	.+190    	; 0x11a2 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    10e4:	8c 81       	ldd	r24, Y+4	; 0x04
    10e6:	9d 81       	ldd	r25, Y+5	; 0x05
    10e8:	00 97       	sbiw	r24, 0x00	; 0
    10ea:	21 f4       	brne	.+8      	; 0x10f4 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10ec:	0f 90       	pop	r0
    10ee:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    10f0:	80 e0       	ldi	r24, 0x00	; 0
    10f2:	57 c0       	rjmp	.+174    	; 0x11a2 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    10f4:	ff 20       	and	r15, r15
    10f6:	29 f4       	brne	.+10     	; 0x1102 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10f8:	ce 01       	movw	r24, r28
    10fa:	01 96       	adiw	r24, 0x01	; 1
    10fc:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1100:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1102:	0f 90       	pop	r0
    1104:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1106:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    110a:	0f b6       	in	r0, 0x3f	; 63
    110c:	f8 94       	cli
    110e:	0f 92       	push	r0
    1110:	f8 01       	movw	r30, r16
    1112:	85 8d       	ldd	r24, Z+29	; 0x1d
    1114:	8f 3f       	cpi	r24, 0xFF	; 255
    1116:	09 f4       	brne	.+2      	; 0x111a <xQueueGenericReceive+0xea>
    1118:	15 8e       	std	Z+29, r1	; 0x1d
    111a:	f8 01       	movw	r30, r16
    111c:	86 8d       	ldd	r24, Z+30	; 0x1e
    111e:	8f 3f       	cpi	r24, 0xFF	; 255
    1120:	09 f4       	brne	.+2      	; 0x1124 <xQueueGenericReceive+0xf4>
    1122:	16 8e       	std	Z+30, r1	; 0x1e
    1124:	0f 90       	pop	r0
    1126:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1128:	ce 01       	movw	r24, r28
    112a:	01 96       	adiw	r24, 0x01	; 1
    112c:	be 01       	movw	r22, r28
    112e:	6c 5f       	subi	r22, 0xFC	; 252
    1130:	7f 4f       	sbci	r23, 0xFF	; 255
    1132:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xTaskCheckForTimeOut>
    1136:	88 23       	and	r24, r24
    1138:	71 f5       	brne	.+92     	; 0x1196 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    113a:	0f b6       	in	r0, 0x3f	; 63
    113c:	f8 94       	cli
    113e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1140:	f8 01       	movw	r30, r16
    1142:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1144:	0f 90       	pop	r0
    1146:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1148:	88 23       	and	r24, r24
    114a:	f9 f4       	brne	.+62     	; 0x118a <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    114c:	f8 01       	movw	r30, r16
    114e:	80 81       	ld	r24, Z
    1150:	91 81       	ldd	r25, Z+1	; 0x01
    1152:	00 97       	sbiw	r24, 0x00	; 0
    1154:	51 f4       	brne	.+20     	; 0x116a <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	f8 94       	cli
    115a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    115c:	f8 01       	movw	r30, r16
    115e:	82 81       	ldd	r24, Z+2	; 0x02
    1160:	93 81       	ldd	r25, Z+3	; 0x03
    1162:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1166:	0f 90       	pop	r0
    1168:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    116a:	6c 81       	ldd	r22, Y+4	; 0x04
    116c:	7d 81       	ldd	r23, Y+5	; 0x05
    116e:	c6 01       	movw	r24, r12
    1170:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1174:	c8 01       	movw	r24, r16
    1176:	0e 94 0a 06 	call	0xc14	; 0xc14 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    117a:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
    117e:	88 23       	and	r24, r24
    1180:	09 f0       	breq	.+2      	; 0x1184 <xQueueGenericReceive+0x154>
    1182:	75 cf       	rjmp	.-278    	; 0x106e <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    1184:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
    1188:	72 cf       	rjmp	.-284    	; 0x106e <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    118a:	c8 01       	movw	r24, r16
    118c:	0e 94 0a 06 	call	0xc14	; 0xc14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1190:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
    1194:	6c cf       	rjmp	.-296    	; 0x106e <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1196:	c8 01       	movw	r24, r16
    1198:	0e 94 0a 06 	call	0xc14	; 0xc14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    119c:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    11a0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11a2:	0f 90       	pop	r0
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	1f 91       	pop	r17
    11b2:	0f 91       	pop	r16
    11b4:	ff 90       	pop	r15
    11b6:	ef 90       	pop	r14
    11b8:	df 90       	pop	r13
    11ba:	cf 90       	pop	r12
    11bc:	bf 90       	pop	r11
    11be:	9f 90       	pop	r9
    11c0:	8f 90       	pop	r8
    11c2:	08 95       	ret

000011c4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    11c4:	0f 93       	push	r16
    11c6:	1f 93       	push	r17
    11c8:	cf 93       	push	r28
    11ca:	df 93       	push	r29
    11cc:	ec 01       	movw	r28, r24
    11ce:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    11d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11d2:	88 23       	and	r24, r24
    11d4:	f1 f0       	breq	.+60     	; 0x1212 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    11d6:	ce 01       	movw	r24, r28
    11d8:	0e 94 db 05 	call	0xbb6	; 0xbb6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    11dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11de:	81 50       	subi	r24, 0x01	; 1
    11e0:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    11e2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11e4:	8f 3f       	cpi	r24, 0xFF	; 255
    11e6:	81 f4       	brne	.+32     	; 0x1208 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11e8:	88 85       	ldd	r24, Y+8	; 0x08
    11ea:	88 23       	and	r24, r24
    11ec:	a1 f0       	breq	.+40     	; 0x1216 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11ee:	ce 01       	movw	r24, r28
    11f0:	08 96       	adiw	r24, 0x08	; 8
    11f2:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <xTaskRemoveFromEventList>
    11f6:	88 23       	and	r24, r24
    11f8:	81 f0       	breq	.+32     	; 0x121a <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    11fa:	01 15       	cp	r16, r1
    11fc:	11 05       	cpc	r17, r1
    11fe:	79 f0       	breq	.+30     	; 0x121e <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	f8 01       	movw	r30, r16
    1204:	80 83       	st	Z, r24
    1206:	0c c0       	rjmp	.+24     	; 0x1220 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1208:	8d 8d       	ldd	r24, Y+29	; 0x1d
    120a:	8f 5f       	subi	r24, 0xFF	; 255
    120c:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	07 c0       	rjmp	.+14     	; 0x1220 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	05 c0       	rjmp	.+10     	; 0x1220 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	03 c0       	rjmp	.+6      	; 0x1220 <xQueueReceiveFromISR+0x5c>
    121a:	81 e0       	ldi	r24, 0x01	; 1
    121c:	01 c0       	rjmp	.+2      	; 0x1220 <xQueueReceiveFromISR+0x5c>
    121e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1220:	df 91       	pop	r29
    1222:	cf 91       	pop	r28
    1224:	1f 91       	pop	r17
    1226:	0f 91       	pop	r16
    1228:	08 95       	ret

0000122a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1230:	fc 01       	movw	r30, r24
    1232:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1234:	0f 90       	pop	r0
    1236:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1238:	08 95       	ret

0000123a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    123a:	fc 01       	movw	r30, r24
    123c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    123e:	08 95       	ret

00001240 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
    1244:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1246:	88 81       	ld	r24, Y
    1248:	99 81       	ldd	r25, Y+1	; 0x01
    124a:	0e 94 8d 03 	call	0x71a	; 0x71a <vPortFree>
	vPortFree( pxQueue );
    124e:	ce 01       	movw	r24, r28
    1250:	0e 94 8d 03 	call	0x71a	; 0x71a <vPortFree>
}
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	08 95       	ret

0000125a <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    125a:	fc 01       	movw	r30, r24
    125c:	92 8d       	ldd	r25, Z+26	; 0x1a
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	91 11       	cpse	r25, r1
    1262:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1264:	08 95       	ret

00001266 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1266:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1268:	22 8d       	ldd	r18, Z+26	; 0x1a
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	93 8d       	ldd	r25, Z+27	; 0x1b
    126e:	29 13       	cpse	r18, r25
    1270:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1272:	08 95       	ret

00001274 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1274:	cf 93       	push	r28
    1276:	df 93       	push	r29
    1278:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    127a:	e0 91 6c 1a 	lds	r30, 0x1A6C
    127e:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1282:	93 83       	std	Z+3, r25	; 0x03
    1284:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1286:	80 91 74 1a 	lds	r24, 0x1A74
    128a:	90 91 75 1a 	lds	r25, 0x1A75
    128e:	c8 17       	cp	r28, r24
    1290:	d9 07       	cpc	r29, r25
    1292:	68 f4       	brcc	.+26     	; 0x12ae <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1294:	80 91 77 1a 	lds	r24, 0x1A77
    1298:	90 91 78 1a 	lds	r25, 0x1A78
    129c:	60 91 6c 1a 	lds	r22, 0x1A6C
    12a0:	70 91 6d 1a 	lds	r23, 0x1A6D
    12a4:	6e 5f       	subi	r22, 0xFE	; 254
    12a6:	7f 4f       	sbci	r23, 0xFF	; 255
    12a8:	0e 94 d7 03 	call	0x7ae	; 0x7ae <vListInsert>
    12ac:	17 c0       	rjmp	.+46     	; 0x12dc <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    12ae:	80 91 79 1a 	lds	r24, 0x1A79
    12b2:	90 91 7a 1a 	lds	r25, 0x1A7A
    12b6:	60 91 6c 1a 	lds	r22, 0x1A6C
    12ba:	70 91 6d 1a 	lds	r23, 0x1A6D
    12be:	6e 5f       	subi	r22, 0xFE	; 254
    12c0:	7f 4f       	sbci	r23, 0xFF	; 255
    12c2:	0e 94 d7 03 	call	0x7ae	; 0x7ae <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    12c6:	80 91 2d 02 	lds	r24, 0x022D
    12ca:	90 91 2e 02 	lds	r25, 0x022E
    12ce:	c8 17       	cp	r28, r24
    12d0:	d9 07       	cpc	r29, r25
    12d2:	20 f4       	brcc	.+8      	; 0x12dc <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    12d4:	d0 93 2e 02 	sts	0x022E, r29
    12d8:	c0 93 2d 02 	sts	0x022D, r28
		}
	}
}
    12dc:	df 91       	pop	r29
    12de:	cf 91       	pop	r28
    12e0:	08 95       	ret

000012e2 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    12e2:	cd e7       	ldi	r28, 0x7D	; 125
    12e4:	da e1       	ldi	r29, 0x1A	; 26
    12e6:	88 81       	ld	r24, Y
    12e8:	82 30       	cpi	r24, 0x02	; 2
    12ea:	e8 f3       	brcs	.-6      	; 0x12e6 <prvIdleTask+0x4>
			{
				taskYIELD();
    12ec:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
    12f0:	fa cf       	rjmp	.-12     	; 0x12e6 <prvIdleTask+0x4>

000012f2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    12f2:	4f 92       	push	r4
    12f4:	5f 92       	push	r5
    12f6:	6f 92       	push	r6
    12f8:	7f 92       	push	r7
    12fa:	8f 92       	push	r8
    12fc:	9f 92       	push	r9
    12fe:	bf 92       	push	r11
    1300:	cf 92       	push	r12
    1302:	df 92       	push	r13
    1304:	ef 92       	push	r14
    1306:	ff 92       	push	r15
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	2c 01       	movw	r4, r24
    1312:	4b 01       	movw	r8, r22
    1314:	ea 01       	movw	r28, r20
    1316:	39 01       	movw	r6, r18
    1318:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    131a:	8a e2       	ldi	r24, 0x2A	; 42
    131c:	90 e0       	ldi	r25, 0x00	; 0
    131e:	0e 94 64 03 	call	0x6c8	; 0x6c8 <pvPortMalloc>
    1322:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1324:	00 97       	sbiw	r24, 0x00	; 0
    1326:	09 f4       	brne	.+2      	; 0x132a <xTaskGenericCreate+0x38>
    1328:	e3 c0       	rjmp	.+454    	; 0x14f0 <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    132a:	c1 14       	cp	r12, r1
    132c:	d1 04       	cpc	r13, r1
    132e:	09 f0       	breq	.+2      	; 0x1332 <xTaskGenericCreate+0x40>
    1330:	f4 c0       	rjmp	.+488    	; 0x151a <xTaskGenericCreate+0x228>
    1332:	ce 01       	movw	r24, r28
    1334:	0e 94 64 03 	call	0x6c8	; 0x6c8 <pvPortMalloc>
    1338:	6c 01       	movw	r12, r24
    133a:	f8 01       	movw	r30, r16
    133c:	90 8f       	std	Z+24, r25	; 0x18
    133e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1340:	00 97       	sbiw	r24, 0x00	; 0
    1342:	29 f4       	brne	.+10     	; 0x134e <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1344:	c8 01       	movw	r24, r16
    1346:	0e 94 8d 03 	call	0x71a	; 0x71a <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    134a:	8f ef       	ldi	r24, 0xFF	; 255
    134c:	d6 c0       	rjmp	.+428    	; 0x14fa <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    134e:	c6 01       	movw	r24, r12
    1350:	65 ea       	ldi	r22, 0xA5	; 165
    1352:	70 e0       	ldi	r23, 0x00	; 0
    1354:	ae 01       	movw	r20, r28
    1356:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    135a:	9e 01       	movw	r18, r28
    135c:	21 50       	subi	r18, 0x01	; 1
    135e:	30 40       	sbci	r19, 0x00	; 0
    1360:	f8 01       	movw	r30, r16
    1362:	87 89       	ldd	r24, Z+23	; 0x17
    1364:	90 8d       	ldd	r25, Z+24	; 0x18
    1366:	6c 01       	movw	r12, r24
    1368:	c2 0e       	add	r12, r18
    136a:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    136c:	c8 01       	movw	r24, r16
    136e:	49 96       	adiw	r24, 0x19	; 25
    1370:	b4 01       	movw	r22, r8
    1372:	40 e1       	ldi	r20, 0x10	; 16
    1374:	50 e0       	ldi	r21, 0x00	; 0
    1376:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    137a:	f8 01       	movw	r30, r16
    137c:	10 a6       	lds	r17, 0xb0
    137e:	cb 2d       	mov	r28, r11
    1380:	f3 e0       	ldi	r31, 0x03	; 3
    1382:	fb 15       	cp	r31, r11
    1384:	08 f4       	brcc	.+2      	; 0x1388 <xTaskGenericCreate+0x96>
    1386:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1388:	f8 01       	movw	r30, r16
    138a:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    138c:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    138e:	88 24       	eor	r8, r8
    1390:	99 24       	eor	r9, r9
    1392:	68 94       	set
    1394:	81 f8       	bld	r8, 1
    1396:	80 0e       	add	r8, r16
    1398:	91 1e       	adc	r9, r17
    139a:	c4 01       	movw	r24, r8
    139c:	0e 94 aa 03 	call	0x754	; 0x754 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    13a0:	c8 01       	movw	r24, r16
    13a2:	0c 96       	adiw	r24, 0x0c	; 12
    13a4:	0e 94 aa 03 	call	0x754	; 0x754 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    13a8:	f8 01       	movw	r30, r16
    13aa:	11 87       	std	Z+9, r17	; 0x09
    13ac:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    13ae:	84 e0       	ldi	r24, 0x04	; 4
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    13b2:	8c 1b       	sub	r24, r28
    13b4:	91 09       	sbc	r25, r1
    13b6:	95 87       	std	Z+13, r25	; 0x0d
    13b8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    13ba:	13 8b       	std	Z+19, r17	; 0x13
    13bc:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    13be:	c6 01       	movw	r24, r12
    13c0:	b2 01       	movw	r22, r4
    13c2:	a3 01       	movw	r20, r6
    13c4:	0e 94 3b 04 	call	0x876	; 0x876 <pxPortInitialiseStack>
    13c8:	f8 01       	movw	r30, r16
    13ca:	91 83       	std	Z+1, r25	; 0x01
    13cc:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    13ce:	e1 14       	cp	r14, r1
    13d0:	f1 04       	cpc	r15, r1
    13d2:	19 f0       	breq	.+6      	; 0x13da <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    13d4:	f7 01       	movw	r30, r14
    13d6:	11 83       	std	Z+1, r17	; 0x01
    13d8:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    13e0:	80 91 76 1a 	lds	r24, 0x1A76
    13e4:	8f 5f       	subi	r24, 0xFF	; 255
    13e6:	80 93 76 1a 	sts	0x1A76, r24
			if( pxCurrentTCB == NULL )
    13ea:	80 91 6c 1a 	lds	r24, 0x1A6C
    13ee:	90 91 6d 1a 	lds	r25, 0x1A6D
    13f2:	00 97       	sbiw	r24, 0x00	; 0
    13f4:	d9 f5       	brne	.+118    	; 0x146c <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    13f6:	10 93 6d 1a 	sts	0x1A6D, r17
    13fa:	00 93 6c 1a 	sts	0x1A6C, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    13fe:	80 91 76 1a 	lds	r24, 0x1A76
    1402:	81 30       	cpi	r24, 0x01	; 1
    1404:	09 f0       	breq	.+2      	; 0x1408 <xTaskGenericCreate+0x116>
    1406:	41 c0       	rjmp	.+130    	; 0x148a <xTaskGenericCreate+0x198>
    1408:	c0 e0       	ldi	r28, 0x00	; 0
    140a:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    140c:	ce 01       	movw	r24, r28
    140e:	88 0f       	add	r24, r24
    1410:	99 1f       	adc	r25, r25
    1412:	88 0f       	add	r24, r24
    1414:	99 1f       	adc	r25, r25
    1416:	88 0f       	add	r24, r24
    1418:	99 1f       	adc	r25, r25
    141a:	8c 0f       	add	r24, r28
    141c:	9d 1f       	adc	r25, r29
    141e:	83 58       	subi	r24, 0x83	; 131
    1420:	95 4e       	sbci	r25, 0xE5	; 229
    1422:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
    1426:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1428:	c4 30       	cpi	r28, 0x04	; 4
    142a:	d1 05       	cpc	r29, r1
    142c:	79 f7       	brne	.-34     	; 0x140c <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    142e:	c1 ea       	ldi	r28, 0xA1	; 161
    1430:	da e1       	ldi	r29, 0x1A	; 26
    1432:	ce 01       	movw	r24, r28
    1434:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1438:	0f 2e       	mov	r0, r31
    143a:	fa ea       	ldi	r31, 0xAA	; 170
    143c:	ef 2e       	mov	r14, r31
    143e:	fa e1       	ldi	r31, 0x1A	; 26
    1440:	ff 2e       	mov	r15, r31
    1442:	f0 2d       	mov	r31, r0
    1444:	c7 01       	movw	r24, r14
    1446:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    144a:	83 eb       	ldi	r24, 0xB3	; 179
    144c:	9a e1       	ldi	r25, 0x1A	; 26
    144e:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1452:	8c eb       	ldi	r24, 0xBC	; 188
    1454:	9a e1       	ldi	r25, 0x1A	; 26
    1456:	0e 94 9c 03 	call	0x738	; 0x738 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    145a:	d0 93 7a 1a 	sts	0x1A7A, r29
    145e:	c0 93 79 1a 	sts	0x1A79, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1462:	f0 92 78 1a 	sts	0x1A78, r15
    1466:	e0 92 77 1a 	sts	0x1A77, r14
    146a:	0f c0       	rjmp	.+30     	; 0x148a <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    146c:	80 91 72 1a 	lds	r24, 0x1A72
    1470:	88 23       	and	r24, r24
    1472:	59 f4       	brne	.+22     	; 0x148a <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1474:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1478:	f0 91 6d 1a 	lds	r31, 0x1A6D
    147c:	86 89       	ldd	r24, Z+22	; 0x16
    147e:	b8 16       	cp	r11, r24
    1480:	20 f0       	brcs	.+8      	; 0x148a <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    1482:	10 93 6d 1a 	sts	0x1A6D, r17
    1486:	00 93 6c 1a 	sts	0x1A6C, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    148a:	f8 01       	movw	r30, r16
    148c:	86 89       	ldd	r24, Z+22	; 0x16
    148e:	90 91 7b 1a 	lds	r25, 0x1A7B
    1492:	98 17       	cp	r25, r24
    1494:	10 f4       	brcc	.+4      	; 0x149a <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1496:	80 93 7b 1a 	sts	0x1A7B, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    149a:	90 91 7c 1a 	lds	r25, 0x1A7C
    149e:	9f 5f       	subi	r25, 0xFF	; 255
    14a0:	90 93 7c 1a 	sts	0x1A7C, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    14a4:	90 91 73 1a 	lds	r25, 0x1A73
    14a8:	98 17       	cp	r25, r24
    14aa:	10 f4       	brcc	.+4      	; 0x14b0 <xTaskGenericCreate+0x1be>
    14ac:	80 93 73 1a 	sts	0x1A73, r24
    14b0:	90 e0       	ldi	r25, 0x00	; 0
    14b2:	9c 01       	movw	r18, r24
    14b4:	22 0f       	add	r18, r18
    14b6:	33 1f       	adc	r19, r19
    14b8:	22 0f       	add	r18, r18
    14ba:	33 1f       	adc	r19, r19
    14bc:	22 0f       	add	r18, r18
    14be:	33 1f       	adc	r19, r19
    14c0:	82 0f       	add	r24, r18
    14c2:	93 1f       	adc	r25, r19
    14c4:	83 58       	subi	r24, 0x83	; 131
    14c6:	95 4e       	sbci	r25, 0xE5	; 229
    14c8:	b4 01       	movw	r22, r8
    14ca:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    14d2:	80 91 72 1a 	lds	r24, 0x1A72
    14d6:	88 23       	and	r24, r24
    14d8:	69 f0       	breq	.+26     	; 0x14f4 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    14da:	e0 91 6c 1a 	lds	r30, 0x1A6C
    14de:	f0 91 6d 1a 	lds	r31, 0x1A6D
    14e2:	86 89       	ldd	r24, Z+22	; 0x16
    14e4:	8b 15       	cp	r24, r11
    14e6:	40 f4       	brcc	.+16     	; 0x14f8 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    14e8:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	05 c0       	rjmp	.+10     	; 0x14fa <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    14f0:	8f ef       	ldi	r24, 0xFF	; 255
    14f2:	03 c0       	rjmp	.+6      	; 0x14fa <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    14f4:	81 e0       	ldi	r24, 0x01	; 1
    14f6:	01 c0       	rjmp	.+2      	; 0x14fa <xTaskGenericCreate+0x208>
    14f8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    14fa:	df 91       	pop	r29
    14fc:	cf 91       	pop	r28
    14fe:	1f 91       	pop	r17
    1500:	0f 91       	pop	r16
    1502:	ff 90       	pop	r15
    1504:	ef 90       	pop	r14
    1506:	df 90       	pop	r13
    1508:	cf 90       	pop	r12
    150a:	bf 90       	pop	r11
    150c:	9f 90       	pop	r9
    150e:	8f 90       	pop	r8
    1510:	7f 90       	pop	r7
    1512:	6f 90       	pop	r6
    1514:	5f 90       	pop	r5
    1516:	4f 90       	pop	r4
    1518:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    151a:	fc 01       	movw	r30, r24
    151c:	d0 8e       	std	Z+24, r13	; 0x18
    151e:	c7 8a       	std	Z+23, r12	; 0x17
    1520:	16 cf       	rjmp	.-468    	; 0x134e <xTaskGenericCreate+0x5c>

00001522 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    1522:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1524:	82 85       	ldd	r24, Z+10	; 0x0a
    1526:	93 85       	ldd	r25, Z+11	; 0x0b
    1528:	2a e1       	ldi	r18, 0x1A	; 26
    152a:	8c 3b       	cpi	r24, 0xBC	; 188
    152c:	92 07       	cpc	r25, r18
    152e:	61 f4       	brne	.+24     	; 0x1548 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    1530:	24 89       	ldd	r18, Z+20	; 0x14
    1532:	35 89       	ldd	r19, Z+21	; 0x15
    1534:	8a e1       	ldi	r24, 0x1A	; 26
    1536:	23 3b       	cpi	r18, 0xB3	; 179
    1538:	38 07       	cpc	r19, r24
    153a:	41 f0       	breq	.+16     	; 0x154c <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    153c:	81 e0       	ldi	r24, 0x01	; 1
    153e:	21 15       	cp	r18, r1
    1540:	31 05       	cpc	r19, r1
    1542:	29 f0       	breq	.+10     	; 0x154e <xTaskIsTaskSuspended+0x2c>
    1544:	80 e0       	ldi	r24, 0x00	; 0
    1546:	08 95       	ret
    1548:	80 e0       	ldi	r24, 0x00	; 0
    154a:	08 95       	ret
    154c:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    154e:	08 95       	ret

00001550 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    1550:	0f 93       	push	r16
    1552:	1f 93       	push	r17
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    155a:	00 97       	sbiw	r24, 0x00	; 0
    155c:	b9 f1       	breq	.+110    	; 0x15cc <vTaskResume+0x7c>
    155e:	80 91 6c 1a 	lds	r24, 0x1A6C
    1562:	90 91 6d 1a 	lds	r25, 0x1A6D
    1566:	c8 17       	cp	r28, r24
    1568:	d9 07       	cpc	r29, r25
    156a:	81 f1       	breq	.+96     	; 0x15cc <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1572:	ce 01       	movw	r24, r28
    1574:	0e 94 91 0a 	call	0x1522	; 0x1522 <xTaskIsTaskSuspended>
    1578:	81 30       	cpi	r24, 0x01	; 1
    157a:	31 f5       	brne	.+76     	; 0x15c8 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    157c:	8e 01       	movw	r16, r28
    157e:	0e 5f       	subi	r16, 0xFE	; 254
    1580:	1f 4f       	sbci	r17, 0xFF	; 255
    1582:	c8 01       	movw	r24, r16
    1584:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1588:	8e 89       	ldd	r24, Y+22	; 0x16
    158a:	90 91 73 1a 	lds	r25, 0x1A73
    158e:	98 17       	cp	r25, r24
    1590:	10 f4       	brcc	.+4      	; 0x1596 <vTaskResume+0x46>
    1592:	80 93 73 1a 	sts	0x1A73, r24
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	9c 01       	movw	r18, r24
    159a:	22 0f       	add	r18, r18
    159c:	33 1f       	adc	r19, r19
    159e:	22 0f       	add	r18, r18
    15a0:	33 1f       	adc	r19, r19
    15a2:	22 0f       	add	r18, r18
    15a4:	33 1f       	adc	r19, r19
    15a6:	82 0f       	add	r24, r18
    15a8:	93 1f       	adc	r25, r19
    15aa:	83 58       	subi	r24, 0x83	; 131
    15ac:	95 4e       	sbci	r25, 0xE5	; 229
    15ae:	b8 01       	movw	r22, r16
    15b0:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    15b4:	e0 91 6c 1a 	lds	r30, 0x1A6C
    15b8:	f0 91 6d 1a 	lds	r31, 0x1A6D
    15bc:	9e 89       	ldd	r25, Y+22	; 0x16
    15be:	86 89       	ldd	r24, Z+22	; 0x16
    15c0:	98 17       	cp	r25, r24
    15c2:	10 f0       	brcs	.+4      	; 0x15c8 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    15c4:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    15c8:	0f 90       	pop	r0
    15ca:	0f be       	out	0x3f, r0	; 63
		}
	}
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	08 95       	ret

000015d6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    15d6:	ef 92       	push	r14
    15d8:	ff 92       	push	r15
    15da:	1f 93       	push	r17
    15dc:	cf 93       	push	r28
    15de:	df 93       	push	r29
    15e0:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    15e2:	0e 94 91 0a 	call	0x1522	; 0x1522 <xTaskIsTaskSuspended>
    15e6:	81 30       	cpi	r24, 0x01	; 1
    15e8:	b9 f5       	brne	.+110    	; 0x1658 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    15ea:	80 91 71 1a 	lds	r24, 0x1A71
    15ee:	88 23       	and	r24, r24
    15f0:	51 f5       	brne	.+84     	; 0x1646 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    15f2:	e0 91 6c 1a 	lds	r30, 0x1A6C
    15f6:	f0 91 6d 1a 	lds	r31, 0x1A6D
    15fa:	11 e0       	ldi	r17, 0x01	; 1
    15fc:	9e 89       	ldd	r25, Y+22	; 0x16
    15fe:	86 89       	ldd	r24, Z+22	; 0x16
    1600:	98 17       	cp	r25, r24
    1602:	08 f4       	brcc	.+2      	; 0x1606 <xTaskResumeFromISR+0x30>
    1604:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    1606:	ee 24       	eor	r14, r14
    1608:	ff 24       	eor	r15, r15
    160a:	68 94       	set
    160c:	e1 f8       	bld	r14, 1
    160e:	ec 0e       	add	r14, r28
    1610:	fd 1e       	adc	r15, r29
    1612:	c7 01       	movw	r24, r14
    1614:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1618:	8e 89       	ldd	r24, Y+22	; 0x16
    161a:	90 91 73 1a 	lds	r25, 0x1A73
    161e:	98 17       	cp	r25, r24
    1620:	10 f4       	brcc	.+4      	; 0x1626 <xTaskResumeFromISR+0x50>
    1622:	80 93 73 1a 	sts	0x1A73, r24
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	9c 01       	movw	r18, r24
    162a:	22 0f       	add	r18, r18
    162c:	33 1f       	adc	r19, r19
    162e:	22 0f       	add	r18, r18
    1630:	33 1f       	adc	r19, r19
    1632:	22 0f       	add	r18, r18
    1634:	33 1f       	adc	r19, r19
    1636:	82 0f       	add	r24, r18
    1638:	93 1f       	adc	r25, r19
    163a:	83 58       	subi	r24, 0x83	; 131
    163c:	95 4e       	sbci	r25, 0xE5	; 229
    163e:	b7 01       	movw	r22, r14
    1640:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
    1644:	0a c0       	rjmp	.+20     	; 0x165a <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1646:	be 01       	movw	r22, r28
    1648:	64 5f       	subi	r22, 0xF4	; 244
    164a:	7f 4f       	sbci	r23, 0xFF	; 255
    164c:	83 eb       	ldi	r24, 0xB3	; 179
    164e:	9a e1       	ldi	r25, 0x1A	; 26
    1650:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    1654:	10 e0       	ldi	r17, 0x00	; 0
    1656:	01 c0       	rjmp	.+2      	; 0x165a <xTaskResumeFromISR+0x84>
    1658:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    165a:	81 2f       	mov	r24, r17
    165c:	df 91       	pop	r29
    165e:	cf 91       	pop	r28
    1660:	1f 91       	pop	r17
    1662:	ff 90       	pop	r15
    1664:	ef 90       	pop	r14
    1666:	08 95       	ret

00001668 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1668:	af 92       	push	r10
    166a:	bf 92       	push	r11
    166c:	cf 92       	push	r12
    166e:	df 92       	push	r13
    1670:	ef 92       	push	r14
    1672:	ff 92       	push	r15
    1674:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1676:	81 e7       	ldi	r24, 0x71	; 113
    1678:	99 e0       	ldi	r25, 0x09	; 9
    167a:	68 e2       	ldi	r22, 0x28	; 40
    167c:	72 e0       	ldi	r23, 0x02	; 2
    167e:	45 e5       	ldi	r20, 0x55	; 85
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	20 e0       	ldi	r18, 0x00	; 0
    1684:	30 e0       	ldi	r19, 0x00	; 0
    1686:	00 e0       	ldi	r16, 0x00	; 0
    1688:	ee 24       	eor	r14, r14
    168a:	ff 24       	eor	r15, r15
    168c:	cc 24       	eor	r12, r12
    168e:	dd 24       	eor	r13, r13
    1690:	aa 24       	eor	r10, r10
    1692:	bb 24       	eor	r11, r11
    1694:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1698:	81 30       	cpi	r24, 0x01	; 1
    169a:	49 f4       	brne	.+18     	; 0x16ae <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    169c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    169e:	80 93 72 1a 	sts	0x1A72, r24
		xTickCount = ( portTickType ) 0U;
    16a2:	10 92 75 1a 	sts	0x1A75, r1
    16a6:	10 92 74 1a 	sts	0x1A74, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    16aa:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    16ae:	0f 91       	pop	r16
    16b0:	ff 90       	pop	r15
    16b2:	ef 90       	pop	r14
    16b4:	df 90       	pop	r13
    16b6:	cf 90       	pop	r12
    16b8:	bf 90       	pop	r11
    16ba:	af 90       	pop	r10
    16bc:	08 95       	ret

000016be <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    16be:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    16c0:	10 92 72 1a 	sts	0x1A72, r1
	vPortEndScheduler();
    16c4:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortEndScheduler>
}
    16c8:	08 95       	ret

000016ca <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    16ca:	80 91 71 1a 	lds	r24, 0x1A71
    16ce:	8f 5f       	subi	r24, 0xFF	; 255
    16d0:	80 93 71 1a 	sts	0x1A71, r24
}
    16d4:	08 95       	ret

000016d6 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    16d6:	0f b6       	in	r0, 0x3f	; 63
    16d8:	f8 94       	cli
    16da:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    16dc:	80 91 74 1a 	lds	r24, 0x1A74
    16e0:	90 91 75 1a 	lds	r25, 0x1A75
	}
	taskEXIT_CRITICAL();
    16e4:	0f 90       	pop	r0
    16e6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    16e8:	08 95       	ret

000016ea <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    16ea:	80 91 74 1a 	lds	r24, 0x1A74
    16ee:	90 91 75 1a 	lds	r25, 0x1A75
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16f2:	08 95       	ret

000016f4 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    16f4:	80 91 76 1a 	lds	r24, 0x1A76
}
    16f8:	08 95       	ret

000016fa <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    16fa:	0f 93       	push	r16
    16fc:	1f 93       	push	r17
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1702:	80 91 71 1a 	lds	r24, 0x1A71
    1706:	88 23       	and	r24, r24
    1708:	09 f0       	breq	.+2      	; 0x170c <vTaskIncrementTick+0x12>
    170a:	b3 c0       	rjmp	.+358    	; 0x1872 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    170c:	80 91 74 1a 	lds	r24, 0x1A74
    1710:	90 91 75 1a 	lds	r25, 0x1A75
    1714:	01 96       	adiw	r24, 0x01	; 1
    1716:	90 93 75 1a 	sts	0x1A75, r25
    171a:	80 93 74 1a 	sts	0x1A74, r24
		if( xTickCount == ( portTickType ) 0U )
    171e:	80 91 74 1a 	lds	r24, 0x1A74
    1722:	90 91 75 1a 	lds	r25, 0x1A75
    1726:	00 97       	sbiw	r24, 0x00	; 0
    1728:	99 f5       	brne	.+102    	; 0x1790 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    172a:	80 91 79 1a 	lds	r24, 0x1A79
    172e:	90 91 7a 1a 	lds	r25, 0x1A7A
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1732:	20 91 77 1a 	lds	r18, 0x1A77
    1736:	30 91 78 1a 	lds	r19, 0x1A78
    173a:	30 93 7a 1a 	sts	0x1A7A, r19
    173e:	20 93 79 1a 	sts	0x1A79, r18
			pxOverflowDelayedTaskList = pxTemp;
    1742:	90 93 78 1a 	sts	0x1A78, r25
    1746:	80 93 77 1a 	sts	0x1A77, r24
			xNumOfOverflows++;
    174a:	80 91 6e 1a 	lds	r24, 0x1A6E
    174e:	8f 5f       	subi	r24, 0xFF	; 255
    1750:	80 93 6e 1a 	sts	0x1A6E, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1754:	e0 91 79 1a 	lds	r30, 0x1A79
    1758:	f0 91 7a 1a 	lds	r31, 0x1A7A
    175c:	80 81       	ld	r24, Z
    175e:	88 23       	and	r24, r24
    1760:	39 f4       	brne	.+14     	; 0x1770 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1762:	8f ef       	ldi	r24, 0xFF	; 255
    1764:	9f ef       	ldi	r25, 0xFF	; 255
    1766:	90 93 2e 02 	sts	0x022E, r25
    176a:	80 93 2d 02 	sts	0x022D, r24
    176e:	10 c0       	rjmp	.+32     	; 0x1790 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1770:	e0 91 79 1a 	lds	r30, 0x1A79
    1774:	f0 91 7a 1a 	lds	r31, 0x1A7A
    1778:	05 80       	ldd	r0, Z+5	; 0x05
    177a:	f6 81       	ldd	r31, Z+6	; 0x06
    177c:	e0 2d       	mov	r30, r0
    177e:	06 80       	ldd	r0, Z+6	; 0x06
    1780:	f7 81       	ldd	r31, Z+7	; 0x07
    1782:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1784:	82 81       	ldd	r24, Z+2	; 0x02
    1786:	93 81       	ldd	r25, Z+3	; 0x03
    1788:	90 93 2e 02 	sts	0x022E, r25
    178c:	80 93 2d 02 	sts	0x022D, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1790:	20 91 74 1a 	lds	r18, 0x1A74
    1794:	30 91 75 1a 	lds	r19, 0x1A75
    1798:	80 91 2d 02 	lds	r24, 0x022D
    179c:	90 91 2e 02 	lds	r25, 0x022E
    17a0:	28 17       	cp	r18, r24
    17a2:	39 07       	cpc	r19, r25
    17a4:	08 f4       	brcc	.+2      	; 0x17a8 <vTaskIncrementTick+0xae>
    17a6:	6a c0       	rjmp	.+212    	; 0x187c <vTaskIncrementTick+0x182>
    17a8:	e0 91 79 1a 	lds	r30, 0x1A79
    17ac:	f0 91 7a 1a 	lds	r31, 0x1A7A
    17b0:	80 81       	ld	r24, Z
    17b2:	88 23       	and	r24, r24
    17b4:	99 f0       	breq	.+38     	; 0x17dc <vTaskIncrementTick+0xe2>
    17b6:	e0 91 79 1a 	lds	r30, 0x1A79
    17ba:	f0 91 7a 1a 	lds	r31, 0x1A7A
    17be:	05 80       	ldd	r0, Z+5	; 0x05
    17c0:	f6 81       	ldd	r31, Z+6	; 0x06
    17c2:	e0 2d       	mov	r30, r0
    17c4:	c6 81       	ldd	r28, Z+6	; 0x06
    17c6:	d7 81       	ldd	r29, Z+7	; 0x07
    17c8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ca:	9b 81       	ldd	r25, Y+3	; 0x03
    17cc:	20 91 74 1a 	lds	r18, 0x1A74
    17d0:	30 91 75 1a 	lds	r19, 0x1A75
    17d4:	28 17       	cp	r18, r24
    17d6:	39 07       	cpc	r19, r25
    17d8:	f8 f4       	brcc	.+62     	; 0x1818 <vTaskIncrementTick+0x11e>
    17da:	19 c0       	rjmp	.+50     	; 0x180e <vTaskIncrementTick+0x114>
    17dc:	8f ef       	ldi	r24, 0xFF	; 255
    17de:	9f ef       	ldi	r25, 0xFF	; 255
    17e0:	90 93 2e 02 	sts	0x022E, r25
    17e4:	80 93 2d 02 	sts	0x022D, r24
    17e8:	49 c0       	rjmp	.+146    	; 0x187c <vTaskIncrementTick+0x182>
    17ea:	e0 91 79 1a 	lds	r30, 0x1A79
    17ee:	f0 91 7a 1a 	lds	r31, 0x1A7A
    17f2:	05 80       	ldd	r0, Z+5	; 0x05
    17f4:	f6 81       	ldd	r31, Z+6	; 0x06
    17f6:	e0 2d       	mov	r30, r0
    17f8:	c6 81       	ldd	r28, Z+6	; 0x06
    17fa:	d7 81       	ldd	r29, Z+7	; 0x07
    17fc:	8a 81       	ldd	r24, Y+2	; 0x02
    17fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1800:	20 91 74 1a 	lds	r18, 0x1A74
    1804:	30 91 75 1a 	lds	r19, 0x1A75
    1808:	28 17       	cp	r18, r24
    180a:	39 07       	cpc	r19, r25
    180c:	28 f4       	brcc	.+10     	; 0x1818 <vTaskIncrementTick+0x11e>
    180e:	90 93 2e 02 	sts	0x022E, r25
    1812:	80 93 2d 02 	sts	0x022D, r24
    1816:	32 c0       	rjmp	.+100    	; 0x187c <vTaskIncrementTick+0x182>
    1818:	8e 01       	movw	r16, r28
    181a:	0e 5f       	subi	r16, 0xFE	; 254
    181c:	1f 4f       	sbci	r17, 0xFF	; 255
    181e:	c8 01       	movw	r24, r16
    1820:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
    1824:	8c 89       	ldd	r24, Y+20	; 0x14
    1826:	9d 89       	ldd	r25, Y+21	; 0x15
    1828:	00 97       	sbiw	r24, 0x00	; 0
    182a:	21 f0       	breq	.+8      	; 0x1834 <vTaskIncrementTick+0x13a>
    182c:	ce 01       	movw	r24, r28
    182e:	0c 96       	adiw	r24, 0x0c	; 12
    1830:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
    1834:	8e 89       	ldd	r24, Y+22	; 0x16
    1836:	90 91 73 1a 	lds	r25, 0x1A73
    183a:	98 17       	cp	r25, r24
    183c:	10 f4       	brcc	.+4      	; 0x1842 <vTaskIncrementTick+0x148>
    183e:	80 93 73 1a 	sts	0x1A73, r24
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	9c 01       	movw	r18, r24
    1846:	22 0f       	add	r18, r18
    1848:	33 1f       	adc	r19, r19
    184a:	22 0f       	add	r18, r18
    184c:	33 1f       	adc	r19, r19
    184e:	22 0f       	add	r18, r18
    1850:	33 1f       	adc	r19, r19
    1852:	82 0f       	add	r24, r18
    1854:	93 1f       	adc	r25, r19
    1856:	83 58       	subi	r24, 0x83	; 131
    1858:	95 4e       	sbci	r25, 0xE5	; 229
    185a:	b8 01       	movw	r22, r16
    185c:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
    1860:	e0 91 79 1a 	lds	r30, 0x1A79
    1864:	f0 91 7a 1a 	lds	r31, 0x1A7A
    1868:	80 81       	ld	r24, Z
    186a:	88 23       	and	r24, r24
    186c:	09 f0       	breq	.+2      	; 0x1870 <vTaskIncrementTick+0x176>
    186e:	bd cf       	rjmp	.-134    	; 0x17ea <vTaskIncrementTick+0xf0>
    1870:	b5 cf       	rjmp	.-150    	; 0x17dc <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    1872:	80 91 70 1a 	lds	r24, 0x1A70
    1876:	8f 5f       	subi	r24, 0xFF	; 255
    1878:	80 93 70 1a 	sts	0x1A70, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    187c:	df 91       	pop	r29
    187e:	cf 91       	pop	r28
    1880:	1f 91       	pop	r17
    1882:	0f 91       	pop	r16
    1884:	08 95       	ret

00001886 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1886:	af 92       	push	r10
    1888:	bf 92       	push	r11
    188a:	cf 92       	push	r12
    188c:	df 92       	push	r13
    188e:	ef 92       	push	r14
    1890:	ff 92       	push	r15
    1892:	0f 93       	push	r16
    1894:	1f 93       	push	r17
    1896:	cf 93       	push	r28
    1898:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    189a:	0f b6       	in	r0, 0x3f	; 63
    189c:	f8 94       	cli
    189e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    18a0:	80 91 71 1a 	lds	r24, 0x1A71
    18a4:	81 50       	subi	r24, 0x01	; 1
    18a6:	80 93 71 1a 	sts	0x1A71, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    18aa:	80 91 71 1a 	lds	r24, 0x1A71
    18ae:	88 23       	and	r24, r24
    18b0:	09 f0       	breq	.+2      	; 0x18b4 <xTaskResumeAll+0x2e>
    18b2:	69 c0       	rjmp	.+210    	; 0x1986 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    18b4:	80 91 76 1a 	lds	r24, 0x1A76
    18b8:	88 23       	and	r24, r24
    18ba:	81 f5       	brne	.+96     	; 0x191c <xTaskResumeAll+0x96>
    18bc:	67 c0       	rjmp	.+206    	; 0x198c <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    18be:	d6 01       	movw	r26, r12
    18c0:	ed 91       	ld	r30, X+
    18c2:	fc 91       	ld	r31, X
    18c4:	c6 81       	ldd	r28, Z+6	; 0x06
    18c6:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    18c8:	ce 01       	movw	r24, r28
    18ca:	0c 96       	adiw	r24, 0x0c	; 12
    18cc:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    18d0:	8e 01       	movw	r16, r28
    18d2:	0e 5f       	subi	r16, 0xFE	; 254
    18d4:	1f 4f       	sbci	r17, 0xFF	; 255
    18d6:	c8 01       	movw	r24, r16
    18d8:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    18dc:	8e 89       	ldd	r24, Y+22	; 0x16
    18de:	90 91 73 1a 	lds	r25, 0x1A73
    18e2:	98 17       	cp	r25, r24
    18e4:	10 f4       	brcc	.+4      	; 0x18ea <xTaskResumeAll+0x64>
    18e6:	80 93 73 1a 	sts	0x1A73, r24
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	9c 01       	movw	r18, r24
    18ee:	22 0f       	add	r18, r18
    18f0:	33 1f       	adc	r19, r19
    18f2:	22 0f       	add	r18, r18
    18f4:	33 1f       	adc	r19, r19
    18f6:	22 0f       	add	r18, r18
    18f8:	33 1f       	adc	r19, r19
    18fa:	82 0f       	add	r24, r18
    18fc:	93 1f       	adc	r25, r19
    18fe:	83 58       	subi	r24, 0x83	; 131
    1900:	95 4e       	sbci	r25, 0xE5	; 229
    1902:	b8 01       	movw	r22, r16
    1904:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1908:	e0 91 6c 1a 	lds	r30, 0x1A6C
    190c:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1910:	9e 89       	ldd	r25, Y+22	; 0x16
    1912:	86 89       	ldd	r24, Z+22	; 0x16
    1914:	98 17       	cp	r25, r24
    1916:	88 f0       	brcs	.+34     	; 0x193a <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1918:	ba 2c       	mov	r11, r10
    191a:	0f c0       	rjmp	.+30     	; 0x193a <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    191c:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    191e:	0f 2e       	mov	r0, r31
    1920:	f3 eb       	ldi	r31, 0xB3	; 179
    1922:	ef 2e       	mov	r14, r31
    1924:	fa e1       	ldi	r31, 0x1A	; 26
    1926:	ff 2e       	mov	r15, r31
    1928:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    192a:	0f 2e       	mov	r0, r31
    192c:	f8 eb       	ldi	r31, 0xB8	; 184
    192e:	cf 2e       	mov	r12, r31
    1930:	fa e1       	ldi	r31, 0x1A	; 26
    1932:	df 2e       	mov	r13, r31
    1934:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1936:	aa 24       	eor	r10, r10
    1938:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    193a:	f7 01       	movw	r30, r14
    193c:	80 81       	ld	r24, Z
    193e:	88 23       	and	r24, r24
    1940:	09 f0       	breq	.+2      	; 0x1944 <xTaskResumeAll+0xbe>
    1942:	bd cf       	rjmp	.-134    	; 0x18be <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1944:	80 91 70 1a 	lds	r24, 0x1A70
    1948:	88 23       	and	r24, r24
    194a:	81 f0       	breq	.+32     	; 0x196c <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    194c:	80 91 70 1a 	lds	r24, 0x1A70
    1950:	88 23       	and	r24, r24
    1952:	99 f0       	breq	.+38     	; 0x197a <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1954:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <vTaskIncrementTick>
						--uxMissedTicks;
    1958:	80 91 70 1a 	lds	r24, 0x1A70
    195c:	81 50       	subi	r24, 0x01	; 1
    195e:	80 93 70 1a 	sts	0x1A70, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1962:	80 91 70 1a 	lds	r24, 0x1A70
    1966:	88 23       	and	r24, r24
    1968:	a9 f7       	brne	.-22     	; 0x1954 <xTaskResumeAll+0xce>
    196a:	07 c0       	rjmp	.+14     	; 0x197a <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    196c:	f1 e0       	ldi	r31, 0x01	; 1
    196e:	bf 16       	cp	r11, r31
    1970:	21 f0       	breq	.+8      	; 0x197a <xTaskResumeAll+0xf4>
    1972:	80 91 6f 1a 	lds	r24, 0x1A6F
    1976:	81 30       	cpi	r24, 0x01	; 1
    1978:	41 f4       	brne	.+16     	; 0x198a <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    197a:	10 92 6f 1a 	sts	0x1A6F, r1
					portYIELD_WITHIN_API();
    197e:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1982:	81 e0       	ldi	r24, 0x01	; 1
    1984:	03 c0       	rjmp	.+6      	; 0x198c <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1986:	80 e0       	ldi	r24, 0x00	; 0
    1988:	01 c0       	rjmp	.+2      	; 0x198c <xTaskResumeAll+0x106>
    198a:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1990:	df 91       	pop	r29
    1992:	cf 91       	pop	r28
    1994:	1f 91       	pop	r17
    1996:	0f 91       	pop	r16
    1998:	ff 90       	pop	r15
    199a:	ef 90       	pop	r14
    199c:	df 90       	pop	r13
    199e:	cf 90       	pop	r12
    19a0:	bf 90       	pop	r11
    19a2:	af 90       	pop	r10
    19a4:	08 95       	ret

000019a6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    19ac:	00 97       	sbiw	r24, 0x00	; 0
    19ae:	b1 f0       	breq	.+44     	; 0x19dc <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    19b0:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    19b4:	80 91 74 1a 	lds	r24, 0x1A74
    19b8:	90 91 75 1a 	lds	r25, 0x1A75
    19bc:	c8 0f       	add	r28, r24
    19be:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    19c0:	80 91 6c 1a 	lds	r24, 0x1A6C
    19c4:	90 91 6d 1a 	lds	r25, 0x1A6D
    19c8:	02 96       	adiw	r24, 0x02	; 2
    19ca:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    19ce:	ce 01       	movw	r24, r28
    19d0:	0e 94 3a 09 	call	0x1274	; 0x1274 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    19d4:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    19d8:	88 23       	and	r24, r24
    19da:	11 f4       	brne	.+4      	; 0x19e0 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    19dc:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
		}
	}
    19e0:	df 91       	pop	r29
    19e2:	cf 91       	pop	r28
    19e4:	08 95       	ret

000019e6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    19e6:	0f 93       	push	r16
    19e8:	1f 93       	push	r17
    19ea:	cf 93       	push	r28
    19ec:	df 93       	push	r29
    19ee:	8c 01       	movw	r16, r24
    19f0:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    19f2:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    19f6:	f8 01       	movw	r30, r16
    19f8:	80 81       	ld	r24, Z
    19fa:	91 81       	ldd	r25, Z+1	; 0x01
    19fc:	c8 0f       	add	r28, r24
    19fe:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1a00:	20 91 74 1a 	lds	r18, 0x1A74
    1a04:	30 91 75 1a 	lds	r19, 0x1A75
    1a08:	28 17       	cp	r18, r24
    1a0a:	39 07       	cpc	r19, r25
    1a0c:	68 f4       	brcc	.+26     	; 0x1a28 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1a0e:	c8 17       	cp	r28, r24
    1a10:	d9 07       	cpc	r29, r25
    1a12:	50 f5       	brcc	.+84     	; 0x1a68 <vTaskDelayUntil+0x82>
    1a14:	80 91 74 1a 	lds	r24, 0x1A74
    1a18:	90 91 75 1a 	lds	r25, 0x1A75
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1a1c:	d1 83       	std	Z+1, r29	; 0x01
    1a1e:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1a20:	8c 17       	cp	r24, r28
    1a22:	9d 07       	cpc	r25, r29
    1a24:	b0 f4       	brcc	.+44     	; 0x1a52 <vTaskDelayUntil+0x6c>
    1a26:	0b c0       	rjmp	.+22     	; 0x1a3e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1a28:	c8 17       	cp	r28, r24
    1a2a:	d9 07       	cpc	r29, r25
    1a2c:	c8 f0       	brcs	.+50     	; 0x1a60 <vTaskDelayUntil+0x7a>
    1a2e:	80 91 74 1a 	lds	r24, 0x1A74
    1a32:	90 91 75 1a 	lds	r25, 0x1A75
    1a36:	8c 17       	cp	r24, r28
    1a38:	9d 07       	cpc	r25, r29
    1a3a:	90 f0       	brcs	.+36     	; 0x1a60 <vTaskDelayUntil+0x7a>
    1a3c:	15 c0       	rjmp	.+42     	; 0x1a68 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1a3e:	80 91 6c 1a 	lds	r24, 0x1A6C
    1a42:	90 91 6d 1a 	lds	r25, 0x1A6D
    1a46:	02 96       	adiw	r24, 0x02	; 2
    1a48:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	0e 94 3a 09 	call	0x1274	; 0x1274 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1a52:	0e 94 43 0c 	call	0x1886	; 0x1886 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a56:	88 23       	and	r24, r24
    1a58:	59 f4       	brne	.+22     	; 0x1a70 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1a5a:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
    1a5e:	08 c0       	rjmp	.+16     	; 0x1a70 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1a60:	f8 01       	movw	r30, r16
    1a62:	d1 83       	std	Z+1, r29	; 0x01
    1a64:	c0 83       	st	Z, r28
    1a66:	eb cf       	rjmp	.-42     	; 0x1a3e <vTaskDelayUntil+0x58>
    1a68:	f8 01       	movw	r30, r16
    1a6a:	d1 83       	std	Z+1, r29	; 0x01
    1a6c:	c0 83       	st	Z, r28
    1a6e:	f1 cf       	rjmp	.-30     	; 0x1a52 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1a70:	df 91       	pop	r29
    1a72:	cf 91       	pop	r28
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	08 95       	ret

00001a7a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1a7a:	80 91 71 1a 	lds	r24, 0x1A71
    1a7e:	88 23       	and	r24, r24
    1a80:	99 f4       	brne	.+38     	; 0x1aa8 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1a82:	80 91 73 1a 	lds	r24, 0x1A73
    1a86:	90 e0       	ldi	r25, 0x00	; 0
    1a88:	fc 01       	movw	r30, r24
    1a8a:	ee 0f       	add	r30, r30
    1a8c:	ff 1f       	adc	r31, r31
    1a8e:	ee 0f       	add	r30, r30
    1a90:	ff 1f       	adc	r31, r31
    1a92:	ee 0f       	add	r30, r30
    1a94:	ff 1f       	adc	r31, r31
    1a96:	8e 0f       	add	r24, r30
    1a98:	9f 1f       	adc	r25, r31
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	e3 58       	subi	r30, 0x83	; 131
    1a9e:	f5 4e       	sbci	r31, 0xE5	; 229
    1aa0:	80 81       	ld	r24, Z
    1aa2:	88 23       	and	r24, r24
    1aa4:	29 f0       	breq	.+10     	; 0x1ab0 <vTaskSwitchContext+0x36>
    1aa6:	1b c0       	rjmp	.+54     	; 0x1ade <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	80 93 6f 1a 	sts	0x1A6F, r24
    1aae:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1ab0:	80 91 73 1a 	lds	r24, 0x1A73
    1ab4:	81 50       	subi	r24, 0x01	; 1
    1ab6:	80 93 73 1a 	sts	0x1A73, r24
    1aba:	80 91 73 1a 	lds	r24, 0x1A73
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	ee 0f       	add	r30, r30
    1ac8:	ff 1f       	adc	r31, r31
    1aca:	ee 0f       	add	r30, r30
    1acc:	ff 1f       	adc	r31, r31
    1ace:	8e 0f       	add	r24, r30
    1ad0:	9f 1f       	adc	r25, r31
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	e3 58       	subi	r30, 0x83	; 131
    1ad6:	f5 4e       	sbci	r31, 0xE5	; 229
    1ad8:	80 81       	ld	r24, Z
    1ada:	88 23       	and	r24, r24
    1adc:	49 f3       	breq	.-46     	; 0x1ab0 <vTaskSwitchContext+0x36>
    1ade:	80 91 73 1a 	lds	r24, 0x1A73
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	fc 01       	movw	r30, r24
    1ae6:	ee 0f       	add	r30, r30
    1ae8:	ff 1f       	adc	r31, r31
    1aea:	ee 0f       	add	r30, r30
    1aec:	ff 1f       	adc	r31, r31
    1aee:	ee 0f       	add	r30, r30
    1af0:	ff 1f       	adc	r31, r31
    1af2:	e8 0f       	add	r30, r24
    1af4:	f9 1f       	adc	r31, r25
    1af6:	e3 58       	subi	r30, 0x83	; 131
    1af8:	f5 4e       	sbci	r31, 0xE5	; 229
    1afa:	a1 81       	ldd	r26, Z+1	; 0x01
    1afc:	b2 81       	ldd	r27, Z+2	; 0x02
    1afe:	12 96       	adiw	r26, 0x02	; 2
    1b00:	0d 90       	ld	r0, X+
    1b02:	bc 91       	ld	r27, X
    1b04:	a0 2d       	mov	r26, r0
    1b06:	b2 83       	std	Z+2, r27	; 0x02
    1b08:	a1 83       	std	Z+1, r26	; 0x01
    1b0a:	cf 01       	movw	r24, r30
    1b0c:	03 96       	adiw	r24, 0x03	; 3
    1b0e:	a8 17       	cp	r26, r24
    1b10:	b9 07       	cpc	r27, r25
    1b12:	31 f4       	brne	.+12     	; 0x1b20 <vTaskSwitchContext+0xa6>
    1b14:	12 96       	adiw	r26, 0x02	; 2
    1b16:	8d 91       	ld	r24, X+
    1b18:	9c 91       	ld	r25, X
    1b1a:	13 97       	sbiw	r26, 0x03	; 3
    1b1c:	92 83       	std	Z+2, r25	; 0x02
    1b1e:	81 83       	std	Z+1, r24	; 0x01
    1b20:	01 80       	ldd	r0, Z+1	; 0x01
    1b22:	f2 81       	ldd	r31, Z+2	; 0x02
    1b24:	e0 2d       	mov	r30, r0
    1b26:	86 81       	ldd	r24, Z+6	; 0x06
    1b28:	97 81       	ldd	r25, Z+7	; 0x07
    1b2a:	90 93 6d 1a 	sts	0x1A6D, r25
    1b2e:	80 93 6c 1a 	sts	0x1A6C, r24
    1b32:	08 95       	ret

00001b34 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1b34:	ef 92       	push	r14
    1b36:	ff 92       	push	r15
    1b38:	0f 93       	push	r16
    1b3a:	1f 93       	push	r17
    1b3c:	cf 93       	push	r28
    1b3e:	df 93       	push	r29
    1b40:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1b42:	0f b6       	in	r0, 0x3f	; 63
    1b44:	f8 94       	cli
    1b46:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1b48:	80 91 6c 1a 	lds	r24, 0x1A6C
    1b4c:	90 91 6d 1a 	lds	r25, 0x1A6D
    1b50:	e8 16       	cp	r14, r24
    1b52:	f9 06       	cpc	r15, r25
    1b54:	21 f0       	breq	.+8      	; 0x1b5e <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1b56:	e1 14       	cp	r14, r1
    1b58:	f1 04       	cpc	r15, r1
    1b5a:	41 f4       	brne	.+16     	; 0x1b6c <vTaskSuspend+0x38>
    1b5c:	02 c0       	rjmp	.+4      	; 0x1b62 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    1b5e:	ee 24       	eor	r14, r14
    1b60:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1b62:	c0 91 6c 1a 	lds	r28, 0x1A6C
    1b66:	d0 91 6d 1a 	lds	r29, 0x1A6D
    1b6a:	01 c0       	rjmp	.+2      	; 0x1b6e <vTaskSuspend+0x3a>
    1b6c:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1b6e:	8e 01       	movw	r16, r28
    1b70:	0e 5f       	subi	r16, 0xFE	; 254
    1b72:	1f 4f       	sbci	r17, 0xFF	; 255
    1b74:	c8 01       	movw	r24, r16
    1b76:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b7a:	8c 89       	ldd	r24, Y+20	; 0x14
    1b7c:	9d 89       	ldd	r25, Y+21	; 0x15
    1b7e:	00 97       	sbiw	r24, 0x00	; 0
    1b80:	21 f0       	breq	.+8      	; 0x1b8a <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1b82:	ce 01       	movw	r24, r28
    1b84:	0c 96       	adiw	r24, 0x0c	; 12
    1b86:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1b8a:	8c eb       	ldi	r24, 0xBC	; 188
    1b8c:	9a e1       	ldi	r25, 0x1A	; 26
    1b8e:	b8 01       	movw	r22, r16
    1b90:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1b94:	0f 90       	pop	r0
    1b96:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1b98:	e1 14       	cp	r14, r1
    1b9a:	f1 04       	cpc	r15, r1
    1b9c:	a1 f4       	brne	.+40     	; 0x1bc6 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    1b9e:	80 91 72 1a 	lds	r24, 0x1A72
    1ba2:	88 23       	and	r24, r24
    1ba4:	19 f0       	breq	.+6      	; 0x1bac <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1ba6:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortYield>
    1baa:	0d c0       	rjmp	.+26     	; 0x1bc6 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1bac:	90 91 bc 1a 	lds	r25, 0x1ABC
    1bb0:	80 91 76 1a 	lds	r24, 0x1A76
    1bb4:	98 17       	cp	r25, r24
    1bb6:	29 f4       	brne	.+10     	; 0x1bc2 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1bb8:	10 92 6d 1a 	sts	0x1A6D, r1
    1bbc:	10 92 6c 1a 	sts	0x1A6C, r1
    1bc0:	02 c0       	rjmp	.+4      	; 0x1bc6 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    1bc2:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <vTaskSwitchContext>
				}
			}
		}
	}
    1bc6:	df 91       	pop	r29
    1bc8:	cf 91       	pop	r28
    1bca:	1f 91       	pop	r17
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	08 95       	ret

00001bd4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1bd4:	cf 93       	push	r28
    1bd6:	df 93       	push	r29
    1bd8:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1bda:	60 91 6c 1a 	lds	r22, 0x1A6C
    1bde:	70 91 6d 1a 	lds	r23, 0x1A6D
    1be2:	64 5f       	subi	r22, 0xF4	; 244
    1be4:	7f 4f       	sbci	r23, 0xFF	; 255
    1be6:	0e 94 d7 03 	call	0x7ae	; 0x7ae <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1bea:	80 91 6c 1a 	lds	r24, 0x1A6C
    1bee:	90 91 6d 1a 	lds	r25, 0x1A6D
    1bf2:	02 96       	adiw	r24, 0x02	; 2
    1bf4:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1bf8:	8f ef       	ldi	r24, 0xFF	; 255
    1bfa:	cf 3f       	cpi	r28, 0xFF	; 255
    1bfc:	d8 07       	cpc	r29, r24
    1bfe:	59 f4       	brne	.+22     	; 0x1c16 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c00:	60 91 6c 1a 	lds	r22, 0x1A6C
    1c04:	70 91 6d 1a 	lds	r23, 0x1A6D
    1c08:	6e 5f       	subi	r22, 0xFE	; 254
    1c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c0c:	8c eb       	ldi	r24, 0xBC	; 188
    1c0e:	9a e1       	ldi	r25, 0x1A	; 26
    1c10:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
    1c14:	08 c0       	rjmp	.+16     	; 0x1c26 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1c16:	80 91 74 1a 	lds	r24, 0x1A74
    1c1a:	90 91 75 1a 	lds	r25, 0x1A75
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c1e:	8c 0f       	add	r24, r28
    1c20:	9d 1f       	adc	r25, r29
    1c22:	0e 94 3a 09 	call	0x1274	; 0x1274 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1c26:	df 91       	pop	r29
    1c28:	cf 91       	pop	r28
    1c2a:	08 95       	ret

00001c2c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1c2c:	0f 93       	push	r16
    1c2e:	1f 93       	push	r17
    1c30:	cf 93       	push	r28
    1c32:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1c34:	dc 01       	movw	r26, r24
    1c36:	15 96       	adiw	r26, 0x05	; 5
    1c38:	ed 91       	ld	r30, X+
    1c3a:	fc 91       	ld	r31, X
    1c3c:	16 97       	sbiw	r26, 0x06	; 6
    1c3e:	06 81       	ldd	r16, Z+6	; 0x06
    1c40:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1c42:	e8 01       	movw	r28, r16
    1c44:	2c 96       	adiw	r28, 0x0c	; 12
    1c46:	ce 01       	movw	r24, r28
    1c48:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1c4c:	80 91 71 1a 	lds	r24, 0x1A71
    1c50:	88 23       	and	r24, r24
    1c52:	e9 f4       	brne	.+58     	; 0x1c8e <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1c54:	e8 01       	movw	r28, r16
    1c56:	22 96       	adiw	r28, 0x02	; 2
    1c58:	ce 01       	movw	r24, r28
    1c5a:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1c5e:	f8 01       	movw	r30, r16
    1c60:	86 89       	ldd	r24, Z+22	; 0x16
    1c62:	90 91 73 1a 	lds	r25, 0x1A73
    1c66:	98 17       	cp	r25, r24
    1c68:	10 f4       	brcc	.+4      	; 0x1c6e <xTaskRemoveFromEventList+0x42>
    1c6a:	80 93 73 1a 	sts	0x1A73, r24
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	9c 01       	movw	r18, r24
    1c72:	22 0f       	add	r18, r18
    1c74:	33 1f       	adc	r19, r19
    1c76:	22 0f       	add	r18, r18
    1c78:	33 1f       	adc	r19, r19
    1c7a:	22 0f       	add	r18, r18
    1c7c:	33 1f       	adc	r19, r19
    1c7e:	82 0f       	add	r24, r18
    1c80:	93 1f       	adc	r25, r19
    1c82:	83 58       	subi	r24, 0x83	; 131
    1c84:	95 4e       	sbci	r25, 0xE5	; 229
    1c86:	be 01       	movw	r22, r28
    1c88:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
    1c8c:	05 c0       	rjmp	.+10     	; 0x1c98 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1c8e:	83 eb       	ldi	r24, 0xB3	; 179
    1c90:	9a e1       	ldi	r25, 0x1A	; 26
    1c92:	be 01       	movw	r22, r28
    1c94:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1c98:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1c9c:	f0 91 6d 1a 	lds	r31, 0x1A6D
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1ca0:	81 e0       	ldi	r24, 0x01	; 1
    1ca2:	d8 01       	movw	r26, r16
    1ca4:	56 96       	adiw	r26, 0x16	; 22
    1ca6:	2c 91       	ld	r18, X
    1ca8:	56 97       	sbiw	r26, 0x16	; 22
    1caa:	96 89       	ldd	r25, Z+22	; 0x16
    1cac:	29 17       	cp	r18, r25
    1cae:	08 f4       	brcc	.+2      	; 0x1cb2 <xTaskRemoveFromEventList+0x86>
    1cb0:	80 e0       	ldi	r24, 0x00	; 0
}
    1cb2:	df 91       	pop	r29
    1cb4:	cf 91       	pop	r28
    1cb6:	1f 91       	pop	r17
    1cb8:	0f 91       	pop	r16
    1cba:	08 95       	ret

00001cbc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1cbc:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1cbe:	80 91 6e 1a 	lds	r24, 0x1A6E
    1cc2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1cc4:	80 91 74 1a 	lds	r24, 0x1A74
    1cc8:	90 91 75 1a 	lds	r25, 0x1A75
    1ccc:	92 83       	std	Z+2, r25	; 0x02
    1cce:	81 83       	std	Z+1, r24	; 0x01
}
    1cd0:	08 95       	ret

00001cd2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1cd2:	fc 01       	movw	r30, r24
    1cd4:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1cd6:	0f b6       	in	r0, 0x3f	; 63
    1cd8:	f8 94       	cli
    1cda:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1cdc:	4d 91       	ld	r20, X+
    1cde:	5c 91       	ld	r21, X
    1ce0:	11 97       	sbiw	r26, 0x01	; 1
    1ce2:	6f ef       	ldi	r22, 0xFF	; 255
    1ce4:	4f 3f       	cpi	r20, 0xFF	; 255
    1ce6:	56 07       	cpc	r21, r22
    1ce8:	51 f1       	breq	.+84     	; 0x1d3e <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1cea:	80 91 6e 1a 	lds	r24, 0x1A6E
    1cee:	90 81       	ld	r25, Z
    1cf0:	98 17       	cp	r25, r24
    1cf2:	49 f0       	breq	.+18     	; 0x1d06 <xTaskCheckForTimeOut+0x34>
    1cf4:	20 91 74 1a 	lds	r18, 0x1A74
    1cf8:	30 91 75 1a 	lds	r19, 0x1A75
    1cfc:	81 81       	ldd	r24, Z+1	; 0x01
    1cfe:	92 81       	ldd	r25, Z+2	; 0x02
    1d00:	28 17       	cp	r18, r24
    1d02:	39 07       	cpc	r19, r25
    1d04:	f0 f4       	brcc	.+60     	; 0x1d42 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1d06:	80 91 74 1a 	lds	r24, 0x1A74
    1d0a:	90 91 75 1a 	lds	r25, 0x1A75
    1d0e:	21 81       	ldd	r18, Z+1	; 0x01
    1d10:	32 81       	ldd	r19, Z+2	; 0x02
    1d12:	82 1b       	sub	r24, r18
    1d14:	93 0b       	sbc	r25, r19
    1d16:	84 17       	cp	r24, r20
    1d18:	95 07       	cpc	r25, r21
    1d1a:	a8 f4       	brcc	.+42     	; 0x1d46 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1d1c:	80 91 74 1a 	lds	r24, 0x1A74
    1d20:	90 91 75 1a 	lds	r25, 0x1A75
    1d24:	b9 01       	movw	r22, r18
    1d26:	68 1b       	sub	r22, r24
    1d28:	79 0b       	sbc	r23, r25
    1d2a:	cb 01       	movw	r24, r22
    1d2c:	84 0f       	add	r24, r20
    1d2e:	95 1f       	adc	r25, r21
    1d30:	8d 93       	st	X+, r24
    1d32:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1d34:	cf 01       	movw	r24, r30
    1d36:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1d3a:	80 e0       	ldi	r24, 0x00	; 0
    1d3c:	05 c0       	rjmp	.+10     	; 0x1d48 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1d3e:	80 e0       	ldi	r24, 0x00	; 0
    1d40:	03 c0       	rjmp	.+6      	; 0x1d48 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	01 c0       	rjmp	.+2      	; 0x1d48 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1d46:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1d48:	0f 90       	pop	r0
    1d4a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1d4c:	08 95       	ret

00001d4e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	80 93 6f 1a 	sts	0x1A6F, r24
}
    1d54:	08 95       	ret

00001d56 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1d56:	00 97       	sbiw	r24, 0x00	; 0
    1d58:	29 f4       	brne	.+10     	; 0x1d64 <uxTaskGetStackHighWaterMark+0xe>
    1d5a:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1d5e:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1d62:	01 c0       	rjmp	.+2      	; 0x1d66 <uxTaskGetStackHighWaterMark+0x10>
    1d64:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1d66:	07 88       	ldd	r0, Z+23	; 0x17
    1d68:	f0 8d       	ldd	r31, Z+24	; 0x18
    1d6a:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1d6c:	80 81       	ld	r24, Z
    1d6e:	85 3a       	cpi	r24, 0xA5	; 165
    1d70:	41 f4       	brne	.+16     	; 0x1d82 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    1d72:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1d74:	80 e0       	ldi	r24, 0x00	; 0
    1d76:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    1d78:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1d7a:	21 91       	ld	r18, Z+
    1d7c:	25 3a       	cpi	r18, 0xA5	; 165
    1d7e:	e1 f3       	breq	.-8      	; 0x1d78 <uxTaskGetStackHighWaterMark+0x22>
    1d80:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    1d86:	08 95       	ret

00001d88 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1d88:	80 91 6c 1a 	lds	r24, 0x1A6C
    1d8c:	90 91 6d 1a 	lds	r25, 0x1A6D

		return xReturn;
	}
    1d90:	08 95       	ret

00001d92 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1d92:	0f 93       	push	r16
    1d94:	1f 93       	push	r17
    1d96:	cf 93       	push	r28
    1d98:	df 93       	push	r29
    1d9a:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1d9c:	00 97       	sbiw	r24, 0x00	; 0
    1d9e:	09 f4       	brne	.+2      	; 0x1da2 <vTaskPriorityInherit+0x10>
    1da0:	4d c0       	rjmp	.+154    	; 0x1e3c <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1da2:	8e 89       	ldd	r24, Y+22	; 0x16
    1da4:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1da8:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1dac:	96 89       	ldd	r25, Z+22	; 0x16
    1dae:	89 17       	cp	r24, r25
    1db0:	08 f0       	brcs	.+2      	; 0x1db4 <vTaskPriorityInherit+0x22>
    1db2:	44 c0       	rjmp	.+136    	; 0x1e3c <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1db4:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1db8:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1dbc:	96 89       	ldd	r25, Z+22	; 0x16
    1dbe:	24 e0       	ldi	r18, 0x04	; 4
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	29 1b       	sub	r18, r25
    1dc4:	31 09       	sbc	r19, r1
    1dc6:	3d 87       	std	Y+13, r19	; 0x0d
    1dc8:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	9c 01       	movw	r18, r24
    1dce:	22 0f       	add	r18, r18
    1dd0:	33 1f       	adc	r19, r19
    1dd2:	22 0f       	add	r18, r18
    1dd4:	33 1f       	adc	r19, r19
    1dd6:	22 0f       	add	r18, r18
    1dd8:	33 1f       	adc	r19, r19
    1dda:	82 0f       	add	r24, r18
    1ddc:	93 1f       	adc	r25, r19
    1dde:	83 58       	subi	r24, 0x83	; 131
    1de0:	95 4e       	sbci	r25, 0xE5	; 229
    1de2:	2a 85       	ldd	r18, Y+10	; 0x0a
    1de4:	3b 85       	ldd	r19, Y+11	; 0x0b
    1de6:	28 17       	cp	r18, r24
    1de8:	39 07       	cpc	r19, r25
    1dea:	11 f5       	brne	.+68     	; 0x1e30 <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1dec:	8e 01       	movw	r16, r28
    1dee:	0e 5f       	subi	r16, 0xFE	; 254
    1df0:	1f 4f       	sbci	r17, 0xFF	; 255
    1df2:	c8 01       	movw	r24, r16
    1df4:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1df8:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1dfc:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1e00:	86 89       	ldd	r24, Z+22	; 0x16
    1e02:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1e04:	90 91 73 1a 	lds	r25, 0x1A73
    1e08:	98 17       	cp	r25, r24
    1e0a:	10 f4       	brcc	.+4      	; 0x1e10 <vTaskPriorityInherit+0x7e>
    1e0c:	80 93 73 1a 	sts	0x1A73, r24
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	9c 01       	movw	r18, r24
    1e14:	22 0f       	add	r18, r18
    1e16:	33 1f       	adc	r19, r19
    1e18:	22 0f       	add	r18, r18
    1e1a:	33 1f       	adc	r19, r19
    1e1c:	22 0f       	add	r18, r18
    1e1e:	33 1f       	adc	r19, r19
    1e20:	82 0f       	add	r24, r18
    1e22:	93 1f       	adc	r25, r19
    1e24:	83 58       	subi	r24, 0x83	; 131
    1e26:	95 4e       	sbci	r25, 0xE5	; 229
    1e28:	b8 01       	movw	r22, r16
    1e2a:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
    1e2e:	06 c0       	rjmp	.+12     	; 0x1e3c <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1e30:	e0 91 6c 1a 	lds	r30, 0x1A6C
    1e34:	f0 91 6d 1a 	lds	r31, 0x1A6D
    1e38:	86 89       	ldd	r24, Z+22	; 0x16
    1e3a:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	08 95       	ret

00001e46 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1e46:	0f 93       	push	r16
    1e48:	1f 93       	push	r17
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
    1e4e:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1e50:	00 97       	sbiw	r24, 0x00	; 0
    1e52:	49 f1       	breq	.+82     	; 0x1ea6 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1e54:	9e 89       	ldd	r25, Y+22	; 0x16
    1e56:	89 a5       	lds	r24, 0x69
    1e58:	98 17       	cp	r25, r24
    1e5a:	29 f1       	breq	.+74     	; 0x1ea6 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1e5c:	8e 01       	movw	r16, r28
    1e5e:	0e 5f       	subi	r16, 0xFE	; 254
    1e60:	1f 4f       	sbci	r17, 0xFF	; 255
    1e62:	c8 01       	movw	r24, r16
    1e64:	0e 94 14 04 	call	0x828	; 0x828 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1e68:	49 a5       	lds	r20, 0x69
    1e6a:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1e6c:	24 2f       	mov	r18, r20
    1e6e:	30 e0       	ldi	r19, 0x00	; 0
    1e70:	84 e0       	ldi	r24, 0x04	; 4
    1e72:	90 e0       	ldi	r25, 0x00	; 0
    1e74:	82 1b       	sub	r24, r18
    1e76:	93 0b       	sbc	r25, r19
    1e78:	9d 87       	std	Y+13, r25	; 0x0d
    1e7a:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    1e7c:	80 91 73 1a 	lds	r24, 0x1A73
    1e80:	84 17       	cp	r24, r20
    1e82:	10 f4       	brcc	.+4      	; 0x1e88 <vTaskPriorityDisinherit+0x42>
    1e84:	40 93 73 1a 	sts	0x1A73, r20
    1e88:	c9 01       	movw	r24, r18
    1e8a:	88 0f       	add	r24, r24
    1e8c:	99 1f       	adc	r25, r25
    1e8e:	88 0f       	add	r24, r24
    1e90:	99 1f       	adc	r25, r25
    1e92:	88 0f       	add	r24, r24
    1e94:	99 1f       	adc	r25, r25
    1e96:	28 0f       	add	r18, r24
    1e98:	39 1f       	adc	r19, r25
    1e9a:	c9 01       	movw	r24, r18
    1e9c:	83 58       	subi	r24, 0x83	; 131
    1e9e:	95 4e       	sbci	r25, 0xE5	; 229
    1ea0:	b8 01       	movw	r22, r16
    1ea2:	0e 94 ae 03 	call	0x75c	; 0x75c <vListInsertEnd>
			}
		}
	}
    1ea6:	df 91       	pop	r29
    1ea8:	cf 91       	pop	r28
    1eaa:	1f 91       	pop	r17
    1eac:	0f 91       	pop	r16
    1eae:	08 95       	ret

00001eb0 <memcpy>:
    1eb0:	fb 01       	movw	r30, r22
    1eb2:	dc 01       	movw	r26, r24
    1eb4:	02 c0       	rjmp	.+4      	; 0x1eba <memcpy+0xa>
    1eb6:	01 90       	ld	r0, Z+
    1eb8:	0d 92       	st	X+, r0
    1eba:	41 50       	subi	r20, 0x01	; 1
    1ebc:	50 40       	sbci	r21, 0x00	; 0
    1ebe:	d8 f7       	brcc	.-10     	; 0x1eb6 <memcpy+0x6>
    1ec0:	08 95       	ret

00001ec2 <memset>:
    1ec2:	dc 01       	movw	r26, r24
    1ec4:	01 c0       	rjmp	.+2      	; 0x1ec8 <memset+0x6>
    1ec6:	6d 93       	st	X+, r22
    1ec8:	41 50       	subi	r20, 0x01	; 1
    1eca:	50 40       	sbci	r21, 0x00	; 0
    1ecc:	e0 f7       	brcc	.-8      	; 0x1ec6 <memset+0x4>
    1ece:	08 95       	ret

00001ed0 <strncpy>:
    1ed0:	fb 01       	movw	r30, r22
    1ed2:	dc 01       	movw	r26, r24
    1ed4:	41 50       	subi	r20, 0x01	; 1
    1ed6:	50 40       	sbci	r21, 0x00	; 0
    1ed8:	48 f0       	brcs	.+18     	; 0x1eec <strncpy+0x1c>
    1eda:	01 90       	ld	r0, Z+
    1edc:	0d 92       	st	X+, r0
    1ede:	00 20       	and	r0, r0
    1ee0:	c9 f7       	brne	.-14     	; 0x1ed4 <strncpy+0x4>
    1ee2:	01 c0       	rjmp	.+2      	; 0x1ee6 <strncpy+0x16>
    1ee4:	1d 92       	st	X+, r1
    1ee6:	41 50       	subi	r20, 0x01	; 1
    1ee8:	50 40       	sbci	r21, 0x00	; 0
    1eea:	e0 f7       	brcc	.-8      	; 0x1ee4 <strncpy+0x14>
    1eec:	08 95       	ret

00001eee <_exit>:
    1eee:	f8 94       	cli

00001ef0 <__stop_program>:
    1ef0:	ff cf       	rjmp	.-2      	; 0x1ef0 <__stop_program>
