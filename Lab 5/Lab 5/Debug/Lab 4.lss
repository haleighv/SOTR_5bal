
Lab 4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800200  000020c2  00002156  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000020c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000189b  00800208  00800208  0000215e  2**0
                  ALLOC
  3 .stab         000008a0  00000000  00000000  00002160  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  00002a00  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000180  00000000  00000000  00002bb0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002851  00000000  00000000  00002d30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ba9  00000000  00000000  00005581  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000114a  00000000  00000000  0000612a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000093c  00000000  00000000  00007274  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010f0  00000000  00000000  00007bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000026e1  00000000  00000000  00008ca0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  0000b381  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      34:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <__vector_13>
      38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      68:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      6c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      70:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      74:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      78:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      7c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      80:	0c 94 d9 05 	jmp	0xbb2	; 0xbb2 <__vector_32>
      84:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      88:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      8c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      90:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      94:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      98:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      9c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      ac:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      bc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      cc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      dc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      e0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 ec       	ldi	r30, 0xC2	; 194
      fc:	f0 e2       	ldi	r31, 0x20	; 32
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a8 30       	cpi	r26, 0x08	; 8
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
     10e:	1b be       	out	0x3b, r1	; 59

00000110 <__do_clear_bss>:
     110:	1a e1       	ldi	r17, 0x1A	; 26
     112:	a8 e0       	ldi	r26, 0x08	; 8
     114:	b2 e0       	ldi	r27, 0x02	; 2
     116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
     118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
     11a:	a3 3a       	cpi	r26, 0xA3	; 163
     11c:	b1 07       	cpc	r27, r17
     11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
     120:	0e 94 04 03 	call	0x608	; 0x608 <main>
     124:	0c 94 5f 10 	jmp	0x20be	; 0x20be <_exit>

00000128 <__bad_interrupt>:
     128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <vIO_init>:
* return: void
*--------------------------------------------------------*/
void vIO_init(void)
{
	// Set PortA (LEDs) as all outputs
	DDRA = 0xFF;
     12c:	8f ef       	ldi	r24, 0xFF	; 255
     12e:	81 b9       	out	0x01, r24	; 1
	// Turn LEDs off
	PORTA = 0xFF;
     130:	82 b9       	out	0x02, r24	; 2
}
     132:	08 95       	ret

00000134 <initialize_timer2>:
*
* return: void
*--------------------------------------------------------*/
void initialize_timer2()
{
	TIMSK2 = (1 << OCIE2A);//Set interrupt mask for OC2A
     134:	82 e0       	ldi	r24, 0x02	; 2
     136:	80 93 70 00 	sts	0x0070, r24
	TCCR2A = ((1 << COM2A1) | (1 << COM2A0)|(1<<WGM21));//Set OC2A on Compare Match
     13a:	82 ec       	ldi	r24, 0xC2	; 194
     13c:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B = ((1 << CS22) |(1 << CS21) | (1 << CS20));//Set timer2 to CTC, prescaler of 1024
     140:	87 e0       	ldi	r24, 0x07	; 7
     142:	80 93 b1 00 	sts	0x00B1, r24
	OCR2A  = TIMER2_10Hz; //initialize ocra2 to value corresponding to 14Hz interrupt generation
     146:	80 e6       	ldi	r24, 0x60	; 96
     148:	80 93 b3 00 	sts	0x00B3, r24
}
     14c:	08 95       	ret

0000014e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     14e:	af 92       	push	r10
     150:	bf 92       	push	r11
     152:	cf 92       	push	r12
     154:	df 92       	push	r13
     156:	ef 92       	push	r14
     158:	ff 92       	push	r15
     15a:	0f 93       	push	r16
     15c:	1f 93       	push	r17
     15e:	cf 93       	push	r28
     160:	df 93       	push	r29
     162:	6c 01       	movw	r12, r24
     164:	e6 2e       	mov	r14, r22
     166:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     168:	8a e1       	ldi	r24, 0x1A	; 26
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	0e 94 cc 02 	call	0x598	; 0x598 <pvPortMalloc>
     170:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     172:	00 97       	sbiw	r24, 0x00	; 0
     174:	09 f4       	brne	.+2      	; 0x178 <xCoRoutineCreate+0x2a>
     176:	62 c0       	rjmp	.+196    	; 0x23c <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     178:	80 91 08 02 	lds	r24, 0x0208
     17c:	90 91 09 02 	lds	r25, 0x0209
     180:	00 97       	sbiw	r24, 0x00	; 0
     182:	39 f5       	brne	.+78     	; 0x1d2 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     184:	10 93 09 02 	sts	0x0209, r17
     188:	00 93 08 02 	sts	0x0208, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     18c:	cb e0       	ldi	r28, 0x0B	; 11
     18e:	d2 e0       	ldi	r29, 0x02	; 2
     190:	ce 01       	movw	r24, r28
     192:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
     196:	ce 01       	movw	r24, r28
     198:	09 96       	adiw	r24, 0x09	; 9
     19a:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     19e:	cd e1       	ldi	r28, 0x1D	; 29
     1a0:	d2 e0       	ldi	r29, 0x02	; 2
     1a2:	ce 01       	movw	r24, r28
     1a4:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     1a8:	0f 2e       	mov	r0, r31
     1aa:	f6 e2       	ldi	r31, 0x26	; 38
     1ac:	af 2e       	mov	r10, r31
     1ae:	f2 e0       	ldi	r31, 0x02	; 2
     1b0:	bf 2e       	mov	r11, r31
     1b2:	f0 2d       	mov	r31, r0
     1b4:	c5 01       	movw	r24, r10
     1b6:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     1ba:	8f e2       	ldi	r24, 0x2F	; 47
     1bc:	92 e0       	ldi	r25, 0x02	; 2
     1be:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1c2:	d0 93 39 02 	sts	0x0239, r29
     1c6:	c0 93 38 02 	sts	0x0238, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1ca:	b0 92 3b 02 	sts	0x023B, r11
     1ce:	a0 92 3a 02 	sts	0x023A, r10
     1d2:	ce 2d       	mov	r28, r14
     1d4:	e1 10       	cpse	r14, r1
     1d6:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1d8:	f8 01       	movw	r30, r16
     1da:	11 8e       	std	Z+25, r1	; 0x19
     1dc:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1de:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1e0:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1e2:	c1 92       	st	Z+, r12
     1e4:	d1 92       	st	Z+, r13
     1e6:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1e8:	cf 01       	movw	r24, r30
     1ea:	0e 94 ac 03 	call	0x758	; 0x758 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1ee:	c8 01       	movw	r24, r16
     1f0:	0c 96       	adiw	r24, 0x0c	; 12
     1f2:	0e 94 ac 03 	call	0x758	; 0x758 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1f6:	f8 01       	movw	r30, r16
     1f8:	11 87       	std	Z+9, r17	; 0x09
     1fa:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1fc:	13 8b       	std	Z+19, r17	; 0x13
     1fe:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     200:	84 e0       	ldi	r24, 0x04	; 4
     202:	90 e0       	ldi	r25, 0x00	; 0
     204:	8c 1b       	sub	r24, r28
     206:	91 09       	sbc	r25, r1
     208:	95 87       	std	Z+13, r25	; 0x0d
     20a:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     20c:	86 89       	ldd	r24, Z+22	; 0x16
     20e:	90 91 0a 02 	lds	r25, 0x020A
     212:	98 17       	cp	r25, r24
     214:	10 f4       	brcc	.+4      	; 0x21a <xCoRoutineCreate+0xcc>
     216:	80 93 0a 02 	sts	0x020A, r24
     21a:	90 e0       	ldi	r25, 0x00	; 0
     21c:	9c 01       	movw	r18, r24
     21e:	22 0f       	add	r18, r18
     220:	33 1f       	adc	r19, r19
     222:	22 0f       	add	r18, r18
     224:	33 1f       	adc	r19, r19
     226:	22 0f       	add	r18, r18
     228:	33 1f       	adc	r19, r19
     22a:	82 0f       	add	r24, r18
     22c:	93 1f       	adc	r25, r19
     22e:	85 5f       	subi	r24, 0xF5	; 245
     230:	9d 4f       	sbci	r25, 0xFD	; 253
     232:	b7 01       	movw	r22, r14
     234:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>

		xReturn = pdPASS;
     238:	81 e0       	ldi	r24, 0x01	; 1
     23a:	01 c0       	rjmp	.+2      	; 0x23e <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     23c:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     23e:	df 91       	pop	r29
     240:	cf 91       	pop	r28
     242:	1f 91       	pop	r17
     244:	0f 91       	pop	r16
     246:	ff 90       	pop	r15
     248:	ef 90       	pop	r14
     24a:	df 90       	pop	r13
     24c:	cf 90       	pop	r12
     24e:	bf 90       	pop	r11
     250:	af 90       	pop	r10
     252:	08 95       	ret

00000254 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     254:	0f 93       	push	r16
     256:	1f 93       	push	r17
     258:	cf 93       	push	r28
     25a:	df 93       	push	r29
     25c:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     25e:	c0 91 3c 02 	lds	r28, 0x023C
     262:	d0 91 3d 02 	lds	r29, 0x023D
     266:	c8 0f       	add	r28, r24
     268:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     26a:	80 91 08 02 	lds	r24, 0x0208
     26e:	90 91 09 02 	lds	r25, 0x0209
     272:	02 96       	adiw	r24, 0x02	; 2
     274:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     278:	e0 91 08 02 	lds	r30, 0x0208
     27c:	f0 91 09 02 	lds	r31, 0x0209
     280:	d3 83       	std	Z+3, r29	; 0x03
     282:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     284:	80 91 3c 02 	lds	r24, 0x023C
     288:	90 91 3d 02 	lds	r25, 0x023D
     28c:	c8 17       	cp	r28, r24
     28e:	d9 07       	cpc	r29, r25
     290:	50 f4       	brcc	.+20     	; 0x2a6 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     292:	bf 01       	movw	r22, r30
     294:	6e 5f       	subi	r22, 0xFE	; 254
     296:	7f 4f       	sbci	r23, 0xFF	; 255
     298:	80 91 3a 02 	lds	r24, 0x023A
     29c:	90 91 3b 02 	lds	r25, 0x023B
     2a0:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vListInsert>
     2a4:	09 c0       	rjmp	.+18     	; 0x2b8 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2a6:	bf 01       	movw	r22, r30
     2a8:	6e 5f       	subi	r22, 0xFE	; 254
     2aa:	7f 4f       	sbci	r23, 0xFF	; 255
     2ac:	80 91 38 02 	lds	r24, 0x0238
     2b0:	90 91 39 02 	lds	r25, 0x0239
     2b4:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vListInsert>
	}

	if( pxEventList )
     2b8:	01 15       	cp	r16, r1
     2ba:	11 05       	cpc	r17, r1
     2bc:	49 f0       	breq	.+18     	; 0x2d0 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2be:	60 91 08 02 	lds	r22, 0x0208
     2c2:	70 91 09 02 	lds	r23, 0x0209
     2c6:	64 5f       	subi	r22, 0xF4	; 244
     2c8:	7f 4f       	sbci	r23, 0xFF	; 255
     2ca:	c8 01       	movw	r24, r16
     2cc:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vListInsert>
	}
}
     2d0:	df 91       	pop	r29
     2d2:	cf 91       	pop	r28
     2d4:	1f 91       	pop	r17
     2d6:	0f 91       	pop	r16
     2d8:	08 95       	ret

000002da <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2da:	cf 92       	push	r12
     2dc:	df 92       	push	r13
     2de:	ef 92       	push	r14
     2e0:	ff 92       	push	r15
     2e2:	0f 93       	push	r16
     2e4:	1f 93       	push	r17
     2e6:	cf 93       	push	r28
     2e8:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2ea:	80 91 2f 02 	lds	r24, 0x022F
     2ee:	88 23       	and	r24, r24
     2f0:	b9 f1       	breq	.+110    	; 0x360 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2f2:	0f 2e       	mov	r0, r31
     2f4:	f4 e3       	ldi	r31, 0x34	; 52
     2f6:	ef 2e       	mov	r14, r31
     2f8:	f2 e0       	ldi	r31, 0x02	; 2
     2fa:	ff 2e       	mov	r15, r31
     2fc:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2fe:	0f 2e       	mov	r0, r31
     300:	ff e2       	ldi	r31, 0x2F	; 47
     302:	cf 2e       	mov	r12, r31
     304:	f2 e0       	ldi	r31, 0x02	; 2
     306:	df 2e       	mov	r13, r31
     308:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     30a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     30c:	d7 01       	movw	r26, r14
     30e:	ed 91       	ld	r30, X+
     310:	fc 91       	ld	r31, X
     312:	c6 81       	ldd	r28, Z+6	; 0x06
     314:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     316:	ce 01       	movw	r24, r28
     318:	0c 96       	adiw	r24, 0x0c	; 12
     31a:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     31e:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     320:	8e 01       	movw	r16, r28
     322:	0e 5f       	subi	r16, 0xFE	; 254
     324:	1f 4f       	sbci	r17, 0xFF	; 255
     326:	c8 01       	movw	r24, r16
     328:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     32c:	8e 89       	ldd	r24, Y+22	; 0x16
     32e:	90 91 0a 02 	lds	r25, 0x020A
     332:	98 17       	cp	r25, r24
     334:	10 f4       	brcc	.+4      	; 0x33a <vCoRoutineSchedule+0x60>
     336:	80 93 0a 02 	sts	0x020A, r24
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	9c 01       	movw	r18, r24
     33e:	22 0f       	add	r18, r18
     340:	33 1f       	adc	r19, r19
     342:	22 0f       	add	r18, r18
     344:	33 1f       	adc	r19, r19
     346:	22 0f       	add	r18, r18
     348:	33 1f       	adc	r19, r19
     34a:	82 0f       	add	r24, r18
     34c:	93 1f       	adc	r25, r19
     34e:	85 5f       	subi	r24, 0xF5	; 245
     350:	9d 4f       	sbci	r25, 0xFD	; 253
     352:	b8 01       	movw	r22, r16
     354:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     358:	f6 01       	movw	r30, r12
     35a:	80 81       	ld	r24, Z
     35c:	88 23       	and	r24, r24
     35e:	a9 f6       	brne	.-86     	; 0x30a <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     360:	0e 94 4b 0c 	call	0x1896	; 0x1896 <xTaskGetTickCount>
     364:	20 91 3e 02 	lds	r18, 0x023E
     368:	30 91 3f 02 	lds	r19, 0x023F
     36c:	82 1b       	sub	r24, r18
     36e:	93 0b       	sbc	r25, r19
     370:	90 93 41 02 	sts	0x0241, r25
     374:	80 93 40 02 	sts	0x0240, r24
     378:	74 c0       	rjmp	.+232    	; 0x462 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     37a:	20 91 3c 02 	lds	r18, 0x023C
     37e:	30 91 3d 02 	lds	r19, 0x023D
     382:	2f 5f       	subi	r18, 0xFF	; 255
     384:	3f 4f       	sbci	r19, 0xFF	; 255
     386:	30 93 3d 02 	sts	0x023D, r19
     38a:	20 93 3c 02 	sts	0x023C, r18
		xPassedTicks--;
     38e:	01 97       	sbiw	r24, 0x01	; 1
     390:	90 93 41 02 	sts	0x0241, r25
     394:	80 93 40 02 	sts	0x0240, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     398:	21 15       	cp	r18, r1
     39a:	31 05       	cpc	r19, r1
     39c:	81 f4       	brne	.+32     	; 0x3be <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     39e:	80 91 38 02 	lds	r24, 0x0238
     3a2:	90 91 39 02 	lds	r25, 0x0239
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     3a6:	20 91 3a 02 	lds	r18, 0x023A
     3aa:	30 91 3b 02 	lds	r19, 0x023B
     3ae:	30 93 39 02 	sts	0x0239, r19
     3b2:	20 93 38 02 	sts	0x0238, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     3b6:	90 93 3b 02 	sts	0x023B, r25
     3ba:	80 93 3a 02 	sts	0x023A, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3be:	e0 91 38 02 	lds	r30, 0x0238
     3c2:	f0 91 39 02 	lds	r31, 0x0239
     3c6:	80 81       	ld	r24, Z
     3c8:	88 23       	and	r24, r24
     3ca:	09 f4       	brne	.+2      	; 0x3ce <vCoRoutineSchedule+0xf4>
     3cc:	4a c0       	rjmp	.+148    	; 0x462 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3ce:	05 80       	ldd	r0, Z+5	; 0x05
     3d0:	f6 81       	ldd	r31, Z+6	; 0x06
     3d2:	e0 2d       	mov	r30, r0
     3d4:	c6 81       	ldd	r28, Z+6	; 0x06
     3d6:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3d8:	2a 81       	ldd	r18, Y+2	; 0x02
     3da:	3b 81       	ldd	r19, Y+3	; 0x03
     3dc:	80 91 3c 02 	lds	r24, 0x023C
     3e0:	90 91 3d 02 	lds	r25, 0x023D
     3e4:	82 17       	cp	r24, r18
     3e6:	93 07       	cpc	r25, r19
     3e8:	78 f4       	brcc	.+30     	; 0x408 <vCoRoutineSchedule+0x12e>
     3ea:	3b c0       	rjmp	.+118    	; 0x462 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3ec:	05 80       	ldd	r0, Z+5	; 0x05
     3ee:	f6 81       	ldd	r31, Z+6	; 0x06
     3f0:	e0 2d       	mov	r30, r0
     3f2:	c6 81       	ldd	r28, Z+6	; 0x06
     3f4:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3f6:	2a 81       	ldd	r18, Y+2	; 0x02
     3f8:	3b 81       	ldd	r19, Y+3	; 0x03
     3fa:	80 91 3c 02 	lds	r24, 0x023C
     3fe:	90 91 3d 02 	lds	r25, 0x023D
     402:	82 17       	cp	r24, r18
     404:	93 07       	cpc	r25, r19
     406:	68 f1       	brcs	.+90     	; 0x462 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     408:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
     40a:	8e 01       	movw	r16, r28
     40c:	0e 5f       	subi	r16, 0xFE	; 254
     40e:	1f 4f       	sbci	r17, 0xFF	; 255
     410:	c8 01       	movw	r24, r16
     412:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     416:	8c 89       	ldd	r24, Y+20	; 0x14
     418:	9d 89       	ldd	r25, Y+21	; 0x15
     41a:	00 97       	sbiw	r24, 0x00	; 0
     41c:	21 f0       	breq	.+8      	; 0x426 <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
     41e:	ce 01       	movw	r24, r28
     420:	0c 96       	adiw	r24, 0x0c	; 12
     422:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     426:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     428:	8e 89       	ldd	r24, Y+22	; 0x16
     42a:	90 91 0a 02 	lds	r25, 0x020A
     42e:	98 17       	cp	r25, r24
     430:	10 f4       	brcc	.+4      	; 0x436 <vCoRoutineSchedule+0x15c>
     432:	80 93 0a 02 	sts	0x020A, r24
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	9c 01       	movw	r18, r24
     43a:	22 0f       	add	r18, r18
     43c:	33 1f       	adc	r19, r19
     43e:	22 0f       	add	r18, r18
     440:	33 1f       	adc	r19, r19
     442:	22 0f       	add	r18, r18
     444:	33 1f       	adc	r19, r19
     446:	82 0f       	add	r24, r18
     448:	93 1f       	adc	r25, r19
     44a:	85 5f       	subi	r24, 0xF5	; 245
     44c:	9d 4f       	sbci	r25, 0xFD	; 253
     44e:	b8 01       	movw	r22, r16
     450:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     454:	e0 91 38 02 	lds	r30, 0x0238
     458:	f0 91 39 02 	lds	r31, 0x0239
     45c:	80 81       	ld	r24, Z
     45e:	88 23       	and	r24, r24
     460:	29 f6       	brne	.-118    	; 0x3ec <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     462:	80 91 40 02 	lds	r24, 0x0240
     466:	90 91 41 02 	lds	r25, 0x0241
     46a:	00 97       	sbiw	r24, 0x00	; 0
     46c:	09 f0       	breq	.+2      	; 0x470 <vCoRoutineSchedule+0x196>
     46e:	85 cf       	rjmp	.-246    	; 0x37a <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     470:	80 91 3c 02 	lds	r24, 0x023C
     474:	90 91 3d 02 	lds	r25, 0x023D
     478:	90 93 3f 02 	sts	0x023F, r25
     47c:	80 93 3e 02 	sts	0x023E, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     480:	20 91 0a 02 	lds	r18, 0x020A
     484:	82 2f       	mov	r24, r18
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	fc 01       	movw	r30, r24
     48a:	ee 0f       	add	r30, r30
     48c:	ff 1f       	adc	r31, r31
     48e:	ee 0f       	add	r30, r30
     490:	ff 1f       	adc	r31, r31
     492:	ee 0f       	add	r30, r30
     494:	ff 1f       	adc	r31, r31
     496:	e8 0f       	add	r30, r24
     498:	f9 1f       	adc	r31, r25
     49a:	e5 5f       	subi	r30, 0xF5	; 245
     49c:	fd 4f       	sbci	r31, 0xFD	; 253
     49e:	30 81       	ld	r19, Z
     4a0:	33 23       	and	r19, r19
     4a2:	d9 f4       	brne	.+54     	; 0x4da <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     4a4:	22 23       	and	r18, r18
     4a6:	31 f4       	brne	.+12     	; 0x4b4 <vCoRoutineSchedule+0x1da>
     4a8:	47 c0       	rjmp	.+142    	; 0x538 <vCoRoutineSchedule+0x25e>
     4aa:	22 23       	and	r18, r18
     4ac:	19 f4       	brne	.+6      	; 0x4b4 <vCoRoutineSchedule+0x1da>
     4ae:	20 93 0a 02 	sts	0x020A, r18
     4b2:	42 c0       	rjmp	.+132    	; 0x538 <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     4b4:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4b6:	82 2f       	mov	r24, r18
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	fc 01       	movw	r30, r24
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	ee 0f       	add	r30, r30
     4c2:	ff 1f       	adc	r31, r31
     4c4:	ee 0f       	add	r30, r30
     4c6:	ff 1f       	adc	r31, r31
     4c8:	e8 0f       	add	r30, r24
     4ca:	f9 1f       	adc	r31, r25
     4cc:	e5 5f       	subi	r30, 0xF5	; 245
     4ce:	fd 4f       	sbci	r31, 0xFD	; 253
     4d0:	30 81       	ld	r19, Z
     4d2:	33 23       	and	r19, r19
     4d4:	51 f3       	breq	.-44     	; 0x4aa <vCoRoutineSchedule+0x1d0>
     4d6:	20 93 0a 02 	sts	0x020A, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4da:	fc 01       	movw	r30, r24
     4dc:	ee 0f       	add	r30, r30
     4de:	ff 1f       	adc	r31, r31
     4e0:	ee 0f       	add	r30, r30
     4e2:	ff 1f       	adc	r31, r31
     4e4:	ee 0f       	add	r30, r30
     4e6:	ff 1f       	adc	r31, r31
     4e8:	8e 0f       	add	r24, r30
     4ea:	9f 1f       	adc	r25, r31
     4ec:	fc 01       	movw	r30, r24
     4ee:	e5 5f       	subi	r30, 0xF5	; 245
     4f0:	fd 4f       	sbci	r31, 0xFD	; 253
     4f2:	a1 81       	ldd	r26, Z+1	; 0x01
     4f4:	b2 81       	ldd	r27, Z+2	; 0x02
     4f6:	12 96       	adiw	r26, 0x02	; 2
     4f8:	0d 90       	ld	r0, X+
     4fa:	bc 91       	ld	r27, X
     4fc:	a0 2d       	mov	r26, r0
     4fe:	b2 83       	std	Z+2, r27	; 0x02
     500:	a1 83       	std	Z+1, r26	; 0x01
     502:	cf 01       	movw	r24, r30
     504:	03 96       	adiw	r24, 0x03	; 3
     506:	a8 17       	cp	r26, r24
     508:	b9 07       	cpc	r27, r25
     50a:	31 f4       	brne	.+12     	; 0x518 <vCoRoutineSchedule+0x23e>
     50c:	12 96       	adiw	r26, 0x02	; 2
     50e:	8d 91       	ld	r24, X+
     510:	9c 91       	ld	r25, X
     512:	13 97       	sbiw	r26, 0x03	; 3
     514:	92 83       	std	Z+2, r25	; 0x02
     516:	81 83       	std	Z+1, r24	; 0x01
     518:	01 80       	ldd	r0, Z+1	; 0x01
     51a:	f2 81       	ldd	r31, Z+2	; 0x02
     51c:	e0 2d       	mov	r30, r0
     51e:	a6 81       	ldd	r26, Z+6	; 0x06
     520:	b7 81       	ldd	r27, Z+7	; 0x07
     522:	b0 93 09 02 	sts	0x0209, r27
     526:	a0 93 08 02 	sts	0x0208, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     52a:	ed 91       	ld	r30, X+
     52c:	fc 91       	ld	r31, X
     52e:	11 97       	sbiw	r26, 0x01	; 1
     530:	cd 01       	movw	r24, r26
     532:	57 96       	adiw	r26, 0x17	; 23
     534:	6c 91       	ld	r22, X
     536:	19 95       	eicall

	return;
}
     538:	df 91       	pop	r29
     53a:	cf 91       	pop	r28
     53c:	1f 91       	pop	r17
     53e:	0f 91       	pop	r16
     540:	ff 90       	pop	r15
     542:	ef 90       	pop	r14
     544:	df 90       	pop	r13
     546:	cf 90       	pop	r12
     548:	08 95       	ret

0000054a <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     552:	dc 01       	movw	r26, r24
     554:	15 96       	adiw	r26, 0x05	; 5
     556:	ed 91       	ld	r30, X+
     558:	fc 91       	ld	r31, X
     55a:	16 97       	sbiw	r26, 0x06	; 6
     55c:	06 81       	ldd	r16, Z+6	; 0x06
     55e:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     560:	e8 01       	movw	r28, r16
     562:	2c 96       	adiw	r28, 0x0c	; 12
     564:	ce 01       	movw	r24, r28
     566:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     56a:	8f e2       	ldi	r24, 0x2F	; 47
     56c:	92 e0       	ldi	r25, 0x02	; 2
     56e:	be 01       	movw	r22, r28
     570:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     574:	e0 91 08 02 	lds	r30, 0x0208
     578:	f0 91 09 02 	lds	r31, 0x0209
	{
		xReturn = pdTRUE;
     57c:	81 e0       	ldi	r24, 0x01	; 1
     57e:	d8 01       	movw	r26, r16
     580:	56 96       	adiw	r26, 0x16	; 22
     582:	2c 91       	ld	r18, X
     584:	56 97       	sbiw	r26, 0x16	; 22
     586:	96 89       	ldd	r25, Z+22	; 0x16
     588:	29 17       	cp	r18, r25
     58a:	08 f4       	brcc	.+2      	; 0x58e <xCoRoutineRemoveFromEventList+0x44>
     58c:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     58e:	df 91       	pop	r29
     590:	cf 91       	pop	r28
     592:	1f 91       	pop	r17
     594:	0f 91       	pop	r16
     596:	08 95       	ret

00000598 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     598:	0f 93       	push	r16
     59a:	1f 93       	push	r17
     59c:	cf 93       	push	r28
     59e:	df 93       	push	r29
     5a0:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     5a2:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     5a6:	00 91 42 02 	lds	r16, 0x0242
     5aa:	10 91 43 02 	lds	r17, 0x0243
     5ae:	c0 0f       	add	r28, r16
     5b0:	d1 1f       	adc	r29, r17
     5b2:	88 e1       	ldi	r24, 0x18	; 24
     5b4:	c0 30       	cpi	r28, 0x00	; 0
     5b6:	d8 07       	cpc	r29, r24
     5b8:	50 f4       	brcc	.+20     	; 0x5ce <pvPortMalloc+0x36>
     5ba:	0c 17       	cp	r16, r28
     5bc:	1d 07       	cpc	r17, r29
     5be:	50 f4       	brcc	.+20     	; 0x5d4 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     5c0:	0c 5b       	subi	r16, 0xBC	; 188
     5c2:	1d 4f       	sbci	r17, 0xFD	; 253
			xNextFreeByte += xWantedSize;
     5c4:	d0 93 43 02 	sts	0x0243, r29
     5c8:	c0 93 42 02 	sts	0x0242, r28
     5cc:	05 c0       	rjmp	.+10     	; 0x5d8 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5ce:	00 e0       	ldi	r16, 0x00	; 0
     5d0:	10 e0       	ldi	r17, 0x00	; 0
     5d2:	02 c0       	rjmp	.+4      	; 0x5d8 <pvPortMalloc+0x40>
     5d4:	00 e0       	ldi	r16, 0x00	; 0
     5d6:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
     5d8:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5dc:	80 2f       	mov	r24, r16
     5de:	91 2f       	mov	r25, r17
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	1f 91       	pop	r17
     5e6:	0f 91       	pop	r16
     5e8:	08 95       	ret

000005ea <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     5ea:	08 95       	ret

000005ec <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     5ec:	10 92 43 02 	sts	0x0243, r1
     5f0:	10 92 42 02 	sts	0x0242, r1
}
     5f4:	08 95       	ret

000005f6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     5f6:	20 91 42 02 	lds	r18, 0x0242
     5fa:	30 91 43 02 	lds	r19, 0x0243
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	98 e1       	ldi	r25, 0x18	; 24
     602:	82 1b       	sub	r24, r18
     604:	93 0b       	sbc	r25, r19
}
     606:	08 95       	ret

00000608 <main>:

//-------------------Main Function-----------------------//
int main( void )
{  	
    // Function initializing PORTA as an output and setting LEDs low
	vIO_init(); 
     608:	0e 94 96 00 	call	0x12c	; 0x12c <vIO_init>
	//initialize_timer2();
	SPI_MasterInit(); 
     60c:	0e 94 3b 09 	call	0x1276	; 0x1276 <SPI_MasterInit>
	
	//set SS low
	PORTB &= ~(1 << SPI_SS);
     610:	2c 98       	cbi	0x05, 4	; 5
	//Load data to be transferred
	SPDR = 0x00;
     612:	1e bc       	out	0x2e, r1	; 46
	//wait for spi interrupt flag to signal complete transfer
	while (!(SPSR & (1 << SPIF)));
     614:	0d b4       	in	r0, 0x2d	; 45
     616:	07 fe       	sbrs	r0, 7
     618:	fd cf       	rjmp	.-6      	; 0x614 <main+0xc>
	SPDR = 0x01;
     61a:	81 e0       	ldi	r24, 0x01	; 1
     61c:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));
     61e:	0d b4       	in	r0, 0x2d	; 45
     620:	07 fe       	sbrs	r0, 7
     622:	fd cf       	rjmp	.-6      	; 0x61e <main+0x16>
	SPDR = 0x02;
     624:	82 e0       	ldi	r24, 0x02	; 2
     626:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));
     628:	0d b4       	in	r0, 0x2d	; 45
     62a:	07 fe       	sbrs	r0, 7
     62c:	fd cf       	rjmp	.-6      	; 0x628 <main+0x20>
	SPDR = 0x03;
     62e:	83 e0       	ldi	r24, 0x03	; 3
     630:	8e bd       	out	0x2e, r24	; 46
	//Set SS high
	PORTB = (1 << SPI_SS);
     632:	80 e1       	ldi	r24, 0x10	; 16
     634:	85 b9       	out	0x05, r24	; 5

	PORTA = 0x00;
     636:	12 b8       	out	0x02, r1	; 2
	uint8_t i = 0;
     638:	c0 e0       	ldi	r28, 0x00	; 0
	{
		SSEG_Set_Brightness(i);
		_delay_ms(200);
		i++;
		if(i == 255)
			i = 0;
     63a:	d0 e0       	ldi	r29, 0x00	; 0
     63c:	01 c0       	rjmp	.+2      	; 0x640 <main+0x38>
     63e:	cd 2f       	mov	r28, r29

	PORTA = 0x00;
	uint8_t i = 0;
	for(;;)
	{
		SSEG_Set_Brightness(i);
     640:	8c 2f       	mov	r24, r28
     642:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SSEG_Set_Brightness>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     646:	8f e4       	ldi	r24, 0x4F	; 79
     648:	93 ec       	ldi	r25, 0xC3	; 195
     64a:	01 97       	sbiw	r24, 0x01	; 1
     64c:	f1 f7       	brne	.-4      	; 0x64a <main+0x42>
     64e:	00 c0       	rjmp	.+0      	; 0x650 <main+0x48>
     650:	00 00       	nop
		_delay_ms(200);
		i++;
     652:	cf 5f       	subi	r28, 0xFF	; 255
		if(i == 255)
     654:	cf 3f       	cpi	r28, 0xFF	; 255
     656:	a1 f7       	brne	.-24     	; 0x640 <main+0x38>
     658:	f2 cf       	rjmp	.-28     	; 0x63e <main+0x36>

0000065a <vTaskFunction_timerHandler>:
*--------------------------------------------------------*/



void vTaskFunction_timerHandler(void *pvNada)
{
     65a:	cf 93       	push	r28
     65c:	df 93       	push	r29
     65e:	0f 92       	push	r0
     660:	0f 92       	push	r0
     662:	cd b7       	in	r28, 0x3d	; 61
     664:	de b7       	in	r29, 0x3e	; 62
	static uint8_t task_cnt = 0, sseg_cnt_L = 0, sseg_cnt_R = 0;

	portTickType xLastExecutionTime;
	xLastExecutionTime = xTaskGetTickCount();
     666:	0e 94 4b 0c 	call	0x1896	; 0x1896 <xTaskGetTickCount>
     66a:	9a 83       	std	Y+2, r25	; 0x02
     66c:	89 83       	std	Y+1, r24	; 0x01
	for(;;)
	{	
		//xSemaphoreTake( xBinarySemaphore_timer, portMAX_DELAY );
		PORTA ^= (1 << LED2);//Toggle LED2
     66e:	04 e0       	ldi	r16, 0x04	; 4
		
		SSEG_Write_left_digits(sseg_cnt_L);
		SSEG_Write_right_digits(sseg_cnt_R);
		task_cnt ^= 1;
     670:	11 e0       	ldi	r17, 0x01	; 1
	portTickType xLastExecutionTime;
	xLastExecutionTime = xTaskGetTickCount();
	for(;;)
	{	
		//xSemaphoreTake( xBinarySemaphore_timer, portMAX_DELAY );
		PORTA ^= (1 << LED2);//Toggle LED2
     672:	82 b1       	in	r24, 0x02	; 2
     674:	80 27       	eor	r24, r16
     676:	82 b9       	out	0x02, r24	; 2
		
		SSEG_Write_left_digits(sseg_cnt_L);
     678:	80 91 44 1a 	lds	r24, 0x1A44
     67c:	0e 94 9a 09 	call	0x1334	; 0x1334 <SSEG_Write_left_digits>
		SSEG_Write_right_digits(sseg_cnt_R);
     680:	80 91 45 1a 	lds	r24, 0x1A45
     684:	0e 94 bd 09 	call	0x137a	; 0x137a <SSEG_Write_right_digits>
		task_cnt ^= 1;
     688:	80 91 46 1a 	lds	r24, 0x1A46
     68c:	81 27       	eor	r24, r17
     68e:	80 93 46 1a 	sts	0x1A46, r24
		if(task_cnt)
     692:	88 23       	and	r24, r24
     694:	41 f0       	breq	.+16     	; 0x6a6 <vTaskFunction_timerHandler+0x4c>
		{
			sseg_cnt_L++;
     696:	80 91 44 1a 	lds	r24, 0x1A44
     69a:	8f 5f       	subi	r24, 0xFF	; 255
     69c:	80 93 44 1a 	sts	0x1A44, r24
			PORTA ^= (1 << LED0);//Toggle LED0
     6a0:	82 b1       	in	r24, 0x02	; 2
     6a2:	81 27       	eor	r24, r17
     6a4:	82 b9       	out	0x02, r24	; 2
		}		
		
		if(sseg_cnt_R == 100)
     6a6:	80 91 45 1a 	lds	r24, 0x1A45
     6aa:	84 36       	cpi	r24, 0x64	; 100
     6ac:	19 f4       	brne	.+6      	; 0x6b4 <vTaskFunction_timerHandler+0x5a>
			sseg_cnt_R = 0;
     6ae:	10 92 45 1a 	sts	0x1A45, r1
     6b2:	03 c0       	rjmp	.+6      	; 0x6ba <vTaskFunction_timerHandler+0x60>
		else
			sseg_cnt_R++;
     6b4:	8f 5f       	subi	r24, 0xFF	; 255
     6b6:	80 93 45 1a 	sts	0x1A45, r24
		
		//TCNT2 = 0;
		vTaskDelayUntil(&xLastExecutionTime, 500/portTICK_RATE_MS);
     6ba:	ce 01       	movw	r24, r28
     6bc:	01 96       	adiw	r24, 0x01	; 1
     6be:	64 ef       	ldi	r22, 0xF4	; 244
     6c0:	71 e0       	ldi	r23, 0x01	; 1
     6c2:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <vTaskDelayUntil>
	}
     6c6:	d5 cf       	rjmp	.-86     	; 0x672 <vTaskFunction_timerHandler+0x18>

000006c8 <__vector_13>:
*
* param a: TIMER2_COMPA_vect: vector generated when
*		   timer2 reaches the value held be OCR2A
*--------------------------------------------------------*/
ISR(TIMER2_COMPA_vect)
{
     6c8:	1f 92       	push	r1
     6ca:	0f 92       	push	r0
     6cc:	0f b6       	in	r0, 0x3f	; 63
     6ce:	0f 92       	push	r0
     6d0:	0b b6       	in	r0, 0x3b	; 59
     6d2:	0f 92       	push	r0
     6d4:	11 24       	eor	r1, r1
     6d6:	2f 93       	push	r18
     6d8:	3f 93       	push	r19
     6da:	4f 93       	push	r20
     6dc:	5f 93       	push	r21
     6de:	6f 93       	push	r22
     6e0:	7f 93       	push	r23
     6e2:	8f 93       	push	r24
     6e4:	9f 93       	push	r25
     6e6:	af 93       	push	r26
     6e8:	bf 93       	push	r27
     6ea:	ef 93       	push	r30
     6ec:	ff 93       	push	r31
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
     6ee:	10 92 47 1a 	sts	0x1A47, r1
	/* 'Give' the semaphore to unblock the task. */
	xSemaphoreGiveFromISR( xBinarySemaphore_timer, &xHigherPriorityTaskWoken );
     6f2:	80 91 a1 1a 	lds	r24, 0x1AA1
     6f6:	90 91 a2 1a 	lds	r25, 0x1AA2
     6fa:	60 e0       	ldi	r22, 0x00	; 0
     6fc:	70 e0       	ldi	r23, 0x00	; 0
     6fe:	47 e4       	ldi	r20, 0x47	; 71
     700:	5a e1       	ldi	r21, 0x1A	; 26
     702:	20 e0       	ldi	r18, 0x00	; 0
     704:	0e 94 e7 07 	call	0xfce	; 0xfce <xQueueGenericSendFromISR>
	if( xHigherPriorityTaskWoken == pdTRUE )
     708:	80 91 47 1a 	lds	r24, 0x1A47
     70c:	81 30       	cpi	r24, 0x01	; 1
     70e:	11 f4       	brne	.+4      	; 0x714 <__vector_13+0x4c>
	{
		vPortYield();
     710:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
	}
}
     714:	ff 91       	pop	r31
     716:	ef 91       	pop	r30
     718:	bf 91       	pop	r27
     71a:	af 91       	pop	r26
     71c:	9f 91       	pop	r25
     71e:	8f 91       	pop	r24
     720:	7f 91       	pop	r23
     722:	6f 91       	pop	r22
     724:	5f 91       	pop	r21
     726:	4f 91       	pop	r20
     728:	3f 91       	pop	r19
     72a:	2f 91       	pop	r18
     72c:	0f 90       	pop	r0
     72e:	0b be       	out	0x3b, r0	; 59
     730:	0f 90       	pop	r0
     732:	0f be       	out	0x3f, r0	; 63
     734:	0f 90       	pop	r0
     736:	1f 90       	pop	r1
     738:	18 95       	reti

0000073a <vApplicationTickHook>:
	//else if(count == 1000)
	//{
		//count = 0;
		//SSEG_Write_Decimal_Point(SSEG_DP_4_val);
	//}		
     73a:	08 95       	ret

0000073c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     73c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     73e:	03 96       	adiw	r24, 0x03	; 3
     740:	92 83       	std	Z+2, r25	; 0x02
     742:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     744:	2f ef       	ldi	r18, 0xFF	; 255
     746:	3f ef       	ldi	r19, 0xFF	; 255
     748:	34 83       	std	Z+4, r19	; 0x04
     74a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     74c:	96 83       	std	Z+6, r25	; 0x06
     74e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     750:	90 87       	std	Z+8, r25	; 0x08
     752:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     754:	10 82       	st	Z, r1
}
     756:	08 95       	ret

00000758 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     758:	fc 01       	movw	r30, r24
     75a:	11 86       	std	Z+9, r1	; 0x09
     75c:	10 86       	std	Z+8, r1	; 0x08
}
     75e:	08 95       	ret

00000760 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
     766:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     768:	89 81       	ldd	r24, Y+1	; 0x01
     76a:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     76c:	dc 01       	movw	r26, r24
     76e:	12 96       	adiw	r26, 0x02	; 2
     770:	2d 91       	ld	r18, X+
     772:	3c 91       	ld	r19, X
     774:	13 97       	sbiw	r26, 0x03	; 3
     776:	33 83       	std	Z+3, r19	; 0x03
     778:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     77a:	29 81       	ldd	r18, Y+1	; 0x01
     77c:	3a 81       	ldd	r19, Y+2	; 0x02
     77e:	35 83       	std	Z+5, r19	; 0x05
     780:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     782:	12 96       	adiw	r26, 0x02	; 2
     784:	2d 91       	ld	r18, X+
     786:	3c 91       	ld	r19, X
     788:	13 97       	sbiw	r26, 0x03	; 3
     78a:	d9 01       	movw	r26, r18
     78c:	15 96       	adiw	r26, 0x05	; 5
     78e:	7c 93       	st	X, r23
     790:	6e 93       	st	-X, r22
     792:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     794:	dc 01       	movw	r26, r24
     796:	13 96       	adiw	r26, 0x03	; 3
     798:	7c 93       	st	X, r23
     79a:	6e 93       	st	-X, r22
     79c:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     79e:	7a 83       	std	Y+2, r23	; 0x02
     7a0:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7a2:	d1 87       	std	Z+9, r29	; 0x09
     7a4:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     7a6:	88 81       	ld	r24, Y
     7a8:	8f 5f       	subi	r24, 0xFF	; 255
     7aa:	88 83       	st	Y, r24
}
     7ac:	df 91       	pop	r29
     7ae:	cf 91       	pop	r28
     7b0:	08 95       	ret

000007b2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	ac 01       	movw	r20, r24
     7b8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     7ba:	28 81       	ld	r18, Y
     7bc:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     7be:	8f ef       	ldi	r24, 0xFF	; 255
     7c0:	2f 3f       	cpi	r18, 0xFF	; 255
     7c2:	38 07       	cpc	r19, r24
     7c4:	21 f4       	brne	.+8      	; 0x7ce <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     7c6:	fa 01       	movw	r30, r20
     7c8:	a7 81       	ldd	r26, Z+7	; 0x07
     7ca:	b0 85       	ldd	r27, Z+8	; 0x08
     7cc:	18 c0       	rjmp	.+48     	; 0x7fe <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     7ce:	da 01       	movw	r26, r20
     7d0:	13 96       	adiw	r26, 0x03	; 3
     7d2:	fa 01       	movw	r30, r20
     7d4:	85 81       	ldd	r24, Z+5	; 0x05
     7d6:	96 81       	ldd	r25, Z+6	; 0x06
     7d8:	fc 01       	movw	r30, r24
     7da:	80 81       	ld	r24, Z
     7dc:	91 81       	ldd	r25, Z+1	; 0x01
     7de:	28 17       	cp	r18, r24
     7e0:	39 07       	cpc	r19, r25
     7e2:	68 f0       	brcs	.+26     	; 0x7fe <vListInsert+0x4c>
     7e4:	12 96       	adiw	r26, 0x02	; 2
     7e6:	0d 90       	ld	r0, X+
     7e8:	bc 91       	ld	r27, X
     7ea:	a0 2d       	mov	r26, r0
     7ec:	12 96       	adiw	r26, 0x02	; 2
     7ee:	ed 91       	ld	r30, X+
     7f0:	fc 91       	ld	r31, X
     7f2:	13 97       	sbiw	r26, 0x03	; 3
     7f4:	80 81       	ld	r24, Z
     7f6:	91 81       	ldd	r25, Z+1	; 0x01
     7f8:	28 17       	cp	r18, r24
     7fa:	39 07       	cpc	r19, r25
     7fc:	98 f7       	brcc	.-26     	; 0x7e4 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     7fe:	12 96       	adiw	r26, 0x02	; 2
     800:	ed 91       	ld	r30, X+
     802:	fc 91       	ld	r31, X
     804:	13 97       	sbiw	r26, 0x03	; 3
     806:	fb 83       	std	Y+3, r31	; 0x03
     808:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     80a:	d5 83       	std	Z+5, r29	; 0x05
     80c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     80e:	bd 83       	std	Y+5, r27	; 0x05
     810:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     812:	13 96       	adiw	r26, 0x03	; 3
     814:	dc 93       	st	X, r29
     816:	ce 93       	st	-X, r28
     818:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     81a:	59 87       	std	Y+9, r21	; 0x09
     81c:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     81e:	fa 01       	movw	r30, r20
     820:	80 81       	ld	r24, Z
     822:	8f 5f       	subi	r24, 0xFF	; 255
     824:	80 83       	st	Z, r24
}
     826:	df 91       	pop	r29
     828:	cf 91       	pop	r28
     82a:	08 95       	ret

0000082c <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     82c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     82e:	a2 81       	ldd	r26, Z+2	; 0x02
     830:	b3 81       	ldd	r27, Z+3	; 0x03
     832:	84 81       	ldd	r24, Z+4	; 0x04
     834:	95 81       	ldd	r25, Z+5	; 0x05
     836:	15 96       	adiw	r26, 0x05	; 5
     838:	9c 93       	st	X, r25
     83a:	8e 93       	st	-X, r24
     83c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     83e:	a4 81       	ldd	r26, Z+4	; 0x04
     840:	b5 81       	ldd	r27, Z+5	; 0x05
     842:	82 81       	ldd	r24, Z+2	; 0x02
     844:	93 81       	ldd	r25, Z+3	; 0x03
     846:	13 96       	adiw	r26, 0x03	; 3
     848:	9c 93       	st	X, r25
     84a:	8e 93       	st	-X, r24
     84c:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     84e:	a0 85       	ldd	r26, Z+8	; 0x08
     850:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     852:	11 96       	adiw	r26, 0x01	; 1
     854:	8d 91       	ld	r24, X+
     856:	9c 91       	ld	r25, X
     858:	12 97       	sbiw	r26, 0x02	; 2
     85a:	8e 17       	cp	r24, r30
     85c:	9f 07       	cpc	r25, r31
     85e:	31 f4       	brne	.+12     	; 0x86c <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     860:	84 81       	ldd	r24, Z+4	; 0x04
     862:	95 81       	ldd	r25, Z+5	; 0x05
     864:	12 96       	adiw	r26, 0x02	; 2
     866:	9c 93       	st	X, r25
     868:	8e 93       	st	-X, r24
     86a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     86c:	11 86       	std	Z+9, r1	; 0x09
     86e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     870:	8c 91       	ld	r24, X
     872:	81 50       	subi	r24, 0x01	; 1
     874:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     876:	8c 91       	ld	r24, X
}
     878:	08 95       	ret

0000087a <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     87a:	21 e1       	ldi	r18, 0x11	; 17
     87c:	fc 01       	movw	r30, r24
     87e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     880:	31 97       	sbiw	r30, 0x01	; 1
     882:	32 e2       	ldi	r19, 0x22	; 34
     884:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     886:	fc 01       	movw	r30, r24
     888:	32 97       	sbiw	r30, 0x02	; 2
     88a:	a3 e3       	ldi	r26, 0x33	; 51
     88c:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     88e:	fc 01       	movw	r30, r24
     890:	33 97       	sbiw	r30, 0x03	; 3
     892:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     894:	fc 01       	movw	r30, r24
     896:	34 97       	sbiw	r30, 0x04	; 4
     898:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     89a:	fc 01       	movw	r30, r24
     89c:	35 97       	sbiw	r30, 0x05	; 5
     89e:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     8a0:	fc 01       	movw	r30, r24
     8a2:	36 97       	sbiw	r30, 0x06	; 6
     8a4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     8a6:	fc 01       	movw	r30, r24
     8a8:	37 97       	sbiw	r30, 0x07	; 7
     8aa:	60 e8       	ldi	r22, 0x80	; 128
     8ac:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     8ae:	fc 01       	movw	r30, r24
     8b0:	38 97       	sbiw	r30, 0x08	; 8
     8b2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     8b4:	fc 01       	movw	r30, r24
     8b6:	39 97       	sbiw	r30, 0x09	; 9
     8b8:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     8ba:	fc 01       	movw	r30, r24
     8bc:	3a 97       	sbiw	r30, 0x0a	; 10
     8be:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     8c0:	fc 01       	movw	r30, r24
     8c2:	3b 97       	sbiw	r30, 0x0b	; 11
     8c4:	62 e0       	ldi	r22, 0x02	; 2
     8c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     8c8:	fc 01       	movw	r30, r24
     8ca:	3c 97       	sbiw	r30, 0x0c	; 12
     8cc:	63 e0       	ldi	r22, 0x03	; 3
     8ce:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     8d0:	fc 01       	movw	r30, r24
     8d2:	3d 97       	sbiw	r30, 0x0d	; 13
     8d4:	64 e0       	ldi	r22, 0x04	; 4
     8d6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     8d8:	fc 01       	movw	r30, r24
     8da:	3e 97       	sbiw	r30, 0x0e	; 14
     8dc:	65 e0       	ldi	r22, 0x05	; 5
     8de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     8e0:	fc 01       	movw	r30, r24
     8e2:	3f 97       	sbiw	r30, 0x0f	; 15
     8e4:	66 e0       	ldi	r22, 0x06	; 6
     8e6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     8e8:	fc 01       	movw	r30, r24
     8ea:	70 97       	sbiw	r30, 0x10	; 16
     8ec:	67 e0       	ldi	r22, 0x07	; 7
     8ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     8f0:	fc 01       	movw	r30, r24
     8f2:	71 97       	sbiw	r30, 0x11	; 17
     8f4:	68 e0       	ldi	r22, 0x08	; 8
     8f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     8f8:	fc 01       	movw	r30, r24
     8fa:	72 97       	sbiw	r30, 0x12	; 18
     8fc:	69 e0       	ldi	r22, 0x09	; 9
     8fe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     900:	fc 01       	movw	r30, r24
     902:	73 97       	sbiw	r30, 0x13	; 19
     904:	60 e1       	ldi	r22, 0x10	; 16
     906:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     908:	fc 01       	movw	r30, r24
     90a:	74 97       	sbiw	r30, 0x14	; 20
     90c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     90e:	fc 01       	movw	r30, r24
     910:	75 97       	sbiw	r30, 0x15	; 21
     912:	22 e1       	ldi	r18, 0x12	; 18
     914:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     916:	fc 01       	movw	r30, r24
     918:	76 97       	sbiw	r30, 0x16	; 22
     91a:	23 e1       	ldi	r18, 0x13	; 19
     91c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     91e:	fc 01       	movw	r30, r24
     920:	77 97       	sbiw	r30, 0x17	; 23
     922:	24 e1       	ldi	r18, 0x14	; 20
     924:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     926:	fc 01       	movw	r30, r24
     928:	78 97       	sbiw	r30, 0x18	; 24
     92a:	25 e1       	ldi	r18, 0x15	; 21
     92c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     92e:	fc 01       	movw	r30, r24
     930:	79 97       	sbiw	r30, 0x19	; 25
     932:	26 e1       	ldi	r18, 0x16	; 22
     934:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     936:	fc 01       	movw	r30, r24
     938:	7a 97       	sbiw	r30, 0x1a	; 26
     93a:	27 e1       	ldi	r18, 0x17	; 23
     93c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     93e:	fc 01       	movw	r30, r24
     940:	7b 97       	sbiw	r30, 0x1b	; 27
     942:	28 e1       	ldi	r18, 0x18	; 24
     944:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     946:	fc 01       	movw	r30, r24
     948:	7c 97       	sbiw	r30, 0x1c	; 28
     94a:	29 e1       	ldi	r18, 0x19	; 25
     94c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     94e:	fc 01       	movw	r30, r24
     950:	7d 97       	sbiw	r30, 0x1d	; 29
     952:	20 e2       	ldi	r18, 0x20	; 32
     954:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     956:	fc 01       	movw	r30, r24
     958:	7e 97       	sbiw	r30, 0x1e	; 30
     95a:	21 e2       	ldi	r18, 0x21	; 33
     95c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     95e:	fc 01       	movw	r30, r24
     960:	7f 97       	sbiw	r30, 0x1f	; 31
     962:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     964:	fc 01       	movw	r30, r24
     966:	b0 97       	sbiw	r30, 0x20	; 32
     968:	23 e2       	ldi	r18, 0x23	; 35
     96a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     96c:	fc 01       	movw	r30, r24
     96e:	b1 97       	sbiw	r30, 0x21	; 33
     970:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     972:	fc 01       	movw	r30, r24
     974:	b2 97       	sbiw	r30, 0x22	; 34
     976:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     978:	fc 01       	movw	r30, r24
     97a:	b3 97       	sbiw	r30, 0x23	; 35
     97c:	26 e2       	ldi	r18, 0x26	; 38
     97e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     980:	fc 01       	movw	r30, r24
     982:	b4 97       	sbiw	r30, 0x24	; 36
     984:	27 e2       	ldi	r18, 0x27	; 39
     986:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     988:	fc 01       	movw	r30, r24
     98a:	b5 97       	sbiw	r30, 0x25	; 37
     98c:	28 e2       	ldi	r18, 0x28	; 40
     98e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     990:	fc 01       	movw	r30, r24
     992:	b6 97       	sbiw	r30, 0x26	; 38
     994:	29 e2       	ldi	r18, 0x29	; 41
     996:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     998:	fc 01       	movw	r30, r24
     99a:	b7 97       	sbiw	r30, 0x27	; 39
     99c:	20 e3       	ldi	r18, 0x30	; 48
     99e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     9a0:	fc 01       	movw	r30, r24
     9a2:	b8 97       	sbiw	r30, 0x28	; 40
     9a4:	21 e3       	ldi	r18, 0x31	; 49
     9a6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     9a8:	89 97       	sbiw	r24, 0x29	; 41
}
     9aa:	08 95       	ret

000009ac <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
     9ac:	10 92 99 00 	sts	0x0099, r1

#endif

    portOCRL = ucLowByte;
     9b0:	8e e1       	ldi	r24, 0x1E	; 30
     9b2:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
     9b6:	8b e0       	ldi	r24, 0x0B	; 11
     9b8:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     9bc:	e1 e7       	ldi	r30, 0x71	; 113
     9be:	f0 e0       	ldi	r31, 0x00	; 0
     9c0:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     9c2:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
     9c4:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     9c6:	a0 91 48 1a 	lds	r26, 0x1A48
     9ca:	b0 91 49 1a 	lds	r27, 0x1A49
     9ce:	cd 91       	ld	r28, X+
     9d0:	cd bf       	out	0x3d, r28	; 61
     9d2:	dd 91       	ld	r29, X+
     9d4:	de bf       	out	0x3e, r29	; 62
     9d6:	ff 91       	pop	r31
     9d8:	ef 91       	pop	r30
     9da:	df 91       	pop	r29
     9dc:	cf 91       	pop	r28
     9de:	bf 91       	pop	r27
     9e0:	af 91       	pop	r26
     9e2:	9f 91       	pop	r25
     9e4:	8f 91       	pop	r24
     9e6:	7f 91       	pop	r23
     9e8:	6f 91       	pop	r22
     9ea:	5f 91       	pop	r21
     9ec:	4f 91       	pop	r20
     9ee:	3f 91       	pop	r19
     9f0:	2f 91       	pop	r18
     9f2:	1f 91       	pop	r17
     9f4:	0f 91       	pop	r16
     9f6:	ff 90       	pop	r15
     9f8:	ef 90       	pop	r14
     9fa:	df 90       	pop	r13
     9fc:	cf 90       	pop	r12
     9fe:	bf 90       	pop	r11
     a00:	af 90       	pop	r10
     a02:	9f 90       	pop	r9
     a04:	8f 90       	pop	r8
     a06:	7f 90       	pop	r7
     a08:	6f 90       	pop	r6
     a0a:	5f 90       	pop	r5
     a0c:	4f 90       	pop	r4
     a0e:	3f 90       	pop	r3
     a10:	2f 90       	pop	r2
     a12:	1f 90       	pop	r1
     a14:	0f 90       	pop	r0
     a16:	0c be       	out	0x3c, r0	; 60
     a18:	0f 90       	pop	r0
     a1a:	0b be       	out	0x3b, r0	; 59
     a1c:	0f 90       	pop	r0
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     a22:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	08 95       	ret

00000a28 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     a28:	08 95       	ret

00000a2a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a2a:	0f 92       	push	r0
     a2c:	0f b6       	in	r0, 0x3f	; 63
     a2e:	f8 94       	cli
     a30:	0f 92       	push	r0
     a32:	0b b6       	in	r0, 0x3b	; 59
     a34:	0f 92       	push	r0
     a36:	0c b6       	in	r0, 0x3c	; 60
     a38:	0f 92       	push	r0
     a3a:	1f 92       	push	r1
     a3c:	11 24       	eor	r1, r1
     a3e:	2f 92       	push	r2
     a40:	3f 92       	push	r3
     a42:	4f 92       	push	r4
     a44:	5f 92       	push	r5
     a46:	6f 92       	push	r6
     a48:	7f 92       	push	r7
     a4a:	8f 92       	push	r8
     a4c:	9f 92       	push	r9
     a4e:	af 92       	push	r10
     a50:	bf 92       	push	r11
     a52:	cf 92       	push	r12
     a54:	df 92       	push	r13
     a56:	ef 92       	push	r14
     a58:	ff 92       	push	r15
     a5a:	0f 93       	push	r16
     a5c:	1f 93       	push	r17
     a5e:	2f 93       	push	r18
     a60:	3f 93       	push	r19
     a62:	4f 93       	push	r20
     a64:	5f 93       	push	r21
     a66:	6f 93       	push	r22
     a68:	7f 93       	push	r23
     a6a:	8f 93       	push	r24
     a6c:	9f 93       	push	r25
     a6e:	af 93       	push	r26
     a70:	bf 93       	push	r27
     a72:	cf 93       	push	r28
     a74:	df 93       	push	r29
     a76:	ef 93       	push	r30
     a78:	ff 93       	push	r31
     a7a:	a0 91 48 1a 	lds	r26, 0x1A48
     a7e:	b0 91 49 1a 	lds	r27, 0x1A49
     a82:	0d b6       	in	r0, 0x3d	; 61
     a84:	0d 92       	st	X+, r0
     a86:	0e b6       	in	r0, 0x3e	; 62
     a88:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a8a:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a8e:	a0 91 48 1a 	lds	r26, 0x1A48
     a92:	b0 91 49 1a 	lds	r27, 0x1A49
     a96:	cd 91       	ld	r28, X+
     a98:	cd bf       	out	0x3d, r28	; 61
     a9a:	dd 91       	ld	r29, X+
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	ff 91       	pop	r31
     aa0:	ef 91       	pop	r30
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	bf 91       	pop	r27
     aa8:	af 91       	pop	r26
     aaa:	9f 91       	pop	r25
     aac:	8f 91       	pop	r24
     aae:	7f 91       	pop	r23
     ab0:	6f 91       	pop	r22
     ab2:	5f 91       	pop	r21
     ab4:	4f 91       	pop	r20
     ab6:	3f 91       	pop	r19
     ab8:	2f 91       	pop	r18
     aba:	1f 91       	pop	r17
     abc:	0f 91       	pop	r16
     abe:	ff 90       	pop	r15
     ac0:	ef 90       	pop	r14
     ac2:	df 90       	pop	r13
     ac4:	cf 90       	pop	r12
     ac6:	bf 90       	pop	r11
     ac8:	af 90       	pop	r10
     aca:	9f 90       	pop	r9
     acc:	8f 90       	pop	r8
     ace:	7f 90       	pop	r7
     ad0:	6f 90       	pop	r6
     ad2:	5f 90       	pop	r5
     ad4:	4f 90       	pop	r4
     ad6:	3f 90       	pop	r3
     ad8:	2f 90       	pop	r2
     ada:	1f 90       	pop	r1
     adc:	0f 90       	pop	r0
     ade:	0c be       	out	0x3c, r0	; 60
     ae0:	0f 90       	pop	r0
     ae2:	0b be       	out	0x3b, r0	; 59
     ae4:	0f 90       	pop	r0
     ae6:	0f be       	out	0x3f, r0	; 63
     ae8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     aea:	08 95       	ret

00000aec <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     aec:	0f 92       	push	r0
     aee:	0f b6       	in	r0, 0x3f	; 63
     af0:	f8 94       	cli
     af2:	0f 92       	push	r0
     af4:	0b b6       	in	r0, 0x3b	; 59
     af6:	0f 92       	push	r0
     af8:	0c b6       	in	r0, 0x3c	; 60
     afa:	0f 92       	push	r0
     afc:	1f 92       	push	r1
     afe:	11 24       	eor	r1, r1
     b00:	2f 92       	push	r2
     b02:	3f 92       	push	r3
     b04:	4f 92       	push	r4
     b06:	5f 92       	push	r5
     b08:	6f 92       	push	r6
     b0a:	7f 92       	push	r7
     b0c:	8f 92       	push	r8
     b0e:	9f 92       	push	r9
     b10:	af 92       	push	r10
     b12:	bf 92       	push	r11
     b14:	cf 92       	push	r12
     b16:	df 92       	push	r13
     b18:	ef 92       	push	r14
     b1a:	ff 92       	push	r15
     b1c:	0f 93       	push	r16
     b1e:	1f 93       	push	r17
     b20:	2f 93       	push	r18
     b22:	3f 93       	push	r19
     b24:	4f 93       	push	r20
     b26:	5f 93       	push	r21
     b28:	6f 93       	push	r22
     b2a:	7f 93       	push	r23
     b2c:	8f 93       	push	r24
     b2e:	9f 93       	push	r25
     b30:	af 93       	push	r26
     b32:	bf 93       	push	r27
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	ef 93       	push	r30
     b3a:	ff 93       	push	r31
     b3c:	a0 91 48 1a 	lds	r26, 0x1A48
     b40:	b0 91 49 1a 	lds	r27, 0x1A49
     b44:	0d b6       	in	r0, 0x3d	; 61
     b46:	0d 92       	st	X+, r0
     b48:	0e b6       	in	r0, 0x3e	; 62
     b4a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     b4c:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <vTaskIncrementTick>
	vTaskSwitchContext();
     b50:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b54:	a0 91 48 1a 	lds	r26, 0x1A48
     b58:	b0 91 49 1a 	lds	r27, 0x1A49
     b5c:	cd 91       	ld	r28, X+
     b5e:	cd bf       	out	0x3d, r28	; 61
     b60:	dd 91       	ld	r29, X+
     b62:	de bf       	out	0x3e, r29	; 62
     b64:	ff 91       	pop	r31
     b66:	ef 91       	pop	r30
     b68:	df 91       	pop	r29
     b6a:	cf 91       	pop	r28
     b6c:	bf 91       	pop	r27
     b6e:	af 91       	pop	r26
     b70:	9f 91       	pop	r25
     b72:	8f 91       	pop	r24
     b74:	7f 91       	pop	r23
     b76:	6f 91       	pop	r22
     b78:	5f 91       	pop	r21
     b7a:	4f 91       	pop	r20
     b7c:	3f 91       	pop	r19
     b7e:	2f 91       	pop	r18
     b80:	1f 91       	pop	r17
     b82:	0f 91       	pop	r16
     b84:	ff 90       	pop	r15
     b86:	ef 90       	pop	r14
     b88:	df 90       	pop	r13
     b8a:	cf 90       	pop	r12
     b8c:	bf 90       	pop	r11
     b8e:	af 90       	pop	r10
     b90:	9f 90       	pop	r9
     b92:	8f 90       	pop	r8
     b94:	7f 90       	pop	r7
     b96:	6f 90       	pop	r6
     b98:	5f 90       	pop	r5
     b9a:	4f 90       	pop	r4
     b9c:	3f 90       	pop	r3
     b9e:	2f 90       	pop	r2
     ba0:	1f 90       	pop	r1
     ba2:	0f 90       	pop	r0
     ba4:	0c be       	out	0x3c, r0	; 60
     ba6:	0f 90       	pop	r0
     ba8:	0b be       	out	0x3b, r0	; 59
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bb0:	08 95       	ret

00000bb2 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
     bb2:	0e 94 76 05 	call	0xaec	; 0xaec <vPortYieldFromTick>
			asm volatile ( "reti" );
     bb6:	18 95       	reti

00000bb8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     bb8:	cf 93       	push	r28
     bba:	df 93       	push	r29
     bbc:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     bbe:	cd 91       	ld	r28, X+
     bc0:	dc 91       	ld	r29, X
     bc2:	11 97       	sbiw	r26, 0x01	; 1
     bc4:	20 97       	sbiw	r28, 0x00	; 0
     bc6:	21 f1       	breq	.+72     	; 0xc10 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     bc8:	5c 96       	adiw	r26, 0x1c	; 28
     bca:	4c 91       	ld	r20, X
     bcc:	5c 97       	sbiw	r26, 0x1c	; 28
     bce:	16 96       	adiw	r26, 0x06	; 6
     bd0:	2d 91       	ld	r18, X+
     bd2:	3c 91       	ld	r19, X
     bd4:	17 97       	sbiw	r26, 0x07	; 7
     bd6:	24 0f       	add	r18, r20
     bd8:	31 1d       	adc	r19, r1
     bda:	17 96       	adiw	r26, 0x07	; 7
     bdc:	3c 93       	st	X, r19
     bde:	2e 93       	st	-X, r18
     be0:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     be2:	12 96       	adiw	r26, 0x02	; 2
     be4:	ed 91       	ld	r30, X+
     be6:	fc 91       	ld	r31, X
     be8:	13 97       	sbiw	r26, 0x03	; 3
     bea:	2e 17       	cp	r18, r30
     bec:	3f 07       	cpc	r19, r31
     bee:	20 f0       	brcs	.+8      	; 0xbf8 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     bf0:	17 96       	adiw	r26, 0x07	; 7
     bf2:	dc 93       	st	X, r29
     bf4:	ce 93       	st	-X, r28
     bf6:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     bf8:	16 96       	adiw	r26, 0x06	; 6
     bfa:	3c 91       	ld	r19, X
     bfc:	16 97       	sbiw	r26, 0x06	; 6
     bfe:	17 96       	adiw	r26, 0x07	; 7
     c00:	2c 91       	ld	r18, X
     c02:	86 2f       	mov	r24, r22
     c04:	97 2f       	mov	r25, r23
     c06:	63 2f       	mov	r22, r19
     c08:	72 2f       	mov	r23, r18
     c0a:	50 e0       	ldi	r21, 0x00	; 0
     c0c:	0e 94 40 10 	call	0x2080	; 0x2080 <memcpy>
	}
}
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	08 95       	ret

00000c16 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     c16:	0f 93       	push	r16
     c18:	1f 93       	push	r17
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	f8 94       	cli
     c24:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c26:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c28:	18 16       	cp	r1, r24
     c2a:	c4 f4       	brge	.+48     	; 0xc5c <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c2c:	89 89       	ldd	r24, Y+17	; 0x11
     c2e:	88 23       	and	r24, r24
     c30:	29 f4       	brne	.+10     	; 0xc3c <prvUnlockQueue+0x26>
     c32:	14 c0       	rjmp	.+40     	; 0xc5c <prvUnlockQueue+0x46>
     c34:	89 89       	ldd	r24, Y+17	; 0x11
     c36:	88 23       	and	r24, r24
     c38:	21 f4       	brne	.+8      	; 0xc42 <prvUnlockQueue+0x2c>
     c3a:	10 c0       	rjmp	.+32     	; 0xc5c <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c3c:	8e 01       	movw	r16, r28
     c3e:	0f 5e       	subi	r16, 0xEF	; 239
     c40:	1f 4f       	sbci	r17, 0xFF	; 255
     c42:	c8 01       	movw	r24, r16
     c44:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
     c48:	88 23       	and	r24, r24
     c4a:	11 f0       	breq	.+4      	; 0xc50 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     c4c:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     c50:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c52:	81 50       	subi	r24, 0x01	; 1
     c54:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c56:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c58:	18 16       	cp	r1, r24
     c5a:	64 f3       	brlt	.-40     	; 0xc34 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     c5c:	8f ef       	ldi	r24, 0xFF	; 255
     c5e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     c60:	0f 90       	pop	r0
     c62:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     c64:	0f b6       	in	r0, 0x3f	; 63
     c66:	f8 94       	cli
     c68:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c6a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c6c:	18 16       	cp	r1, r24
     c6e:	c4 f4       	brge	.+48     	; 0xca0 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c70:	88 85       	ldd	r24, Y+8	; 0x08
     c72:	88 23       	and	r24, r24
     c74:	29 f4       	brne	.+10     	; 0xc80 <prvUnlockQueue+0x6a>
     c76:	14 c0       	rjmp	.+40     	; 0xca0 <prvUnlockQueue+0x8a>
     c78:	88 85       	ldd	r24, Y+8	; 0x08
     c7a:	88 23       	and	r24, r24
     c7c:	21 f4       	brne	.+8      	; 0xc86 <prvUnlockQueue+0x70>
     c7e:	10 c0       	rjmp	.+32     	; 0xca0 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c80:	8e 01       	movw	r16, r28
     c82:	08 5f       	subi	r16, 0xF8	; 248
     c84:	1f 4f       	sbci	r17, 0xFF	; 255
     c86:	c8 01       	movw	r24, r16
     c88:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
     c8c:	88 23       	and	r24, r24
     c8e:	11 f0       	breq	.+4      	; 0xc94 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
     c90:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     c94:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c96:	81 50       	subi	r24, 0x01	; 1
     c98:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c9a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c9c:	18 16       	cp	r1, r24
     c9e:	64 f3       	brlt	.-40     	; 0xc78 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     ca0:	8f ef       	ldi	r24, 0xFF	; 255
     ca2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     ca4:	0f 90       	pop	r0
     ca6:	0f be       	out	0x3f, r0	; 63
}
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	08 95       	ret

00000cb2 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     cb2:	cf 93       	push	r28
     cb4:	df 93       	push	r29
     cb6:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     cb8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cba:	22 23       	and	r18, r18
     cbc:	59 f4       	brne	.+22     	; 0xcd4 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     cbe:	88 81       	ld	r24, Y
     cc0:	99 81       	ldd	r25, Y+1	; 0x01
     cc2:	00 97       	sbiw	r24, 0x00	; 0
     cc4:	e1 f5       	brne	.+120    	; 0xd3e <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     cc6:	8a 81       	ldd	r24, Y+2	; 0x02
     cc8:	9b 81       	ldd	r25, Y+3	; 0x03
     cca:	0e 94 0b 10 	call	0x2016	; 0x2016 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     cce:	1b 82       	std	Y+3, r1	; 0x03
     cd0:	1a 82       	std	Y+2, r1	; 0x02
     cd2:	35 c0       	rjmp	.+106    	; 0xd3e <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     cd4:	44 23       	and	r20, r20
     cd6:	b9 f4       	brne	.+46     	; 0xd06 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     cd8:	8c 81       	ldd	r24, Y+4	; 0x04
     cda:	9d 81       	ldd	r25, Y+5	; 0x05
     cdc:	42 2f       	mov	r20, r18
     cde:	50 e0       	ldi	r21, 0x00	; 0
     ce0:	0e 94 40 10 	call	0x2080	; 0x2080 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ce4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ce6:	8c 81       	ldd	r24, Y+4	; 0x04
     ce8:	9d 81       	ldd	r25, Y+5	; 0x05
     cea:	82 0f       	add	r24, r18
     cec:	91 1d       	adc	r25, r1
     cee:	9d 83       	std	Y+5, r25	; 0x05
     cf0:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     cf2:	2a 81       	ldd	r18, Y+2	; 0x02
     cf4:	3b 81       	ldd	r19, Y+3	; 0x03
     cf6:	82 17       	cp	r24, r18
     cf8:	93 07       	cpc	r25, r19
     cfa:	08 f1       	brcs	.+66     	; 0xd3e <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     cfc:	88 81       	ld	r24, Y
     cfe:	99 81       	ldd	r25, Y+1	; 0x01
     d00:	9d 83       	std	Y+5, r25	; 0x05
     d02:	8c 83       	std	Y+4, r24	; 0x04
     d04:	1c c0       	rjmp	.+56     	; 0xd3e <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d06:	8e 81       	ldd	r24, Y+6	; 0x06
     d08:	9f 81       	ldd	r25, Y+7	; 0x07
     d0a:	42 2f       	mov	r20, r18
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	0e 94 40 10 	call	0x2080	; 0x2080 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     d12:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d14:	50 e0       	ldi	r21, 0x00	; 0
     d16:	50 95       	com	r21
     d18:	41 95       	neg	r20
     d1a:	5f 4f       	sbci	r21, 0xFF	; 255
     d1c:	8e 81       	ldd	r24, Y+6	; 0x06
     d1e:	9f 81       	ldd	r25, Y+7	; 0x07
     d20:	84 0f       	add	r24, r20
     d22:	95 1f       	adc	r25, r21
     d24:	9f 83       	std	Y+7, r25	; 0x07
     d26:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     d28:	28 81       	ld	r18, Y
     d2a:	39 81       	ldd	r19, Y+1	; 0x01
     d2c:	82 17       	cp	r24, r18
     d2e:	93 07       	cpc	r25, r19
     d30:	30 f4       	brcc	.+12     	; 0xd3e <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d32:	8a 81       	ldd	r24, Y+2	; 0x02
     d34:	9b 81       	ldd	r25, Y+3	; 0x03
     d36:	48 0f       	add	r20, r24
     d38:	59 1f       	adc	r21, r25
     d3a:	5f 83       	std	Y+7, r21	; 0x07
     d3c:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     d3e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d40:	8f 5f       	subi	r24, 0xFF	; 255
     d42:	8a 8f       	std	Y+26, r24	; 0x1a
}
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	08 95       	ret

00000d4a <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
     d4e:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     d50:	0f b6       	in	r0, 0x3f	; 63
     d52:	f8 94       	cli
     d54:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     d56:	48 81       	ld	r20, Y
     d58:	59 81       	ldd	r21, Y+1	; 0x01
     d5a:	2b 8d       	ldd	r18, Y+27	; 0x1b
     d5c:	30 e0       	ldi	r19, 0x00	; 0
     d5e:	ec 8d       	ldd	r30, Y+28	; 0x1c
     d60:	f0 e0       	ldi	r31, 0x00	; 0
     d62:	2e 9f       	mul	r18, r30
     d64:	c0 01       	movw	r24, r0
     d66:	2f 9f       	mul	r18, r31
     d68:	90 0d       	add	r25, r0
     d6a:	3e 9f       	mul	r19, r30
     d6c:	90 0d       	add	r25, r0
     d6e:	11 24       	eor	r1, r1
     d70:	84 0f       	add	r24, r20
     d72:	95 1f       	adc	r25, r21
     d74:	9b 83       	std	Y+3, r25	; 0x03
     d76:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     d78:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     d7a:	5d 83       	std	Y+5, r21	; 0x05
     d7c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     d7e:	c9 01       	movw	r24, r18
     d80:	01 97       	sbiw	r24, 0x01	; 1
     d82:	e8 9f       	mul	r30, r24
     d84:	90 01       	movw	r18, r0
     d86:	e9 9f       	mul	r30, r25
     d88:	30 0d       	add	r19, r0
     d8a:	f8 9f       	mul	r31, r24
     d8c:	30 0d       	add	r19, r0
     d8e:	11 24       	eor	r1, r1
     d90:	24 0f       	add	r18, r20
     d92:	35 1f       	adc	r19, r21
     d94:	3f 83       	std	Y+7, r19	; 0x07
     d96:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     d98:	8f ef       	ldi	r24, 0xFF	; 255
     d9a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     d9c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     d9e:	66 23       	and	r22, r22
     da0:	61 f4       	brne	.+24     	; 0xdba <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     da2:	88 85       	ldd	r24, Y+8	; 0x08
     da4:	88 23       	and	r24, r24
     da6:	89 f0       	breq	.+34     	; 0xdca <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     da8:	ce 01       	movw	r24, r28
     daa:	08 96       	adiw	r24, 0x08	; 8
     dac:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
     db0:	81 30       	cpi	r24, 0x01	; 1
     db2:	59 f4       	brne	.+22     	; 0xdca <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
     db4:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
     db8:	08 c0       	rjmp	.+16     	; 0xdca <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     dba:	ce 01       	movw	r24, r28
     dbc:	08 96       	adiw	r24, 0x08	; 8
     dbe:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     dc2:	ce 01       	movw	r24, r28
     dc4:	41 96       	adiw	r24, 0x11	; 17
     dc6:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     dca:	0f 90       	pop	r0
     dcc:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	08 95       	ret

00000dd6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     dd6:	0f 93       	push	r16
     dd8:	1f 93       	push	r17
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
     dde:	18 2f       	mov	r17, r24
     de0:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     de2:	88 23       	and	r24, r24
     de4:	f9 f0       	breq	.+62     	; 0xe24 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     de6:	8f e1       	ldi	r24, 0x1F	; 31
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	0e 94 cc 02 	call	0x598	; 0x598 <pvPortMalloc>
     dee:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     df0:	00 97       	sbiw	r24, 0x00	; 0
     df2:	d9 f0       	breq	.+54     	; 0xe2a <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     df4:	01 9f       	mul	r16, r17
     df6:	c0 01       	movw	r24, r0
     df8:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     dfa:	01 96       	adiw	r24, 0x01	; 1
     dfc:	0e 94 cc 02 	call	0x598	; 0x598 <pvPortMalloc>
     e00:	99 83       	std	Y+1, r25	; 0x01
     e02:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     e04:	00 97       	sbiw	r24, 0x00	; 0
     e06:	41 f0       	breq	.+16     	; 0xe18 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     e08:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     e0a:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
     e0c:	ce 01       	movw	r24, r28
     e0e:	61 e0       	ldi	r22, 0x01	; 1
     e10:	0e 94 a5 06 	call	0xd4a	; 0xd4a <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     e14:	ce 01       	movw	r24, r28
     e16:	0b c0       	rjmp	.+22     	; 0xe2e <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     e18:	ce 01       	movw	r24, r28
     e1a:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     e1e:	80 e0       	ldi	r24, 0x00	; 0
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	05 c0       	rjmp	.+10     	; 0xe2e <xQueueGenericCreate+0x58>
     e24:	80 e0       	ldi	r24, 0x00	; 0
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <xQueueGenericCreate+0x58>
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     e2e:	df 91       	pop	r29
     e30:	cf 91       	pop	r28
     e32:	1f 91       	pop	r17
     e34:	0f 91       	pop	r16
     e36:	08 95       	ret

00000e38 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     e38:	8f 92       	push	r8
     e3a:	9f 92       	push	r9
     e3c:	bf 92       	push	r11
     e3e:	cf 92       	push	r12
     e40:	df 92       	push	r13
     e42:	ef 92       	push	r14
     e44:	ff 92       	push	r15
     e46:	0f 93       	push	r16
     e48:	1f 93       	push	r17
     e4a:	cf 93       	push	r28
     e4c:	df 93       	push	r29
     e4e:	00 d0       	rcall	.+0      	; 0xe50 <xQueueGenericSend+0x18>
     e50:	0f 92       	push	r0
     e52:	0f 92       	push	r0
     e54:	cd b7       	in	r28, 0x3d	; 61
     e56:	de b7       	in	r29, 0x3e	; 62
     e58:	8c 01       	movw	r16, r24
     e5a:	4b 01       	movw	r8, r22
     e5c:	5d 83       	std	Y+5, r21	; 0x05
     e5e:	4c 83       	std	Y+4, r20	; 0x04
     e60:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     e62:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e64:	ee 24       	eor	r14, r14
     e66:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e68:	cc 24       	eor	r12, r12
     e6a:	dd 24       	eor	r13, r13
     e6c:	68 94       	set
     e6e:	c3 f8       	bld	r12, 3
     e70:	c8 0e       	add	r12, r24
     e72:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e7a:	f8 01       	movw	r30, r16
     e7c:	92 8d       	ldd	r25, Z+26	; 0x1a
     e7e:	83 8d       	ldd	r24, Z+27	; 0x1b
     e80:	98 17       	cp	r25, r24
     e82:	a8 f4       	brcc	.+42     	; 0xeae <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e84:	c8 01       	movw	r24, r16
     e86:	b4 01       	movw	r22, r8
     e88:	4b 2d       	mov	r20, r11
     e8a:	0e 94 59 06 	call	0xcb2	; 0xcb2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e8e:	f8 01       	movw	r30, r16
     e90:	81 89       	ldd	r24, Z+17	; 0x11
     e92:	88 23       	and	r24, r24
     e94:	41 f0       	breq	.+16     	; 0xea6 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     e96:	c8 01       	movw	r24, r16
     e98:	41 96       	adiw	r24, 0x11	; 17
     e9a:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
     e9e:	81 30       	cpi	r24, 0x01	; 1
     ea0:	11 f4       	brne	.+4      	; 0xea6 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     ea2:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     ea6:	0f 90       	pop	r0
     ea8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	52 c0       	rjmp	.+164    	; 0xf52 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     eae:	8c 81       	ldd	r24, Y+4	; 0x04
     eb0:	9d 81       	ldd	r25, Y+5	; 0x05
     eb2:	00 97       	sbiw	r24, 0x00	; 0
     eb4:	21 f4       	brne	.+8      	; 0xebe <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     eb6:	0f 90       	pop	r0
     eb8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	4a c0       	rjmp	.+148    	; 0xf52 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     ebe:	ff 20       	and	r15, r15
     ec0:	29 f4       	brne	.+10     	; 0xecc <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ec2:	ce 01       	movw	r24, r28
     ec4:	01 96       	adiw	r24, 0x01	; 1
     ec6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     eca:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ed0:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ed4:	0f b6       	in	r0, 0x3f	; 63
     ed6:	f8 94       	cli
     ed8:	0f 92       	push	r0
     eda:	f8 01       	movw	r30, r16
     edc:	85 8d       	ldd	r24, Z+29	; 0x1d
     ede:	8f 3f       	cpi	r24, 0xFF	; 255
     ee0:	09 f4       	brne	.+2      	; 0xee4 <xQueueGenericSend+0xac>
     ee2:	15 8e       	std	Z+29, r1	; 0x1d
     ee4:	f8 01       	movw	r30, r16
     ee6:	86 8d       	ldd	r24, Z+30	; 0x1e
     ee8:	8f 3f       	cpi	r24, 0xFF	; 255
     eea:	09 f4       	brne	.+2      	; 0xeee <xQueueGenericSend+0xb6>
     eec:	16 8e       	std	Z+30, r1	; 0x1e
     eee:	0f 90       	pop	r0
     ef0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ef2:	ce 01       	movw	r24, r28
     ef4:	01 96       	adiw	r24, 0x01	; 1
     ef6:	be 01       	movw	r22, r28
     ef8:	6c 5f       	subi	r22, 0xFC	; 252
     efa:	7f 4f       	sbci	r23, 0xFF	; 255
     efc:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <xTaskCheckForTimeOut>
     f00:	88 23       	and	r24, r24
     f02:	09 f5       	brne	.+66     	; 0xf46 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f04:	0f b6       	in	r0, 0x3f	; 63
     f06:	f8 94       	cli
     f08:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f0a:	f8 01       	movw	r30, r16
     f0c:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f0e:	0f 90       	pop	r0
     f10:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     f12:	f8 01       	movw	r30, r16
     f14:	83 8d       	ldd	r24, Z+27	; 0x1b
     f16:	98 17       	cp	r25, r24
     f18:	81 f4       	brne	.+32     	; 0xf3a <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f1a:	6c 81       	ldd	r22, Y+4	; 0x04
     f1c:	7d 81       	ldd	r23, Y+5	; 0x05
     f1e:	c6 01       	movw	r24, r12
     f20:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f24:	c8 01       	movw	r24, r16
     f26:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     f2a:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
     f2e:	88 23       	and	r24, r24
     f30:	09 f0       	breq	.+2      	; 0xf34 <xQueueGenericSend+0xfc>
     f32:	a0 cf       	rjmp	.-192    	; 0xe74 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     f34:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
     f38:	9d cf       	rjmp	.-198    	; 0xe74 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f3a:	c8 01       	movw	r24, r16
     f3c:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f40:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
     f44:	97 cf       	rjmp	.-210    	; 0xe74 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     f46:	c8 01       	movw	r24, r16
     f48:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f4c:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     f50:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     f52:	0f 90       	pop	r0
     f54:	0f 90       	pop	r0
     f56:	0f 90       	pop	r0
     f58:	0f 90       	pop	r0
     f5a:	0f 90       	pop	r0
     f5c:	df 91       	pop	r29
     f5e:	cf 91       	pop	r28
     f60:	1f 91       	pop	r17
     f62:	0f 91       	pop	r16
     f64:	ff 90       	pop	r15
     f66:	ef 90       	pop	r14
     f68:	df 90       	pop	r13
     f6a:	cf 90       	pop	r12
     f6c:	bf 90       	pop	r11
     f6e:	9f 90       	pop	r9
     f70:	8f 90       	pop	r8
     f72:	08 95       	ret

00000f74 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     f78:	8f e1       	ldi	r24, 0x1F	; 31
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	0e 94 cc 02 	call	0x598	; 0x598 <pvPortMalloc>
     f80:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f82:	00 97       	sbiw	r24, 0x00	; 0
     f84:	f9 f0       	breq	.+62     	; 0xfc4 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     f86:	1b 82       	std	Y+3, r1	; 0x03
     f88:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     f8a:	19 82       	std	Y+1, r1	; 0x01
     f8c:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
     f8e:	1d 82       	std	Y+5, r1	; 0x05
     f90:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
     f92:	1f 82       	std	Y+7, r1	; 0x07
     f94:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     f96:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
     f98:	81 e0       	ldi	r24, 0x01	; 1
     f9a:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
     f9c:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
     f9e:	8f ef       	ldi	r24, 0xFF	; 255
     fa0:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
     fa2:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     fa4:	ce 01       	movw	r24, r28
     fa6:	08 96       	adiw	r24, 0x08	; 8
     fa8:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     fac:	ce 01       	movw	r24, r28
     fae:	41 96       	adiw	r24, 0x11	; 17
     fb0:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
     fb4:	ce 01       	movw	r24, r28
     fb6:	60 e0       	ldi	r22, 0x00	; 0
     fb8:	70 e0       	ldi	r23, 0x00	; 0
     fba:	40 e0       	ldi	r20, 0x00	; 0
     fbc:	50 e0       	ldi	r21, 0x00	; 0
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	0e 94 1c 07 	call	0xe38	; 0xe38 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
     fc4:	8c 2f       	mov	r24, r28
     fc6:	9d 2f       	mov	r25, r29
     fc8:	df 91       	pop	r29
     fca:	cf 91       	pop	r28
     fcc:	08 95       	ret

00000fce <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     fce:	0f 93       	push	r16
     fd0:	1f 93       	push	r17
     fd2:	cf 93       	push	r28
     fd4:	df 93       	push	r29
     fd6:	ec 01       	movw	r28, r24
     fd8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     fda:	9a 8d       	ldd	r25, Y+26	; 0x1a
     fdc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fde:	98 17       	cp	r25, r24
     fe0:	e0 f4       	brcc	.+56     	; 0x101a <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     fe2:	ce 01       	movw	r24, r28
     fe4:	42 2f       	mov	r20, r18
     fe6:	0e 94 59 06 	call	0xcb2	; 0xcb2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     fea:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fec:	8f 3f       	cpi	r24, 0xFF	; 255
     fee:	81 f4       	brne	.+32     	; 0x1010 <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ff0:	89 89       	ldd	r24, Y+17	; 0x11
     ff2:	88 23       	and	r24, r24
     ff4:	a1 f0       	breq	.+40     	; 0x101e <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ff6:	ce 01       	movw	r24, r28
     ff8:	41 96       	adiw	r24, 0x11	; 17
     ffa:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
     ffe:	88 23       	and	r24, r24
    1000:	81 f0       	breq	.+32     	; 0x1022 <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1002:	01 15       	cp	r16, r1
    1004:	11 05       	cpc	r17, r1
    1006:	79 f0       	breq	.+30     	; 0x1026 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	f8 01       	movw	r30, r16
    100c:	80 83       	st	Z, r24
    100e:	0c c0       	rjmp	.+24     	; 0x1028 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1010:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1012:	8f 5f       	subi	r24, 0xFF	; 255
    1014:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	07 c0       	rjmp	.+14     	; 0x1028 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	05 c0       	rjmp	.+10     	; 0x1028 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	03 c0       	rjmp	.+6      	; 0x1028 <xQueueGenericSendFromISR+0x5a>
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	01 c0       	rjmp	.+2      	; 0x1028 <xQueueGenericSendFromISR+0x5a>
    1026:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	1f 91       	pop	r17
    102e:	0f 91       	pop	r16
    1030:	08 95       	ret

00001032 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1032:	8f 92       	push	r8
    1034:	9f 92       	push	r9
    1036:	bf 92       	push	r11
    1038:	cf 92       	push	r12
    103a:	df 92       	push	r13
    103c:	ef 92       	push	r14
    103e:	ff 92       	push	r15
    1040:	0f 93       	push	r16
    1042:	1f 93       	push	r17
    1044:	cf 93       	push	r28
    1046:	df 93       	push	r29
    1048:	00 d0       	rcall	.+0      	; 0x104a <xQueueGenericReceive+0x18>
    104a:	0f 92       	push	r0
    104c:	0f 92       	push	r0
    104e:	cd b7       	in	r28, 0x3d	; 61
    1050:	de b7       	in	r29, 0x3e	; 62
    1052:	8c 01       	movw	r16, r24
    1054:	4b 01       	movw	r8, r22
    1056:	5d 83       	std	Y+5, r21	; 0x05
    1058:	4c 83       	std	Y+4, r20	; 0x04
    105a:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    105c:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    105e:	ee 24       	eor	r14, r14
    1060:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1062:	0f 2e       	mov	r0, r31
    1064:	f1 e1       	ldi	r31, 0x11	; 17
    1066:	cf 2e       	mov	r12, r31
    1068:	dd 24       	eor	r13, r13
    106a:	f0 2d       	mov	r31, r0
    106c:	c8 0e       	add	r12, r24
    106e:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1070:	0f b6       	in	r0, 0x3f	; 63
    1072:	f8 94       	cli
    1074:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1076:	f8 01       	movw	r30, r16
    1078:	82 8d       	ldd	r24, Z+26	; 0x1a
    107a:	88 23       	and	r24, r24
    107c:	a1 f1       	breq	.+104    	; 0x10e6 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    107e:	e6 80       	ldd	r14, Z+6	; 0x06
    1080:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1082:	c8 01       	movw	r24, r16
    1084:	b4 01       	movw	r22, r8
    1086:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    108a:	bb 20       	and	r11, r11
    108c:	d1 f4       	brne	.+52     	; 0x10c2 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    108e:	f8 01       	movw	r30, r16
    1090:	82 8d       	ldd	r24, Z+26	; 0x1a
    1092:	81 50       	subi	r24, 0x01	; 1
    1094:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1096:	80 81       	ld	r24, Z
    1098:	91 81       	ldd	r25, Z+1	; 0x01
    109a:	00 97       	sbiw	r24, 0x00	; 0
    109c:	29 f4       	brne	.+10     	; 0x10a8 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    109e:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <xTaskGetCurrentTaskHandle>
    10a2:	f8 01       	movw	r30, r16
    10a4:	93 83       	std	Z+3, r25	; 0x03
    10a6:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10a8:	f8 01       	movw	r30, r16
    10aa:	80 85       	ldd	r24, Z+8	; 0x08
    10ac:	88 23       	and	r24, r24
    10ae:	b9 f0       	breq	.+46     	; 0x10de <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    10b0:	c8 01       	movw	r24, r16
    10b2:	08 96       	adiw	r24, 0x08	; 8
    10b4:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
    10b8:	81 30       	cpi	r24, 0x01	; 1
    10ba:	89 f4       	brne	.+34     	; 0x10de <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    10bc:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
    10c0:	0e c0       	rjmp	.+28     	; 0x10de <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    10c2:	f8 01       	movw	r30, r16
    10c4:	f7 82       	std	Z+7, r15	; 0x07
    10c6:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10c8:	81 89       	ldd	r24, Z+17	; 0x11
    10ca:	88 23       	and	r24, r24
    10cc:	41 f0       	breq	.+16     	; 0x10de <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10ce:	c8 01       	movw	r24, r16
    10d0:	41 96       	adiw	r24, 0x11	; 17
    10d2:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
    10d6:	88 23       	and	r24, r24
    10d8:	11 f0       	breq	.+4      	; 0x10de <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    10da:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    10de:	0f 90       	pop	r0
    10e0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    10e2:	81 e0       	ldi	r24, 0x01	; 1
    10e4:	5f c0       	rjmp	.+190    	; 0x11a4 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    10e6:	8c 81       	ldd	r24, Y+4	; 0x04
    10e8:	9d 81       	ldd	r25, Y+5	; 0x05
    10ea:	00 97       	sbiw	r24, 0x00	; 0
    10ec:	21 f4       	brne	.+8      	; 0x10f6 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10ee:	0f 90       	pop	r0
    10f0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    10f2:	80 e0       	ldi	r24, 0x00	; 0
    10f4:	57 c0       	rjmp	.+174    	; 0x11a4 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    10f6:	ff 20       	and	r15, r15
    10f8:	29 f4       	brne	.+10     	; 0x1104 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10fa:	ce 01       	movw	r24, r28
    10fc:	01 96       	adiw	r24, 0x01	; 1
    10fe:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1102:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1104:	0f 90       	pop	r0
    1106:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1108:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    110c:	0f b6       	in	r0, 0x3f	; 63
    110e:	f8 94       	cli
    1110:	0f 92       	push	r0
    1112:	f8 01       	movw	r30, r16
    1114:	85 8d       	ldd	r24, Z+29	; 0x1d
    1116:	8f 3f       	cpi	r24, 0xFF	; 255
    1118:	09 f4       	brne	.+2      	; 0x111c <xQueueGenericReceive+0xea>
    111a:	15 8e       	std	Z+29, r1	; 0x1d
    111c:	f8 01       	movw	r30, r16
    111e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1120:	8f 3f       	cpi	r24, 0xFF	; 255
    1122:	09 f4       	brne	.+2      	; 0x1126 <xQueueGenericReceive+0xf4>
    1124:	16 8e       	std	Z+30, r1	; 0x1e
    1126:	0f 90       	pop	r0
    1128:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    112a:	ce 01       	movw	r24, r28
    112c:	01 96       	adiw	r24, 0x01	; 1
    112e:	be 01       	movw	r22, r28
    1130:	6c 5f       	subi	r22, 0xFC	; 252
    1132:	7f 4f       	sbci	r23, 0xFF	; 255
    1134:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <xTaskCheckForTimeOut>
    1138:	88 23       	and	r24, r24
    113a:	71 f5       	brne	.+92     	; 0x1198 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1142:	f8 01       	movw	r30, r16
    1144:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1146:	0f 90       	pop	r0
    1148:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    114a:	88 23       	and	r24, r24
    114c:	f9 f4       	brne	.+62     	; 0x118c <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    114e:	f8 01       	movw	r30, r16
    1150:	80 81       	ld	r24, Z
    1152:	91 81       	ldd	r25, Z+1	; 0x01
    1154:	00 97       	sbiw	r24, 0x00	; 0
    1156:	51 f4       	brne	.+20     	; 0x116c <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    1158:	0f b6       	in	r0, 0x3f	; 63
    115a:	f8 94       	cli
    115c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    115e:	f8 01       	movw	r30, r16
    1160:	82 81       	ldd	r24, Z+2	; 0x02
    1162:	93 81       	ldd	r25, Z+3	; 0x03
    1164:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1168:	0f 90       	pop	r0
    116a:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    116c:	6c 81       	ldd	r22, Y+4	; 0x04
    116e:	7d 81       	ldd	r23, Y+5	; 0x05
    1170:	c6 01       	movw	r24, r12
    1172:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1176:	c8 01       	movw	r24, r16
    1178:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    117c:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
    1180:	88 23       	and	r24, r24
    1182:	09 f0       	breq	.+2      	; 0x1186 <xQueueGenericReceive+0x154>
    1184:	75 cf       	rjmp	.-278    	; 0x1070 <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    1186:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
    118a:	72 cf       	rjmp	.-284    	; 0x1070 <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    118c:	c8 01       	movw	r24, r16
    118e:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1192:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
    1196:	6c cf       	rjmp	.-296    	; 0x1070 <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1198:	c8 01       	movw	r24, r16
    119a:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    119e:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    11a2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	0f 90       	pop	r0
    11ae:	df 91       	pop	r29
    11b0:	cf 91       	pop	r28
    11b2:	1f 91       	pop	r17
    11b4:	0f 91       	pop	r16
    11b6:	ff 90       	pop	r15
    11b8:	ef 90       	pop	r14
    11ba:	df 90       	pop	r13
    11bc:	cf 90       	pop	r12
    11be:	bf 90       	pop	r11
    11c0:	9f 90       	pop	r9
    11c2:	8f 90       	pop	r8
    11c4:	08 95       	ret

000011c6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    11c6:	0f 93       	push	r16
    11c8:	1f 93       	push	r17
    11ca:	cf 93       	push	r28
    11cc:	df 93       	push	r29
    11ce:	ec 01       	movw	r28, r24
    11d0:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    11d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11d4:	88 23       	and	r24, r24
    11d6:	f1 f0       	breq	.+60     	; 0x1214 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    11d8:	ce 01       	movw	r24, r28
    11da:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    11de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11e0:	81 50       	subi	r24, 0x01	; 1
    11e2:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    11e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11e6:	8f 3f       	cpi	r24, 0xFF	; 255
    11e8:	81 f4       	brne	.+32     	; 0x120a <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11ea:	88 85       	ldd	r24, Y+8	; 0x08
    11ec:	88 23       	and	r24, r24
    11ee:	a1 f0       	breq	.+40     	; 0x1218 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11f0:	ce 01       	movw	r24, r28
    11f2:	08 96       	adiw	r24, 0x08	; 8
    11f4:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskRemoveFromEventList>
    11f8:	88 23       	and	r24, r24
    11fa:	81 f0       	breq	.+32     	; 0x121c <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    11fc:	01 15       	cp	r16, r1
    11fe:	11 05       	cpc	r17, r1
    1200:	79 f0       	breq	.+30     	; 0x1220 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	f8 01       	movw	r30, r16
    1206:	80 83       	st	Z, r24
    1208:	0c c0       	rjmp	.+24     	; 0x1222 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    120a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    120c:	8f 5f       	subi	r24, 0xFF	; 255
    120e:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	07 c0       	rjmp	.+14     	; 0x1222 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1214:	80 e0       	ldi	r24, 0x00	; 0
    1216:	05 c0       	rjmp	.+10     	; 0x1222 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1218:	81 e0       	ldi	r24, 0x01	; 1
    121a:	03 c0       	rjmp	.+6      	; 0x1222 <xQueueReceiveFromISR+0x5c>
    121c:	81 e0       	ldi	r24, 0x01	; 1
    121e:	01 c0       	rjmp	.+2      	; 0x1222 <xQueueReceiveFromISR+0x5c>
    1220:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1222:	df 91       	pop	r29
    1224:	cf 91       	pop	r28
    1226:	1f 91       	pop	r17
    1228:	0f 91       	pop	r16
    122a:	08 95       	ret

0000122c <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	f8 94       	cli
    1230:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1232:	fc 01       	movw	r30, r24
    1234:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1236:	0f 90       	pop	r0
    1238:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    123a:	08 95       	ret

0000123c <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    123c:	fc 01       	movw	r30, r24
    123e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1240:	08 95       	ret

00001242 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1242:	cf 93       	push	r28
    1244:	df 93       	push	r29
    1246:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1248:	88 81       	ld	r24, Y
    124a:	99 81       	ldd	r25, Y+1	; 0x01
    124c:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortFree>
	vPortFree( pxQueue );
    1250:	ce 01       	movw	r24, r28
    1252:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortFree>
}
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	08 95       	ret

0000125c <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    125c:	fc 01       	movw	r30, r24
    125e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	91 11       	cpse	r25, r1
    1264:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1266:	08 95       	ret

00001268 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1268:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    126a:	22 8d       	ldd	r18, Z+26	; 0x1a
    126c:	81 e0       	ldi	r24, 0x01	; 1
    126e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1270:	29 13       	cpse	r18, r25
    1272:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1274:	08 95       	ret

00001276 <SPI_MasterInit>:
//-
//-
//---------------------------------------------------------------
void SPI_MasterInit(void)
{
	SPCR |= ((1 << SPE) | (1 << SPIE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0)); 
    1276:	8c b5       	in	r24, 0x2c	; 44
    1278:	83 6d       	ori	r24, 0xD3	; 211
    127a:	8c bd       	out	0x2c, r24	; 44
	SPSR |=  1 << SPI2X; 
    127c:	8d b5       	in	r24, 0x2d	; 45
    127e:	81 60       	ori	r24, 0x01	; 1
    1280:	8d bd       	out	0x2d, r24	; 45
	
	
	SPCR =  (0<<SPIE) |	//No interrupts
    1282:	83 e7       	ldi	r24, 0x73	; 115
    1284:	8c bd       	out	0x2c, r24	; 44
			(0<<CPOL) |	//rising leading edge
			(0<<CPHA) |	//sample leading edge
			(1<<SPR1) | //
			(1<<SPR0) ; //clock speed
	
	SPSR =  (0<<SPIF) |	//SPI interrupt flag
    1286:	81 e0       	ldi	r24, 0x01	; 1
    1288:	8d bd       	out	0x2d, r24	; 45
			(0<<WCOL) |	//Write collision flag
			(1<<SPI2X);	//Doubles SPI clock
			
	DDRB = ((1 << SPI_SS) | (1 << SPI_MOSI) | (1 << SPI_SCK)); //make sure SS is high
    128a:	80 eb       	ldi	r24, 0xB0	; 176
    128c:	84 b9       	out	0x04, r24	; 4
	PORTB = (1 << SPI_SS);
    128e:	80 e1       	ldi	r24, 0x10	; 16
    1290:	85 b9       	out	0x05, r24	; 5
	
}
    1292:	08 95       	ret

00001294 <SPI_MasterTransmit>:
//- a poll, then deselects the device. 
//---------------------------------------------------------------
void SPI_MasterTransmit(uint8_t data)
{
	//set SS low
	PORTB &= ~(1 << SPI_SS);
    1294:	2c 98       	cbi	0x05, 4	; 5
	//Load data to be transferred
	SPDR = data;
    1296:	8e bd       	out	0x2e, r24	; 46
	//wait for spi interrupt flag to signal complete transfer
	while (!(SPSR & (1 << SPIF))); 
    1298:	0d b4       	in	r0, 0x2d	; 45
    129a:	07 fe       	sbrs	r0, 7
    129c:	fd cf       	rjmp	.-6      	; 0x1298 <SPI_MasterTransmit+0x4>
	//Set SS high 
	PORTB = (1 << SPI_SS);	
    129e:	80 e1       	ldi	r24, 0x10	; 16
    12a0:	85 b9       	out	0x05, r24	; 5
}
    12a2:	08 95       	ret

000012a4 <SSEG_Set_Brightness>:
//-
//- Description: This function set the brightness of the 
//- display where 255 is off and 0 is on as bright as possible. 
//---------------------------------------------------------------
void SSEG_Set_Brightness(uint8_t val)
{
    12a4:	cf 93       	push	r28
    12a6:	c8 2f       	mov	r28, r24
	SPI_MasterTransmit(SSEG_BRIGHTNESS);	
    12a8:	8a e7       	ldi	r24, 0x7A	; 122
    12aa:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
	SPI_MasterTransmit(val);	
    12ae:	8c 2f       	mov	r24, r28
    12b0:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
}
    12b4:	cf 91       	pop	r28
    12b6:	08 95       	ret

000012b8 <SSEG_Reset>:
//-
//- Description: This function turns off all display elements. 
//---------------------------------------------------------------
void SSEG_Reset(void)
{
	SPI_MasterTransmit(SSEG_RESET);	
    12b8:	86 e7       	ldi	r24, 0x76	; 118
    12ba:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
}
    12be:	08 95       	ret

000012c0 <SSEG_Write_4vals_array>:
//- pointing to an array of four byte values, one for 
//- each of the 7-segment display locations. The four values
//- are then written to the 7-segment display.  
//---------------------------------------------------------------
void SSEG_Write_4vals_array(uint8_t* vals)
{
    12c0:	1f 93       	push	r17
    12c2:	cf 93       	push	r28
    12c4:	df 93       	push	r29
    12c6:	c8 2f       	mov	r28, r24
    12c8:	d9 2f       	mov	r29, r25
    12ca:	14 e0       	ldi	r17, 0x04	; 4
	uint8_t i;
	for(i = 0; i < 4; i ++)
	{
		SPI_MasterTransmit(*(vals + i));			
    12cc:	89 91       	ld	r24, Y+
    12ce:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
    12d2:	11 50       	subi	r17, 0x01	; 1
//- are then written to the 7-segment display.  
//---------------------------------------------------------------
void SSEG_Write_4vals_array(uint8_t* vals)
{
	uint8_t i;
	for(i = 0; i < 4; i ++)
    12d4:	d9 f7       	brne	.-10     	; 0x12cc <SSEG_Write_4vals_array+0xc>
	{
		SPI_MasterTransmit(*(vals + i));			
	}		
}
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	1f 91       	pop	r17
    12dc:	08 95       	ret

000012de <SSEG_Write_digit>:
//- individual digits to the display. In this case, you need 
//- to first send the initial escape character before you 
//- send the actual data. 
//---------------------------------------------------------------
void SSEG_Write_digit(uint8_t digit, uint8_t val)
{
    12de:	cf 93       	push	r28
    12e0:	c6 2f       	mov	r28, r22
	switch(digit)
    12e2:	82 30       	cpi	r24, 0x02	; 2
    12e4:	89 f0       	breq	.+34     	; 0x1308 <SSEG_Write_digit+0x2a>
    12e6:	83 30       	cpi	r24, 0x03	; 3
    12e8:	18 f4       	brcc	.+6      	; 0x12f0 <SSEG_Write_digit+0x12>
    12ea:	81 30       	cpi	r24, 0x01	; 1
    12ec:	09 f5       	brne	.+66     	; 0x1330 <SSEG_Write_digit+0x52>
    12ee:	05 c0       	rjmp	.+10     	; 0x12fa <SSEG_Write_digit+0x1c>
    12f0:	83 30       	cpi	r24, 0x03	; 3
    12f2:	89 f0       	breq	.+34     	; 0x1316 <SSEG_Write_digit+0x38>
    12f4:	84 30       	cpi	r24, 0x04	; 4
    12f6:	e1 f4       	brne	.+56     	; 0x1330 <SSEG_Write_digit+0x52>
    12f8:	15 c0       	rjmp	.+42     	; 0x1324 <SSEG_Write_digit+0x46>
	{
		case 1:
			SPI_MasterTransmit(DIGIT_1);
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    1300:	8c 2f       	mov	r24, r28
    1302:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break; 
    1306:	14 c0       	rjmp	.+40     	; 0x1330 <SSEG_Write_digit+0x52>
		
		case 2:
			SPI_MasterTransmit(DIGIT_2);
    1308:	82 e0       	ldi	r24, 0x02	; 2
    130a:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    130e:	8c 2f       	mov	r24, r28
    1310:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    1314:	0d c0       	rjmp	.+26     	; 0x1330 <SSEG_Write_digit+0x52>
		
		case 3:
			SPI_MasterTransmit(DIGIT_3);
    1316:	83 e0       	ldi	r24, 0x03	; 3
    1318:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    131c:	8c 2f       	mov	r24, r28
    131e:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    1322:	06 c0       	rjmp	.+12     	; 0x1330 <SSEG_Write_digit+0x52>
		
		case 4:
			SPI_MasterTransmit(DIGIT_4);
    1324:	84 e0       	ldi	r24, 0x04	; 4
    1326:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    132a:	8c 2f       	mov	r24, r28
    132c:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
			
		default:	
			break;
	}	
}
    1330:	cf 91       	pop	r28
    1332:	08 95       	ret

00001334 <SSEG_Write_left_digits>:
//- a tens and ones digit the then sends them off to the two 
//- left-most digits of the display. This function also handles
//- lead zero blanking. 
//---------------------------------------------------------------
void SSEG_Write_left_digits(uint8_t val)
{
    1334:	cf 93       	push	r28
    1336:	df 93       	push	r29
	uint8_t dig_ones_place = val;
	//variable to store the 10's place value once it's determined
	uint8_t dig_tens_place = 0; 
	
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
    1338:	84 36       	cpi	r24, 0x64	; 100
    133a:	e0 f4       	brcc	.+56     	; 0x1374 <SSEG_Write_left_digits+0x40>
	{
		//subtract from tens place until it's zero to determine
		//tens and ones place digits
		while((dig_ones_place - 10) >= 0)
    133c:	28 2f       	mov	r18, r24
    133e:	30 e0       	ldi	r19, 0x00	; 0
    1340:	2a 50       	subi	r18, 0x0A	; 10
    1342:	30 40       	sbci	r19, 0x00	; 0
    1344:	4a f0       	brmi	.+18     	; 0x1358 <SSEG_Write_left_digits+0x24>
    1346:	c8 2f       	mov	r28, r24
    1348:	d0 e0       	ldi	r29, 0x00	; 0
		{
			dig_ones_place -= 10;
    134a:	ca 50       	subi	r28, 0x0A	; 10
			dig_tens_place++;
    134c:	df 5f       	subi	r29, 0xFF	; 255
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
	{
		//subtract from tens place until it's zero to determine
		//tens and ones place digits
		while((dig_ones_place - 10) >= 0)
    134e:	8c 2f       	mov	r24, r28
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	0a 97       	sbiw	r24, 0x0a	; 10
    1354:	d2 f7       	brpl	.-12     	; 0x134a <SSEG_Write_left_digits+0x16>
    1356:	02 c0       	rjmp	.+4      	; 0x135c <SSEG_Write_left_digits+0x28>
    1358:	c8 2f       	mov	r28, r24
    135a:	d0 e0       	ldi	r29, 0x00	; 0
		{
			dig_ones_place -= 10;
			dig_tens_place++;
		}
		SPI_MasterTransmit(DIGIT_1);
    135c:	81 e0       	ldi	r24, 0x01	; 1
    135e:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
		SPI_MasterTransmit(dig_tens_place);
    1362:	8d 2f       	mov	r24, r29
    1364:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
		SPI_MasterTransmit(DIGIT_2);
    1368:	82 e0       	ldi	r24, 0x02	; 2
    136a:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
		SPI_MasterTransmit(dig_ones_place);
    136e:	8c 2f       	mov	r24, r28
    1370:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
	}		
}
    1374:	df 91       	pop	r29
    1376:	cf 91       	pop	r28
    1378:	08 95       	ret

0000137a <SSEG_Write_right_digits>:
//- a tens and ones digit the then sends them off to the two 
//- right-most digits of the display. This function also handles
//- lead zero blanking. 
//---------------------------------------------------------------
void SSEG_Write_right_digits(uint8_t val)
{
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
	uint8_t dig_ones_place = val;
	//variable to store the 10's place value once it's determined
	uint8_t dig_tens_place = 0;
		
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
    137e:	84 36       	cpi	r24, 0x64	; 100
    1380:	e0 f4       	brcc	.+56     	; 0x13ba <SSEG_Write_right_digits+0x40>
	{
		//subtract from tens place until it's zero to determine
		//tens and ones place digits
		while((dig_ones_place - 10) >= 0)
    1382:	28 2f       	mov	r18, r24
    1384:	30 e0       	ldi	r19, 0x00	; 0
    1386:	2a 50       	subi	r18, 0x0A	; 10
    1388:	30 40       	sbci	r19, 0x00	; 0
    138a:	4a f0       	brmi	.+18     	; 0x139e <SSEG_Write_right_digits+0x24>
    138c:	c8 2f       	mov	r28, r24
    138e:	d0 e0       	ldi	r29, 0x00	; 0
		{
			dig_ones_place -= 10;
    1390:	ca 50       	subi	r28, 0x0A	; 10
			dig_tens_place++;
    1392:	df 5f       	subi	r29, 0xFF	; 255
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
	{
		//subtract from tens place until it's zero to determine
		//tens and ones place digits
		while((dig_ones_place - 10) >= 0)
    1394:	8c 2f       	mov	r24, r28
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	0a 97       	sbiw	r24, 0x0a	; 10
    139a:	d2 f7       	brpl	.-12     	; 0x1390 <SSEG_Write_right_digits+0x16>
    139c:	02 c0       	rjmp	.+4      	; 0x13a2 <SSEG_Write_right_digits+0x28>
    139e:	c8 2f       	mov	r28, r24
    13a0:	d0 e0       	ldi	r29, 0x00	; 0
		{
			dig_ones_place -= 10;
			dig_tens_place++;
		}
		SPI_MasterTransmit(DIGIT_3);
    13a2:	83 e0       	ldi	r24, 0x03	; 3
    13a4:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
		SPI_MasterTransmit(dig_tens_place);
    13a8:	8d 2f       	mov	r24, r29
    13aa:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
		SPI_MasterTransmit(DIGIT_4);
    13ae:	84 e0       	ldi	r24, 0x04	; 4
    13b0:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
		SPI_MasterTransmit(dig_ones_place);
    13b4:	8c 2f       	mov	r24, r28
    13b6:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
	}	
}
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	08 95       	ret

000013c0 <SSEG_Write_Decimal_Point>:
//- There are six different values that can be written. Check 
//- out the 7-segment device spec for details on decimal points.
//---------------------------------------------------------------
void SSEG_Write_Decimal_Point(uint8_t val)
{
	switch(val)
    13c0:	82 30       	cpi	r24, 0x02	; 2
    13c2:	e1 f0       	breq	.+56     	; 0x13fc <SSEG_Write_Decimal_Point+0x3c>
    13c4:	83 30       	cpi	r24, 0x03	; 3
    13c6:	28 f4       	brcc	.+10     	; 0x13d2 <SSEG_Write_Decimal_Point+0x12>
    13c8:	88 23       	and	r24, r24
    13ca:	51 f0       	breq	.+20     	; 0x13e0 <SSEG_Write_Decimal_Point+0x20>
    13cc:	81 30       	cpi	r24, 0x01	; 1
    13ce:	89 f5       	brne	.+98     	; 0x1432 <SSEG_Write_Decimal_Point+0x72>
    13d0:	0e c0       	rjmp	.+28     	; 0x13ee <SSEG_Write_Decimal_Point+0x2e>
    13d2:	84 30       	cpi	r24, 0x04	; 4
    13d4:	09 f1       	breq	.+66     	; 0x1418 <SSEG_Write_Decimal_Point+0x58>
    13d6:	84 30       	cpi	r24, 0x04	; 4
    13d8:	c0 f0       	brcs	.+48     	; 0x140a <SSEG_Write_Decimal_Point+0x4a>
    13da:	85 30       	cpi	r24, 0x05	; 5
    13dc:	51 f5       	brne	.+84     	; 0x1432 <SSEG_Write_Decimal_Point+0x72>
    13de:	23 c0       	rjmp	.+70     	; 0x1426 <SSEG_Write_Decimal_Point+0x66>
	{
		case 0:
			SPI_MasterTransmit(SSEG_DEC_PNT);
    13e0:	87 e7       	ldi	r24, 0x77	; 119
    13e2:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(SSEG_DP_0);			
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    13ec:	08 95       	ret
			
		case 1:
			SPI_MasterTransmit(SSEG_DEC_PNT);
    13ee:	87 e7       	ldi	r24, 0x77	; 119
    13f0:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(SSEG_DP_1);
    13f4:	82 e0       	ldi	r24, 0x02	; 2
    13f6:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    13fa:	08 95       	ret
			
		case 2:
			SPI_MasterTransmit(SSEG_DEC_PNT);
    13fc:	87 e7       	ldi	r24, 0x77	; 119
    13fe:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(SSEG_DP_2);
    1402:	84 e0       	ldi	r24, 0x04	; 4
    1404:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    1408:	08 95       	ret
			
		case 3:
			SPI_MasterTransmit(SSEG_DEC_PNT);
    140a:	87 e7       	ldi	r24, 0x77	; 119
    140c:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(SSEG_DP_3);
    1410:	88 e0       	ldi	r24, 0x08	; 8
    1412:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    1416:	08 95       	ret
			
		case 4:
			SPI_MasterTransmit(SSEG_DEC_PNT);
    1418:	87 e7       	ldi	r24, 0x77	; 119
    141a:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(SSEG_DP_4);
    141e:	80 e1       	ldi	r24, 0x10	; 16
    1420:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			break;
    1424:	08 95       	ret
			
		case 5:
			SPI_MasterTransmit(SSEG_DEC_PNT);
    1426:	87 e7       	ldi	r24, 0x77	; 119
    1428:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
			SPI_MasterTransmit(SSEG_DP_5);
    142c:	80 e2       	ldi	r24, 0x20	; 32
    142e:	0e 94 4a 09 	call	0x1294	; 0x1294 <SPI_MasterTransmit>
    1432:	08 95       	ret

00001434 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1434:	cf 93       	push	r28
    1436:	df 93       	push	r29
    1438:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    143a:	e0 91 48 1a 	lds	r30, 0x1A48
    143e:	f0 91 49 1a 	lds	r31, 0x1A49
    1442:	93 83       	std	Z+3, r25	; 0x03
    1444:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1446:	80 91 50 1a 	lds	r24, 0x1A50
    144a:	90 91 51 1a 	lds	r25, 0x1A51
    144e:	c8 17       	cp	r28, r24
    1450:	d9 07       	cpc	r29, r25
    1452:	68 f4       	brcc	.+26     	; 0x146e <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1454:	80 91 53 1a 	lds	r24, 0x1A53
    1458:	90 91 54 1a 	lds	r25, 0x1A54
    145c:	60 91 48 1a 	lds	r22, 0x1A48
    1460:	70 91 49 1a 	lds	r23, 0x1A49
    1464:	6e 5f       	subi	r22, 0xFE	; 254
    1466:	7f 4f       	sbci	r23, 0xFF	; 255
    1468:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vListInsert>
    146c:	17 c0       	rjmp	.+46     	; 0x149c <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    146e:	80 91 55 1a 	lds	r24, 0x1A55
    1472:	90 91 56 1a 	lds	r25, 0x1A56
    1476:	60 91 48 1a 	lds	r22, 0x1A48
    147a:	70 91 49 1a 	lds	r23, 0x1A49
    147e:	6e 5f       	subi	r22, 0xFE	; 254
    1480:	7f 4f       	sbci	r23, 0xFF	; 255
    1482:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1486:	80 91 05 02 	lds	r24, 0x0205
    148a:	90 91 06 02 	lds	r25, 0x0206
    148e:	c8 17       	cp	r28, r24
    1490:	d9 07       	cpc	r29, r25
    1492:	20 f4       	brcc	.+8      	; 0x149c <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1494:	d0 93 06 02 	sts	0x0206, r29
    1498:	c0 93 05 02 	sts	0x0205, r28
		}
	}
}
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	08 95       	ret

000014a2 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    14a2:	c9 e5       	ldi	r28, 0x59	; 89
    14a4:	da e1       	ldi	r29, 0x1A	; 26
    14a6:	88 81       	ld	r24, Y
    14a8:	82 30       	cpi	r24, 0x02	; 2
    14aa:	e8 f3       	brcs	.-6      	; 0x14a6 <prvIdleTask+0x4>
			{
				taskYIELD();
    14ac:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
    14b0:	fa cf       	rjmp	.-12     	; 0x14a6 <prvIdleTask+0x4>

000014b2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    14b2:	4f 92       	push	r4
    14b4:	5f 92       	push	r5
    14b6:	6f 92       	push	r6
    14b8:	7f 92       	push	r7
    14ba:	8f 92       	push	r8
    14bc:	9f 92       	push	r9
    14be:	bf 92       	push	r11
    14c0:	cf 92       	push	r12
    14c2:	df 92       	push	r13
    14c4:	ef 92       	push	r14
    14c6:	ff 92       	push	r15
    14c8:	0f 93       	push	r16
    14ca:	1f 93       	push	r17
    14cc:	cf 93       	push	r28
    14ce:	df 93       	push	r29
    14d0:	2c 01       	movw	r4, r24
    14d2:	4b 01       	movw	r8, r22
    14d4:	ea 01       	movw	r28, r20
    14d6:	39 01       	movw	r6, r18
    14d8:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    14da:	8a e2       	ldi	r24, 0x2A	; 42
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	0e 94 cc 02 	call	0x598	; 0x598 <pvPortMalloc>
    14e2:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    14e4:	00 97       	sbiw	r24, 0x00	; 0
    14e6:	09 f4       	brne	.+2      	; 0x14ea <xTaskGenericCreate+0x38>
    14e8:	e3 c0       	rjmp	.+454    	; 0x16b0 <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    14ea:	c1 14       	cp	r12, r1
    14ec:	d1 04       	cpc	r13, r1
    14ee:	09 f0       	breq	.+2      	; 0x14f2 <xTaskGenericCreate+0x40>
    14f0:	f4 c0       	rjmp	.+488    	; 0x16da <xTaskGenericCreate+0x228>
    14f2:	ce 01       	movw	r24, r28
    14f4:	0e 94 cc 02 	call	0x598	; 0x598 <pvPortMalloc>
    14f8:	6c 01       	movw	r12, r24
    14fa:	f8 01       	movw	r30, r16
    14fc:	90 8f       	std	Z+24, r25	; 0x18
    14fe:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1500:	00 97       	sbiw	r24, 0x00	; 0
    1502:	29 f4       	brne	.+10     	; 0x150e <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1504:	c8 01       	movw	r24, r16
    1506:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    150a:	8f ef       	ldi	r24, 0xFF	; 255
    150c:	d6 c0       	rjmp	.+428    	; 0x16ba <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    150e:	c6 01       	movw	r24, r12
    1510:	65 ea       	ldi	r22, 0xA5	; 165
    1512:	70 e0       	ldi	r23, 0x00	; 0
    1514:	ae 01       	movw	r20, r28
    1516:	0e 94 49 10 	call	0x2092	; 0x2092 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    151a:	9e 01       	movw	r18, r28
    151c:	21 50       	subi	r18, 0x01	; 1
    151e:	30 40       	sbci	r19, 0x00	; 0
    1520:	f8 01       	movw	r30, r16
    1522:	87 89       	ldd	r24, Z+23	; 0x17
    1524:	90 8d       	ldd	r25, Z+24	; 0x18
    1526:	6c 01       	movw	r12, r24
    1528:	c2 0e       	add	r12, r18
    152a:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    152c:	c8 01       	movw	r24, r16
    152e:	49 96       	adiw	r24, 0x19	; 25
    1530:	b4 01       	movw	r22, r8
    1532:	40 e1       	ldi	r20, 0x10	; 16
    1534:	50 e0       	ldi	r21, 0x00	; 0
    1536:	0e 94 50 10 	call	0x20a0	; 0x20a0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    153a:	f8 01       	movw	r30, r16
    153c:	10 a6       	lds	r17, 0xb0
    153e:	cb 2d       	mov	r28, r11
    1540:	f3 e0       	ldi	r31, 0x03	; 3
    1542:	fb 15       	cp	r31, r11
    1544:	08 f4       	brcc	.+2      	; 0x1548 <xTaskGenericCreate+0x96>
    1546:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1548:	f8 01       	movw	r30, r16
    154a:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    154c:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    154e:	88 24       	eor	r8, r8
    1550:	99 24       	eor	r9, r9
    1552:	68 94       	set
    1554:	81 f8       	bld	r8, 1
    1556:	80 0e       	add	r8, r16
    1558:	91 1e       	adc	r9, r17
    155a:	c4 01       	movw	r24, r8
    155c:	0e 94 ac 03 	call	0x758	; 0x758 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1560:	c8 01       	movw	r24, r16
    1562:	0c 96       	adiw	r24, 0x0c	; 12
    1564:	0e 94 ac 03 	call	0x758	; 0x758 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1568:	f8 01       	movw	r30, r16
    156a:	11 87       	std	Z+9, r17	; 0x09
    156c:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    156e:	84 e0       	ldi	r24, 0x04	; 4
    1570:	90 e0       	ldi	r25, 0x00	; 0
    1572:	8c 1b       	sub	r24, r28
    1574:	91 09       	sbc	r25, r1
    1576:	95 87       	std	Z+13, r25	; 0x0d
    1578:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    157a:	13 8b       	std	Z+19, r17	; 0x13
    157c:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    157e:	c6 01       	movw	r24, r12
    1580:	b2 01       	movw	r22, r4
    1582:	a3 01       	movw	r20, r6
    1584:	0e 94 3d 04 	call	0x87a	; 0x87a <pxPortInitialiseStack>
    1588:	f8 01       	movw	r30, r16
    158a:	91 83       	std	Z+1, r25	; 0x01
    158c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    158e:	e1 14       	cp	r14, r1
    1590:	f1 04       	cpc	r15, r1
    1592:	19 f0       	breq	.+6      	; 0x159a <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1594:	f7 01       	movw	r30, r14
    1596:	11 83       	std	Z+1, r17	; 0x01
    1598:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	f8 94       	cli
    159e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    15a0:	80 91 52 1a 	lds	r24, 0x1A52
    15a4:	8f 5f       	subi	r24, 0xFF	; 255
    15a6:	80 93 52 1a 	sts	0x1A52, r24
			if( pxCurrentTCB == NULL )
    15aa:	80 91 48 1a 	lds	r24, 0x1A48
    15ae:	90 91 49 1a 	lds	r25, 0x1A49
    15b2:	00 97       	sbiw	r24, 0x00	; 0
    15b4:	d9 f5       	brne	.+118    	; 0x162c <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    15b6:	10 93 49 1a 	sts	0x1A49, r17
    15ba:	00 93 48 1a 	sts	0x1A48, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    15be:	80 91 52 1a 	lds	r24, 0x1A52
    15c2:	81 30       	cpi	r24, 0x01	; 1
    15c4:	09 f0       	breq	.+2      	; 0x15c8 <xTaskGenericCreate+0x116>
    15c6:	41 c0       	rjmp	.+130    	; 0x164a <xTaskGenericCreate+0x198>
    15c8:	c0 e0       	ldi	r28, 0x00	; 0
    15ca:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    15cc:	ce 01       	movw	r24, r28
    15ce:	88 0f       	add	r24, r24
    15d0:	99 1f       	adc	r25, r25
    15d2:	88 0f       	add	r24, r24
    15d4:	99 1f       	adc	r25, r25
    15d6:	88 0f       	add	r24, r24
    15d8:	99 1f       	adc	r25, r25
    15da:	8c 0f       	add	r24, r28
    15dc:	9d 1f       	adc	r25, r29
    15de:	87 5a       	subi	r24, 0xA7	; 167
    15e0:	95 4e       	sbci	r25, 0xE5	; 229
    15e2:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
    15e6:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    15e8:	c4 30       	cpi	r28, 0x04	; 4
    15ea:	d1 05       	cpc	r29, r1
    15ec:	79 f7       	brne	.-34     	; 0x15cc <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    15ee:	cd e7       	ldi	r28, 0x7D	; 125
    15f0:	da e1       	ldi	r29, 0x1A	; 26
    15f2:	ce 01       	movw	r24, r28
    15f4:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    15f8:	0f 2e       	mov	r0, r31
    15fa:	f6 e8       	ldi	r31, 0x86	; 134
    15fc:	ef 2e       	mov	r14, r31
    15fe:	fa e1       	ldi	r31, 0x1A	; 26
    1600:	ff 2e       	mov	r15, r31
    1602:	f0 2d       	mov	r31, r0
    1604:	c7 01       	movw	r24, r14
    1606:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    160a:	8f e8       	ldi	r24, 0x8F	; 143
    160c:	9a e1       	ldi	r25, 0x1A	; 26
    160e:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1612:	88 e9       	ldi	r24, 0x98	; 152
    1614:	9a e1       	ldi	r25, 0x1A	; 26
    1616:	0e 94 9e 03 	call	0x73c	; 0x73c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    161a:	d0 93 56 1a 	sts	0x1A56, r29
    161e:	c0 93 55 1a 	sts	0x1A55, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1622:	f0 92 54 1a 	sts	0x1A54, r15
    1626:	e0 92 53 1a 	sts	0x1A53, r14
    162a:	0f c0       	rjmp	.+30     	; 0x164a <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    162c:	80 91 4e 1a 	lds	r24, 0x1A4E
    1630:	88 23       	and	r24, r24
    1632:	59 f4       	brne	.+22     	; 0x164a <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1634:	e0 91 48 1a 	lds	r30, 0x1A48
    1638:	f0 91 49 1a 	lds	r31, 0x1A49
    163c:	86 89       	ldd	r24, Z+22	; 0x16
    163e:	b8 16       	cp	r11, r24
    1640:	20 f0       	brcs	.+8      	; 0x164a <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    1642:	10 93 49 1a 	sts	0x1A49, r17
    1646:	00 93 48 1a 	sts	0x1A48, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    164a:	f8 01       	movw	r30, r16
    164c:	86 89       	ldd	r24, Z+22	; 0x16
    164e:	90 91 57 1a 	lds	r25, 0x1A57
    1652:	98 17       	cp	r25, r24
    1654:	10 f4       	brcc	.+4      	; 0x165a <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1656:	80 93 57 1a 	sts	0x1A57, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    165a:	90 91 58 1a 	lds	r25, 0x1A58
    165e:	9f 5f       	subi	r25, 0xFF	; 255
    1660:	90 93 58 1a 	sts	0x1A58, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1664:	90 91 4f 1a 	lds	r25, 0x1A4F
    1668:	98 17       	cp	r25, r24
    166a:	10 f4       	brcc	.+4      	; 0x1670 <xTaskGenericCreate+0x1be>
    166c:	80 93 4f 1a 	sts	0x1A4F, r24
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	9c 01       	movw	r18, r24
    1674:	22 0f       	add	r18, r18
    1676:	33 1f       	adc	r19, r19
    1678:	22 0f       	add	r18, r18
    167a:	33 1f       	adc	r19, r19
    167c:	22 0f       	add	r18, r18
    167e:	33 1f       	adc	r19, r19
    1680:	82 0f       	add	r24, r18
    1682:	93 1f       	adc	r25, r19
    1684:	87 5a       	subi	r24, 0xA7	; 167
    1686:	95 4e       	sbci	r25, 0xE5	; 229
    1688:	b4 01       	movw	r22, r8
    168a:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    168e:	0f 90       	pop	r0
    1690:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1692:	80 91 4e 1a 	lds	r24, 0x1A4E
    1696:	88 23       	and	r24, r24
    1698:	69 f0       	breq	.+26     	; 0x16b4 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    169a:	e0 91 48 1a 	lds	r30, 0x1A48
    169e:	f0 91 49 1a 	lds	r31, 0x1A49
    16a2:	86 89       	ldd	r24, Z+22	; 0x16
    16a4:	8b 15       	cp	r24, r11
    16a6:	40 f4       	brcc	.+16     	; 0x16b8 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    16a8:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	05 c0       	rjmp	.+10     	; 0x16ba <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    16b0:	8f ef       	ldi	r24, 0xFF	; 255
    16b2:	03 c0       	rjmp	.+6      	; 0x16ba <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	01 c0       	rjmp	.+2      	; 0x16ba <xTaskGenericCreate+0x208>
    16b8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    16ba:	df 91       	pop	r29
    16bc:	cf 91       	pop	r28
    16be:	1f 91       	pop	r17
    16c0:	0f 91       	pop	r16
    16c2:	ff 90       	pop	r15
    16c4:	ef 90       	pop	r14
    16c6:	df 90       	pop	r13
    16c8:	cf 90       	pop	r12
    16ca:	bf 90       	pop	r11
    16cc:	9f 90       	pop	r9
    16ce:	8f 90       	pop	r8
    16d0:	7f 90       	pop	r7
    16d2:	6f 90       	pop	r6
    16d4:	5f 90       	pop	r5
    16d6:	4f 90       	pop	r4
    16d8:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    16da:	fc 01       	movw	r30, r24
    16dc:	d0 8e       	std	Z+24, r13	; 0x18
    16de:	c7 8a       	std	Z+23, r12	; 0x17
    16e0:	16 cf       	rjmp	.-468    	; 0x150e <xTaskGenericCreate+0x5c>

000016e2 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    16e2:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    16e4:	82 85       	ldd	r24, Z+10	; 0x0a
    16e6:	93 85       	ldd	r25, Z+11	; 0x0b
    16e8:	2a e1       	ldi	r18, 0x1A	; 26
    16ea:	88 39       	cpi	r24, 0x98	; 152
    16ec:	92 07       	cpc	r25, r18
    16ee:	61 f4       	brne	.+24     	; 0x1708 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    16f0:	24 89       	ldd	r18, Z+20	; 0x14
    16f2:	35 89       	ldd	r19, Z+21	; 0x15
    16f4:	8a e1       	ldi	r24, 0x1A	; 26
    16f6:	2f 38       	cpi	r18, 0x8F	; 143
    16f8:	38 07       	cpc	r19, r24
    16fa:	41 f0       	breq	.+16     	; 0x170c <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	21 15       	cp	r18, r1
    1700:	31 05       	cpc	r19, r1
    1702:	29 f0       	breq	.+10     	; 0x170e <xTaskIsTaskSuspended+0x2c>
    1704:	80 e0       	ldi	r24, 0x00	; 0
    1706:	08 95       	ret
    1708:	80 e0       	ldi	r24, 0x00	; 0
    170a:	08 95       	ret
    170c:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    170e:	08 95       	ret

00001710 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    1710:	0f 93       	push	r16
    1712:	1f 93       	push	r17
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    171a:	00 97       	sbiw	r24, 0x00	; 0
    171c:	b9 f1       	breq	.+110    	; 0x178c <vTaskResume+0x7c>
    171e:	80 91 48 1a 	lds	r24, 0x1A48
    1722:	90 91 49 1a 	lds	r25, 0x1A49
    1726:	c8 17       	cp	r28, r24
    1728:	d9 07       	cpc	r29, r25
    172a:	81 f1       	breq	.+96     	; 0x178c <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    172c:	0f b6       	in	r0, 0x3f	; 63
    172e:	f8 94       	cli
    1730:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1732:	ce 01       	movw	r24, r28
    1734:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <xTaskIsTaskSuspended>
    1738:	81 30       	cpi	r24, 0x01	; 1
    173a:	31 f5       	brne	.+76     	; 0x1788 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    173c:	8e 01       	movw	r16, r28
    173e:	0e 5f       	subi	r16, 0xFE	; 254
    1740:	1f 4f       	sbci	r17, 0xFF	; 255
    1742:	c8 01       	movw	r24, r16
    1744:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1748:	8e 89       	ldd	r24, Y+22	; 0x16
    174a:	90 91 4f 1a 	lds	r25, 0x1A4F
    174e:	98 17       	cp	r25, r24
    1750:	10 f4       	brcc	.+4      	; 0x1756 <vTaskResume+0x46>
    1752:	80 93 4f 1a 	sts	0x1A4F, r24
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	9c 01       	movw	r18, r24
    175a:	22 0f       	add	r18, r18
    175c:	33 1f       	adc	r19, r19
    175e:	22 0f       	add	r18, r18
    1760:	33 1f       	adc	r19, r19
    1762:	22 0f       	add	r18, r18
    1764:	33 1f       	adc	r19, r19
    1766:	82 0f       	add	r24, r18
    1768:	93 1f       	adc	r25, r19
    176a:	87 5a       	subi	r24, 0xA7	; 167
    176c:	95 4e       	sbci	r25, 0xE5	; 229
    176e:	b8 01       	movw	r22, r16
    1770:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1774:	e0 91 48 1a 	lds	r30, 0x1A48
    1778:	f0 91 49 1a 	lds	r31, 0x1A49
    177c:	9e 89       	ldd	r25, Y+22	; 0x16
    177e:	86 89       	ldd	r24, Z+22	; 0x16
    1780:	98 17       	cp	r25, r24
    1782:	10 f0       	brcs	.+4      	; 0x1788 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    1784:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    1788:	0f 90       	pop	r0
    178a:	0f be       	out	0x3f, r0	; 63
		}
	}
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	1f 91       	pop	r17
    1792:	0f 91       	pop	r16
    1794:	08 95       	ret

00001796 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    1796:	ef 92       	push	r14
    1798:	ff 92       	push	r15
    179a:	1f 93       	push	r17
    179c:	cf 93       	push	r28
    179e:	df 93       	push	r29
    17a0:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    17a2:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <xTaskIsTaskSuspended>
    17a6:	81 30       	cpi	r24, 0x01	; 1
    17a8:	b9 f5       	brne	.+110    	; 0x1818 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    17aa:	80 91 4d 1a 	lds	r24, 0x1A4D
    17ae:	88 23       	and	r24, r24
    17b0:	51 f5       	brne	.+84     	; 0x1806 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    17b2:	e0 91 48 1a 	lds	r30, 0x1A48
    17b6:	f0 91 49 1a 	lds	r31, 0x1A49
    17ba:	11 e0       	ldi	r17, 0x01	; 1
    17bc:	9e 89       	ldd	r25, Y+22	; 0x16
    17be:	86 89       	ldd	r24, Z+22	; 0x16
    17c0:	98 17       	cp	r25, r24
    17c2:	08 f4       	brcc	.+2      	; 0x17c6 <xTaskResumeFromISR+0x30>
    17c4:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    17c6:	ee 24       	eor	r14, r14
    17c8:	ff 24       	eor	r15, r15
    17ca:	68 94       	set
    17cc:	e1 f8       	bld	r14, 1
    17ce:	ec 0e       	add	r14, r28
    17d0:	fd 1e       	adc	r15, r29
    17d2:	c7 01       	movw	r24, r14
    17d4:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    17d8:	8e 89       	ldd	r24, Y+22	; 0x16
    17da:	90 91 4f 1a 	lds	r25, 0x1A4F
    17de:	98 17       	cp	r25, r24
    17e0:	10 f4       	brcc	.+4      	; 0x17e6 <xTaskResumeFromISR+0x50>
    17e2:	80 93 4f 1a 	sts	0x1A4F, r24
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	9c 01       	movw	r18, r24
    17ea:	22 0f       	add	r18, r18
    17ec:	33 1f       	adc	r19, r19
    17ee:	22 0f       	add	r18, r18
    17f0:	33 1f       	adc	r19, r19
    17f2:	22 0f       	add	r18, r18
    17f4:	33 1f       	adc	r19, r19
    17f6:	82 0f       	add	r24, r18
    17f8:	93 1f       	adc	r25, r19
    17fa:	87 5a       	subi	r24, 0xA7	; 167
    17fc:	95 4e       	sbci	r25, 0xE5	; 229
    17fe:	b7 01       	movw	r22, r14
    1800:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
    1804:	0a c0       	rjmp	.+20     	; 0x181a <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1806:	be 01       	movw	r22, r28
    1808:	64 5f       	subi	r22, 0xF4	; 244
    180a:	7f 4f       	sbci	r23, 0xFF	; 255
    180c:	8f e8       	ldi	r24, 0x8F	; 143
    180e:	9a e1       	ldi	r25, 0x1A	; 26
    1810:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    1814:	10 e0       	ldi	r17, 0x00	; 0
    1816:	01 c0       	rjmp	.+2      	; 0x181a <xTaskResumeFromISR+0x84>
    1818:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    181a:	81 2f       	mov	r24, r17
    181c:	df 91       	pop	r29
    181e:	cf 91       	pop	r28
    1820:	1f 91       	pop	r17
    1822:	ff 90       	pop	r15
    1824:	ef 90       	pop	r14
    1826:	08 95       	ret

00001828 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1828:	af 92       	push	r10
    182a:	bf 92       	push	r11
    182c:	cf 92       	push	r12
    182e:	df 92       	push	r13
    1830:	ef 92       	push	r14
    1832:	ff 92       	push	r15
    1834:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1836:	81 e5       	ldi	r24, 0x51	; 81
    1838:	9a e0       	ldi	r25, 0x0A	; 10
    183a:	60 e0       	ldi	r22, 0x00	; 0
    183c:	72 e0       	ldi	r23, 0x02	; 2
    183e:	45 e5       	ldi	r20, 0x55	; 85
    1840:	50 e0       	ldi	r21, 0x00	; 0
    1842:	20 e0       	ldi	r18, 0x00	; 0
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	00 e0       	ldi	r16, 0x00	; 0
    1848:	ee 24       	eor	r14, r14
    184a:	ff 24       	eor	r15, r15
    184c:	cc 24       	eor	r12, r12
    184e:	dd 24       	eor	r13, r13
    1850:	aa 24       	eor	r10, r10
    1852:	bb 24       	eor	r11, r11
    1854:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1858:	81 30       	cpi	r24, 0x01	; 1
    185a:	49 f4       	brne	.+18     	; 0x186e <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    185c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    185e:	80 93 4e 1a 	sts	0x1A4E, r24
		xTickCount = ( portTickType ) 0U;
    1862:	10 92 51 1a 	sts	0x1A51, r1
    1866:	10 92 50 1a 	sts	0x1A50, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    186a:	0e 94 d6 04 	call	0x9ac	; 0x9ac <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    186e:	0f 91       	pop	r16
    1870:	ff 90       	pop	r15
    1872:	ef 90       	pop	r14
    1874:	df 90       	pop	r13
    1876:	cf 90       	pop	r12
    1878:	bf 90       	pop	r11
    187a:	af 90       	pop	r10
    187c:	08 95       	ret

0000187e <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    187e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1880:	10 92 4e 1a 	sts	0x1A4E, r1
	vPortEndScheduler();
    1884:	0e 94 14 05 	call	0xa28	; 0xa28 <vPortEndScheduler>
}
    1888:	08 95       	ret

0000188a <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    188a:	80 91 4d 1a 	lds	r24, 0x1A4D
    188e:	8f 5f       	subi	r24, 0xFF	; 255
    1890:	80 93 4d 1a 	sts	0x1A4D, r24
}
    1894:	08 95       	ret

00001896 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    189c:	80 91 50 1a 	lds	r24, 0x1A50
    18a0:	90 91 51 1a 	lds	r25, 0x1A51
	}
	taskEXIT_CRITICAL();
    18a4:	0f 90       	pop	r0
    18a6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    18a8:	08 95       	ret

000018aa <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    18aa:	80 91 50 1a 	lds	r24, 0x1A50
    18ae:	90 91 51 1a 	lds	r25, 0x1A51
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18b2:	08 95       	ret

000018b4 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    18b4:	80 91 52 1a 	lds	r24, 0x1A52
}
    18b8:	08 95       	ret

000018ba <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    18ba:	0f 93       	push	r16
    18bc:	1f 93       	push	r17
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    18c2:	80 91 4d 1a 	lds	r24, 0x1A4D
    18c6:	88 23       	and	r24, r24
    18c8:	09 f0       	breq	.+2      	; 0x18cc <vTaskIncrementTick+0x12>
    18ca:	b3 c0       	rjmp	.+358    	; 0x1a32 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    18cc:	80 91 50 1a 	lds	r24, 0x1A50
    18d0:	90 91 51 1a 	lds	r25, 0x1A51
    18d4:	01 96       	adiw	r24, 0x01	; 1
    18d6:	90 93 51 1a 	sts	0x1A51, r25
    18da:	80 93 50 1a 	sts	0x1A50, r24
		if( xTickCount == ( portTickType ) 0U )
    18de:	80 91 50 1a 	lds	r24, 0x1A50
    18e2:	90 91 51 1a 	lds	r25, 0x1A51
    18e6:	00 97       	sbiw	r24, 0x00	; 0
    18e8:	99 f5       	brne	.+102    	; 0x1950 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    18ea:	80 91 55 1a 	lds	r24, 0x1A55
    18ee:	90 91 56 1a 	lds	r25, 0x1A56
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    18f2:	20 91 53 1a 	lds	r18, 0x1A53
    18f6:	30 91 54 1a 	lds	r19, 0x1A54
    18fa:	30 93 56 1a 	sts	0x1A56, r19
    18fe:	20 93 55 1a 	sts	0x1A55, r18
			pxOverflowDelayedTaskList = pxTemp;
    1902:	90 93 54 1a 	sts	0x1A54, r25
    1906:	80 93 53 1a 	sts	0x1A53, r24
			xNumOfOverflows++;
    190a:	80 91 4a 1a 	lds	r24, 0x1A4A
    190e:	8f 5f       	subi	r24, 0xFF	; 255
    1910:	80 93 4a 1a 	sts	0x1A4A, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1914:	e0 91 55 1a 	lds	r30, 0x1A55
    1918:	f0 91 56 1a 	lds	r31, 0x1A56
    191c:	80 81       	ld	r24, Z
    191e:	88 23       	and	r24, r24
    1920:	39 f4       	brne	.+14     	; 0x1930 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1922:	8f ef       	ldi	r24, 0xFF	; 255
    1924:	9f ef       	ldi	r25, 0xFF	; 255
    1926:	90 93 06 02 	sts	0x0206, r25
    192a:	80 93 05 02 	sts	0x0205, r24
    192e:	10 c0       	rjmp	.+32     	; 0x1950 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1930:	e0 91 55 1a 	lds	r30, 0x1A55
    1934:	f0 91 56 1a 	lds	r31, 0x1A56
    1938:	05 80       	ldd	r0, Z+5	; 0x05
    193a:	f6 81       	ldd	r31, Z+6	; 0x06
    193c:	e0 2d       	mov	r30, r0
    193e:	06 80       	ldd	r0, Z+6	; 0x06
    1940:	f7 81       	ldd	r31, Z+7	; 0x07
    1942:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1944:	82 81       	ldd	r24, Z+2	; 0x02
    1946:	93 81       	ldd	r25, Z+3	; 0x03
    1948:	90 93 06 02 	sts	0x0206, r25
    194c:	80 93 05 02 	sts	0x0205, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1950:	20 91 50 1a 	lds	r18, 0x1A50
    1954:	30 91 51 1a 	lds	r19, 0x1A51
    1958:	80 91 05 02 	lds	r24, 0x0205
    195c:	90 91 06 02 	lds	r25, 0x0206
    1960:	28 17       	cp	r18, r24
    1962:	39 07       	cpc	r19, r25
    1964:	08 f4       	brcc	.+2      	; 0x1968 <vTaskIncrementTick+0xae>
    1966:	6c c0       	rjmp	.+216    	; 0x1a40 <vTaskIncrementTick+0x186>
    1968:	e0 91 55 1a 	lds	r30, 0x1A55
    196c:	f0 91 56 1a 	lds	r31, 0x1A56
    1970:	80 81       	ld	r24, Z
    1972:	88 23       	and	r24, r24
    1974:	99 f0       	breq	.+38     	; 0x199c <vTaskIncrementTick+0xe2>
    1976:	e0 91 55 1a 	lds	r30, 0x1A55
    197a:	f0 91 56 1a 	lds	r31, 0x1A56
    197e:	05 80       	ldd	r0, Z+5	; 0x05
    1980:	f6 81       	ldd	r31, Z+6	; 0x06
    1982:	e0 2d       	mov	r30, r0
    1984:	c6 81       	ldd	r28, Z+6	; 0x06
    1986:	d7 81       	ldd	r29, Z+7	; 0x07
    1988:	8a 81       	ldd	r24, Y+2	; 0x02
    198a:	9b 81       	ldd	r25, Y+3	; 0x03
    198c:	20 91 50 1a 	lds	r18, 0x1A50
    1990:	30 91 51 1a 	lds	r19, 0x1A51
    1994:	28 17       	cp	r18, r24
    1996:	39 07       	cpc	r19, r25
    1998:	f8 f4       	brcc	.+62     	; 0x19d8 <vTaskIncrementTick+0x11e>
    199a:	19 c0       	rjmp	.+50     	; 0x19ce <vTaskIncrementTick+0x114>
    199c:	8f ef       	ldi	r24, 0xFF	; 255
    199e:	9f ef       	ldi	r25, 0xFF	; 255
    19a0:	90 93 06 02 	sts	0x0206, r25
    19a4:	80 93 05 02 	sts	0x0205, r24
    19a8:	4b c0       	rjmp	.+150    	; 0x1a40 <vTaskIncrementTick+0x186>
    19aa:	e0 91 55 1a 	lds	r30, 0x1A55
    19ae:	f0 91 56 1a 	lds	r31, 0x1A56
    19b2:	05 80       	ldd	r0, Z+5	; 0x05
    19b4:	f6 81       	ldd	r31, Z+6	; 0x06
    19b6:	e0 2d       	mov	r30, r0
    19b8:	c6 81       	ldd	r28, Z+6	; 0x06
    19ba:	d7 81       	ldd	r29, Z+7	; 0x07
    19bc:	8a 81       	ldd	r24, Y+2	; 0x02
    19be:	9b 81       	ldd	r25, Y+3	; 0x03
    19c0:	20 91 50 1a 	lds	r18, 0x1A50
    19c4:	30 91 51 1a 	lds	r19, 0x1A51
    19c8:	28 17       	cp	r18, r24
    19ca:	39 07       	cpc	r19, r25
    19cc:	28 f4       	brcc	.+10     	; 0x19d8 <vTaskIncrementTick+0x11e>
    19ce:	90 93 06 02 	sts	0x0206, r25
    19d2:	80 93 05 02 	sts	0x0205, r24
    19d6:	34 c0       	rjmp	.+104    	; 0x1a40 <vTaskIncrementTick+0x186>
    19d8:	8e 01       	movw	r16, r28
    19da:	0e 5f       	subi	r16, 0xFE	; 254
    19dc:	1f 4f       	sbci	r17, 0xFF	; 255
    19de:	c8 01       	movw	r24, r16
    19e0:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
    19e4:	8c 89       	ldd	r24, Y+20	; 0x14
    19e6:	9d 89       	ldd	r25, Y+21	; 0x15
    19e8:	00 97       	sbiw	r24, 0x00	; 0
    19ea:	21 f0       	breq	.+8      	; 0x19f4 <vTaskIncrementTick+0x13a>
    19ec:	ce 01       	movw	r24, r28
    19ee:	0c 96       	adiw	r24, 0x0c	; 12
    19f0:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
    19f4:	8e 89       	ldd	r24, Y+22	; 0x16
    19f6:	90 91 4f 1a 	lds	r25, 0x1A4F
    19fa:	98 17       	cp	r25, r24
    19fc:	10 f4       	brcc	.+4      	; 0x1a02 <vTaskIncrementTick+0x148>
    19fe:	80 93 4f 1a 	sts	0x1A4F, r24
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	9c 01       	movw	r18, r24
    1a06:	22 0f       	add	r18, r18
    1a08:	33 1f       	adc	r19, r19
    1a0a:	22 0f       	add	r18, r18
    1a0c:	33 1f       	adc	r19, r19
    1a0e:	22 0f       	add	r18, r18
    1a10:	33 1f       	adc	r19, r19
    1a12:	82 0f       	add	r24, r18
    1a14:	93 1f       	adc	r25, r19
    1a16:	87 5a       	subi	r24, 0xA7	; 167
    1a18:	95 4e       	sbci	r25, 0xE5	; 229
    1a1a:	b8 01       	movw	r22, r16
    1a1c:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
    1a20:	e0 91 55 1a 	lds	r30, 0x1A55
    1a24:	f0 91 56 1a 	lds	r31, 0x1A56
    1a28:	80 81       	ld	r24, Z
    1a2a:	88 23       	and	r24, r24
    1a2c:	09 f0       	breq	.+2      	; 0x1a30 <vTaskIncrementTick+0x176>
    1a2e:	bd cf       	rjmp	.-134    	; 0x19aa <vTaskIncrementTick+0xf0>
    1a30:	b5 cf       	rjmp	.-150    	; 0x199c <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    1a32:	80 91 4c 1a 	lds	r24, 0x1A4C
    1a36:	8f 5f       	subi	r24, 0xFF	; 255
    1a38:	80 93 4c 1a 	sts	0x1A4C, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
    1a3c:	0e 94 9d 03 	call	0x73a	; 0x73a <vApplicationTickHook>

	#if ( configUSE_TICK_HOOK == 1 )
	{
		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
    1a40:	80 91 4c 1a 	lds	r24, 0x1A4C
    1a44:	88 23       	and	r24, r24
    1a46:	11 f4       	brne	.+4      	; 0x1a4c <vTaskIncrementTick+0x192>
		{
			vApplicationTickHook();
    1a48:	0e 94 9d 03 	call	0x73a	; 0x73a <vApplicationTickHook>
		}
	}
	#endif
}
    1a4c:	df 91       	pop	r29
    1a4e:	cf 91       	pop	r28
    1a50:	1f 91       	pop	r17
    1a52:	0f 91       	pop	r16
    1a54:	08 95       	ret

00001a56 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1a56:	af 92       	push	r10
    1a58:	bf 92       	push	r11
    1a5a:	cf 92       	push	r12
    1a5c:	df 92       	push	r13
    1a5e:	ef 92       	push	r14
    1a60:	ff 92       	push	r15
    1a62:	0f 93       	push	r16
    1a64:	1f 93       	push	r17
    1a66:	cf 93       	push	r28
    1a68:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1a70:	80 91 4d 1a 	lds	r24, 0x1A4D
    1a74:	81 50       	subi	r24, 0x01	; 1
    1a76:	80 93 4d 1a 	sts	0x1A4D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a7a:	80 91 4d 1a 	lds	r24, 0x1A4D
    1a7e:	88 23       	and	r24, r24
    1a80:	09 f0       	breq	.+2      	; 0x1a84 <xTaskResumeAll+0x2e>
    1a82:	69 c0       	rjmp	.+210    	; 0x1b56 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1a84:	80 91 52 1a 	lds	r24, 0x1A52
    1a88:	88 23       	and	r24, r24
    1a8a:	81 f5       	brne	.+96     	; 0x1aec <xTaskResumeAll+0x96>
    1a8c:	67 c0       	rjmp	.+206    	; 0x1b5c <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1a8e:	d6 01       	movw	r26, r12
    1a90:	ed 91       	ld	r30, X+
    1a92:	fc 91       	ld	r31, X
    1a94:	c6 81       	ldd	r28, Z+6	; 0x06
    1a96:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    1a98:	ce 01       	movw	r24, r28
    1a9a:	0c 96       	adiw	r24, 0x0c	; 12
    1a9c:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    1aa0:	8e 01       	movw	r16, r28
    1aa2:	0e 5f       	subi	r16, 0xFE	; 254
    1aa4:	1f 4f       	sbci	r17, 0xFF	; 255
    1aa6:	c8 01       	movw	r24, r16
    1aa8:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1aac:	8e 89       	ldd	r24, Y+22	; 0x16
    1aae:	90 91 4f 1a 	lds	r25, 0x1A4F
    1ab2:	98 17       	cp	r25, r24
    1ab4:	10 f4       	brcc	.+4      	; 0x1aba <xTaskResumeAll+0x64>
    1ab6:	80 93 4f 1a 	sts	0x1A4F, r24
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	9c 01       	movw	r18, r24
    1abe:	22 0f       	add	r18, r18
    1ac0:	33 1f       	adc	r19, r19
    1ac2:	22 0f       	add	r18, r18
    1ac4:	33 1f       	adc	r19, r19
    1ac6:	22 0f       	add	r18, r18
    1ac8:	33 1f       	adc	r19, r19
    1aca:	82 0f       	add	r24, r18
    1acc:	93 1f       	adc	r25, r19
    1ace:	87 5a       	subi	r24, 0xA7	; 167
    1ad0:	95 4e       	sbci	r25, 0xE5	; 229
    1ad2:	b8 01       	movw	r22, r16
    1ad4:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1ad8:	e0 91 48 1a 	lds	r30, 0x1A48
    1adc:	f0 91 49 1a 	lds	r31, 0x1A49
    1ae0:	9e 89       	ldd	r25, Y+22	; 0x16
    1ae2:	86 89       	ldd	r24, Z+22	; 0x16
    1ae4:	98 17       	cp	r25, r24
    1ae6:	88 f0       	brcs	.+34     	; 0x1b0a <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1ae8:	ba 2c       	mov	r11, r10
    1aea:	0f c0       	rjmp	.+30     	; 0x1b0a <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1aec:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1aee:	0f 2e       	mov	r0, r31
    1af0:	ff e8       	ldi	r31, 0x8F	; 143
    1af2:	ef 2e       	mov	r14, r31
    1af4:	fa e1       	ldi	r31, 0x1A	; 26
    1af6:	ff 2e       	mov	r15, r31
    1af8:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1afa:	0f 2e       	mov	r0, r31
    1afc:	f4 e9       	ldi	r31, 0x94	; 148
    1afe:	cf 2e       	mov	r12, r31
    1b00:	fa e1       	ldi	r31, 0x1A	; 26
    1b02:	df 2e       	mov	r13, r31
    1b04:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1b06:	aa 24       	eor	r10, r10
    1b08:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1b0a:	f7 01       	movw	r30, r14
    1b0c:	80 81       	ld	r24, Z
    1b0e:	88 23       	and	r24, r24
    1b10:	09 f0       	breq	.+2      	; 0x1b14 <xTaskResumeAll+0xbe>
    1b12:	bd cf       	rjmp	.-134    	; 0x1a8e <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1b14:	80 91 4c 1a 	lds	r24, 0x1A4C
    1b18:	88 23       	and	r24, r24
    1b1a:	81 f0       	breq	.+32     	; 0x1b3c <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1b1c:	80 91 4c 1a 	lds	r24, 0x1A4C
    1b20:	88 23       	and	r24, r24
    1b22:	99 f0       	breq	.+38     	; 0x1b4a <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1b24:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <vTaskIncrementTick>
						--uxMissedTicks;
    1b28:	80 91 4c 1a 	lds	r24, 0x1A4C
    1b2c:	81 50       	subi	r24, 0x01	; 1
    1b2e:	80 93 4c 1a 	sts	0x1A4C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1b32:	80 91 4c 1a 	lds	r24, 0x1A4C
    1b36:	88 23       	and	r24, r24
    1b38:	a9 f7       	brne	.-22     	; 0x1b24 <xTaskResumeAll+0xce>
    1b3a:	07 c0       	rjmp	.+14     	; 0x1b4a <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1b3c:	f1 e0       	ldi	r31, 0x01	; 1
    1b3e:	bf 16       	cp	r11, r31
    1b40:	21 f0       	breq	.+8      	; 0x1b4a <xTaskResumeAll+0xf4>
    1b42:	80 91 4b 1a 	lds	r24, 0x1A4B
    1b46:	81 30       	cpi	r24, 0x01	; 1
    1b48:	41 f4       	brne	.+16     	; 0x1b5a <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1b4a:	10 92 4b 1a 	sts	0x1A4B, r1
					portYIELD_WITHIN_API();
    1b4e:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1b52:	81 e0       	ldi	r24, 0x01	; 1
    1b54:	03 c0       	rjmp	.+6      	; 0x1b5c <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1b56:	80 e0       	ldi	r24, 0x00	; 0
    1b58:	01 c0       	rjmp	.+2      	; 0x1b5c <xTaskResumeAll+0x106>
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1b5c:	0f 90       	pop	r0
    1b5e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1b60:	df 91       	pop	r29
    1b62:	cf 91       	pop	r28
    1b64:	1f 91       	pop	r17
    1b66:	0f 91       	pop	r16
    1b68:	ff 90       	pop	r15
    1b6a:	ef 90       	pop	r14
    1b6c:	df 90       	pop	r13
    1b6e:	cf 90       	pop	r12
    1b70:	bf 90       	pop	r11
    1b72:	af 90       	pop	r10
    1b74:	08 95       	ret

00001b76 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1b76:	cf 93       	push	r28
    1b78:	df 93       	push	r29
    1b7a:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1b7c:	00 97       	sbiw	r24, 0x00	; 0
    1b7e:	b1 f0       	breq	.+44     	; 0x1bac <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1b80:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1b84:	80 91 50 1a 	lds	r24, 0x1A50
    1b88:	90 91 51 1a 	lds	r25, 0x1A51
    1b8c:	c8 0f       	add	r28, r24
    1b8e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1b90:	80 91 48 1a 	lds	r24, 0x1A48
    1b94:	90 91 49 1a 	lds	r25, 0x1A49
    1b98:	02 96       	adiw	r24, 0x02	; 2
    1b9a:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b9e:	ce 01       	movw	r24, r28
    1ba0:	0e 94 1a 0a 	call	0x1434	; 0x1434 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1ba4:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ba8:	88 23       	and	r24, r24
    1baa:	11 f4       	brne	.+4      	; 0x1bb0 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1bac:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
		}
	}
    1bb0:	df 91       	pop	r29
    1bb2:	cf 91       	pop	r28
    1bb4:	08 95       	ret

00001bb6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1bb6:	0f 93       	push	r16
    1bb8:	1f 93       	push	r17
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    1bbe:	8c 01       	movw	r16, r24
    1bc0:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1bc2:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1bc6:	f8 01       	movw	r30, r16
    1bc8:	80 81       	ld	r24, Z
    1bca:	91 81       	ldd	r25, Z+1	; 0x01
    1bcc:	c8 0f       	add	r28, r24
    1bce:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1bd0:	20 91 50 1a 	lds	r18, 0x1A50
    1bd4:	30 91 51 1a 	lds	r19, 0x1A51
    1bd8:	28 17       	cp	r18, r24
    1bda:	39 07       	cpc	r19, r25
    1bdc:	68 f4       	brcc	.+26     	; 0x1bf8 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1bde:	c8 17       	cp	r28, r24
    1be0:	d9 07       	cpc	r29, r25
    1be2:	50 f5       	brcc	.+84     	; 0x1c38 <vTaskDelayUntil+0x82>
    1be4:	80 91 50 1a 	lds	r24, 0x1A50
    1be8:	90 91 51 1a 	lds	r25, 0x1A51
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1bec:	d1 83       	std	Z+1, r29	; 0x01
    1bee:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1bf0:	8c 17       	cp	r24, r28
    1bf2:	9d 07       	cpc	r25, r29
    1bf4:	b0 f4       	brcc	.+44     	; 0x1c22 <vTaskDelayUntil+0x6c>
    1bf6:	0b c0       	rjmp	.+22     	; 0x1c0e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1bf8:	c8 17       	cp	r28, r24
    1bfa:	d9 07       	cpc	r29, r25
    1bfc:	c8 f0       	brcs	.+50     	; 0x1c30 <vTaskDelayUntil+0x7a>
    1bfe:	80 91 50 1a 	lds	r24, 0x1A50
    1c02:	90 91 51 1a 	lds	r25, 0x1A51
    1c06:	8c 17       	cp	r24, r28
    1c08:	9d 07       	cpc	r25, r29
    1c0a:	90 f0       	brcs	.+36     	; 0x1c30 <vTaskDelayUntil+0x7a>
    1c0c:	15 c0       	rjmp	.+42     	; 0x1c38 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1c0e:	80 91 48 1a 	lds	r24, 0x1A48
    1c12:	90 91 49 1a 	lds	r25, 0x1A49
    1c16:	02 96       	adiw	r24, 0x02	; 2
    1c18:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c1c:	ce 01       	movw	r24, r28
    1c1e:	0e 94 1a 0a 	call	0x1434	; 0x1434 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c22:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c26:	88 23       	and	r24, r24
    1c28:	59 f4       	brne	.+22     	; 0x1c40 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1c2a:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
    1c2e:	08 c0       	rjmp	.+16     	; 0x1c40 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c30:	f8 01       	movw	r30, r16
    1c32:	d1 83       	std	Z+1, r29	; 0x01
    1c34:	c0 83       	st	Z, r28
    1c36:	eb cf       	rjmp	.-42     	; 0x1c0e <vTaskDelayUntil+0x58>
    1c38:	f8 01       	movw	r30, r16
    1c3a:	d1 83       	std	Z+1, r29	; 0x01
    1c3c:	c0 83       	st	Z, r28
    1c3e:	f1 cf       	rjmp	.-30     	; 0x1c22 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	1f 91       	pop	r17
    1c46:	0f 91       	pop	r16
    1c48:	08 95       	ret

00001c4a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1c4a:	80 91 4d 1a 	lds	r24, 0x1A4D
    1c4e:	88 23       	and	r24, r24
    1c50:	99 f4       	brne	.+38     	; 0x1c78 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1c52:	80 91 4f 1a 	lds	r24, 0x1A4F
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	fc 01       	movw	r30, r24
    1c5a:	ee 0f       	add	r30, r30
    1c5c:	ff 1f       	adc	r31, r31
    1c5e:	ee 0f       	add	r30, r30
    1c60:	ff 1f       	adc	r31, r31
    1c62:	ee 0f       	add	r30, r30
    1c64:	ff 1f       	adc	r31, r31
    1c66:	8e 0f       	add	r24, r30
    1c68:	9f 1f       	adc	r25, r31
    1c6a:	fc 01       	movw	r30, r24
    1c6c:	e7 5a       	subi	r30, 0xA7	; 167
    1c6e:	f5 4e       	sbci	r31, 0xE5	; 229
    1c70:	80 81       	ld	r24, Z
    1c72:	88 23       	and	r24, r24
    1c74:	29 f0       	breq	.+10     	; 0x1c80 <vTaskSwitchContext+0x36>
    1c76:	1b c0       	rjmp	.+54     	; 0x1cae <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1c78:	81 e0       	ldi	r24, 0x01	; 1
    1c7a:	80 93 4b 1a 	sts	0x1A4B, r24
    1c7e:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1c80:	80 91 4f 1a 	lds	r24, 0x1A4F
    1c84:	81 50       	subi	r24, 0x01	; 1
    1c86:	80 93 4f 1a 	sts	0x1A4F, r24
    1c8a:	80 91 4f 1a 	lds	r24, 0x1A4F
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
    1c90:	fc 01       	movw	r30, r24
    1c92:	ee 0f       	add	r30, r30
    1c94:	ff 1f       	adc	r31, r31
    1c96:	ee 0f       	add	r30, r30
    1c98:	ff 1f       	adc	r31, r31
    1c9a:	ee 0f       	add	r30, r30
    1c9c:	ff 1f       	adc	r31, r31
    1c9e:	8e 0f       	add	r24, r30
    1ca0:	9f 1f       	adc	r25, r31
    1ca2:	fc 01       	movw	r30, r24
    1ca4:	e7 5a       	subi	r30, 0xA7	; 167
    1ca6:	f5 4e       	sbci	r31, 0xE5	; 229
    1ca8:	80 81       	ld	r24, Z
    1caa:	88 23       	and	r24, r24
    1cac:	49 f3       	breq	.-46     	; 0x1c80 <vTaskSwitchContext+0x36>
    1cae:	80 91 4f 1a 	lds	r24, 0x1A4F
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	ee 0f       	add	r30, r30
    1cb8:	ff 1f       	adc	r31, r31
    1cba:	ee 0f       	add	r30, r30
    1cbc:	ff 1f       	adc	r31, r31
    1cbe:	ee 0f       	add	r30, r30
    1cc0:	ff 1f       	adc	r31, r31
    1cc2:	e8 0f       	add	r30, r24
    1cc4:	f9 1f       	adc	r31, r25
    1cc6:	e7 5a       	subi	r30, 0xA7	; 167
    1cc8:	f5 4e       	sbci	r31, 0xE5	; 229
    1cca:	a1 81       	ldd	r26, Z+1	; 0x01
    1ccc:	b2 81       	ldd	r27, Z+2	; 0x02
    1cce:	12 96       	adiw	r26, 0x02	; 2
    1cd0:	0d 90       	ld	r0, X+
    1cd2:	bc 91       	ld	r27, X
    1cd4:	a0 2d       	mov	r26, r0
    1cd6:	b2 83       	std	Z+2, r27	; 0x02
    1cd8:	a1 83       	std	Z+1, r26	; 0x01
    1cda:	cf 01       	movw	r24, r30
    1cdc:	03 96       	adiw	r24, 0x03	; 3
    1cde:	a8 17       	cp	r26, r24
    1ce0:	b9 07       	cpc	r27, r25
    1ce2:	31 f4       	brne	.+12     	; 0x1cf0 <vTaskSwitchContext+0xa6>
    1ce4:	12 96       	adiw	r26, 0x02	; 2
    1ce6:	8d 91       	ld	r24, X+
    1ce8:	9c 91       	ld	r25, X
    1cea:	13 97       	sbiw	r26, 0x03	; 3
    1cec:	92 83       	std	Z+2, r25	; 0x02
    1cee:	81 83       	std	Z+1, r24	; 0x01
    1cf0:	01 80       	ldd	r0, Z+1	; 0x01
    1cf2:	f2 81       	ldd	r31, Z+2	; 0x02
    1cf4:	e0 2d       	mov	r30, r0
    1cf6:	86 81       	ldd	r24, Z+6	; 0x06
    1cf8:	97 81       	ldd	r25, Z+7	; 0x07
    1cfa:	90 93 49 1a 	sts	0x1A49, r25
    1cfe:	80 93 48 1a 	sts	0x1A48, r24
    1d02:	08 95       	ret

00001d04 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1d04:	ef 92       	push	r14
    1d06:	ff 92       	push	r15
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1d12:	0f b6       	in	r0, 0x3f	; 63
    1d14:	f8 94       	cli
    1d16:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1d18:	80 91 48 1a 	lds	r24, 0x1A48
    1d1c:	90 91 49 1a 	lds	r25, 0x1A49
    1d20:	e8 16       	cp	r14, r24
    1d22:	f9 06       	cpc	r15, r25
    1d24:	21 f0       	breq	.+8      	; 0x1d2e <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1d26:	e1 14       	cp	r14, r1
    1d28:	f1 04       	cpc	r15, r1
    1d2a:	41 f4       	brne	.+16     	; 0x1d3c <vTaskSuspend+0x38>
    1d2c:	02 c0       	rjmp	.+4      	; 0x1d32 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    1d2e:	ee 24       	eor	r14, r14
    1d30:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1d32:	c0 91 48 1a 	lds	r28, 0x1A48
    1d36:	d0 91 49 1a 	lds	r29, 0x1A49
    1d3a:	01 c0       	rjmp	.+2      	; 0x1d3e <vTaskSuspend+0x3a>
    1d3c:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1d3e:	8e 01       	movw	r16, r28
    1d40:	0e 5f       	subi	r16, 0xFE	; 254
    1d42:	1f 4f       	sbci	r17, 0xFF	; 255
    1d44:	c8 01       	movw	r24, r16
    1d46:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1d4a:	8c 89       	ldd	r24, Y+20	; 0x14
    1d4c:	9d 89       	ldd	r25, Y+21	; 0x15
    1d4e:	00 97       	sbiw	r24, 0x00	; 0
    1d50:	21 f0       	breq	.+8      	; 0x1d5a <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1d52:	ce 01       	movw	r24, r28
    1d54:	0c 96       	adiw	r24, 0x0c	; 12
    1d56:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1d5a:	88 e9       	ldi	r24, 0x98	; 152
    1d5c:	9a e1       	ldi	r25, 0x1A	; 26
    1d5e:	b8 01       	movw	r22, r16
    1d60:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1d68:	e1 14       	cp	r14, r1
    1d6a:	f1 04       	cpc	r15, r1
    1d6c:	a1 f4       	brne	.+40     	; 0x1d96 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    1d6e:	80 91 4e 1a 	lds	r24, 0x1A4E
    1d72:	88 23       	and	r24, r24
    1d74:	19 f0       	breq	.+6      	; 0x1d7c <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1d76:	0e 94 15 05 	call	0xa2a	; 0xa2a <vPortYield>
    1d7a:	0d c0       	rjmp	.+26     	; 0x1d96 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1d7c:	90 91 98 1a 	lds	r25, 0x1A98
    1d80:	80 91 52 1a 	lds	r24, 0x1A52
    1d84:	98 17       	cp	r25, r24
    1d86:	29 f4       	brne	.+10     	; 0x1d92 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1d88:	10 92 49 1a 	sts	0x1A49, r1
    1d8c:	10 92 48 1a 	sts	0x1A48, r1
    1d90:	02 c0       	rjmp	.+4      	; 0x1d96 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    1d92:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vTaskSwitchContext>
				}
			}
		}
	}
    1d96:	df 91       	pop	r29
    1d98:	cf 91       	pop	r28
    1d9a:	1f 91       	pop	r17
    1d9c:	0f 91       	pop	r16
    1d9e:	ff 90       	pop	r15
    1da0:	ef 90       	pop	r14
    1da2:	08 95       	ret

00001da4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1da4:	cf 93       	push	r28
    1da6:	df 93       	push	r29
    1da8:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1daa:	60 91 48 1a 	lds	r22, 0x1A48
    1dae:	70 91 49 1a 	lds	r23, 0x1A49
    1db2:	64 5f       	subi	r22, 0xF4	; 244
    1db4:	7f 4f       	sbci	r23, 0xFF	; 255
    1db6:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1dba:	80 91 48 1a 	lds	r24, 0x1A48
    1dbe:	90 91 49 1a 	lds	r25, 0x1A49
    1dc2:	02 96       	adiw	r24, 0x02	; 2
    1dc4:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1dc8:	8f ef       	ldi	r24, 0xFF	; 255
    1dca:	cf 3f       	cpi	r28, 0xFF	; 255
    1dcc:	d8 07       	cpc	r29, r24
    1dce:	59 f4       	brne	.+22     	; 0x1de6 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1dd0:	60 91 48 1a 	lds	r22, 0x1A48
    1dd4:	70 91 49 1a 	lds	r23, 0x1A49
    1dd8:	6e 5f       	subi	r22, 0xFE	; 254
    1dda:	7f 4f       	sbci	r23, 0xFF	; 255
    1ddc:	88 e9       	ldi	r24, 0x98	; 152
    1dde:	9a e1       	ldi	r25, 0x1A	; 26
    1de0:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
    1de4:	08 c0       	rjmp	.+16     	; 0x1df6 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1de6:	80 91 50 1a 	lds	r24, 0x1A50
    1dea:	90 91 51 1a 	lds	r25, 0x1A51
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1dee:	8c 0f       	add	r24, r28
    1df0:	9d 1f       	adc	r25, r29
    1df2:	0e 94 1a 0a 	call	0x1434	; 0x1434 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1df6:	df 91       	pop	r29
    1df8:	cf 91       	pop	r28
    1dfa:	08 95       	ret

00001dfc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1dfc:	0f 93       	push	r16
    1dfe:	1f 93       	push	r17
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1e04:	dc 01       	movw	r26, r24
    1e06:	15 96       	adiw	r26, 0x05	; 5
    1e08:	ed 91       	ld	r30, X+
    1e0a:	fc 91       	ld	r31, X
    1e0c:	16 97       	sbiw	r26, 0x06	; 6
    1e0e:	06 81       	ldd	r16, Z+6	; 0x06
    1e10:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1e12:	e8 01       	movw	r28, r16
    1e14:	2c 96       	adiw	r28, 0x0c	; 12
    1e16:	ce 01       	movw	r24, r28
    1e18:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e1c:	80 91 4d 1a 	lds	r24, 0x1A4D
    1e20:	88 23       	and	r24, r24
    1e22:	e9 f4       	brne	.+58     	; 0x1e5e <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1e24:	e8 01       	movw	r28, r16
    1e26:	22 96       	adiw	r28, 0x02	; 2
    1e28:	ce 01       	movw	r24, r28
    1e2a:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1e2e:	f8 01       	movw	r30, r16
    1e30:	86 89       	ldd	r24, Z+22	; 0x16
    1e32:	90 91 4f 1a 	lds	r25, 0x1A4F
    1e36:	98 17       	cp	r25, r24
    1e38:	10 f4       	brcc	.+4      	; 0x1e3e <xTaskRemoveFromEventList+0x42>
    1e3a:	80 93 4f 1a 	sts	0x1A4F, r24
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	9c 01       	movw	r18, r24
    1e42:	22 0f       	add	r18, r18
    1e44:	33 1f       	adc	r19, r19
    1e46:	22 0f       	add	r18, r18
    1e48:	33 1f       	adc	r19, r19
    1e4a:	22 0f       	add	r18, r18
    1e4c:	33 1f       	adc	r19, r19
    1e4e:	82 0f       	add	r24, r18
    1e50:	93 1f       	adc	r25, r19
    1e52:	87 5a       	subi	r24, 0xA7	; 167
    1e54:	95 4e       	sbci	r25, 0xE5	; 229
    1e56:	be 01       	movw	r22, r28
    1e58:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
    1e5c:	05 c0       	rjmp	.+10     	; 0x1e68 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1e5e:	8f e8       	ldi	r24, 0x8F	; 143
    1e60:	9a e1       	ldi	r25, 0x1A	; 26
    1e62:	be 01       	movw	r22, r28
    1e64:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e68:	e0 91 48 1a 	lds	r30, 0x1A48
    1e6c:	f0 91 49 1a 	lds	r31, 0x1A49
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1e70:	81 e0       	ldi	r24, 0x01	; 1
    1e72:	d8 01       	movw	r26, r16
    1e74:	56 96       	adiw	r26, 0x16	; 22
    1e76:	2c 91       	ld	r18, X
    1e78:	56 97       	sbiw	r26, 0x16	; 22
    1e7a:	96 89       	ldd	r25, Z+22	; 0x16
    1e7c:	29 17       	cp	r18, r25
    1e7e:	08 f4       	brcc	.+2      	; 0x1e82 <xTaskRemoveFromEventList+0x86>
    1e80:	80 e0       	ldi	r24, 0x00	; 0
}
    1e82:	df 91       	pop	r29
    1e84:	cf 91       	pop	r28
    1e86:	1f 91       	pop	r17
    1e88:	0f 91       	pop	r16
    1e8a:	08 95       	ret

00001e8c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1e8c:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1e8e:	80 91 4a 1a 	lds	r24, 0x1A4A
    1e92:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1e94:	80 91 50 1a 	lds	r24, 0x1A50
    1e98:	90 91 51 1a 	lds	r25, 0x1A51
    1e9c:	92 83       	std	Z+2, r25	; 0x02
    1e9e:	81 83       	std	Z+1, r24	; 0x01
}
    1ea0:	08 95       	ret

00001ea2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1ea2:	fc 01       	movw	r30, r24
    1ea4:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1ea6:	0f b6       	in	r0, 0x3f	; 63
    1ea8:	f8 94       	cli
    1eaa:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1eac:	4d 91       	ld	r20, X+
    1eae:	5c 91       	ld	r21, X
    1eb0:	11 97       	sbiw	r26, 0x01	; 1
    1eb2:	6f ef       	ldi	r22, 0xFF	; 255
    1eb4:	4f 3f       	cpi	r20, 0xFF	; 255
    1eb6:	56 07       	cpc	r21, r22
    1eb8:	51 f1       	breq	.+84     	; 0x1f0e <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1eba:	80 91 4a 1a 	lds	r24, 0x1A4A
    1ebe:	90 81       	ld	r25, Z
    1ec0:	98 17       	cp	r25, r24
    1ec2:	49 f0       	breq	.+18     	; 0x1ed6 <xTaskCheckForTimeOut+0x34>
    1ec4:	20 91 50 1a 	lds	r18, 0x1A50
    1ec8:	30 91 51 1a 	lds	r19, 0x1A51
    1ecc:	81 81       	ldd	r24, Z+1	; 0x01
    1ece:	92 81       	ldd	r25, Z+2	; 0x02
    1ed0:	28 17       	cp	r18, r24
    1ed2:	39 07       	cpc	r19, r25
    1ed4:	f0 f4       	brcc	.+60     	; 0x1f12 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1ed6:	80 91 50 1a 	lds	r24, 0x1A50
    1eda:	90 91 51 1a 	lds	r25, 0x1A51
    1ede:	21 81       	ldd	r18, Z+1	; 0x01
    1ee0:	32 81       	ldd	r19, Z+2	; 0x02
    1ee2:	82 1b       	sub	r24, r18
    1ee4:	93 0b       	sbc	r25, r19
    1ee6:	84 17       	cp	r24, r20
    1ee8:	95 07       	cpc	r25, r21
    1eea:	a8 f4       	brcc	.+42     	; 0x1f16 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1eec:	80 91 50 1a 	lds	r24, 0x1A50
    1ef0:	90 91 51 1a 	lds	r25, 0x1A51
    1ef4:	b9 01       	movw	r22, r18
    1ef6:	68 1b       	sub	r22, r24
    1ef8:	79 0b       	sbc	r23, r25
    1efa:	cb 01       	movw	r24, r22
    1efc:	84 0f       	add	r24, r20
    1efe:	95 1f       	adc	r25, r21
    1f00:	8d 93       	st	X+, r24
    1f02:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1f04:	cf 01       	movw	r24, r30
    1f06:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	05 c0       	rjmp	.+10     	; 0x1f18 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1f0e:	80 e0       	ldi	r24, 0x00	; 0
    1f10:	03 c0       	rjmp	.+6      	; 0x1f18 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1f12:	81 e0       	ldi	r24, 0x01	; 1
    1f14:	01 c0       	rjmp	.+2      	; 0x1f18 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1f16:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1f18:	0f 90       	pop	r0
    1f1a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1f1c:	08 95       	ret

00001f1e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	80 93 4b 1a 	sts	0x1A4B, r24
}
    1f24:	08 95       	ret

00001f26 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1f26:	00 97       	sbiw	r24, 0x00	; 0
    1f28:	29 f4       	brne	.+10     	; 0x1f34 <uxTaskGetStackHighWaterMark+0xe>
    1f2a:	e0 91 48 1a 	lds	r30, 0x1A48
    1f2e:	f0 91 49 1a 	lds	r31, 0x1A49
    1f32:	01 c0       	rjmp	.+2      	; 0x1f36 <uxTaskGetStackHighWaterMark+0x10>
    1f34:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1f36:	07 88       	ldd	r0, Z+23	; 0x17
    1f38:	f0 8d       	ldd	r31, Z+24	; 0x18
    1f3a:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1f3c:	80 81       	ld	r24, Z
    1f3e:	85 3a       	cpi	r24, 0xA5	; 165
    1f40:	41 f4       	brne	.+16     	; 0x1f52 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    1f42:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1f44:	80 e0       	ldi	r24, 0x00	; 0
    1f46:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    1f48:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1f4a:	21 91       	ld	r18, Z+
    1f4c:	25 3a       	cpi	r18, 0xA5	; 165
    1f4e:	e1 f3       	breq	.-8      	; 0x1f48 <uxTaskGetStackHighWaterMark+0x22>
    1f50:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1f52:	80 e0       	ldi	r24, 0x00	; 0
    1f54:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    1f56:	08 95       	ret

00001f58 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1f58:	80 91 48 1a 	lds	r24, 0x1A48
    1f5c:	90 91 49 1a 	lds	r25, 0x1A49

		return xReturn;
	}
    1f60:	08 95       	ret

00001f62 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1f62:	0f 93       	push	r16
    1f64:	1f 93       	push	r17
    1f66:	cf 93       	push	r28
    1f68:	df 93       	push	r29
    1f6a:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1f6c:	00 97       	sbiw	r24, 0x00	; 0
    1f6e:	09 f4       	brne	.+2      	; 0x1f72 <vTaskPriorityInherit+0x10>
    1f70:	4d c0       	rjmp	.+154    	; 0x200c <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1f72:	8e 89       	ldd	r24, Y+22	; 0x16
    1f74:	e0 91 48 1a 	lds	r30, 0x1A48
    1f78:	f0 91 49 1a 	lds	r31, 0x1A49
    1f7c:	96 89       	ldd	r25, Z+22	; 0x16
    1f7e:	89 17       	cp	r24, r25
    1f80:	08 f0       	brcs	.+2      	; 0x1f84 <vTaskPriorityInherit+0x22>
    1f82:	44 c0       	rjmp	.+136    	; 0x200c <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1f84:	e0 91 48 1a 	lds	r30, 0x1A48
    1f88:	f0 91 49 1a 	lds	r31, 0x1A49
    1f8c:	96 89       	ldd	r25, Z+22	; 0x16
    1f8e:	24 e0       	ldi	r18, 0x04	; 4
    1f90:	30 e0       	ldi	r19, 0x00	; 0
    1f92:	29 1b       	sub	r18, r25
    1f94:	31 09       	sbc	r19, r1
    1f96:	3d 87       	std	Y+13, r19	; 0x0d
    1f98:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	9c 01       	movw	r18, r24
    1f9e:	22 0f       	add	r18, r18
    1fa0:	33 1f       	adc	r19, r19
    1fa2:	22 0f       	add	r18, r18
    1fa4:	33 1f       	adc	r19, r19
    1fa6:	22 0f       	add	r18, r18
    1fa8:	33 1f       	adc	r19, r19
    1faa:	82 0f       	add	r24, r18
    1fac:	93 1f       	adc	r25, r19
    1fae:	87 5a       	subi	r24, 0xA7	; 167
    1fb0:	95 4e       	sbci	r25, 0xE5	; 229
    1fb2:	2a 85       	ldd	r18, Y+10	; 0x0a
    1fb4:	3b 85       	ldd	r19, Y+11	; 0x0b
    1fb6:	28 17       	cp	r18, r24
    1fb8:	39 07       	cpc	r19, r25
    1fba:	11 f5       	brne	.+68     	; 0x2000 <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1fbc:	8e 01       	movw	r16, r28
    1fbe:	0e 5f       	subi	r16, 0xFE	; 254
    1fc0:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc2:	c8 01       	movw	r24, r16
    1fc4:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1fc8:	e0 91 48 1a 	lds	r30, 0x1A48
    1fcc:	f0 91 49 1a 	lds	r31, 0x1A49
    1fd0:	86 89       	ldd	r24, Z+22	; 0x16
    1fd2:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1fd4:	90 91 4f 1a 	lds	r25, 0x1A4F
    1fd8:	98 17       	cp	r25, r24
    1fda:	10 f4       	brcc	.+4      	; 0x1fe0 <vTaskPriorityInherit+0x7e>
    1fdc:	80 93 4f 1a 	sts	0x1A4F, r24
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	9c 01       	movw	r18, r24
    1fe4:	22 0f       	add	r18, r18
    1fe6:	33 1f       	adc	r19, r19
    1fe8:	22 0f       	add	r18, r18
    1fea:	33 1f       	adc	r19, r19
    1fec:	22 0f       	add	r18, r18
    1fee:	33 1f       	adc	r19, r19
    1ff0:	82 0f       	add	r24, r18
    1ff2:	93 1f       	adc	r25, r19
    1ff4:	87 5a       	subi	r24, 0xA7	; 167
    1ff6:	95 4e       	sbci	r25, 0xE5	; 229
    1ff8:	b8 01       	movw	r22, r16
    1ffa:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
    1ffe:	06 c0       	rjmp	.+12     	; 0x200c <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2000:	e0 91 48 1a 	lds	r30, 0x1A48
    2004:	f0 91 49 1a 	lds	r31, 0x1A49
    2008:	86 89       	ldd	r24, Z+22	; 0x16
    200a:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    200c:	df 91       	pop	r29
    200e:	cf 91       	pop	r28
    2010:	1f 91       	pop	r17
    2012:	0f 91       	pop	r16
    2014:	08 95       	ret

00002016 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2016:	0f 93       	push	r16
    2018:	1f 93       	push	r17
    201a:	cf 93       	push	r28
    201c:	df 93       	push	r29
    201e:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2020:	00 97       	sbiw	r24, 0x00	; 0
    2022:	49 f1       	breq	.+82     	; 0x2076 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2024:	9e 89       	ldd	r25, Y+22	; 0x16
    2026:	89 a5       	lds	r24, 0x69
    2028:	98 17       	cp	r25, r24
    202a:	29 f1       	breq	.+74     	; 0x2076 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    202c:	8e 01       	movw	r16, r28
    202e:	0e 5f       	subi	r16, 0xFE	; 254
    2030:	1f 4f       	sbci	r17, 0xFF	; 255
    2032:	c8 01       	movw	r24, r16
    2034:	0e 94 16 04 	call	0x82c	; 0x82c <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2038:	49 a5       	lds	r20, 0x69
    203a:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    203c:	24 2f       	mov	r18, r20
    203e:	30 e0       	ldi	r19, 0x00	; 0
    2040:	84 e0       	ldi	r24, 0x04	; 4
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	82 1b       	sub	r24, r18
    2046:	93 0b       	sbc	r25, r19
    2048:	9d 87       	std	Y+13, r25	; 0x0d
    204a:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    204c:	80 91 4f 1a 	lds	r24, 0x1A4F
    2050:	84 17       	cp	r24, r20
    2052:	10 f4       	brcc	.+4      	; 0x2058 <vTaskPriorityDisinherit+0x42>
    2054:	40 93 4f 1a 	sts	0x1A4F, r20
    2058:	c9 01       	movw	r24, r18
    205a:	88 0f       	add	r24, r24
    205c:	99 1f       	adc	r25, r25
    205e:	88 0f       	add	r24, r24
    2060:	99 1f       	adc	r25, r25
    2062:	88 0f       	add	r24, r24
    2064:	99 1f       	adc	r25, r25
    2066:	28 0f       	add	r18, r24
    2068:	39 1f       	adc	r19, r25
    206a:	c9 01       	movw	r24, r18
    206c:	87 5a       	subi	r24, 0xA7	; 167
    206e:	95 4e       	sbci	r25, 0xE5	; 229
    2070:	b8 01       	movw	r22, r16
    2072:	0e 94 b0 03 	call	0x760	; 0x760 <vListInsertEnd>
			}
		}
	}
    2076:	df 91       	pop	r29
    2078:	cf 91       	pop	r28
    207a:	1f 91       	pop	r17
    207c:	0f 91       	pop	r16
    207e:	08 95       	ret

00002080 <memcpy>:
    2080:	fb 01       	movw	r30, r22
    2082:	dc 01       	movw	r26, r24
    2084:	02 c0       	rjmp	.+4      	; 0x208a <memcpy+0xa>
    2086:	01 90       	ld	r0, Z+
    2088:	0d 92       	st	X+, r0
    208a:	41 50       	subi	r20, 0x01	; 1
    208c:	50 40       	sbci	r21, 0x00	; 0
    208e:	d8 f7       	brcc	.-10     	; 0x2086 <memcpy+0x6>
    2090:	08 95       	ret

00002092 <memset>:
    2092:	dc 01       	movw	r26, r24
    2094:	01 c0       	rjmp	.+2      	; 0x2098 <memset+0x6>
    2096:	6d 93       	st	X+, r22
    2098:	41 50       	subi	r20, 0x01	; 1
    209a:	50 40       	sbci	r21, 0x00	; 0
    209c:	e0 f7       	brcc	.-8      	; 0x2096 <memset+0x4>
    209e:	08 95       	ret

000020a0 <strncpy>:
    20a0:	fb 01       	movw	r30, r22
    20a2:	dc 01       	movw	r26, r24
    20a4:	41 50       	subi	r20, 0x01	; 1
    20a6:	50 40       	sbci	r21, 0x00	; 0
    20a8:	48 f0       	brcs	.+18     	; 0x20bc <strncpy+0x1c>
    20aa:	01 90       	ld	r0, Z+
    20ac:	0d 92       	st	X+, r0
    20ae:	00 20       	and	r0, r0
    20b0:	c9 f7       	brne	.-14     	; 0x20a4 <strncpy+0x4>
    20b2:	01 c0       	rjmp	.+2      	; 0x20b6 <strncpy+0x16>
    20b4:	1d 92       	st	X+, r1
    20b6:	41 50       	subi	r20, 0x01	; 1
    20b8:	50 40       	sbci	r21, 0x00	; 0
    20ba:	e0 f7       	brcc	.-8      	; 0x20b4 <strncpy+0x14>
    20bc:	08 95       	ret

000020be <_exit>:
    20be:	f8 94       	cli

000020c0 <__stop_program>:
    20c0:	ff cf       	rjmp	.-2      	; 0x20c0 <__stop_program>
