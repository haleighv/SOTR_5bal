
Lab 3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000028  00800200  00002050  000020e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002050  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000189b  00800228  00800228  0000210c  2**0
                  ALLOC
  3 .stab         000008a0  00000000  00000000  0000210c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  000029ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00002b58  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000266c  00000000  00000000  00002cb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a95  00000000  00000000  00005324  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f83  00000000  00000000  00005db9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008fc  00000000  00000000  00006d3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000101c  00000000  00000000  00007638  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002511  00000000  00000000  00008654  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  0000ab65  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      20:	0c 94 0f 04 	jmp	0x81e	; 0x81e <__vector_8>
      24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      34:	0c 94 d6 03 	jmp	0x7ac	; 0x7ac <__vector_13>
      38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      68:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      6c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      70:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      74:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      78:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      7c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      80:	0c 94 87 06 	jmp	0xd0e	; 0xd0e <__vector_32>
      84:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      88:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      8c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      90:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      94:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      98:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      9c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      ac:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      bc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      cc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      dc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      e0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e0 e5       	ldi	r30, 0x50	; 80
      fc:	f0 e2       	ldi	r31, 0x20	; 32
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a8 32       	cpi	r26, 0x28	; 40
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
     10e:	1b be       	out	0x3b, r1	; 59

00000110 <__do_clear_bss>:
     110:	1a e1       	ldi	r17, 0x1A	; 26
     112:	a8 e2       	ldi	r26, 0x28	; 40
     114:	b2 e0       	ldi	r27, 0x02	; 2
     116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
     118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
     11a:	a3 3c       	cpi	r26, 0xC3	; 195
     11c:	b1 07       	cpc	r27, r17
     11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
     120:	0e 94 72 03 	call	0x6e4	; 0x6e4 <main>
     124:	0c 94 26 10 	jmp	0x204c	; 0x204c <_exit>

00000128 <__bad_interrupt>:
     128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <vIO_init>:
* return: void
*--------------------------------------------------------*/
void vIO_init(void)
{
	// Set PORTE (switches) to inputs
	DDRE = 0x00;
     12c:	1d b8       	out	0x0d, r1	; 13
	// Set PortA (LEDs) as all outputs
	DDRA = 0xFF;
     12e:	8f ef       	ldi	r24, 0xFF	; 255
     130:	81 b9       	out	0x01, r24	; 1
	// Turn LEDs off
	PORTA = 0xFF;
     132:	82 b9       	out	0x02, r24	; 2
}
     134:	08 95       	ret

00000136 <initialize_timer2>:
*
* return: void
*--------------------------------------------------------*/
void initialize_timer2()
{		
	TIMSK2 = (1 << OCIE2A);//Set interrupt mask for OC2A
     136:	82 e0       	ldi	r24, 0x02	; 2
     138:	80 93 70 00 	sts	0x0070, r24
	TCCR2A = ((1 << COM2A1) | (1 << COM2A0));//Set OC2A on Compare Match
     13c:	80 ec       	ldi	r24, 0xC0	; 192
     13e:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B = ((1 << WGM22)  | (1 << CS21) | (1 << CS20));//Set timer2 to CTC, prescaler of 8
     142:	8b e0       	ldi	r24, 0x0B	; 11
     144:	80 93 b1 00 	sts	0x00B1, r24
	OCR2A  = TIMER2_7Hz; 
     148:	87 e7       	ldi	r24, 0x77	; 119
     14a:	80 93 b3 00 	sts	0x00B3, r24
}
     14e:	08 95       	ret

00000150 <initialize_button_read>:
*
* return: void
*--------------------------------------------------------*/
void initialize_button_read()
{
	EICRB |= (1<<ISC70);
     150:	ea e6       	ldi	r30, 0x6A	; 106
     152:	f0 e0       	ldi	r31, 0x00	; 0
     154:	80 81       	ld	r24, Z
     156:	80 64       	ori	r24, 0x40	; 64
     158:	80 83       	st	Z, r24
	EIMSK |= (1<<INT7);	
     15a:	ef 9a       	sbi	0x1d, 7	; 29
     15c:	08 95       	ret

0000015e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     15e:	af 92       	push	r10
     160:	bf 92       	push	r11
     162:	cf 92       	push	r12
     164:	df 92       	push	r13
     166:	ef 92       	push	r14
     168:	ff 92       	push	r15
     16a:	0f 93       	push	r16
     16c:	1f 93       	push	r17
     16e:	cf 93       	push	r28
     170:	df 93       	push	r29
     172:	6c 01       	movw	r12, r24
     174:	e6 2e       	mov	r14, r22
     176:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     178:	8a e1       	ldi	r24, 0x1A	; 26
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <pvPortMalloc>
     180:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     182:	00 97       	sbiw	r24, 0x00	; 0
     184:	09 f4       	brne	.+2      	; 0x188 <xCoRoutineCreate+0x2a>
     186:	62 c0       	rjmp	.+196    	; 0x24c <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     188:	80 91 28 02 	lds	r24, 0x0228
     18c:	90 91 29 02 	lds	r25, 0x0229
     190:	00 97       	sbiw	r24, 0x00	; 0
     192:	39 f5       	brne	.+78     	; 0x1e2 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     194:	10 93 29 02 	sts	0x0229, r17
     198:	00 93 28 02 	sts	0x0228, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     19c:	cb e2       	ldi	r28, 0x2B	; 43
     19e:	d2 e0       	ldi	r29, 0x02	; 2
     1a0:	ce 01       	movw	r24, r28
     1a2:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
     1a6:	ce 01       	movw	r24, r28
     1a8:	09 96       	adiw	r24, 0x09	; 9
     1aa:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     1ae:	cd e3       	ldi	r28, 0x3D	; 61
     1b0:	d2 e0       	ldi	r29, 0x02	; 2
     1b2:	ce 01       	movw	r24, r28
     1b4:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     1b8:	0f 2e       	mov	r0, r31
     1ba:	f6 e4       	ldi	r31, 0x46	; 70
     1bc:	af 2e       	mov	r10, r31
     1be:	f2 e0       	ldi	r31, 0x02	; 2
     1c0:	bf 2e       	mov	r11, r31
     1c2:	f0 2d       	mov	r31, r0
     1c4:	c5 01       	movw	r24, r10
     1c6:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     1ca:	8f e4       	ldi	r24, 0x4F	; 79
     1cc:	92 e0       	ldi	r25, 0x02	; 2
     1ce:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1d2:	d0 93 59 02 	sts	0x0259, r29
     1d6:	c0 93 58 02 	sts	0x0258, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1da:	b0 92 5b 02 	sts	0x025B, r11
     1de:	a0 92 5a 02 	sts	0x025A, r10
     1e2:	ce 2d       	mov	r28, r14
     1e4:	e1 10       	cpse	r14, r1
     1e6:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1e8:	f8 01       	movw	r30, r16
     1ea:	11 8e       	std	Z+25, r1	; 0x19
     1ec:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1ee:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1f0:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1f2:	c1 92       	st	Z+, r12
     1f4:	d1 92       	st	Z+, r13
     1f6:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1f8:	cf 01       	movw	r24, r30
     1fa:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1fe:	c8 01       	movw	r24, r16
     200:	0c 96       	adiw	r24, 0x0c	; 12
     202:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     206:	f8 01       	movw	r30, r16
     208:	11 87       	std	Z+9, r17	; 0x09
     20a:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     20c:	13 8b       	std	Z+19, r17	; 0x13
     20e:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     210:	84 e0       	ldi	r24, 0x04	; 4
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	8c 1b       	sub	r24, r28
     216:	91 09       	sbc	r25, r1
     218:	95 87       	std	Z+13, r25	; 0x0d
     21a:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     21c:	86 89       	ldd	r24, Z+22	; 0x16
     21e:	90 91 2a 02 	lds	r25, 0x022A
     222:	98 17       	cp	r25, r24
     224:	10 f4       	brcc	.+4      	; 0x22a <xCoRoutineCreate+0xcc>
     226:	80 93 2a 02 	sts	0x022A, r24
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	9c 01       	movw	r18, r24
     22e:	22 0f       	add	r18, r18
     230:	33 1f       	adc	r19, r19
     232:	22 0f       	add	r18, r18
     234:	33 1f       	adc	r19, r19
     236:	22 0f       	add	r18, r18
     238:	33 1f       	adc	r19, r19
     23a:	82 0f       	add	r24, r18
     23c:	93 1f       	adc	r25, r19
     23e:	85 5d       	subi	r24, 0xD5	; 213
     240:	9d 4f       	sbci	r25, 0xFD	; 253
     242:	b7 01       	movw	r22, r14
     244:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>

		xReturn = pdPASS;
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	01 c0       	rjmp	.+2      	; 0x24e <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     24c:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     24e:	df 91       	pop	r29
     250:	cf 91       	pop	r28
     252:	1f 91       	pop	r17
     254:	0f 91       	pop	r16
     256:	ff 90       	pop	r15
     258:	ef 90       	pop	r14
     25a:	df 90       	pop	r13
     25c:	cf 90       	pop	r12
     25e:	bf 90       	pop	r11
     260:	af 90       	pop	r10
     262:	08 95       	ret

00000264 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     264:	0f 93       	push	r16
     266:	1f 93       	push	r17
     268:	cf 93       	push	r28
     26a:	df 93       	push	r29
     26c:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     26e:	c0 91 5c 02 	lds	r28, 0x025C
     272:	d0 91 5d 02 	lds	r29, 0x025D
     276:	c8 0f       	add	r28, r24
     278:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     27a:	80 91 28 02 	lds	r24, 0x0228
     27e:	90 91 29 02 	lds	r25, 0x0229
     282:	02 96       	adiw	r24, 0x02	; 2
     284:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     288:	e0 91 28 02 	lds	r30, 0x0228
     28c:	f0 91 29 02 	lds	r31, 0x0229
     290:	d3 83       	std	Z+3, r29	; 0x03
     292:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     294:	80 91 5c 02 	lds	r24, 0x025C
     298:	90 91 5d 02 	lds	r25, 0x025D
     29c:	c8 17       	cp	r28, r24
     29e:	d9 07       	cpc	r29, r25
     2a0:	50 f4       	brcc	.+20     	; 0x2b6 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2a2:	bf 01       	movw	r22, r30
     2a4:	6e 5f       	subi	r22, 0xFE	; 254
     2a6:	7f 4f       	sbci	r23, 0xFF	; 255
     2a8:	80 91 5a 02 	lds	r24, 0x025A
     2ac:	90 91 5b 02 	lds	r25, 0x025B
     2b0:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsert>
     2b4:	09 c0       	rjmp	.+18     	; 0x2c8 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2b6:	bf 01       	movw	r22, r30
     2b8:	6e 5f       	subi	r22, 0xFE	; 254
     2ba:	7f 4f       	sbci	r23, 0xFF	; 255
     2bc:	80 91 58 02 	lds	r24, 0x0258
     2c0:	90 91 59 02 	lds	r25, 0x0259
     2c4:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsert>
	}

	if( pxEventList )
     2c8:	01 15       	cp	r16, r1
     2ca:	11 05       	cpc	r17, r1
     2cc:	49 f0       	breq	.+18     	; 0x2e0 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2ce:	60 91 28 02 	lds	r22, 0x0228
     2d2:	70 91 29 02 	lds	r23, 0x0229
     2d6:	64 5f       	subi	r22, 0xF4	; 244
     2d8:	7f 4f       	sbci	r23, 0xFF	; 255
     2da:	c8 01       	movw	r24, r16
     2dc:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsert>
	}
}
     2e0:	df 91       	pop	r29
     2e2:	cf 91       	pop	r28
     2e4:	1f 91       	pop	r17
     2e6:	0f 91       	pop	r16
     2e8:	08 95       	ret

000002ea <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2ea:	cf 92       	push	r12
     2ec:	df 92       	push	r13
     2ee:	ef 92       	push	r14
     2f0:	ff 92       	push	r15
     2f2:	0f 93       	push	r16
     2f4:	1f 93       	push	r17
     2f6:	cf 93       	push	r28
     2f8:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2fa:	80 91 4f 02 	lds	r24, 0x024F
     2fe:	88 23       	and	r24, r24
     300:	b9 f1       	breq	.+110    	; 0x370 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     302:	0f 2e       	mov	r0, r31
     304:	f4 e5       	ldi	r31, 0x54	; 84
     306:	ef 2e       	mov	r14, r31
     308:	f2 e0       	ldi	r31, 0x02	; 2
     30a:	ff 2e       	mov	r15, r31
     30c:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     30e:	0f 2e       	mov	r0, r31
     310:	ff e4       	ldi	r31, 0x4F	; 79
     312:	cf 2e       	mov	r12, r31
     314:	f2 e0       	ldi	r31, 0x02	; 2
     316:	df 2e       	mov	r13, r31
     318:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     31a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     31c:	d7 01       	movw	r26, r14
     31e:	ed 91       	ld	r30, X+
     320:	fc 91       	ld	r31, X
     322:	c6 81       	ldd	r28, Z+6	; 0x06
     324:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     326:	ce 01       	movw	r24, r28
     328:	0c 96       	adiw	r24, 0x0c	; 12
     32a:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     32e:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     330:	8e 01       	movw	r16, r28
     332:	0e 5f       	subi	r16, 0xFE	; 254
     334:	1f 4f       	sbci	r17, 0xFF	; 255
     336:	c8 01       	movw	r24, r16
     338:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     33c:	8e 89       	ldd	r24, Y+22	; 0x16
     33e:	90 91 2a 02 	lds	r25, 0x022A
     342:	98 17       	cp	r25, r24
     344:	10 f4       	brcc	.+4      	; 0x34a <vCoRoutineSchedule+0x60>
     346:	80 93 2a 02 	sts	0x022A, r24
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	9c 01       	movw	r18, r24
     34e:	22 0f       	add	r18, r18
     350:	33 1f       	adc	r19, r19
     352:	22 0f       	add	r18, r18
     354:	33 1f       	adc	r19, r19
     356:	22 0f       	add	r18, r18
     358:	33 1f       	adc	r19, r19
     35a:	82 0f       	add	r24, r18
     35c:	93 1f       	adc	r25, r19
     35e:	85 5d       	subi	r24, 0xD5	; 213
     360:	9d 4f       	sbci	r25, 0xFD	; 253
     362:	b8 01       	movw	r22, r16
     364:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     368:	f6 01       	movw	r30, r12
     36a:	80 81       	ld	r24, Z
     36c:	88 23       	and	r24, r24
     36e:	a9 f6       	brne	.-86     	; 0x31a <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     370:	0e 94 1a 0c 	call	0x1834	; 0x1834 <xTaskGetTickCount>
     374:	20 91 5e 02 	lds	r18, 0x025E
     378:	30 91 5f 02 	lds	r19, 0x025F
     37c:	82 1b       	sub	r24, r18
     37e:	93 0b       	sbc	r25, r19
     380:	90 93 61 02 	sts	0x0261, r25
     384:	80 93 60 02 	sts	0x0260, r24
     388:	74 c0       	rjmp	.+232    	; 0x472 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     38a:	20 91 5c 02 	lds	r18, 0x025C
     38e:	30 91 5d 02 	lds	r19, 0x025D
     392:	2f 5f       	subi	r18, 0xFF	; 255
     394:	3f 4f       	sbci	r19, 0xFF	; 255
     396:	30 93 5d 02 	sts	0x025D, r19
     39a:	20 93 5c 02 	sts	0x025C, r18
		xPassedTicks--;
     39e:	01 97       	sbiw	r24, 0x01	; 1
     3a0:	90 93 61 02 	sts	0x0261, r25
     3a4:	80 93 60 02 	sts	0x0260, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     3a8:	21 15       	cp	r18, r1
     3aa:	31 05       	cpc	r19, r1
     3ac:	81 f4       	brne	.+32     	; 0x3ce <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     3ae:	80 91 58 02 	lds	r24, 0x0258
     3b2:	90 91 59 02 	lds	r25, 0x0259
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     3b6:	20 91 5a 02 	lds	r18, 0x025A
     3ba:	30 91 5b 02 	lds	r19, 0x025B
     3be:	30 93 59 02 	sts	0x0259, r19
     3c2:	20 93 58 02 	sts	0x0258, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     3c6:	90 93 5b 02 	sts	0x025B, r25
     3ca:	80 93 5a 02 	sts	0x025A, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3ce:	e0 91 58 02 	lds	r30, 0x0258
     3d2:	f0 91 59 02 	lds	r31, 0x0259
     3d6:	80 81       	ld	r24, Z
     3d8:	88 23       	and	r24, r24
     3da:	09 f4       	brne	.+2      	; 0x3de <vCoRoutineSchedule+0xf4>
     3dc:	4a c0       	rjmp	.+148    	; 0x472 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3de:	05 80       	ldd	r0, Z+5	; 0x05
     3e0:	f6 81       	ldd	r31, Z+6	; 0x06
     3e2:	e0 2d       	mov	r30, r0
     3e4:	c6 81       	ldd	r28, Z+6	; 0x06
     3e6:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3e8:	2a 81       	ldd	r18, Y+2	; 0x02
     3ea:	3b 81       	ldd	r19, Y+3	; 0x03
     3ec:	80 91 5c 02 	lds	r24, 0x025C
     3f0:	90 91 5d 02 	lds	r25, 0x025D
     3f4:	82 17       	cp	r24, r18
     3f6:	93 07       	cpc	r25, r19
     3f8:	78 f4       	brcc	.+30     	; 0x418 <vCoRoutineSchedule+0x12e>
     3fa:	3b c0       	rjmp	.+118    	; 0x472 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3fc:	05 80       	ldd	r0, Z+5	; 0x05
     3fe:	f6 81       	ldd	r31, Z+6	; 0x06
     400:	e0 2d       	mov	r30, r0
     402:	c6 81       	ldd	r28, Z+6	; 0x06
     404:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     406:	2a 81       	ldd	r18, Y+2	; 0x02
     408:	3b 81       	ldd	r19, Y+3	; 0x03
     40a:	80 91 5c 02 	lds	r24, 0x025C
     40e:	90 91 5d 02 	lds	r25, 0x025D
     412:	82 17       	cp	r24, r18
     414:	93 07       	cpc	r25, r19
     416:	68 f1       	brcs	.+90     	; 0x472 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     418:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
     41a:	8e 01       	movw	r16, r28
     41c:	0e 5f       	subi	r16, 0xFE	; 254
     41e:	1f 4f       	sbci	r17, 0xFF	; 255
     420:	c8 01       	movw	r24, r16
     422:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     426:	8c 89       	ldd	r24, Y+20	; 0x14
     428:	9d 89       	ldd	r25, Y+21	; 0x15
     42a:	00 97       	sbiw	r24, 0x00	; 0
     42c:	21 f0       	breq	.+8      	; 0x436 <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
     42e:	ce 01       	movw	r24, r28
     430:	0c 96       	adiw	r24, 0x0c	; 12
     432:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     436:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     438:	8e 89       	ldd	r24, Y+22	; 0x16
     43a:	90 91 2a 02 	lds	r25, 0x022A
     43e:	98 17       	cp	r25, r24
     440:	10 f4       	brcc	.+4      	; 0x446 <vCoRoutineSchedule+0x15c>
     442:	80 93 2a 02 	sts	0x022A, r24
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	9c 01       	movw	r18, r24
     44a:	22 0f       	add	r18, r18
     44c:	33 1f       	adc	r19, r19
     44e:	22 0f       	add	r18, r18
     450:	33 1f       	adc	r19, r19
     452:	22 0f       	add	r18, r18
     454:	33 1f       	adc	r19, r19
     456:	82 0f       	add	r24, r18
     458:	93 1f       	adc	r25, r19
     45a:	85 5d       	subi	r24, 0xD5	; 213
     45c:	9d 4f       	sbci	r25, 0xFD	; 253
     45e:	b8 01       	movw	r22, r16
     460:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     464:	e0 91 58 02 	lds	r30, 0x0258
     468:	f0 91 59 02 	lds	r31, 0x0259
     46c:	80 81       	ld	r24, Z
     46e:	88 23       	and	r24, r24
     470:	29 f6       	brne	.-118    	; 0x3fc <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     472:	80 91 60 02 	lds	r24, 0x0260
     476:	90 91 61 02 	lds	r25, 0x0261
     47a:	00 97       	sbiw	r24, 0x00	; 0
     47c:	09 f0       	breq	.+2      	; 0x480 <vCoRoutineSchedule+0x196>
     47e:	85 cf       	rjmp	.-246    	; 0x38a <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     480:	80 91 5c 02 	lds	r24, 0x025C
     484:	90 91 5d 02 	lds	r25, 0x025D
     488:	90 93 5f 02 	sts	0x025F, r25
     48c:	80 93 5e 02 	sts	0x025E, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     490:	20 91 2a 02 	lds	r18, 0x022A
     494:	82 2f       	mov	r24, r18
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	fc 01       	movw	r30, r24
     49a:	ee 0f       	add	r30, r30
     49c:	ff 1f       	adc	r31, r31
     49e:	ee 0f       	add	r30, r30
     4a0:	ff 1f       	adc	r31, r31
     4a2:	ee 0f       	add	r30, r30
     4a4:	ff 1f       	adc	r31, r31
     4a6:	e8 0f       	add	r30, r24
     4a8:	f9 1f       	adc	r31, r25
     4aa:	e5 5d       	subi	r30, 0xD5	; 213
     4ac:	fd 4f       	sbci	r31, 0xFD	; 253
     4ae:	30 81       	ld	r19, Z
     4b0:	33 23       	and	r19, r19
     4b2:	d9 f4       	brne	.+54     	; 0x4ea <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     4b4:	22 23       	and	r18, r18
     4b6:	31 f4       	brne	.+12     	; 0x4c4 <vCoRoutineSchedule+0x1da>
     4b8:	47 c0       	rjmp	.+142    	; 0x548 <vCoRoutineSchedule+0x25e>
     4ba:	22 23       	and	r18, r18
     4bc:	19 f4       	brne	.+6      	; 0x4c4 <vCoRoutineSchedule+0x1da>
     4be:	20 93 2a 02 	sts	0x022A, r18
     4c2:	42 c0       	rjmp	.+132    	; 0x548 <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     4c4:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4c6:	82 2f       	mov	r24, r18
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	fc 01       	movw	r30, r24
     4cc:	ee 0f       	add	r30, r30
     4ce:	ff 1f       	adc	r31, r31
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	ee 0f       	add	r30, r30
     4d6:	ff 1f       	adc	r31, r31
     4d8:	e8 0f       	add	r30, r24
     4da:	f9 1f       	adc	r31, r25
     4dc:	e5 5d       	subi	r30, 0xD5	; 213
     4de:	fd 4f       	sbci	r31, 0xFD	; 253
     4e0:	30 81       	ld	r19, Z
     4e2:	33 23       	and	r19, r19
     4e4:	51 f3       	breq	.-44     	; 0x4ba <vCoRoutineSchedule+0x1d0>
     4e6:	20 93 2a 02 	sts	0x022A, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4ea:	fc 01       	movw	r30, r24
     4ec:	ee 0f       	add	r30, r30
     4ee:	ff 1f       	adc	r31, r31
     4f0:	ee 0f       	add	r30, r30
     4f2:	ff 1f       	adc	r31, r31
     4f4:	ee 0f       	add	r30, r30
     4f6:	ff 1f       	adc	r31, r31
     4f8:	8e 0f       	add	r24, r30
     4fa:	9f 1f       	adc	r25, r31
     4fc:	fc 01       	movw	r30, r24
     4fe:	e5 5d       	subi	r30, 0xD5	; 213
     500:	fd 4f       	sbci	r31, 0xFD	; 253
     502:	a1 81       	ldd	r26, Z+1	; 0x01
     504:	b2 81       	ldd	r27, Z+2	; 0x02
     506:	12 96       	adiw	r26, 0x02	; 2
     508:	0d 90       	ld	r0, X+
     50a:	bc 91       	ld	r27, X
     50c:	a0 2d       	mov	r26, r0
     50e:	b2 83       	std	Z+2, r27	; 0x02
     510:	a1 83       	std	Z+1, r26	; 0x01
     512:	cf 01       	movw	r24, r30
     514:	03 96       	adiw	r24, 0x03	; 3
     516:	a8 17       	cp	r26, r24
     518:	b9 07       	cpc	r27, r25
     51a:	31 f4       	brne	.+12     	; 0x528 <vCoRoutineSchedule+0x23e>
     51c:	12 96       	adiw	r26, 0x02	; 2
     51e:	8d 91       	ld	r24, X+
     520:	9c 91       	ld	r25, X
     522:	13 97       	sbiw	r26, 0x03	; 3
     524:	92 83       	std	Z+2, r25	; 0x02
     526:	81 83       	std	Z+1, r24	; 0x01
     528:	01 80       	ldd	r0, Z+1	; 0x01
     52a:	f2 81       	ldd	r31, Z+2	; 0x02
     52c:	e0 2d       	mov	r30, r0
     52e:	a6 81       	ldd	r26, Z+6	; 0x06
     530:	b7 81       	ldd	r27, Z+7	; 0x07
     532:	b0 93 29 02 	sts	0x0229, r27
     536:	a0 93 28 02 	sts	0x0228, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     53a:	ed 91       	ld	r30, X+
     53c:	fc 91       	ld	r31, X
     53e:	11 97       	sbiw	r26, 0x01	; 1
     540:	cd 01       	movw	r24, r26
     542:	57 96       	adiw	r26, 0x17	; 23
     544:	6c 91       	ld	r22, X
     546:	19 95       	eicall

	return;
}
     548:	df 91       	pop	r29
     54a:	cf 91       	pop	r28
     54c:	1f 91       	pop	r17
     54e:	0f 91       	pop	r16
     550:	ff 90       	pop	r15
     552:	ef 90       	pop	r14
     554:	df 90       	pop	r13
     556:	cf 90       	pop	r12
     558:	08 95       	ret

0000055a <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     55a:	0f 93       	push	r16
     55c:	1f 93       	push	r17
     55e:	cf 93       	push	r28
     560:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     562:	dc 01       	movw	r26, r24
     564:	15 96       	adiw	r26, 0x05	; 5
     566:	ed 91       	ld	r30, X+
     568:	fc 91       	ld	r31, X
     56a:	16 97       	sbiw	r26, 0x06	; 6
     56c:	06 81       	ldd	r16, Z+6	; 0x06
     56e:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     570:	e8 01       	movw	r28, r16
     572:	2c 96       	adiw	r28, 0x0c	; 12
     574:	ce 01       	movw	r24, r28
     576:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     57a:	8f e4       	ldi	r24, 0x4F	; 79
     57c:	92 e0       	ldi	r25, 0x02	; 2
     57e:	be 01       	movw	r22, r28
     580:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     584:	e0 91 28 02 	lds	r30, 0x0228
     588:	f0 91 29 02 	lds	r31, 0x0229
	{
		xReturn = pdTRUE;
     58c:	81 e0       	ldi	r24, 0x01	; 1
     58e:	d8 01       	movw	r26, r16
     590:	56 96       	adiw	r26, 0x16	; 22
     592:	2c 91       	ld	r18, X
     594:	56 97       	sbiw	r26, 0x16	; 22
     596:	96 89       	ldd	r25, Z+22	; 0x16
     598:	29 17       	cp	r18, r25
     59a:	08 f4       	brcc	.+2      	; 0x59e <xCoRoutineRemoveFromEventList+0x44>
     59c:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     59e:	df 91       	pop	r29
     5a0:	cf 91       	pop	r28
     5a2:	1f 91       	pop	r17
     5a4:	0f 91       	pop	r16
     5a6:	08 95       	ret

000005a8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5a8:	0f 93       	push	r16
     5aa:	1f 93       	push	r17
     5ac:	cf 93       	push	r28
     5ae:	df 93       	push	r29
     5b0:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     5b2:	0e 94 14 0c 	call	0x1828	; 0x1828 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     5b6:	00 91 62 02 	lds	r16, 0x0262
     5ba:	10 91 63 02 	lds	r17, 0x0263
     5be:	c0 0f       	add	r28, r16
     5c0:	d1 1f       	adc	r29, r17
     5c2:	88 e1       	ldi	r24, 0x18	; 24
     5c4:	c0 30       	cpi	r28, 0x00	; 0
     5c6:	d8 07       	cpc	r29, r24
     5c8:	50 f4       	brcc	.+20     	; 0x5de <pvPortMalloc+0x36>
     5ca:	0c 17       	cp	r16, r28
     5cc:	1d 07       	cpc	r17, r29
     5ce:	50 f4       	brcc	.+20     	; 0x5e4 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     5d0:	0c 59       	subi	r16, 0x9C	; 156
     5d2:	1d 4f       	sbci	r17, 0xFD	; 253
			xNextFreeByte += xWantedSize;
     5d4:	d0 93 63 02 	sts	0x0263, r29
     5d8:	c0 93 62 02 	sts	0x0262, r28
     5dc:	05 c0       	rjmp	.+10     	; 0x5e8 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5de:	00 e0       	ldi	r16, 0x00	; 0
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	02 c0       	rjmp	.+4      	; 0x5e8 <pvPortMalloc+0x40>
     5e4:	00 e0       	ldi	r16, 0x00	; 0
     5e6:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
     5e8:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5ec:	80 2f       	mov	r24, r16
     5ee:	91 2f       	mov	r25, r17
     5f0:	df 91       	pop	r29
     5f2:	cf 91       	pop	r28
     5f4:	1f 91       	pop	r17
     5f6:	0f 91       	pop	r16
     5f8:	08 95       	ret

000005fa <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     5fa:	08 95       	ret

000005fc <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     5fc:	10 92 63 02 	sts	0x0263, r1
     600:	10 92 62 02 	sts	0x0262, r1
}
     604:	08 95       	ret

00000606 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     606:	20 91 62 02 	lds	r18, 0x0262
     60a:	30 91 63 02 	lds	r19, 0x0263
     60e:	80 e0       	ldi	r24, 0x00	; 0
     610:	98 e1       	ldi	r25, 0x18	; 24
     612:	82 1b       	sub	r24, r18
     614:	93 0b       	sbc	r25, r19
}
     616:	08 95       	ret

00000618 <vTaskFunction_timerHandler>:
{
	for(;;)
	{
		xSemaphoreTake( xBinarySemaphore_timer, portMAX_DELAY );
		PORTA ^= (1 << LED7);//Toggle LED7
		TCNT2 = 0;
     618:	c2 eb       	ldi	r28, 0xB2	; 178
     61a:	d0 e0       	ldi	r29, 0x00	; 0

void vTaskFunction_timerHandler(void *pvNada)
{
	for(;;)
	{
		xSemaphoreTake( xBinarySemaphore_timer, portMAX_DELAY );
     61c:	80 91 bf 1a 	lds	r24, 0x1ABF
     620:	90 91 c0 1a 	lds	r25, 0x1AC0
     624:	60 e0       	ldi	r22, 0x00	; 0
     626:	70 e0       	ldi	r23, 0x00	; 0
     628:	4f ef       	ldi	r20, 0xFF	; 255
     62a:	5f ef       	ldi	r21, 0xFF	; 255
     62c:	20 e0       	ldi	r18, 0x00	; 0
     62e:	0e 94 c7 08 	call	0x118e	; 0x118e <xQueueGenericReceive>
		PORTA ^= (1 << LED7);//Toggle LED7
     632:	82 b1       	in	r24, 0x02	; 2
     634:	80 58       	subi	r24, 0x80	; 128
     636:	82 b9       	out	0x02, r24	; 2
		TCNT2 = 0;
     638:	18 82       	st	Y, r1
     63a:	f0 cf       	rjmp	.-32     	; 0x61c <vTaskFunction_timerHandler+0x4>

0000063c <vTaskFunction_buttonHandler>:
			led2.freq_delay = DELAY_MS_4HZ; // Set LED2 to blink at 4Hz
		}
		else // If it's asserted...
		{
			PORTA &= ~(1 << LED6); //Turn LED6 on
			OCR2A = TIMER2_7Hz; // Set timer2 to blink LED7 at 7Hz
     63c:	c3 eb       	ldi	r28, 0xB3	; 179
     63e:	d0 e0       	ldi	r29, 0x00	; 0
     640:	0f 2e       	mov	r0, r31
     642:	f7 e7       	ldi	r31, 0x77	; 119
     644:	ff 2e       	mov	r15, r31
     646:	f0 2d       	mov	r31, r0
			led2.freq_delay = DELAY_MS_2HZ; // Set LED2 to blink at 2Hz
     648:	0e e1       	ldi	r16, 0x1E	; 30
     64a:	12 e0       	ldi	r17, 0x02	; 2
     64c:	0f 2e       	mov	r0, r31
     64e:	fa ef       	ldi	r31, 0xFA	; 250
     650:	cf 2e       	mov	r12, r31
     652:	dd 24       	eor	r13, r13
     654:	f0 2d       	mov	r31, r0
		xSemaphoreTake( xBinarySemaphore_buttonPress, portMAX_DELAY );
		vTaskDelay(DEBOUNCE_DELAY / portTICK_RATE_MS); // Block task for debounce
		if(PINE & 0b10000000)// check if SW7 is asserted (active low)
		{
			PORTA |= (1 << LED6); //Turn LED6 off
			OCR2A = TIMER2_14Hz; // Set timer2 to blink LED7 at 14Hz
     656:	0f 2e       	mov	r0, r31
     658:	f4 ed       	ldi	r31, 0xD4	; 212
     65a:	ef 2e       	mov	r14, r31
     65c:	f0 2d       	mov	r31, r0
			led2.freq_delay = DELAY_MS_4HZ; // Set LED2 to blink at 4Hz
     65e:	0f 2e       	mov	r0, r31
     660:	fd e7       	ldi	r31, 0x7D	; 125
     662:	af 2e       	mov	r10, r31
     664:	bb 24       	eor	r11, r11
     666:	f0 2d       	mov	r31, r0

void vTaskFunction_buttonHandler(void *pvNada)
{	
	for(;;)
	{
		xSemaphoreTake( xBinarySemaphore_buttonPress, portMAX_DELAY );
     668:	80 91 c1 1a 	lds	r24, 0x1AC1
     66c:	90 91 c2 1a 	lds	r25, 0x1AC2
     670:	60 e0       	ldi	r22, 0x00	; 0
     672:	70 e0       	ldi	r23, 0x00	; 0
     674:	4f ef       	ldi	r20, 0xFF	; 255
     676:	5f ef       	ldi	r21, 0xFF	; 255
     678:	20 e0       	ldi	r18, 0x00	; 0
     67a:	0e 94 c7 08 	call	0x118e	; 0x118e <xQueueGenericReceive>
		vTaskDelay(DEBOUNCE_DELAY / portTICK_RATE_MS); // Block task for debounce
     67e:	84 e1       	ldi	r24, 0x14	; 20
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <vTaskDelay>
		if(PINE & 0b10000000)// check if SW7 is asserted (active low)
     686:	67 9b       	sbis	0x0c, 7	; 12
     688:	06 c0       	rjmp	.+12     	; 0x696 <vTaskFunction_buttonHandler+0x5a>
		{
			PORTA |= (1 << LED6); //Turn LED6 off
     68a:	16 9a       	sbi	0x02, 6	; 2
			OCR2A = TIMER2_14Hz; // Set timer2 to blink LED7 at 14Hz
     68c:	e8 82       	st	Y, r14
			led2.freq_delay = DELAY_MS_4HZ; // Set LED2 to blink at 4Hz
     68e:	f8 01       	movw	r30, r16
     690:	b1 82       	std	Z+1, r11	; 0x01
     692:	a0 82       	st	Z, r10
     694:	05 c0       	rjmp	.+10     	; 0x6a0 <vTaskFunction_buttonHandler+0x64>
		}
		else // If it's asserted...
		{
			PORTA &= ~(1 << LED6); //Turn LED6 on
     696:	16 98       	cbi	0x02, 6	; 2
			OCR2A = TIMER2_7Hz; // Set timer2 to blink LED7 at 7Hz
     698:	f8 82       	st	Y, r15
			led2.freq_delay = DELAY_MS_2HZ; // Set LED2 to blink at 2Hz
     69a:	f8 01       	movw	r30, r16
     69c:	d1 82       	std	Z+1, r13	; 0x01
     69e:	c0 82       	st	Z, r12
		}
		EIMSK |= (1<<INT7); //re-enable external interrupt mask for button
     6a0:	ef 9a       	sbi	0x1d, 7	; 29
	}
     6a2:	e2 cf       	rjmp	.-60     	; 0x668 <vTaskFunction_buttonHandler+0x2c>

000006a4 <vTaskFunction_LEDToggle>:
*		   the task to run at a desired frequency.
*
* return: void
*--------------------------------------------------------*/
void vTaskFunction_LEDToggle(void *target_led)
{
     6a4:	cf 93       	push	r28
     6a6:	df 93       	push	r29
     6a8:	0f 92       	push	r0
     6aa:	0f 92       	push	r0
     6ac:	cd b7       	in	r28, 0x3d	; 61
     6ae:	de b7       	in	r29, 0x3e	; 62
     6b0:	8c 01       	movw	r16, r24
	portTickType xLastWakeTime;
	// pointer to the value that describes which LED to toggle
	LED *local_led = (LED *) target_led;
	
	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
     6b2:	0e 94 1a 0c 	call	0x1834	; 0x1834 <xTaskGetTickCount>
     6b6:	9a 83       	std	Y+2, r25	; 0x02
     6b8:	89 83       	std	Y+1, r24	; 0x01
	for (;;)
	{
		// toggle the LED pin
		PORTA ^= (1 << local_led->pos);
     6ba:	ee 24       	eor	r14, r14
     6bc:	ff 24       	eor	r15, r15
     6be:	e3 94       	inc	r14
     6c0:	22 b1       	in	r18, 0x02	; 2
     6c2:	c7 01       	movw	r24, r14
     6c4:	f8 01       	movw	r30, r16
     6c6:	00 80       	ld	r0, Z
     6c8:	02 c0       	rjmp	.+4      	; 0x6ce <vTaskFunction_LEDToggle+0x2a>
     6ca:	88 0f       	add	r24, r24
     6cc:	99 1f       	adc	r25, r25
     6ce:	0a 94       	dec	r0
     6d0:	e2 f7       	brpl	.-8      	; 0x6ca <vTaskFunction_LEDToggle+0x26>
     6d2:	82 27       	eor	r24, r18
     6d4:	82 b9       	out	0x02, r24	; 2
		
		// periodically run every 'LED_delay_ms' milliseconds
		vTaskDelayUntil(&xLastWakeTime, local_led->freq_delay / portTICK_RATE_MS);
     6d6:	62 81       	ldd	r22, Z+2	; 0x02
     6d8:	73 81       	ldd	r23, Z+3	; 0x03
     6da:	ce 01       	movw	r24, r28
     6dc:	01 96       	adiw	r24, 0x01	; 1
     6de:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <vTaskDelayUntil>
     6e2:	ee cf       	rjmp	.-36     	; 0x6c0 <vTaskFunction_LEDToggle+0x1c>

000006e4 <main>:
xSemaphoreHandle xBinarySemaphore_buttonPress;
xSemaphoreHandle xBinarySemaphore_timer;

//-------------------Main Function-----------------------//
int main( void )
{  	
     6e4:	af 92       	push	r10
     6e6:	bf 92       	push	r11
     6e8:	cf 92       	push	r12
     6ea:	df 92       	push	r13
     6ec:	ef 92       	push	r14
     6ee:	ff 92       	push	r15
     6f0:	0f 93       	push	r16
    // Function initializing PORTA as an output and setting LEDs low, set PORTE as input
	vIO_init(); 
     6f2:	0e 94 96 00 	call	0x12c	; 0x12c <vIO_init>
	initialize_timer2();
     6f6:	0e 94 9b 00 	call	0x136	; 0x136 <initialize_timer2>
	initialize_button_read();
     6fa:	0e 94 a8 00 	call	0x150	; 0x150 <initialize_button_read>

	vSemaphoreCreateBinary( xBinarySemaphore_buttonPress );
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	60 e0       	ldi	r22, 0x00	; 0
     702:	43 e0       	ldi	r20, 0x03	; 3
     704:	0e 94 99 07 	call	0xf32	; 0xf32 <xQueueGenericCreate>
     708:	90 93 c2 1a 	sts	0x1AC2, r25
     70c:	80 93 c1 1a 	sts	0x1AC1, r24
     710:	00 97       	sbiw	r24, 0x00	; 0
     712:	39 f0       	breq	.+14     	; 0x722 <main+0x3e>
     714:	60 e0       	ldi	r22, 0x00	; 0
     716:	70 e0       	ldi	r23, 0x00	; 0
     718:	40 e0       	ldi	r20, 0x00	; 0
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	0e 94 ca 07 	call	0xf94	; 0xf94 <xQueueGenericSend>
	vSemaphoreCreateBinary( xBinarySemaphore_timer );
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	60 e0       	ldi	r22, 0x00	; 0
     726:	43 e0       	ldi	r20, 0x03	; 3
     728:	0e 94 99 07 	call	0xf32	; 0xf32 <xQueueGenericCreate>
     72c:	90 93 c0 1a 	sts	0x1AC0, r25
     730:	80 93 bf 1a 	sts	0x1ABF, r24
     734:	00 97       	sbiw	r24, 0x00	; 0
     736:	39 f0       	breq	.+14     	; 0x746 <main+0x62>
     738:	60 e0       	ldi	r22, 0x00	; 0
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	40 e0       	ldi	r20, 0x00	; 0
     73e:	50 e0       	ldi	r21, 0x00	; 0
     740:	20 e0       	ldi	r18, 0x00	; 0
     742:	0e 94 ca 07 	call	0xf94	; 0xf94 <xQueueGenericSend>
	
	// Creates a task to blink LED2
	xTaskCreate(vTaskFunction_LEDToggle, "LED2 Task", configMINIMAL_STACK_SIZE, (void *) &led2, 1, NULL );
     746:	82 e5       	ldi	r24, 0x52	; 82
     748:	93 e0       	ldi	r25, 0x03	; 3
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	72 e0       	ldi	r23, 0x02	; 2
     74e:	45 e5       	ldi	r20, 0x55	; 85
     750:	50 e0       	ldi	r21, 0x00	; 0
     752:	2c e1       	ldi	r18, 0x1C	; 28
     754:	32 e0       	ldi	r19, 0x02	; 2
     756:	01 e0       	ldi	r16, 0x01	; 1
     758:	ee 24       	eor	r14, r14
     75a:	ff 24       	eor	r15, r15
     75c:	cc 24       	eor	r12, r12
     75e:	dd 24       	eor	r13, r13
     760:	aa 24       	eor	r10, r10
     762:	bb 24       	eor	r11, r11
     764:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGenericCreate>
	// Creates a handler task for the interrupt generated by SW7
	xTaskCreate(vTaskFunction_buttonHandler, "BTN Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL );
     768:	8e e1       	ldi	r24, 0x1E	; 30
     76a:	93 e0       	ldi	r25, 0x03	; 3
     76c:	6a e0       	ldi	r22, 0x0A	; 10
     76e:	72 e0       	ldi	r23, 0x02	; 2
     770:	45 e5       	ldi	r20, 0x55	; 85
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	20 e0       	ldi	r18, 0x00	; 0
     776:	30 e0       	ldi	r19, 0x00	; 0
     778:	02 e0       	ldi	r16, 0x02	; 2
     77a:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGenericCreate>
	// Creates a handler task for the interrupt generated by Timer2 CTC
	xTaskCreate(vTaskFunction_timerHandler, "TMR Task", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     77e:	8c e0       	ldi	r24, 0x0C	; 12
     780:	93 e0       	ldi	r25, 0x03	; 3
     782:	63 e1       	ldi	r22, 0x13	; 19
     784:	72 e0       	ldi	r23, 0x02	; 2
     786:	45 e5       	ldi	r20, 0x55	; 85
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	20 e0       	ldi	r18, 0x00	; 0
     78c:	30 e0       	ldi	r19, 0x00	; 0
     78e:	01 e0       	ldi	r16, 0x01	; 1
     790:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGenericCreate>
	
    // Start the task scheduler
	vTaskStartScheduler();
     794:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vTaskStartScheduler>

	return 0;
}
     798:	80 e0       	ldi	r24, 0x00	; 0
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	0f 91       	pop	r16
     79e:	ff 90       	pop	r15
     7a0:	ef 90       	pop	r14
     7a2:	df 90       	pop	r13
     7a4:	cf 90       	pop	r12
     7a6:	bf 90       	pop	r11
     7a8:	af 90       	pop	r10
     7aa:	08 95       	ret

000007ac <__vector_13>:
*
* param a: TIMER2_COMPA_vect: vector generated when
*		   timer2 reaches the value held be OCR2A
*--------------------------------------------------------*/
ISR(TIMER2_COMPA_vect)
{
     7ac:	1f 92       	push	r1
     7ae:	0f 92       	push	r0
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	0f 92       	push	r0
     7b4:	0b b6       	in	r0, 0x3b	; 59
     7b6:	0f 92       	push	r0
     7b8:	11 24       	eor	r1, r1
     7ba:	2f 93       	push	r18
     7bc:	3f 93       	push	r19
     7be:	4f 93       	push	r20
     7c0:	5f 93       	push	r21
     7c2:	6f 93       	push	r22
     7c4:	7f 93       	push	r23
     7c6:	8f 93       	push	r24
     7c8:	9f 93       	push	r25
     7ca:	af 93       	push	r26
     7cc:	bf 93       	push	r27
     7ce:	ef 93       	push	r30
     7d0:	ff 93       	push	r31
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
     7d2:	10 92 64 1a 	sts	0x1A64, r1
	/* 'Give' the semaphore to unblock the task. */
	xSemaphoreGiveFromISR( xBinarySemaphore_timer, &xHigherPriorityTaskWoken );
     7d6:	80 91 bf 1a 	lds	r24, 0x1ABF
     7da:	90 91 c0 1a 	lds	r25, 0x1AC0
     7de:	60 e0       	ldi	r22, 0x00	; 0
     7e0:	70 e0       	ldi	r23, 0x00	; 0
     7e2:	44 e6       	ldi	r20, 0x64	; 100
     7e4:	5a e1       	ldi	r21, 0x1A	; 26
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	0e 94 95 08 	call	0x112a	; 0x112a <xQueueGenericSendFromISR>
	if( xHigherPriorityTaskWoken == pdTRUE )
     7ec:	80 91 64 1a 	lds	r24, 0x1A64
     7f0:	81 30       	cpi	r24, 0x01	; 1
     7f2:	11 f4       	brne	.+4      	; 0x7f8 <__vector_13+0x4c>
	{
		vPortYield();
     7f4:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
	}
}
     7f8:	ff 91       	pop	r31
     7fa:	ef 91       	pop	r30
     7fc:	bf 91       	pop	r27
     7fe:	af 91       	pop	r26
     800:	9f 91       	pop	r25
     802:	8f 91       	pop	r24
     804:	7f 91       	pop	r23
     806:	6f 91       	pop	r22
     808:	5f 91       	pop	r21
     80a:	4f 91       	pop	r20
     80c:	3f 91       	pop	r19
     80e:	2f 91       	pop	r18
     810:	0f 90       	pop	r0
     812:	0b be       	out	0x3b, r0	; 59
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	0f 90       	pop	r0
     81a:	1f 90       	pop	r1
     81c:	18 95       	reti

0000081e <__vector_8>:
*
* param a: INT7_vect: vector generated when
*		   a logic level change on pin E7 occurs
*--------------------------------------------------------*/
ISR(INT7_vect)
{
     81e:	1f 92       	push	r1
     820:	0f 92       	push	r0
     822:	0f b6       	in	r0, 0x3f	; 63
     824:	0f 92       	push	r0
     826:	0b b6       	in	r0, 0x3b	; 59
     828:	0f 92       	push	r0
     82a:	11 24       	eor	r1, r1
     82c:	2f 93       	push	r18
     82e:	3f 93       	push	r19
     830:	4f 93       	push	r20
     832:	5f 93       	push	r21
     834:	6f 93       	push	r22
     836:	7f 93       	push	r23
     838:	8f 93       	push	r24
     83a:	9f 93       	push	r25
     83c:	af 93       	push	r26
     83e:	bf 93       	push	r27
     840:	ef 93       	push	r30
     842:	ff 93       	push	r31
	EIMSK &= ~(1<<INT7);//disable external interrupt mask
     844:	ef 98       	cbi	0x1d, 7	; 29
	EIFR &= (1 << INTF7); //clear the interrupt flag, just in case debounce queued another vector
     846:	8c b3       	in	r24, 0x1c	; 28
     848:	80 78       	andi	r24, 0x80	; 128
     84a:	8c bb       	out	0x1c, r24	; 28
	
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
     84c:	10 92 65 1a 	sts	0x1A65, r1
	/* 'Give' the semaphore to unblock the task. */
	xSemaphoreGiveFromISR( xBinarySemaphore_buttonPress, &xHigherPriorityTaskWoken );
     850:	80 91 c1 1a 	lds	r24, 0x1AC1
     854:	90 91 c2 1a 	lds	r25, 0x1AC2
     858:	60 e0       	ldi	r22, 0x00	; 0
     85a:	70 e0       	ldi	r23, 0x00	; 0
     85c:	45 e6       	ldi	r20, 0x65	; 101
     85e:	5a e1       	ldi	r21, 0x1A	; 26
     860:	20 e0       	ldi	r18, 0x00	; 0
     862:	0e 94 95 08 	call	0x112a	; 0x112a <xQueueGenericSendFromISR>
	if( xHigherPriorityTaskWoken == pdTRUE )
     866:	80 91 65 1a 	lds	r24, 0x1A65
     86a:	81 30       	cpi	r24, 0x01	; 1
     86c:	11 f4       	brne	.+4      	; 0x872 <__vector_8+0x54>
	{
		vPortYield();
     86e:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
	}		
}
     872:	ff 91       	pop	r31
     874:	ef 91       	pop	r30
     876:	bf 91       	pop	r27
     878:	af 91       	pop	r26
     87a:	9f 91       	pop	r25
     87c:	8f 91       	pop	r24
     87e:	7f 91       	pop	r23
     880:	6f 91       	pop	r22
     882:	5f 91       	pop	r21
     884:	4f 91       	pop	r20
     886:	3f 91       	pop	r19
     888:	2f 91       	pop	r18
     88a:	0f 90       	pop	r0
     88c:	0b be       	out	0x3b, r0	; 59
     88e:	0f 90       	pop	r0
     890:	0f be       	out	0x3f, r0	; 63
     892:	0f 90       	pop	r0
     894:	1f 90       	pop	r1
     896:	18 95       	reti

00000898 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     898:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     89a:	03 96       	adiw	r24, 0x03	; 3
     89c:	92 83       	std	Z+2, r25	; 0x02
     89e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8a0:	2f ef       	ldi	r18, 0xFF	; 255
     8a2:	3f ef       	ldi	r19, 0xFF	; 255
     8a4:	34 83       	std	Z+4, r19	; 0x04
     8a6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     8a8:	96 83       	std	Z+6, r25	; 0x06
     8aa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     8ac:	90 87       	std	Z+8, r25	; 0x08
     8ae:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     8b0:	10 82       	st	Z, r1
}
     8b2:	08 95       	ret

000008b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8b4:	fc 01       	movw	r30, r24
     8b6:	11 86       	std	Z+9, r1	; 0x09
     8b8:	10 86       	std	Z+8, r1	; 0x08
}
     8ba:	08 95       	ret

000008bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	ec 01       	movw	r28, r24
     8c2:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     8c4:	89 81       	ldd	r24, Y+1	; 0x01
     8c6:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     8c8:	dc 01       	movw	r26, r24
     8ca:	12 96       	adiw	r26, 0x02	; 2
     8cc:	2d 91       	ld	r18, X+
     8ce:	3c 91       	ld	r19, X
     8d0:	13 97       	sbiw	r26, 0x03	; 3
     8d2:	33 83       	std	Z+3, r19	; 0x03
     8d4:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     8d6:	29 81       	ldd	r18, Y+1	; 0x01
     8d8:	3a 81       	ldd	r19, Y+2	; 0x02
     8da:	35 83       	std	Z+5, r19	; 0x05
     8dc:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8de:	12 96       	adiw	r26, 0x02	; 2
     8e0:	2d 91       	ld	r18, X+
     8e2:	3c 91       	ld	r19, X
     8e4:	13 97       	sbiw	r26, 0x03	; 3
     8e6:	d9 01       	movw	r26, r18
     8e8:	15 96       	adiw	r26, 0x05	; 5
     8ea:	7c 93       	st	X, r23
     8ec:	6e 93       	st	-X, r22
     8ee:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     8f0:	dc 01       	movw	r26, r24
     8f2:	13 96       	adiw	r26, 0x03	; 3
     8f4:	7c 93       	st	X, r23
     8f6:	6e 93       	st	-X, r22
     8f8:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     8fa:	7a 83       	std	Y+2, r23	; 0x02
     8fc:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8fe:	d1 87       	std	Z+9, r29	; 0x09
     900:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     902:	88 81       	ld	r24, Y
     904:	8f 5f       	subi	r24, 0xFF	; 255
     906:	88 83       	st	Y, r24
}
     908:	df 91       	pop	r29
     90a:	cf 91       	pop	r28
     90c:	08 95       	ret

0000090e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     90e:	cf 93       	push	r28
     910:	df 93       	push	r29
     912:	ac 01       	movw	r20, r24
     914:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     916:	28 81       	ld	r18, Y
     918:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     91a:	8f ef       	ldi	r24, 0xFF	; 255
     91c:	2f 3f       	cpi	r18, 0xFF	; 255
     91e:	38 07       	cpc	r19, r24
     920:	21 f4       	brne	.+8      	; 0x92a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     922:	fa 01       	movw	r30, r20
     924:	a7 81       	ldd	r26, Z+7	; 0x07
     926:	b0 85       	ldd	r27, Z+8	; 0x08
     928:	18 c0       	rjmp	.+48     	; 0x95a <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     92a:	da 01       	movw	r26, r20
     92c:	13 96       	adiw	r26, 0x03	; 3
     92e:	fa 01       	movw	r30, r20
     930:	85 81       	ldd	r24, Z+5	; 0x05
     932:	96 81       	ldd	r25, Z+6	; 0x06
     934:	fc 01       	movw	r30, r24
     936:	80 81       	ld	r24, Z
     938:	91 81       	ldd	r25, Z+1	; 0x01
     93a:	28 17       	cp	r18, r24
     93c:	39 07       	cpc	r19, r25
     93e:	68 f0       	brcs	.+26     	; 0x95a <vListInsert+0x4c>
     940:	12 96       	adiw	r26, 0x02	; 2
     942:	0d 90       	ld	r0, X+
     944:	bc 91       	ld	r27, X
     946:	a0 2d       	mov	r26, r0
     948:	12 96       	adiw	r26, 0x02	; 2
     94a:	ed 91       	ld	r30, X+
     94c:	fc 91       	ld	r31, X
     94e:	13 97       	sbiw	r26, 0x03	; 3
     950:	80 81       	ld	r24, Z
     952:	91 81       	ldd	r25, Z+1	; 0x01
     954:	28 17       	cp	r18, r24
     956:	39 07       	cpc	r19, r25
     958:	98 f7       	brcc	.-26     	; 0x940 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     95a:	12 96       	adiw	r26, 0x02	; 2
     95c:	ed 91       	ld	r30, X+
     95e:	fc 91       	ld	r31, X
     960:	13 97       	sbiw	r26, 0x03	; 3
     962:	fb 83       	std	Y+3, r31	; 0x03
     964:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     966:	d5 83       	std	Z+5, r29	; 0x05
     968:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     96a:	bd 83       	std	Y+5, r27	; 0x05
     96c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     96e:	13 96       	adiw	r26, 0x03	; 3
     970:	dc 93       	st	X, r29
     972:	ce 93       	st	-X, r28
     974:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     976:	59 87       	std	Y+9, r21	; 0x09
     978:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     97a:	fa 01       	movw	r30, r20
     97c:	80 81       	ld	r24, Z
     97e:	8f 5f       	subi	r24, 0xFF	; 255
     980:	80 83       	st	Z, r24
}
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	08 95       	ret

00000988 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     988:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     98a:	a2 81       	ldd	r26, Z+2	; 0x02
     98c:	b3 81       	ldd	r27, Z+3	; 0x03
     98e:	84 81       	ldd	r24, Z+4	; 0x04
     990:	95 81       	ldd	r25, Z+5	; 0x05
     992:	15 96       	adiw	r26, 0x05	; 5
     994:	9c 93       	st	X, r25
     996:	8e 93       	st	-X, r24
     998:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     99a:	a4 81       	ldd	r26, Z+4	; 0x04
     99c:	b5 81       	ldd	r27, Z+5	; 0x05
     99e:	82 81       	ldd	r24, Z+2	; 0x02
     9a0:	93 81       	ldd	r25, Z+3	; 0x03
     9a2:	13 96       	adiw	r26, 0x03	; 3
     9a4:	9c 93       	st	X, r25
     9a6:	8e 93       	st	-X, r24
     9a8:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     9aa:	a0 85       	ldd	r26, Z+8	; 0x08
     9ac:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9ae:	11 96       	adiw	r26, 0x01	; 1
     9b0:	8d 91       	ld	r24, X+
     9b2:	9c 91       	ld	r25, X
     9b4:	12 97       	sbiw	r26, 0x02	; 2
     9b6:	8e 17       	cp	r24, r30
     9b8:	9f 07       	cpc	r25, r31
     9ba:	31 f4       	brne	.+12     	; 0x9c8 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9bc:	84 81       	ldd	r24, Z+4	; 0x04
     9be:	95 81       	ldd	r25, Z+5	; 0x05
     9c0:	12 96       	adiw	r26, 0x02	; 2
     9c2:	9c 93       	st	X, r25
     9c4:	8e 93       	st	-X, r24
     9c6:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     9c8:	11 86       	std	Z+9, r1	; 0x09
     9ca:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9cc:	8c 91       	ld	r24, X
     9ce:	81 50       	subi	r24, 0x01	; 1
     9d0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     9d2:	8c 91       	ld	r24, X
}
     9d4:	08 95       	ret

000009d6 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     9d6:	21 e1       	ldi	r18, 0x11	; 17
     9d8:	fc 01       	movw	r30, r24
     9da:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     9dc:	31 97       	sbiw	r30, 0x01	; 1
     9de:	32 e2       	ldi	r19, 0x22	; 34
     9e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     9e2:	fc 01       	movw	r30, r24
     9e4:	32 97       	sbiw	r30, 0x02	; 2
     9e6:	a3 e3       	ldi	r26, 0x33	; 51
     9e8:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     9ea:	fc 01       	movw	r30, r24
     9ec:	33 97       	sbiw	r30, 0x03	; 3
     9ee:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     9f0:	fc 01       	movw	r30, r24
     9f2:	34 97       	sbiw	r30, 0x04	; 4
     9f4:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     9f6:	fc 01       	movw	r30, r24
     9f8:	35 97       	sbiw	r30, 0x05	; 5
     9fa:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     9fc:	fc 01       	movw	r30, r24
     9fe:	36 97       	sbiw	r30, 0x06	; 6
     a00:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     a02:	fc 01       	movw	r30, r24
     a04:	37 97       	sbiw	r30, 0x07	; 7
     a06:	60 e8       	ldi	r22, 0x80	; 128
     a08:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     a0a:	fc 01       	movw	r30, r24
     a0c:	38 97       	sbiw	r30, 0x08	; 8
     a0e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     a10:	fc 01       	movw	r30, r24
     a12:	39 97       	sbiw	r30, 0x09	; 9
     a14:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     a16:	fc 01       	movw	r30, r24
     a18:	3a 97       	sbiw	r30, 0x0a	; 10
     a1a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     a1c:	fc 01       	movw	r30, r24
     a1e:	3b 97       	sbiw	r30, 0x0b	; 11
     a20:	62 e0       	ldi	r22, 0x02	; 2
     a22:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     a24:	fc 01       	movw	r30, r24
     a26:	3c 97       	sbiw	r30, 0x0c	; 12
     a28:	63 e0       	ldi	r22, 0x03	; 3
     a2a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     a2c:	fc 01       	movw	r30, r24
     a2e:	3d 97       	sbiw	r30, 0x0d	; 13
     a30:	64 e0       	ldi	r22, 0x04	; 4
     a32:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     a34:	fc 01       	movw	r30, r24
     a36:	3e 97       	sbiw	r30, 0x0e	; 14
     a38:	65 e0       	ldi	r22, 0x05	; 5
     a3a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     a3c:	fc 01       	movw	r30, r24
     a3e:	3f 97       	sbiw	r30, 0x0f	; 15
     a40:	66 e0       	ldi	r22, 0x06	; 6
     a42:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     a44:	fc 01       	movw	r30, r24
     a46:	70 97       	sbiw	r30, 0x10	; 16
     a48:	67 e0       	ldi	r22, 0x07	; 7
     a4a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     a4c:	fc 01       	movw	r30, r24
     a4e:	71 97       	sbiw	r30, 0x11	; 17
     a50:	68 e0       	ldi	r22, 0x08	; 8
     a52:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     a54:	fc 01       	movw	r30, r24
     a56:	72 97       	sbiw	r30, 0x12	; 18
     a58:	69 e0       	ldi	r22, 0x09	; 9
     a5a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     a5c:	fc 01       	movw	r30, r24
     a5e:	73 97       	sbiw	r30, 0x13	; 19
     a60:	60 e1       	ldi	r22, 0x10	; 16
     a62:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     a64:	fc 01       	movw	r30, r24
     a66:	74 97       	sbiw	r30, 0x14	; 20
     a68:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     a6a:	fc 01       	movw	r30, r24
     a6c:	75 97       	sbiw	r30, 0x15	; 21
     a6e:	22 e1       	ldi	r18, 0x12	; 18
     a70:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     a72:	fc 01       	movw	r30, r24
     a74:	76 97       	sbiw	r30, 0x16	; 22
     a76:	23 e1       	ldi	r18, 0x13	; 19
     a78:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     a7a:	fc 01       	movw	r30, r24
     a7c:	77 97       	sbiw	r30, 0x17	; 23
     a7e:	24 e1       	ldi	r18, 0x14	; 20
     a80:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     a82:	fc 01       	movw	r30, r24
     a84:	78 97       	sbiw	r30, 0x18	; 24
     a86:	25 e1       	ldi	r18, 0x15	; 21
     a88:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     a8a:	fc 01       	movw	r30, r24
     a8c:	79 97       	sbiw	r30, 0x19	; 25
     a8e:	26 e1       	ldi	r18, 0x16	; 22
     a90:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     a92:	fc 01       	movw	r30, r24
     a94:	7a 97       	sbiw	r30, 0x1a	; 26
     a96:	27 e1       	ldi	r18, 0x17	; 23
     a98:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     a9a:	fc 01       	movw	r30, r24
     a9c:	7b 97       	sbiw	r30, 0x1b	; 27
     a9e:	28 e1       	ldi	r18, 0x18	; 24
     aa0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     aa2:	fc 01       	movw	r30, r24
     aa4:	7c 97       	sbiw	r30, 0x1c	; 28
     aa6:	29 e1       	ldi	r18, 0x19	; 25
     aa8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     aaa:	fc 01       	movw	r30, r24
     aac:	7d 97       	sbiw	r30, 0x1d	; 29
     aae:	20 e2       	ldi	r18, 0x20	; 32
     ab0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     ab2:	fc 01       	movw	r30, r24
     ab4:	7e 97       	sbiw	r30, 0x1e	; 30
     ab6:	21 e2       	ldi	r18, 0x21	; 33
     ab8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     aba:	fc 01       	movw	r30, r24
     abc:	7f 97       	sbiw	r30, 0x1f	; 31
     abe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     ac0:	fc 01       	movw	r30, r24
     ac2:	b0 97       	sbiw	r30, 0x20	; 32
     ac4:	23 e2       	ldi	r18, 0x23	; 35
     ac6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ac8:	fc 01       	movw	r30, r24
     aca:	b1 97       	sbiw	r30, 0x21	; 33
     acc:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ace:	fc 01       	movw	r30, r24
     ad0:	b2 97       	sbiw	r30, 0x22	; 34
     ad2:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     ad4:	fc 01       	movw	r30, r24
     ad6:	b3 97       	sbiw	r30, 0x23	; 35
     ad8:	26 e2       	ldi	r18, 0x26	; 38
     ada:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     adc:	fc 01       	movw	r30, r24
     ade:	b4 97       	sbiw	r30, 0x24	; 36
     ae0:	27 e2       	ldi	r18, 0x27	; 39
     ae2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     ae4:	fc 01       	movw	r30, r24
     ae6:	b5 97       	sbiw	r30, 0x25	; 37
     ae8:	28 e2       	ldi	r18, 0x28	; 40
     aea:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     aec:	fc 01       	movw	r30, r24
     aee:	b6 97       	sbiw	r30, 0x26	; 38
     af0:	29 e2       	ldi	r18, 0x29	; 41
     af2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     af4:	fc 01       	movw	r30, r24
     af6:	b7 97       	sbiw	r30, 0x27	; 39
     af8:	20 e3       	ldi	r18, 0x30	; 48
     afa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     afc:	fc 01       	movw	r30, r24
     afe:	b8 97       	sbiw	r30, 0x28	; 40
     b00:	21 e3       	ldi	r18, 0x31	; 49
     b02:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     b04:	89 97       	sbiw	r24, 0x29	; 41
}
     b06:	08 95       	ret

00000b08 <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
     b08:	10 92 99 00 	sts	0x0099, r1

#endif

    portOCRL = ucLowByte;
     b0c:	89 ef       	ldi	r24, 0xF9	; 249
     b0e:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
     b12:	8b e0       	ldi	r24, 0x0B	; 11
     b14:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     b18:	e1 e7       	ldi	r30, 0x71	; 113
     b1a:	f0 e0       	ldi	r31, 0x00	; 0
     b1c:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     b1e:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
     b20:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     b22:	a0 91 66 1a 	lds	r26, 0x1A66
     b26:	b0 91 67 1a 	lds	r27, 0x1A67
     b2a:	cd 91       	ld	r28, X+
     b2c:	cd bf       	out	0x3d, r28	; 61
     b2e:	dd 91       	ld	r29, X+
     b30:	de bf       	out	0x3e, r29	; 62
     b32:	ff 91       	pop	r31
     b34:	ef 91       	pop	r30
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	bf 91       	pop	r27
     b3c:	af 91       	pop	r26
     b3e:	9f 91       	pop	r25
     b40:	8f 91       	pop	r24
     b42:	7f 91       	pop	r23
     b44:	6f 91       	pop	r22
     b46:	5f 91       	pop	r21
     b48:	4f 91       	pop	r20
     b4a:	3f 91       	pop	r19
     b4c:	2f 91       	pop	r18
     b4e:	1f 91       	pop	r17
     b50:	0f 91       	pop	r16
     b52:	ff 90       	pop	r15
     b54:	ef 90       	pop	r14
     b56:	df 90       	pop	r13
     b58:	cf 90       	pop	r12
     b5a:	bf 90       	pop	r11
     b5c:	af 90       	pop	r10
     b5e:	9f 90       	pop	r9
     b60:	8f 90       	pop	r8
     b62:	7f 90       	pop	r7
     b64:	6f 90       	pop	r6
     b66:	5f 90       	pop	r5
     b68:	4f 90       	pop	r4
     b6a:	3f 90       	pop	r3
     b6c:	2f 90       	pop	r2
     b6e:	1f 90       	pop	r1
     b70:	0f 90       	pop	r0
     b72:	0c be       	out	0x3c, r0	; 60
     b74:	0f 90       	pop	r0
     b76:	0b be       	out	0x3b, r0	; 59
     b78:	0f 90       	pop	r0
     b7a:	0f be       	out	0x3f, r0	; 63
     b7c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     b7e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     b80:	81 e0       	ldi	r24, 0x01	; 1
     b82:	08 95       	ret

00000b84 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     b84:	08 95       	ret

00000b86 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b86:	0f 92       	push	r0
     b88:	0f b6       	in	r0, 0x3f	; 63
     b8a:	f8 94       	cli
     b8c:	0f 92       	push	r0
     b8e:	0b b6       	in	r0, 0x3b	; 59
     b90:	0f 92       	push	r0
     b92:	0c b6       	in	r0, 0x3c	; 60
     b94:	0f 92       	push	r0
     b96:	1f 92       	push	r1
     b98:	11 24       	eor	r1, r1
     b9a:	2f 92       	push	r2
     b9c:	3f 92       	push	r3
     b9e:	4f 92       	push	r4
     ba0:	5f 92       	push	r5
     ba2:	6f 92       	push	r6
     ba4:	7f 92       	push	r7
     ba6:	8f 92       	push	r8
     ba8:	9f 92       	push	r9
     baa:	af 92       	push	r10
     bac:	bf 92       	push	r11
     bae:	cf 92       	push	r12
     bb0:	df 92       	push	r13
     bb2:	ef 92       	push	r14
     bb4:	ff 92       	push	r15
     bb6:	0f 93       	push	r16
     bb8:	1f 93       	push	r17
     bba:	2f 93       	push	r18
     bbc:	3f 93       	push	r19
     bbe:	4f 93       	push	r20
     bc0:	5f 93       	push	r21
     bc2:	6f 93       	push	r22
     bc4:	7f 93       	push	r23
     bc6:	8f 93       	push	r24
     bc8:	9f 93       	push	r25
     bca:	af 93       	push	r26
     bcc:	bf 93       	push	r27
     bce:	cf 93       	push	r28
     bd0:	df 93       	push	r29
     bd2:	ef 93       	push	r30
     bd4:	ff 93       	push	r31
     bd6:	a0 91 66 1a 	lds	r26, 0x1A66
     bda:	b0 91 67 1a 	lds	r27, 0x1A67
     bde:	0d b6       	in	r0, 0x3d	; 61
     be0:	0d 92       	st	X+, r0
     be2:	0e b6       	in	r0, 0x3e	; 62
     be4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     be6:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bea:	a0 91 66 1a 	lds	r26, 0x1A66
     bee:	b0 91 67 1a 	lds	r27, 0x1A67
     bf2:	cd 91       	ld	r28, X+
     bf4:	cd bf       	out	0x3d, r28	; 61
     bf6:	dd 91       	ld	r29, X+
     bf8:	de bf       	out	0x3e, r29	; 62
     bfa:	ff 91       	pop	r31
     bfc:	ef 91       	pop	r30
     bfe:	df 91       	pop	r29
     c00:	cf 91       	pop	r28
     c02:	bf 91       	pop	r27
     c04:	af 91       	pop	r26
     c06:	9f 91       	pop	r25
     c08:	8f 91       	pop	r24
     c0a:	7f 91       	pop	r23
     c0c:	6f 91       	pop	r22
     c0e:	5f 91       	pop	r21
     c10:	4f 91       	pop	r20
     c12:	3f 91       	pop	r19
     c14:	2f 91       	pop	r18
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	ef 90       	pop	r14
     c1e:	df 90       	pop	r13
     c20:	cf 90       	pop	r12
     c22:	bf 90       	pop	r11
     c24:	af 90       	pop	r10
     c26:	9f 90       	pop	r9
     c28:	8f 90       	pop	r8
     c2a:	7f 90       	pop	r7
     c2c:	6f 90       	pop	r6
     c2e:	5f 90       	pop	r5
     c30:	4f 90       	pop	r4
     c32:	3f 90       	pop	r3
     c34:	2f 90       	pop	r2
     c36:	1f 90       	pop	r1
     c38:	0f 90       	pop	r0
     c3a:	0c be       	out	0x3c, r0	; 60
     c3c:	0f 90       	pop	r0
     c3e:	0b be       	out	0x3b, r0	; 59
     c40:	0f 90       	pop	r0
     c42:	0f be       	out	0x3f, r0	; 63
     c44:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c46:	08 95       	ret

00000c48 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c48:	0f 92       	push	r0
     c4a:	0f b6       	in	r0, 0x3f	; 63
     c4c:	f8 94       	cli
     c4e:	0f 92       	push	r0
     c50:	0b b6       	in	r0, 0x3b	; 59
     c52:	0f 92       	push	r0
     c54:	0c b6       	in	r0, 0x3c	; 60
     c56:	0f 92       	push	r0
     c58:	1f 92       	push	r1
     c5a:	11 24       	eor	r1, r1
     c5c:	2f 92       	push	r2
     c5e:	3f 92       	push	r3
     c60:	4f 92       	push	r4
     c62:	5f 92       	push	r5
     c64:	6f 92       	push	r6
     c66:	7f 92       	push	r7
     c68:	8f 92       	push	r8
     c6a:	9f 92       	push	r9
     c6c:	af 92       	push	r10
     c6e:	bf 92       	push	r11
     c70:	cf 92       	push	r12
     c72:	df 92       	push	r13
     c74:	ef 92       	push	r14
     c76:	ff 92       	push	r15
     c78:	0f 93       	push	r16
     c7a:	1f 93       	push	r17
     c7c:	2f 93       	push	r18
     c7e:	3f 93       	push	r19
     c80:	4f 93       	push	r20
     c82:	5f 93       	push	r21
     c84:	6f 93       	push	r22
     c86:	7f 93       	push	r23
     c88:	8f 93       	push	r24
     c8a:	9f 93       	push	r25
     c8c:	af 93       	push	r26
     c8e:	bf 93       	push	r27
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	ef 93       	push	r30
     c96:	ff 93       	push	r31
     c98:	a0 91 66 1a 	lds	r26, 0x1A66
     c9c:	b0 91 67 1a 	lds	r27, 0x1A67
     ca0:	0d b6       	in	r0, 0x3d	; 61
     ca2:	0d 92       	st	X+, r0
     ca4:	0e b6       	in	r0, 0x3e	; 62
     ca6:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     ca8:	0e 94 2c 0c 	call	0x1858	; 0x1858 <vTaskIncrementTick>
	vTaskSwitchContext();
     cac:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cb0:	a0 91 66 1a 	lds	r26, 0x1A66
     cb4:	b0 91 67 1a 	lds	r27, 0x1A67
     cb8:	cd 91       	ld	r28, X+
     cba:	cd bf       	out	0x3d, r28	; 61
     cbc:	dd 91       	ld	r29, X+
     cbe:	de bf       	out	0x3e, r29	; 62
     cc0:	ff 91       	pop	r31
     cc2:	ef 91       	pop	r30
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	bf 91       	pop	r27
     cca:	af 91       	pop	r26
     ccc:	9f 91       	pop	r25
     cce:	8f 91       	pop	r24
     cd0:	7f 91       	pop	r23
     cd2:	6f 91       	pop	r22
     cd4:	5f 91       	pop	r21
     cd6:	4f 91       	pop	r20
     cd8:	3f 91       	pop	r19
     cda:	2f 91       	pop	r18
     cdc:	1f 91       	pop	r17
     cde:	0f 91       	pop	r16
     ce0:	ff 90       	pop	r15
     ce2:	ef 90       	pop	r14
     ce4:	df 90       	pop	r13
     ce6:	cf 90       	pop	r12
     ce8:	bf 90       	pop	r11
     cea:	af 90       	pop	r10
     cec:	9f 90       	pop	r9
     cee:	8f 90       	pop	r8
     cf0:	7f 90       	pop	r7
     cf2:	6f 90       	pop	r6
     cf4:	5f 90       	pop	r5
     cf6:	4f 90       	pop	r4
     cf8:	3f 90       	pop	r3
     cfa:	2f 90       	pop	r2
     cfc:	1f 90       	pop	r1
     cfe:	0f 90       	pop	r0
     d00:	0c be       	out	0x3c, r0	; 60
     d02:	0f 90       	pop	r0
     d04:	0b be       	out	0x3b, r0	; 59
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63
     d0a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d0c:	08 95       	ret

00000d0e <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
     d0e:	0e 94 24 06 	call	0xc48	; 0xc48 <vPortYieldFromTick>
			asm volatile ( "reti" );
     d12:	18 95       	reti

00000d14 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
     d18:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     d1a:	cd 91       	ld	r28, X+
     d1c:	dc 91       	ld	r29, X
     d1e:	11 97       	sbiw	r26, 0x01	; 1
     d20:	20 97       	sbiw	r28, 0x00	; 0
     d22:	21 f1       	breq	.+72     	; 0xd6c <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     d24:	5c 96       	adiw	r26, 0x1c	; 28
     d26:	4c 91       	ld	r20, X
     d28:	5c 97       	sbiw	r26, 0x1c	; 28
     d2a:	16 96       	adiw	r26, 0x06	; 6
     d2c:	2d 91       	ld	r18, X+
     d2e:	3c 91       	ld	r19, X
     d30:	17 97       	sbiw	r26, 0x07	; 7
     d32:	24 0f       	add	r18, r20
     d34:	31 1d       	adc	r19, r1
     d36:	17 96       	adiw	r26, 0x07	; 7
     d38:	3c 93       	st	X, r19
     d3a:	2e 93       	st	-X, r18
     d3c:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     d3e:	12 96       	adiw	r26, 0x02	; 2
     d40:	ed 91       	ld	r30, X+
     d42:	fc 91       	ld	r31, X
     d44:	13 97       	sbiw	r26, 0x03	; 3
     d46:	2e 17       	cp	r18, r30
     d48:	3f 07       	cpc	r19, r31
     d4a:	20 f0       	brcs	.+8      	; 0xd54 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     d4c:	17 96       	adiw	r26, 0x07	; 7
     d4e:	dc 93       	st	X, r29
     d50:	ce 93       	st	-X, r28
     d52:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     d54:	16 96       	adiw	r26, 0x06	; 6
     d56:	3c 91       	ld	r19, X
     d58:	16 97       	sbiw	r26, 0x06	; 6
     d5a:	17 96       	adiw	r26, 0x07	; 7
     d5c:	2c 91       	ld	r18, X
     d5e:	86 2f       	mov	r24, r22
     d60:	97 2f       	mov	r25, r23
     d62:	63 2f       	mov	r22, r19
     d64:	72 2f       	mov	r23, r18
     d66:	50 e0       	ldi	r21, 0x00	; 0
     d68:	0e 94 07 10 	call	0x200e	; 0x200e <memcpy>
	}
}
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	08 95       	ret

00000d72 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     d72:	0f 93       	push	r16
     d74:	1f 93       	push	r17
     d76:	cf 93       	push	r28
     d78:	df 93       	push	r29
     d7a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     d82:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d84:	18 16       	cp	r1, r24
     d86:	c4 f4       	brge	.+48     	; 0xdb8 <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d88:	89 89       	ldd	r24, Y+17	; 0x11
     d8a:	88 23       	and	r24, r24
     d8c:	29 f4       	brne	.+10     	; 0xd98 <prvUnlockQueue+0x26>
     d8e:	14 c0       	rjmp	.+40     	; 0xdb8 <prvUnlockQueue+0x46>
     d90:	89 89       	ldd	r24, Y+17	; 0x11
     d92:	88 23       	and	r24, r24
     d94:	21 f4       	brne	.+8      	; 0xd9e <prvUnlockQueue+0x2c>
     d96:	10 c0       	rjmp	.+32     	; 0xdb8 <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d98:	8e 01       	movw	r16, r28
     d9a:	0f 5e       	subi	r16, 0xEF	; 239
     d9c:	1f 4f       	sbci	r17, 0xFF	; 255
     d9e:	c8 01       	movw	r24, r16
     da0:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
     da4:	88 23       	and	r24, r24
     da6:	11 f0       	breq	.+4      	; 0xdac <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     da8:	0e 94 56 0f 	call	0x1eac	; 0x1eac <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     dac:	8e 8d       	ldd	r24, Y+30	; 0x1e
     dae:	81 50       	subi	r24, 0x01	; 1
     db0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     db2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     db4:	18 16       	cp	r1, r24
     db6:	64 f3       	brlt	.-40     	; 0xd90 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     db8:	8f ef       	ldi	r24, 0xFF	; 255
     dba:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     dc6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     dc8:	18 16       	cp	r1, r24
     dca:	c4 f4       	brge	.+48     	; 0xdfc <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dcc:	88 85       	ldd	r24, Y+8	; 0x08
     dce:	88 23       	and	r24, r24
     dd0:	29 f4       	brne	.+10     	; 0xddc <prvUnlockQueue+0x6a>
     dd2:	14 c0       	rjmp	.+40     	; 0xdfc <prvUnlockQueue+0x8a>
     dd4:	88 85       	ldd	r24, Y+8	; 0x08
     dd6:	88 23       	and	r24, r24
     dd8:	21 f4       	brne	.+8      	; 0xde2 <prvUnlockQueue+0x70>
     dda:	10 c0       	rjmp	.+32     	; 0xdfc <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ddc:	8e 01       	movw	r16, r28
     dde:	08 5f       	subi	r16, 0xF8	; 248
     de0:	1f 4f       	sbci	r17, 0xFF	; 255
     de2:	c8 01       	movw	r24, r16
     de4:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
     de8:	88 23       	and	r24, r24
     dea:	11 f0       	breq	.+4      	; 0xdf0 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
     dec:	0e 94 56 0f 	call	0x1eac	; 0x1eac <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     df0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     df2:	81 50       	subi	r24, 0x01	; 1
     df4:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     df6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     df8:	18 16       	cp	r1, r24
     dfa:	64 f3       	brlt	.-40     	; 0xdd4 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     dfc:	8f ef       	ldi	r24, 0xFF	; 255
     dfe:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e00:	0f 90       	pop	r0
     e02:	0f be       	out	0x3f, r0	; 63
}
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	1f 91       	pop	r17
     e0a:	0f 91       	pop	r16
     e0c:	08 95       	ret

00000e0e <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     e0e:	cf 93       	push	r28
     e10:	df 93       	push	r29
     e12:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     e14:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e16:	22 23       	and	r18, r18
     e18:	59 f4       	brne	.+22     	; 0xe30 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e1a:	88 81       	ld	r24, Y
     e1c:	99 81       	ldd	r25, Y+1	; 0x01
     e1e:	00 97       	sbiw	r24, 0x00	; 0
     e20:	e1 f5       	brne	.+120    	; 0xe9a <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     e22:	8a 81       	ldd	r24, Y+2	; 0x02
     e24:	9b 81       	ldd	r25, Y+3	; 0x03
     e26:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     e2a:	1b 82       	std	Y+3, r1	; 0x03
     e2c:	1a 82       	std	Y+2, r1	; 0x02
     e2e:	35 c0       	rjmp	.+106    	; 0xe9a <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     e30:	44 23       	and	r20, r20
     e32:	b9 f4       	brne	.+46     	; 0xe62 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     e34:	8c 81       	ldd	r24, Y+4	; 0x04
     e36:	9d 81       	ldd	r25, Y+5	; 0x05
     e38:	42 2f       	mov	r20, r18
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 07 10 	call	0x200e	; 0x200e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     e40:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e42:	8c 81       	ldd	r24, Y+4	; 0x04
     e44:	9d 81       	ldd	r25, Y+5	; 0x05
     e46:	82 0f       	add	r24, r18
     e48:	91 1d       	adc	r25, r1
     e4a:	9d 83       	std	Y+5, r25	; 0x05
     e4c:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     e4e:	2a 81       	ldd	r18, Y+2	; 0x02
     e50:	3b 81       	ldd	r19, Y+3	; 0x03
     e52:	82 17       	cp	r24, r18
     e54:	93 07       	cpc	r25, r19
     e56:	08 f1       	brcs	.+66     	; 0xe9a <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     e58:	88 81       	ld	r24, Y
     e5a:	99 81       	ldd	r25, Y+1	; 0x01
     e5c:	9d 83       	std	Y+5, r25	; 0x05
     e5e:	8c 83       	std	Y+4, r24	; 0x04
     e60:	1c c0       	rjmp	.+56     	; 0xe9a <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     e62:	8e 81       	ldd	r24, Y+6	; 0x06
     e64:	9f 81       	ldd	r25, Y+7	; 0x07
     e66:	42 2f       	mov	r20, r18
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	0e 94 07 10 	call	0x200e	; 0x200e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     e6e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     e70:	50 e0       	ldi	r21, 0x00	; 0
     e72:	50 95       	com	r21
     e74:	41 95       	neg	r20
     e76:	5f 4f       	sbci	r21, 0xFF	; 255
     e78:	8e 81       	ldd	r24, Y+6	; 0x06
     e7a:	9f 81       	ldd	r25, Y+7	; 0x07
     e7c:	84 0f       	add	r24, r20
     e7e:	95 1f       	adc	r25, r21
     e80:	9f 83       	std	Y+7, r25	; 0x07
     e82:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     e84:	28 81       	ld	r18, Y
     e86:	39 81       	ldd	r19, Y+1	; 0x01
     e88:	82 17       	cp	r24, r18
     e8a:	93 07       	cpc	r25, r19
     e8c:	30 f4       	brcc	.+12     	; 0xe9a <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     e8e:	8a 81       	ldd	r24, Y+2	; 0x02
     e90:	9b 81       	ldd	r25, Y+3	; 0x03
     e92:	48 0f       	add	r20, r24
     e94:	59 1f       	adc	r21, r25
     e96:	5f 83       	std	Y+7, r21	; 0x07
     e98:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     e9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e9c:	8f 5f       	subi	r24, 0xFF	; 255
     e9e:	8a 8f       	std	Y+26, r24	; 0x1a
}
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	08 95       	ret

00000ea6 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
     ea6:	cf 93       	push	r28
     ea8:	df 93       	push	r29
     eaa:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     eac:	0f b6       	in	r0, 0x3f	; 63
     eae:	f8 94       	cli
     eb0:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     eb2:	48 81       	ld	r20, Y
     eb4:	59 81       	ldd	r21, Y+1	; 0x01
     eb6:	2b 8d       	ldd	r18, Y+27	; 0x1b
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	ec 8d       	ldd	r30, Y+28	; 0x1c
     ebc:	f0 e0       	ldi	r31, 0x00	; 0
     ebe:	2e 9f       	mul	r18, r30
     ec0:	c0 01       	movw	r24, r0
     ec2:	2f 9f       	mul	r18, r31
     ec4:	90 0d       	add	r25, r0
     ec6:	3e 9f       	mul	r19, r30
     ec8:	90 0d       	add	r25, r0
     eca:	11 24       	eor	r1, r1
     ecc:	84 0f       	add	r24, r20
     ece:	95 1f       	adc	r25, r21
     ed0:	9b 83       	std	Y+3, r25	; 0x03
     ed2:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     ed4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     ed6:	5d 83       	std	Y+5, r21	; 0x05
     ed8:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     eda:	c9 01       	movw	r24, r18
     edc:	01 97       	sbiw	r24, 0x01	; 1
     ede:	e8 9f       	mul	r30, r24
     ee0:	90 01       	movw	r18, r0
     ee2:	e9 9f       	mul	r30, r25
     ee4:	30 0d       	add	r19, r0
     ee6:	f8 9f       	mul	r31, r24
     ee8:	30 0d       	add	r19, r0
     eea:	11 24       	eor	r1, r1
     eec:	24 0f       	add	r18, r20
     eee:	35 1f       	adc	r19, r21
     ef0:	3f 83       	std	Y+7, r19	; 0x07
     ef2:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     ef4:	8f ef       	ldi	r24, 0xFF	; 255
     ef6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     ef8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     efa:	66 23       	and	r22, r22
     efc:	61 f4       	brne	.+24     	; 0xf16 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     efe:	88 85       	ldd	r24, Y+8	; 0x08
     f00:	88 23       	and	r24, r24
     f02:	89 f0       	breq	.+34     	; 0xf26 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     f04:	ce 01       	movw	r24, r28
     f06:	08 96       	adiw	r24, 0x08	; 8
     f08:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
     f0c:	81 30       	cpi	r24, 0x01	; 1
     f0e:	59 f4       	brne	.+22     	; 0xf26 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
     f10:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
     f14:	08 c0       	rjmp	.+16     	; 0xf26 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     f16:	ce 01       	movw	r24, r28
     f18:	08 96       	adiw	r24, 0x08	; 8
     f1a:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     f1e:	ce 01       	movw	r24, r28
     f20:	41 96       	adiw	r24, 0x11	; 17
     f22:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret

00000f32 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     f32:	0f 93       	push	r16
     f34:	1f 93       	push	r17
     f36:	cf 93       	push	r28
     f38:	df 93       	push	r29
     f3a:	18 2f       	mov	r17, r24
     f3c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     f3e:	88 23       	and	r24, r24
     f40:	f9 f0       	breq	.+62     	; 0xf80 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     f42:	8f e1       	ldi	r24, 0x1F	; 31
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <pvPortMalloc>
     f4a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f4c:	00 97       	sbiw	r24, 0x00	; 0
     f4e:	d9 f0       	breq	.+54     	; 0xf86 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     f50:	01 9f       	mul	r16, r17
     f52:	c0 01       	movw	r24, r0
     f54:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     f56:	01 96       	adiw	r24, 0x01	; 1
     f58:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <pvPortMalloc>
     f5c:	99 83       	std	Y+1, r25	; 0x01
     f5e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     f60:	00 97       	sbiw	r24, 0x00	; 0
     f62:	41 f0       	breq	.+16     	; 0xf74 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     f64:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     f66:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
     f68:	ce 01       	movw	r24, r28
     f6a:	61 e0       	ldi	r22, 0x01	; 1
     f6c:	0e 94 53 07 	call	0xea6	; 0xea6 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     f70:	ce 01       	movw	r24, r28
     f72:	0b c0       	rjmp	.+22     	; 0xf8a <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     f74:	ce 01       	movw	r24, r28
     f76:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	05 c0       	rjmp	.+10     	; 0xf8a <xQueueGenericCreate+0x58>
     f80:	80 e0       	ldi	r24, 0x00	; 0
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	02 c0       	rjmp	.+4      	; 0xf8a <xQueueGenericCreate+0x58>
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	1f 91       	pop	r17
     f90:	0f 91       	pop	r16
     f92:	08 95       	ret

00000f94 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     f94:	8f 92       	push	r8
     f96:	9f 92       	push	r9
     f98:	bf 92       	push	r11
     f9a:	cf 92       	push	r12
     f9c:	df 92       	push	r13
     f9e:	ef 92       	push	r14
     fa0:	ff 92       	push	r15
     fa2:	0f 93       	push	r16
     fa4:	1f 93       	push	r17
     fa6:	cf 93       	push	r28
     fa8:	df 93       	push	r29
     faa:	00 d0       	rcall	.+0      	; 0xfac <xQueueGenericSend+0x18>
     fac:	0f 92       	push	r0
     fae:	0f 92       	push	r0
     fb0:	cd b7       	in	r28, 0x3d	; 61
     fb2:	de b7       	in	r29, 0x3e	; 62
     fb4:	8c 01       	movw	r16, r24
     fb6:	4b 01       	movw	r8, r22
     fb8:	5d 83       	std	Y+5, r21	; 0x05
     fba:	4c 83       	std	Y+4, r20	; 0x04
     fbc:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     fbe:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     fc0:	ee 24       	eor	r14, r14
     fc2:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     fc4:	cc 24       	eor	r12, r12
     fc6:	dd 24       	eor	r13, r13
     fc8:	68 94       	set
     fca:	c3 f8       	bld	r12, 3
     fcc:	c8 0e       	add	r12, r24
     fce:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     fd0:	0f b6       	in	r0, 0x3f	; 63
     fd2:	f8 94       	cli
     fd4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     fd6:	f8 01       	movw	r30, r16
     fd8:	92 8d       	ldd	r25, Z+26	; 0x1a
     fda:	83 8d       	ldd	r24, Z+27	; 0x1b
     fdc:	98 17       	cp	r25, r24
     fde:	a8 f4       	brcc	.+42     	; 0x100a <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     fe0:	c8 01       	movw	r24, r16
     fe2:	b4 01       	movw	r22, r8
     fe4:	4b 2d       	mov	r20, r11
     fe6:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fea:	f8 01       	movw	r30, r16
     fec:	81 89       	ldd	r24, Z+17	; 0x11
     fee:	88 23       	and	r24, r24
     ff0:	41 f0       	breq	.+16     	; 0x1002 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     ff2:	c8 01       	movw	r24, r16
     ff4:	41 96       	adiw	r24, 0x11	; 17
     ff6:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
     ffa:	81 30       	cpi	r24, 0x01	; 1
     ffc:	11 f4       	brne	.+4      	; 0x1002 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     ffe:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	52 c0       	rjmp	.+164    	; 0x10ae <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    100a:	8c 81       	ldd	r24, Y+4	; 0x04
    100c:	9d 81       	ldd	r25, Y+5	; 0x05
    100e:	00 97       	sbiw	r24, 0x00	; 0
    1010:	21 f4       	brne	.+8      	; 0x101a <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1012:	0f 90       	pop	r0
    1014:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	4a c0       	rjmp	.+148    	; 0x10ae <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    101a:	ff 20       	and	r15, r15
    101c:	29 f4       	brne	.+10     	; 0x1028 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    101e:	ce 01       	movw	r24, r28
    1020:	01 96       	adiw	r24, 0x01	; 1
    1022:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1026:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1028:	0f 90       	pop	r0
    102a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    102c:	0e 94 14 0c 	call	0x1828	; 0x1828 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1030:	0f b6       	in	r0, 0x3f	; 63
    1032:	f8 94       	cli
    1034:	0f 92       	push	r0
    1036:	f8 01       	movw	r30, r16
    1038:	85 8d       	ldd	r24, Z+29	; 0x1d
    103a:	8f 3f       	cpi	r24, 0xFF	; 255
    103c:	09 f4       	brne	.+2      	; 0x1040 <xQueueGenericSend+0xac>
    103e:	15 8e       	std	Z+29, r1	; 0x1d
    1040:	f8 01       	movw	r30, r16
    1042:	86 8d       	ldd	r24, Z+30	; 0x1e
    1044:	8f 3f       	cpi	r24, 0xFF	; 255
    1046:	09 f4       	brne	.+2      	; 0x104a <xQueueGenericSend+0xb6>
    1048:	16 8e       	std	Z+30, r1	; 0x1e
    104a:	0f 90       	pop	r0
    104c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    104e:	ce 01       	movw	r24, r28
    1050:	01 96       	adiw	r24, 0x01	; 1
    1052:	be 01       	movw	r22, r28
    1054:	6c 5f       	subi	r22, 0xFC	; 252
    1056:	7f 4f       	sbci	r23, 0xFF	; 255
    1058:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <xTaskCheckForTimeOut>
    105c:	88 23       	and	r24, r24
    105e:	09 f5       	brne	.+66     	; 0x10a2 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1060:	0f b6       	in	r0, 0x3f	; 63
    1062:	f8 94       	cli
    1064:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1066:	f8 01       	movw	r30, r16
    1068:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    106e:	f8 01       	movw	r30, r16
    1070:	83 8d       	ldd	r24, Z+27	; 0x1b
    1072:	98 17       	cp	r25, r24
    1074:	81 f4       	brne	.+32     	; 0x1096 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1076:	6c 81       	ldd	r22, Y+4	; 0x04
    1078:	7d 81       	ldd	r23, Y+5	; 0x05
    107a:	c6 01       	movw	r24, r12
    107c:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1080:	c8 01       	movw	r24, r16
    1082:	0e 94 b9 06 	call	0xd72	; 0xd72 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1086:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
    108a:	88 23       	and	r24, r24
    108c:	09 f0       	breq	.+2      	; 0x1090 <xQueueGenericSend+0xfc>
    108e:	a0 cf       	rjmp	.-192    	; 0xfd0 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    1090:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
    1094:	9d cf       	rjmp	.-198    	; 0xfd0 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1096:	c8 01       	movw	r24, r16
    1098:	0e 94 b9 06 	call	0xd72	; 0xd72 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    109c:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
    10a0:	97 cf       	rjmp	.-210    	; 0xfd0 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    10a2:	c8 01       	movw	r24, r16
    10a4:	0e 94 b9 06 	call	0xd72	; 0xd72 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10a8:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    10ac:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	cf 90       	pop	r12
    10c8:	bf 90       	pop	r11
    10ca:	9f 90       	pop	r9
    10cc:	8f 90       	pop	r8
    10ce:	08 95       	ret

000010d0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    10d0:	cf 93       	push	r28
    10d2:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    10d4:	8f e1       	ldi	r24, 0x1F	; 31
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <pvPortMalloc>
    10dc:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    10de:	00 97       	sbiw	r24, 0x00	; 0
    10e0:	f9 f0       	breq	.+62     	; 0x1120 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    10e2:	1b 82       	std	Y+3, r1	; 0x03
    10e4:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    10e6:	19 82       	std	Y+1, r1	; 0x01
    10e8:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    10ea:	1d 82       	std	Y+5, r1	; 0x05
    10ec:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    10ee:	1f 82       	std	Y+7, r1	; 0x07
    10f0:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    10f2:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    10f4:	81 e0       	ldi	r24, 0x01	; 1
    10f6:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    10f8:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    10fa:	8f ef       	ldi	r24, 0xFF	; 255
    10fc:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    10fe:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1100:	ce 01       	movw	r24, r28
    1102:	08 96       	adiw	r24, 0x08	; 8
    1104:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1108:	ce 01       	movw	r24, r28
    110a:	41 96       	adiw	r24, 0x11	; 17
    110c:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1110:	ce 01       	movw	r24, r28
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	70 e0       	ldi	r23, 0x00	; 0
    1116:	40 e0       	ldi	r20, 0x00	; 0
    1118:	50 e0       	ldi	r21, 0x00	; 0
    111a:	20 e0       	ldi	r18, 0x00	; 0
    111c:	0e 94 ca 07 	call	0xf94	; 0xf94 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1120:	8c 2f       	mov	r24, r28
    1122:	9d 2f       	mov	r25, r29
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	08 95       	ret

0000112a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    112a:	0f 93       	push	r16
    112c:	1f 93       	push	r17
    112e:	cf 93       	push	r28
    1130:	df 93       	push	r29
    1132:	ec 01       	movw	r28, r24
    1134:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1136:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1138:	8b 8d       	ldd	r24, Y+27	; 0x1b
    113a:	98 17       	cp	r25, r24
    113c:	e0 f4       	brcc	.+56     	; 0x1176 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    113e:	ce 01       	movw	r24, r28
    1140:	42 2f       	mov	r20, r18
    1142:	0e 94 07 07 	call	0xe0e	; 0xe0e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1146:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1148:	8f 3f       	cpi	r24, 0xFF	; 255
    114a:	81 f4       	brne	.+32     	; 0x116c <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    114c:	89 89       	ldd	r24, Y+17	; 0x11
    114e:	88 23       	and	r24, r24
    1150:	a1 f0       	breq	.+40     	; 0x117a <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1152:	ce 01       	movw	r24, r28
    1154:	41 96       	adiw	r24, 0x11	; 17
    1156:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
    115a:	88 23       	and	r24, r24
    115c:	81 f0       	breq	.+32     	; 0x117e <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    115e:	01 15       	cp	r16, r1
    1160:	11 05       	cpc	r17, r1
    1162:	79 f0       	breq	.+30     	; 0x1182 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	f8 01       	movw	r30, r16
    1168:	80 83       	st	Z, r24
    116a:	0c c0       	rjmp	.+24     	; 0x1184 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    116c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    116e:	8f 5f       	subi	r24, 0xFF	; 255
    1170:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	07 c0       	rjmp	.+14     	; 0x1184 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1176:	80 e0       	ldi	r24, 0x00	; 0
    1178:	05 c0       	rjmp	.+10     	; 0x1184 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	03 c0       	rjmp	.+6      	; 0x1184 <xQueueGenericSendFromISR+0x5a>
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	01 c0       	rjmp	.+2      	; 0x1184 <xQueueGenericSendFromISR+0x5a>
    1182:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1184:	df 91       	pop	r29
    1186:	cf 91       	pop	r28
    1188:	1f 91       	pop	r17
    118a:	0f 91       	pop	r16
    118c:	08 95       	ret

0000118e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    118e:	8f 92       	push	r8
    1190:	9f 92       	push	r9
    1192:	bf 92       	push	r11
    1194:	cf 92       	push	r12
    1196:	df 92       	push	r13
    1198:	ef 92       	push	r14
    119a:	ff 92       	push	r15
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	00 d0       	rcall	.+0      	; 0x11a6 <xQueueGenericReceive+0x18>
    11a6:	0f 92       	push	r0
    11a8:	0f 92       	push	r0
    11aa:	cd b7       	in	r28, 0x3d	; 61
    11ac:	de b7       	in	r29, 0x3e	; 62
    11ae:	8c 01       	movw	r16, r24
    11b0:	4b 01       	movw	r8, r22
    11b2:	5d 83       	std	Y+5, r21	; 0x05
    11b4:	4c 83       	std	Y+4, r20	; 0x04
    11b6:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    11b8:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    11ba:	ee 24       	eor	r14, r14
    11bc:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    11be:	0f 2e       	mov	r0, r31
    11c0:	f1 e1       	ldi	r31, 0x11	; 17
    11c2:	cf 2e       	mov	r12, r31
    11c4:	dd 24       	eor	r13, r13
    11c6:	f0 2d       	mov	r31, r0
    11c8:	c8 0e       	add	r12, r24
    11ca:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	f8 94       	cli
    11d0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    11d2:	f8 01       	movw	r30, r16
    11d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    11d6:	88 23       	and	r24, r24
    11d8:	a1 f1       	breq	.+104    	; 0x1242 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    11da:	e6 80       	ldd	r14, Z+6	; 0x06
    11dc:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    11de:	c8 01       	movw	r24, r16
    11e0:	b4 01       	movw	r22, r8
    11e2:	0e 94 8a 06 	call	0xd14	; 0xd14 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    11e6:	bb 20       	and	r11, r11
    11e8:	d1 f4       	brne	.+52     	; 0x121e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    11ea:	f8 01       	movw	r30, r16
    11ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    11ee:	81 50       	subi	r24, 0x01	; 1
    11f0:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    11f2:	80 81       	ld	r24, Z
    11f4:	91 81       	ldd	r25, Z+1	; 0x01
    11f6:	00 97       	sbiw	r24, 0x00	; 0
    11f8:	29 f4       	brne	.+10     	; 0x1204 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    11fa:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <xTaskGetCurrentTaskHandle>
    11fe:	f8 01       	movw	r30, r16
    1200:	93 83       	std	Z+3, r25	; 0x03
    1202:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1204:	f8 01       	movw	r30, r16
    1206:	80 85       	ldd	r24, Z+8	; 0x08
    1208:	88 23       	and	r24, r24
    120a:	b9 f0       	breq	.+46     	; 0x123a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    120c:	c8 01       	movw	r24, r16
    120e:	08 96       	adiw	r24, 0x08	; 8
    1210:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
    1214:	81 30       	cpi	r24, 0x01	; 1
    1216:	89 f4       	brne	.+34     	; 0x123a <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    1218:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
    121c:	0e c0       	rjmp	.+28     	; 0x123a <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    121e:	f8 01       	movw	r30, r16
    1220:	f7 82       	std	Z+7, r15	; 0x07
    1222:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1224:	81 89       	ldd	r24, Z+17	; 0x11
    1226:	88 23       	and	r24, r24
    1228:	41 f0       	breq	.+16     	; 0x123a <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    122a:	c8 01       	movw	r24, r16
    122c:	41 96       	adiw	r24, 0x11	; 17
    122e:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
    1232:	88 23       	and	r24, r24
    1234:	11 f0       	breq	.+4      	; 0x123a <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1236:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    123a:	0f 90       	pop	r0
    123c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	5f c0       	rjmp	.+190    	; 0x1300 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1242:	8c 81       	ldd	r24, Y+4	; 0x04
    1244:	9d 81       	ldd	r25, Y+5	; 0x05
    1246:	00 97       	sbiw	r24, 0x00	; 0
    1248:	21 f4       	brne	.+8      	; 0x1252 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    124a:	0f 90       	pop	r0
    124c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    124e:	80 e0       	ldi	r24, 0x00	; 0
    1250:	57 c0       	rjmp	.+174    	; 0x1300 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    1252:	ff 20       	and	r15, r15
    1254:	29 f4       	brne	.+10     	; 0x1260 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1256:	ce 01       	movw	r24, r28
    1258:	01 96       	adiw	r24, 0x01	; 1
    125a:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    125e:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1260:	0f 90       	pop	r0
    1262:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1264:	0e 94 14 0c 	call	0x1828	; 0x1828 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	0f 92       	push	r0
    126e:	f8 01       	movw	r30, r16
    1270:	85 8d       	ldd	r24, Z+29	; 0x1d
    1272:	8f 3f       	cpi	r24, 0xFF	; 255
    1274:	09 f4       	brne	.+2      	; 0x1278 <xQueueGenericReceive+0xea>
    1276:	15 8e       	std	Z+29, r1	; 0x1d
    1278:	f8 01       	movw	r30, r16
    127a:	86 8d       	ldd	r24, Z+30	; 0x1e
    127c:	8f 3f       	cpi	r24, 0xFF	; 255
    127e:	09 f4       	brne	.+2      	; 0x1282 <xQueueGenericReceive+0xf4>
    1280:	16 8e       	std	Z+30, r1	; 0x1e
    1282:	0f 90       	pop	r0
    1284:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1286:	ce 01       	movw	r24, r28
    1288:	01 96       	adiw	r24, 0x01	; 1
    128a:	be 01       	movw	r22, r28
    128c:	6c 5f       	subi	r22, 0xFC	; 252
    128e:	7f 4f       	sbci	r23, 0xFF	; 255
    1290:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <xTaskCheckForTimeOut>
    1294:	88 23       	and	r24, r24
    1296:	71 f5       	brne	.+92     	; 0x12f4 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    129e:	f8 01       	movw	r30, r16
    12a0:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    12a6:	88 23       	and	r24, r24
    12a8:	f9 f4       	brne	.+62     	; 0x12e8 <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12aa:	f8 01       	movw	r30, r16
    12ac:	80 81       	ld	r24, Z
    12ae:	91 81       	ldd	r25, Z+1	; 0x01
    12b0:	00 97       	sbiw	r24, 0x00	; 0
    12b2:	51 f4       	brne	.+20     	; 0x12c8 <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	f8 94       	cli
    12b8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    12ba:	f8 01       	movw	r30, r16
    12bc:	82 81       	ldd	r24, Z+2	; 0x02
    12be:	93 81       	ldd	r25, Z+3	; 0x03
    12c0:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    12c4:	0f 90       	pop	r0
    12c6:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    12c8:	6c 81       	ldd	r22, Y+4	; 0x04
    12ca:	7d 81       	ldd	r23, Y+5	; 0x05
    12cc:	c6 01       	movw	r24, r12
    12ce:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    12d2:	c8 01       	movw	r24, r16
    12d4:	0e 94 b9 06 	call	0xd72	; 0xd72 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    12d8:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
    12dc:	88 23       	and	r24, r24
    12de:	09 f0       	breq	.+2      	; 0x12e2 <xQueueGenericReceive+0x154>
    12e0:	75 cf       	rjmp	.-278    	; 0x11cc <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    12e2:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
    12e6:	72 cf       	rjmp	.-284    	; 0x11cc <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12e8:	c8 01       	movw	r24, r16
    12ea:	0e 94 b9 06 	call	0xd72	; 0xd72 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12ee:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
    12f2:	6c cf       	rjmp	.-296    	; 0x11cc <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    12f4:	c8 01       	movw	r24, r16
    12f6:	0e 94 b9 06 	call	0xd72	; 0xd72 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12fa:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    12fe:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1300:	0f 90       	pop	r0
    1302:	0f 90       	pop	r0
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	df 91       	pop	r29
    130c:	cf 91       	pop	r28
    130e:	1f 91       	pop	r17
    1310:	0f 91       	pop	r16
    1312:	ff 90       	pop	r15
    1314:	ef 90       	pop	r14
    1316:	df 90       	pop	r13
    1318:	cf 90       	pop	r12
    131a:	bf 90       	pop	r11
    131c:	9f 90       	pop	r9
    131e:	8f 90       	pop	r8
    1320:	08 95       	ret

00001322 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1322:	0f 93       	push	r16
    1324:	1f 93       	push	r17
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	ec 01       	movw	r28, r24
    132c:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    132e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1330:	88 23       	and	r24, r24
    1332:	f1 f0       	breq	.+60     	; 0x1370 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1334:	ce 01       	movw	r24, r28
    1336:	0e 94 8a 06 	call	0xd14	; 0xd14 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    133a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    133c:	81 50       	subi	r24, 0x01	; 1
    133e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1340:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1342:	8f 3f       	cpi	r24, 0xFF	; 255
    1344:	81 f4       	brne	.+32     	; 0x1366 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1346:	88 85       	ldd	r24, Y+8	; 0x08
    1348:	88 23       	and	r24, r24
    134a:	a1 f0       	breq	.+40     	; 0x1374 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    134c:	ce 01       	movw	r24, r28
    134e:	08 96       	adiw	r24, 0x08	; 8
    1350:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <xTaskRemoveFromEventList>
    1354:	88 23       	and	r24, r24
    1356:	81 f0       	breq	.+32     	; 0x1378 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1358:	01 15       	cp	r16, r1
    135a:	11 05       	cpc	r17, r1
    135c:	79 f0       	breq	.+30     	; 0x137c <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	f8 01       	movw	r30, r16
    1362:	80 83       	st	Z, r24
    1364:	0c c0       	rjmp	.+24     	; 0x137e <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1366:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1368:	8f 5f       	subi	r24, 0xFF	; 255
    136a:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	07 c0       	rjmp	.+14     	; 0x137e <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1370:	80 e0       	ldi	r24, 0x00	; 0
    1372:	05 c0       	rjmp	.+10     	; 0x137e <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	03 c0       	rjmp	.+6      	; 0x137e <xQueueReceiveFromISR+0x5c>
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	01 c0       	rjmp	.+2      	; 0x137e <xQueueReceiveFromISR+0x5c>
    137c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	1f 91       	pop	r17
    1384:	0f 91       	pop	r16
    1386:	08 95       	ret

00001388 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	f8 94       	cli
    138c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    138e:	fc 01       	movw	r30, r24
    1390:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1396:	08 95       	ret

00001398 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1398:	fc 01       	movw	r30, r24
    139a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    139c:	08 95       	ret

0000139e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    139e:	cf 93       	push	r28
    13a0:	df 93       	push	r29
    13a2:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    13a4:	88 81       	ld	r24, Y
    13a6:	99 81       	ldd	r25, Y+1	; 0x01
    13a8:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vPortFree>
	vPortFree( pxQueue );
    13ac:	ce 01       	movw	r24, r28
    13ae:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vPortFree>
}
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	08 95       	ret

000013b8 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    13b8:	fc 01       	movw	r30, r24
    13ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	91 11       	cpse	r25, r1
    13c0:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    13c2:	08 95       	ret

000013c4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    13c4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    13c6:	22 8d       	ldd	r18, Z+26	; 0x1a
    13c8:	81 e0       	ldi	r24, 0x01	; 1
    13ca:	93 8d       	ldd	r25, Z+27	; 0x1b
    13cc:	29 13       	cpse	r18, r25
    13ce:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    13d0:	08 95       	ret

000013d2 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    13d2:	cf 93       	push	r28
    13d4:	df 93       	push	r29
    13d6:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    13d8:	e0 91 66 1a 	lds	r30, 0x1A66
    13dc:	f0 91 67 1a 	lds	r31, 0x1A67
    13e0:	93 83       	std	Z+3, r25	; 0x03
    13e2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    13e4:	80 91 6e 1a 	lds	r24, 0x1A6E
    13e8:	90 91 6f 1a 	lds	r25, 0x1A6F
    13ec:	c8 17       	cp	r28, r24
    13ee:	d9 07       	cpc	r29, r25
    13f0:	68 f4       	brcc	.+26     	; 0x140c <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13f2:	80 91 71 1a 	lds	r24, 0x1A71
    13f6:	90 91 72 1a 	lds	r25, 0x1A72
    13fa:	60 91 66 1a 	lds	r22, 0x1A66
    13fe:	70 91 67 1a 	lds	r23, 0x1A67
    1402:	6e 5f       	subi	r22, 0xFE	; 254
    1404:	7f 4f       	sbci	r23, 0xFF	; 255
    1406:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsert>
    140a:	17 c0       	rjmp	.+46     	; 0x143a <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    140c:	80 91 73 1a 	lds	r24, 0x1A73
    1410:	90 91 74 1a 	lds	r25, 0x1A74
    1414:	60 91 66 1a 	lds	r22, 0x1A66
    1418:	70 91 67 1a 	lds	r23, 0x1A67
    141c:	6e 5f       	subi	r22, 0xFE	; 254
    141e:	7f 4f       	sbci	r23, 0xFF	; 255
    1420:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1424:	80 91 25 02 	lds	r24, 0x0225
    1428:	90 91 26 02 	lds	r25, 0x0226
    142c:	c8 17       	cp	r28, r24
    142e:	d9 07       	cpc	r29, r25
    1430:	20 f4       	brcc	.+8      	; 0x143a <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1432:	d0 93 26 02 	sts	0x0226, r29
    1436:	c0 93 25 02 	sts	0x0225, r28
		}
	}
}
    143a:	df 91       	pop	r29
    143c:	cf 91       	pop	r28
    143e:	08 95       	ret

00001440 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1440:	c7 e7       	ldi	r28, 0x77	; 119
    1442:	da e1       	ldi	r29, 0x1A	; 26
    1444:	88 81       	ld	r24, Y
    1446:	82 30       	cpi	r24, 0x02	; 2
    1448:	e8 f3       	brcs	.-6      	; 0x1444 <prvIdleTask+0x4>
			{
				taskYIELD();
    144a:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
    144e:	fa cf       	rjmp	.-12     	; 0x1444 <prvIdleTask+0x4>

00001450 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1450:	4f 92       	push	r4
    1452:	5f 92       	push	r5
    1454:	6f 92       	push	r6
    1456:	7f 92       	push	r7
    1458:	8f 92       	push	r8
    145a:	9f 92       	push	r9
    145c:	bf 92       	push	r11
    145e:	cf 92       	push	r12
    1460:	df 92       	push	r13
    1462:	ef 92       	push	r14
    1464:	ff 92       	push	r15
    1466:	0f 93       	push	r16
    1468:	1f 93       	push	r17
    146a:	cf 93       	push	r28
    146c:	df 93       	push	r29
    146e:	2c 01       	movw	r4, r24
    1470:	4b 01       	movw	r8, r22
    1472:	ea 01       	movw	r28, r20
    1474:	39 01       	movw	r6, r18
    1476:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1478:	8a e2       	ldi	r24, 0x2A	; 42
    147a:	90 e0       	ldi	r25, 0x00	; 0
    147c:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <pvPortMalloc>
    1480:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1482:	00 97       	sbiw	r24, 0x00	; 0
    1484:	09 f4       	brne	.+2      	; 0x1488 <xTaskGenericCreate+0x38>
    1486:	e3 c0       	rjmp	.+454    	; 0x164e <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1488:	c1 14       	cp	r12, r1
    148a:	d1 04       	cpc	r13, r1
    148c:	09 f0       	breq	.+2      	; 0x1490 <xTaskGenericCreate+0x40>
    148e:	f4 c0       	rjmp	.+488    	; 0x1678 <xTaskGenericCreate+0x228>
    1490:	ce 01       	movw	r24, r28
    1492:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <pvPortMalloc>
    1496:	6c 01       	movw	r12, r24
    1498:	f8 01       	movw	r30, r16
    149a:	90 8f       	std	Z+24, r25	; 0x18
    149c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    149e:	00 97       	sbiw	r24, 0x00	; 0
    14a0:	29 f4       	brne	.+10     	; 0x14ac <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    14a2:	c8 01       	movw	r24, r16
    14a4:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    14a8:	8f ef       	ldi	r24, 0xFF	; 255
    14aa:	d6 c0       	rjmp	.+428    	; 0x1658 <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    14ac:	c6 01       	movw	r24, r12
    14ae:	65 ea       	ldi	r22, 0xA5	; 165
    14b0:	70 e0       	ldi	r23, 0x00	; 0
    14b2:	ae 01       	movw	r20, r28
    14b4:	0e 94 10 10 	call	0x2020	; 0x2020 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    14b8:	9e 01       	movw	r18, r28
    14ba:	21 50       	subi	r18, 0x01	; 1
    14bc:	30 40       	sbci	r19, 0x00	; 0
    14be:	f8 01       	movw	r30, r16
    14c0:	87 89       	ldd	r24, Z+23	; 0x17
    14c2:	90 8d       	ldd	r25, Z+24	; 0x18
    14c4:	6c 01       	movw	r12, r24
    14c6:	c2 0e       	add	r12, r18
    14c8:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    14ca:	c8 01       	movw	r24, r16
    14cc:	49 96       	adiw	r24, 0x19	; 25
    14ce:	b4 01       	movw	r22, r8
    14d0:	40 e1       	ldi	r20, 0x10	; 16
    14d2:	50 e0       	ldi	r21, 0x00	; 0
    14d4:	0e 94 17 10 	call	0x202e	; 0x202e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    14d8:	f8 01       	movw	r30, r16
    14da:	10 a6       	lds	r17, 0xb0
    14dc:	cb 2d       	mov	r28, r11
    14de:	f3 e0       	ldi	r31, 0x03	; 3
    14e0:	fb 15       	cp	r31, r11
    14e2:	08 f4       	brcc	.+2      	; 0x14e6 <xTaskGenericCreate+0x96>
    14e4:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    14e6:	f8 01       	movw	r30, r16
    14e8:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    14ea:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    14ec:	88 24       	eor	r8, r8
    14ee:	99 24       	eor	r9, r9
    14f0:	68 94       	set
    14f2:	81 f8       	bld	r8, 1
    14f4:	80 0e       	add	r8, r16
    14f6:	91 1e       	adc	r9, r17
    14f8:	c4 01       	movw	r24, r8
    14fa:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    14fe:	c8 01       	movw	r24, r16
    1500:	0c 96       	adiw	r24, 0x0c	; 12
    1502:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1506:	f8 01       	movw	r30, r16
    1508:	11 87       	std	Z+9, r17	; 0x09
    150a:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    150c:	84 e0       	ldi	r24, 0x04	; 4
    150e:	90 e0       	ldi	r25, 0x00	; 0
    1510:	8c 1b       	sub	r24, r28
    1512:	91 09       	sbc	r25, r1
    1514:	95 87       	std	Z+13, r25	; 0x0d
    1516:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1518:	13 8b       	std	Z+19, r17	; 0x13
    151a:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    151c:	c6 01       	movw	r24, r12
    151e:	b2 01       	movw	r22, r4
    1520:	a3 01       	movw	r20, r6
    1522:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <pxPortInitialiseStack>
    1526:	f8 01       	movw	r30, r16
    1528:	91 83       	std	Z+1, r25	; 0x01
    152a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    152c:	e1 14       	cp	r14, r1
    152e:	f1 04       	cpc	r15, r1
    1530:	19 f0       	breq	.+6      	; 0x1538 <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1532:	f7 01       	movw	r30, r14
    1534:	11 83       	std	Z+1, r17	; 0x01
    1536:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1538:	0f b6       	in	r0, 0x3f	; 63
    153a:	f8 94       	cli
    153c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    153e:	80 91 70 1a 	lds	r24, 0x1A70
    1542:	8f 5f       	subi	r24, 0xFF	; 255
    1544:	80 93 70 1a 	sts	0x1A70, r24
			if( pxCurrentTCB == NULL )
    1548:	80 91 66 1a 	lds	r24, 0x1A66
    154c:	90 91 67 1a 	lds	r25, 0x1A67
    1550:	00 97       	sbiw	r24, 0x00	; 0
    1552:	d9 f5       	brne	.+118    	; 0x15ca <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1554:	10 93 67 1a 	sts	0x1A67, r17
    1558:	00 93 66 1a 	sts	0x1A66, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    155c:	80 91 70 1a 	lds	r24, 0x1A70
    1560:	81 30       	cpi	r24, 0x01	; 1
    1562:	09 f0       	breq	.+2      	; 0x1566 <xTaskGenericCreate+0x116>
    1564:	41 c0       	rjmp	.+130    	; 0x15e8 <xTaskGenericCreate+0x198>
    1566:	c0 e0       	ldi	r28, 0x00	; 0
    1568:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    156a:	ce 01       	movw	r24, r28
    156c:	88 0f       	add	r24, r24
    156e:	99 1f       	adc	r25, r25
    1570:	88 0f       	add	r24, r24
    1572:	99 1f       	adc	r25, r25
    1574:	88 0f       	add	r24, r24
    1576:	99 1f       	adc	r25, r25
    1578:	8c 0f       	add	r24, r28
    157a:	9d 1f       	adc	r25, r29
    157c:	89 58       	subi	r24, 0x89	; 137
    157e:	95 4e       	sbci	r25, 0xE5	; 229
    1580:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
    1584:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1586:	c4 30       	cpi	r28, 0x04	; 4
    1588:	d1 05       	cpc	r29, r1
    158a:	79 f7       	brne	.-34     	; 0x156a <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    158c:	cb e9       	ldi	r28, 0x9B	; 155
    158e:	da e1       	ldi	r29, 0x1A	; 26
    1590:	ce 01       	movw	r24, r28
    1592:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1596:	0f 2e       	mov	r0, r31
    1598:	f4 ea       	ldi	r31, 0xA4	; 164
    159a:	ef 2e       	mov	r14, r31
    159c:	fa e1       	ldi	r31, 0x1A	; 26
    159e:	ff 2e       	mov	r15, r31
    15a0:	f0 2d       	mov	r31, r0
    15a2:	c7 01       	movw	r24, r14
    15a4:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    15a8:	8d ea       	ldi	r24, 0xAD	; 173
    15aa:	9a e1       	ldi	r25, 0x1A	; 26
    15ac:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    15b0:	86 eb       	ldi	r24, 0xB6	; 182
    15b2:	9a e1       	ldi	r25, 0x1A	; 26
    15b4:	0e 94 4c 04 	call	0x898	; 0x898 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    15b8:	d0 93 74 1a 	sts	0x1A74, r29
    15bc:	c0 93 73 1a 	sts	0x1A73, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    15c0:	f0 92 72 1a 	sts	0x1A72, r15
    15c4:	e0 92 71 1a 	sts	0x1A71, r14
    15c8:	0f c0       	rjmp	.+30     	; 0x15e8 <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    15ca:	80 91 6c 1a 	lds	r24, 0x1A6C
    15ce:	88 23       	and	r24, r24
    15d0:	59 f4       	brne	.+22     	; 0x15e8 <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    15d2:	e0 91 66 1a 	lds	r30, 0x1A66
    15d6:	f0 91 67 1a 	lds	r31, 0x1A67
    15da:	86 89       	ldd	r24, Z+22	; 0x16
    15dc:	b8 16       	cp	r11, r24
    15de:	20 f0       	brcs	.+8      	; 0x15e8 <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    15e0:	10 93 67 1a 	sts	0x1A67, r17
    15e4:	00 93 66 1a 	sts	0x1A66, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    15e8:	f8 01       	movw	r30, r16
    15ea:	86 89       	ldd	r24, Z+22	; 0x16
    15ec:	90 91 75 1a 	lds	r25, 0x1A75
    15f0:	98 17       	cp	r25, r24
    15f2:	10 f4       	brcc	.+4      	; 0x15f8 <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    15f4:	80 93 75 1a 	sts	0x1A75, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    15f8:	90 91 76 1a 	lds	r25, 0x1A76
    15fc:	9f 5f       	subi	r25, 0xFF	; 255
    15fe:	90 93 76 1a 	sts	0x1A76, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1602:	90 91 6d 1a 	lds	r25, 0x1A6D
    1606:	98 17       	cp	r25, r24
    1608:	10 f4       	brcc	.+4      	; 0x160e <xTaskGenericCreate+0x1be>
    160a:	80 93 6d 1a 	sts	0x1A6D, r24
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	9c 01       	movw	r18, r24
    1612:	22 0f       	add	r18, r18
    1614:	33 1f       	adc	r19, r19
    1616:	22 0f       	add	r18, r18
    1618:	33 1f       	adc	r19, r19
    161a:	22 0f       	add	r18, r18
    161c:	33 1f       	adc	r19, r19
    161e:	82 0f       	add	r24, r18
    1620:	93 1f       	adc	r25, r19
    1622:	89 58       	subi	r24, 0x89	; 137
    1624:	95 4e       	sbci	r25, 0xE5	; 229
    1626:	b4 01       	movw	r22, r8
    1628:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    162c:	0f 90       	pop	r0
    162e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1630:	80 91 6c 1a 	lds	r24, 0x1A6C
    1634:	88 23       	and	r24, r24
    1636:	69 f0       	breq	.+26     	; 0x1652 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1638:	e0 91 66 1a 	lds	r30, 0x1A66
    163c:	f0 91 67 1a 	lds	r31, 0x1A67
    1640:	86 89       	ldd	r24, Z+22	; 0x16
    1642:	8b 15       	cp	r24, r11
    1644:	40 f4       	brcc	.+16     	; 0x1656 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    1646:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	05 c0       	rjmp	.+10     	; 0x1658 <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    164e:	8f ef       	ldi	r24, 0xFF	; 255
    1650:	03 c0       	rjmp	.+6      	; 0x1658 <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1652:	81 e0       	ldi	r24, 0x01	; 1
    1654:	01 c0       	rjmp	.+2      	; 0x1658 <xTaskGenericCreate+0x208>
    1656:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	1f 91       	pop	r17
    165e:	0f 91       	pop	r16
    1660:	ff 90       	pop	r15
    1662:	ef 90       	pop	r14
    1664:	df 90       	pop	r13
    1666:	cf 90       	pop	r12
    1668:	bf 90       	pop	r11
    166a:	9f 90       	pop	r9
    166c:	8f 90       	pop	r8
    166e:	7f 90       	pop	r7
    1670:	6f 90       	pop	r6
    1672:	5f 90       	pop	r5
    1674:	4f 90       	pop	r4
    1676:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1678:	fc 01       	movw	r30, r24
    167a:	d0 8e       	std	Z+24, r13	; 0x18
    167c:	c7 8a       	std	Z+23, r12	; 0x17
    167e:	16 cf       	rjmp	.-468    	; 0x14ac <xTaskGenericCreate+0x5c>

00001680 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    1680:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1682:	82 85       	ldd	r24, Z+10	; 0x0a
    1684:	93 85       	ldd	r25, Z+11	; 0x0b
    1686:	2a e1       	ldi	r18, 0x1A	; 26
    1688:	86 3b       	cpi	r24, 0xB6	; 182
    168a:	92 07       	cpc	r25, r18
    168c:	61 f4       	brne	.+24     	; 0x16a6 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    168e:	24 89       	ldd	r18, Z+20	; 0x14
    1690:	35 89       	ldd	r19, Z+21	; 0x15
    1692:	8a e1       	ldi	r24, 0x1A	; 26
    1694:	2d 3a       	cpi	r18, 0xAD	; 173
    1696:	38 07       	cpc	r19, r24
    1698:	41 f0       	breq	.+16     	; 0x16aa <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	21 15       	cp	r18, r1
    169e:	31 05       	cpc	r19, r1
    16a0:	29 f0       	breq	.+10     	; 0x16ac <xTaskIsTaskSuspended+0x2c>
    16a2:	80 e0       	ldi	r24, 0x00	; 0
    16a4:	08 95       	ret
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	08 95       	ret
    16aa:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    16ac:	08 95       	ret

000016ae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    16ae:	0f 93       	push	r16
    16b0:	1f 93       	push	r17
    16b2:	cf 93       	push	r28
    16b4:	df 93       	push	r29
    16b6:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    16b8:	00 97       	sbiw	r24, 0x00	; 0
    16ba:	b9 f1       	breq	.+110    	; 0x172a <vTaskResume+0x7c>
    16bc:	80 91 66 1a 	lds	r24, 0x1A66
    16c0:	90 91 67 1a 	lds	r25, 0x1A67
    16c4:	c8 17       	cp	r28, r24
    16c6:	d9 07       	cpc	r29, r25
    16c8:	81 f1       	breq	.+96     	; 0x172a <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    16d0:	ce 01       	movw	r24, r28
    16d2:	0e 94 40 0b 	call	0x1680	; 0x1680 <xTaskIsTaskSuspended>
    16d6:	81 30       	cpi	r24, 0x01	; 1
    16d8:	31 f5       	brne	.+76     	; 0x1726 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    16da:	8e 01       	movw	r16, r28
    16dc:	0e 5f       	subi	r16, 0xFE	; 254
    16de:	1f 4f       	sbci	r17, 0xFF	; 255
    16e0:	c8 01       	movw	r24, r16
    16e2:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    16e6:	8e 89       	ldd	r24, Y+22	; 0x16
    16e8:	90 91 6d 1a 	lds	r25, 0x1A6D
    16ec:	98 17       	cp	r25, r24
    16ee:	10 f4       	brcc	.+4      	; 0x16f4 <vTaskResume+0x46>
    16f0:	80 93 6d 1a 	sts	0x1A6D, r24
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	9c 01       	movw	r18, r24
    16f8:	22 0f       	add	r18, r18
    16fa:	33 1f       	adc	r19, r19
    16fc:	22 0f       	add	r18, r18
    16fe:	33 1f       	adc	r19, r19
    1700:	22 0f       	add	r18, r18
    1702:	33 1f       	adc	r19, r19
    1704:	82 0f       	add	r24, r18
    1706:	93 1f       	adc	r25, r19
    1708:	89 58       	subi	r24, 0x89	; 137
    170a:	95 4e       	sbci	r25, 0xE5	; 229
    170c:	b8 01       	movw	r22, r16
    170e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1712:	e0 91 66 1a 	lds	r30, 0x1A66
    1716:	f0 91 67 1a 	lds	r31, 0x1A67
    171a:	9e 89       	ldd	r25, Y+22	; 0x16
    171c:	86 89       	ldd	r24, Z+22	; 0x16
    171e:	98 17       	cp	r25, r24
    1720:	10 f0       	brcs	.+4      	; 0x1726 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    1722:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    1726:	0f 90       	pop	r0
    1728:	0f be       	out	0x3f, r0	; 63
		}
	}
    172a:	df 91       	pop	r29
    172c:	cf 91       	pop	r28
    172e:	1f 91       	pop	r17
    1730:	0f 91       	pop	r16
    1732:	08 95       	ret

00001734 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    1734:	ef 92       	push	r14
    1736:	ff 92       	push	r15
    1738:	1f 93       	push	r17
    173a:	cf 93       	push	r28
    173c:	df 93       	push	r29
    173e:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1740:	0e 94 40 0b 	call	0x1680	; 0x1680 <xTaskIsTaskSuspended>
    1744:	81 30       	cpi	r24, 0x01	; 1
    1746:	b9 f5       	brne	.+110    	; 0x17b6 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1748:	80 91 6b 1a 	lds	r24, 0x1A6B
    174c:	88 23       	and	r24, r24
    174e:	51 f5       	brne	.+84     	; 0x17a4 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    1750:	e0 91 66 1a 	lds	r30, 0x1A66
    1754:	f0 91 67 1a 	lds	r31, 0x1A67
    1758:	11 e0       	ldi	r17, 0x01	; 1
    175a:	9e 89       	ldd	r25, Y+22	; 0x16
    175c:	86 89       	ldd	r24, Z+22	; 0x16
    175e:	98 17       	cp	r25, r24
    1760:	08 f4       	brcc	.+2      	; 0x1764 <xTaskResumeFromISR+0x30>
    1762:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    1764:	ee 24       	eor	r14, r14
    1766:	ff 24       	eor	r15, r15
    1768:	68 94       	set
    176a:	e1 f8       	bld	r14, 1
    176c:	ec 0e       	add	r14, r28
    176e:	fd 1e       	adc	r15, r29
    1770:	c7 01       	movw	r24, r14
    1772:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1776:	8e 89       	ldd	r24, Y+22	; 0x16
    1778:	90 91 6d 1a 	lds	r25, 0x1A6D
    177c:	98 17       	cp	r25, r24
    177e:	10 f4       	brcc	.+4      	; 0x1784 <xTaskResumeFromISR+0x50>
    1780:	80 93 6d 1a 	sts	0x1A6D, r24
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	9c 01       	movw	r18, r24
    1788:	22 0f       	add	r18, r18
    178a:	33 1f       	adc	r19, r19
    178c:	22 0f       	add	r18, r18
    178e:	33 1f       	adc	r19, r19
    1790:	22 0f       	add	r18, r18
    1792:	33 1f       	adc	r19, r19
    1794:	82 0f       	add	r24, r18
    1796:	93 1f       	adc	r25, r19
    1798:	89 58       	subi	r24, 0x89	; 137
    179a:	95 4e       	sbci	r25, 0xE5	; 229
    179c:	b7 01       	movw	r22, r14
    179e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    17a2:	0a c0       	rjmp	.+20     	; 0x17b8 <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    17a4:	be 01       	movw	r22, r28
    17a6:	64 5f       	subi	r22, 0xF4	; 244
    17a8:	7f 4f       	sbci	r23, 0xFF	; 255
    17aa:	8d ea       	ldi	r24, 0xAD	; 173
    17ac:	9a e1       	ldi	r25, 0x1A	; 26
    17ae:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    17b2:	10 e0       	ldi	r17, 0x00	; 0
    17b4:	01 c0       	rjmp	.+2      	; 0x17b8 <xTaskResumeFromISR+0x84>
    17b6:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    17b8:	81 2f       	mov	r24, r17
    17ba:	df 91       	pop	r29
    17bc:	cf 91       	pop	r28
    17be:	1f 91       	pop	r17
    17c0:	ff 90       	pop	r15
    17c2:	ef 90       	pop	r14
    17c4:	08 95       	ret

000017c6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    17c6:	af 92       	push	r10
    17c8:	bf 92       	push	r11
    17ca:	cf 92       	push	r12
    17cc:	df 92       	push	r13
    17ce:	ef 92       	push	r14
    17d0:	ff 92       	push	r15
    17d2:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    17d4:	80 e2       	ldi	r24, 0x20	; 32
    17d6:	9a e0       	ldi	r25, 0x0A	; 10
    17d8:	60 e2       	ldi	r22, 0x20	; 32
    17da:	72 e0       	ldi	r23, 0x02	; 2
    17dc:	45 e5       	ldi	r20, 0x55	; 85
    17de:	50 e0       	ldi	r21, 0x00	; 0
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	30 e0       	ldi	r19, 0x00	; 0
    17e4:	00 e0       	ldi	r16, 0x00	; 0
    17e6:	ee 24       	eor	r14, r14
    17e8:	ff 24       	eor	r15, r15
    17ea:	cc 24       	eor	r12, r12
    17ec:	dd 24       	eor	r13, r13
    17ee:	aa 24       	eor	r10, r10
    17f0:	bb 24       	eor	r11, r11
    17f2:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    17f6:	81 30       	cpi	r24, 0x01	; 1
    17f8:	49 f4       	brne	.+18     	; 0x180c <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    17fa:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    17fc:	80 93 6c 1a 	sts	0x1A6C, r24
		xTickCount = ( portTickType ) 0U;
    1800:	10 92 6f 1a 	sts	0x1A6F, r1
    1804:	10 92 6e 1a 	sts	0x1A6E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1808:	0e 94 84 05 	call	0xb08	; 0xb08 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    180c:	0f 91       	pop	r16
    180e:	ff 90       	pop	r15
    1810:	ef 90       	pop	r14
    1812:	df 90       	pop	r13
    1814:	cf 90       	pop	r12
    1816:	bf 90       	pop	r11
    1818:	af 90       	pop	r10
    181a:	08 95       	ret

0000181c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    181c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    181e:	10 92 6c 1a 	sts	0x1A6C, r1
	vPortEndScheduler();
    1822:	0e 94 c2 05 	call	0xb84	; 0xb84 <vPortEndScheduler>
}
    1826:	08 95       	ret

00001828 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1828:	80 91 6b 1a 	lds	r24, 0x1A6B
    182c:	8f 5f       	subi	r24, 0xFF	; 255
    182e:	80 93 6b 1a 	sts	0x1A6B, r24
}
    1832:	08 95       	ret

00001834 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    183a:	80 91 6e 1a 	lds	r24, 0x1A6E
    183e:	90 91 6f 1a 	lds	r25, 0x1A6F
	}
	taskEXIT_CRITICAL();
    1842:	0f 90       	pop	r0
    1844:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1846:	08 95       	ret

00001848 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1848:	80 91 6e 1a 	lds	r24, 0x1A6E
    184c:	90 91 6f 1a 	lds	r25, 0x1A6F
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1850:	08 95       	ret

00001852 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1852:	80 91 70 1a 	lds	r24, 0x1A70
}
    1856:	08 95       	ret

00001858 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1858:	0f 93       	push	r16
    185a:	1f 93       	push	r17
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1860:	80 91 6b 1a 	lds	r24, 0x1A6B
    1864:	88 23       	and	r24, r24
    1866:	09 f0       	breq	.+2      	; 0x186a <vTaskIncrementTick+0x12>
    1868:	b3 c0       	rjmp	.+358    	; 0x19d0 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    186a:	80 91 6e 1a 	lds	r24, 0x1A6E
    186e:	90 91 6f 1a 	lds	r25, 0x1A6F
    1872:	01 96       	adiw	r24, 0x01	; 1
    1874:	90 93 6f 1a 	sts	0x1A6F, r25
    1878:	80 93 6e 1a 	sts	0x1A6E, r24
		if( xTickCount == ( portTickType ) 0U )
    187c:	80 91 6e 1a 	lds	r24, 0x1A6E
    1880:	90 91 6f 1a 	lds	r25, 0x1A6F
    1884:	00 97       	sbiw	r24, 0x00	; 0
    1886:	99 f5       	brne	.+102    	; 0x18ee <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    1888:	80 91 73 1a 	lds	r24, 0x1A73
    188c:	90 91 74 1a 	lds	r25, 0x1A74
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1890:	20 91 71 1a 	lds	r18, 0x1A71
    1894:	30 91 72 1a 	lds	r19, 0x1A72
    1898:	30 93 74 1a 	sts	0x1A74, r19
    189c:	20 93 73 1a 	sts	0x1A73, r18
			pxOverflowDelayedTaskList = pxTemp;
    18a0:	90 93 72 1a 	sts	0x1A72, r25
    18a4:	80 93 71 1a 	sts	0x1A71, r24
			xNumOfOverflows++;
    18a8:	80 91 68 1a 	lds	r24, 0x1A68
    18ac:	8f 5f       	subi	r24, 0xFF	; 255
    18ae:	80 93 68 1a 	sts	0x1A68, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    18b2:	e0 91 73 1a 	lds	r30, 0x1A73
    18b6:	f0 91 74 1a 	lds	r31, 0x1A74
    18ba:	80 81       	ld	r24, Z
    18bc:	88 23       	and	r24, r24
    18be:	39 f4       	brne	.+14     	; 0x18ce <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    18c0:	8f ef       	ldi	r24, 0xFF	; 255
    18c2:	9f ef       	ldi	r25, 0xFF	; 255
    18c4:	90 93 26 02 	sts	0x0226, r25
    18c8:	80 93 25 02 	sts	0x0225, r24
    18cc:	10 c0       	rjmp	.+32     	; 0x18ee <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    18ce:	e0 91 73 1a 	lds	r30, 0x1A73
    18d2:	f0 91 74 1a 	lds	r31, 0x1A74
    18d6:	05 80       	ldd	r0, Z+5	; 0x05
    18d8:	f6 81       	ldd	r31, Z+6	; 0x06
    18da:	e0 2d       	mov	r30, r0
    18dc:	06 80       	ldd	r0, Z+6	; 0x06
    18de:	f7 81       	ldd	r31, Z+7	; 0x07
    18e0:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    18e2:	82 81       	ldd	r24, Z+2	; 0x02
    18e4:	93 81       	ldd	r25, Z+3	; 0x03
    18e6:	90 93 26 02 	sts	0x0226, r25
    18ea:	80 93 25 02 	sts	0x0225, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    18ee:	20 91 6e 1a 	lds	r18, 0x1A6E
    18f2:	30 91 6f 1a 	lds	r19, 0x1A6F
    18f6:	80 91 25 02 	lds	r24, 0x0225
    18fa:	90 91 26 02 	lds	r25, 0x0226
    18fe:	28 17       	cp	r18, r24
    1900:	39 07       	cpc	r19, r25
    1902:	08 f4       	brcc	.+2      	; 0x1906 <vTaskIncrementTick+0xae>
    1904:	6a c0       	rjmp	.+212    	; 0x19da <vTaskIncrementTick+0x182>
    1906:	e0 91 73 1a 	lds	r30, 0x1A73
    190a:	f0 91 74 1a 	lds	r31, 0x1A74
    190e:	80 81       	ld	r24, Z
    1910:	88 23       	and	r24, r24
    1912:	99 f0       	breq	.+38     	; 0x193a <vTaskIncrementTick+0xe2>
    1914:	e0 91 73 1a 	lds	r30, 0x1A73
    1918:	f0 91 74 1a 	lds	r31, 0x1A74
    191c:	05 80       	ldd	r0, Z+5	; 0x05
    191e:	f6 81       	ldd	r31, Z+6	; 0x06
    1920:	e0 2d       	mov	r30, r0
    1922:	c6 81       	ldd	r28, Z+6	; 0x06
    1924:	d7 81       	ldd	r29, Z+7	; 0x07
    1926:	8a 81       	ldd	r24, Y+2	; 0x02
    1928:	9b 81       	ldd	r25, Y+3	; 0x03
    192a:	20 91 6e 1a 	lds	r18, 0x1A6E
    192e:	30 91 6f 1a 	lds	r19, 0x1A6F
    1932:	28 17       	cp	r18, r24
    1934:	39 07       	cpc	r19, r25
    1936:	f8 f4       	brcc	.+62     	; 0x1976 <vTaskIncrementTick+0x11e>
    1938:	19 c0       	rjmp	.+50     	; 0x196c <vTaskIncrementTick+0x114>
    193a:	8f ef       	ldi	r24, 0xFF	; 255
    193c:	9f ef       	ldi	r25, 0xFF	; 255
    193e:	90 93 26 02 	sts	0x0226, r25
    1942:	80 93 25 02 	sts	0x0225, r24
    1946:	49 c0       	rjmp	.+146    	; 0x19da <vTaskIncrementTick+0x182>
    1948:	e0 91 73 1a 	lds	r30, 0x1A73
    194c:	f0 91 74 1a 	lds	r31, 0x1A74
    1950:	05 80       	ldd	r0, Z+5	; 0x05
    1952:	f6 81       	ldd	r31, Z+6	; 0x06
    1954:	e0 2d       	mov	r30, r0
    1956:	c6 81       	ldd	r28, Z+6	; 0x06
    1958:	d7 81       	ldd	r29, Z+7	; 0x07
    195a:	8a 81       	ldd	r24, Y+2	; 0x02
    195c:	9b 81       	ldd	r25, Y+3	; 0x03
    195e:	20 91 6e 1a 	lds	r18, 0x1A6E
    1962:	30 91 6f 1a 	lds	r19, 0x1A6F
    1966:	28 17       	cp	r18, r24
    1968:	39 07       	cpc	r19, r25
    196a:	28 f4       	brcc	.+10     	; 0x1976 <vTaskIncrementTick+0x11e>
    196c:	90 93 26 02 	sts	0x0226, r25
    1970:	80 93 25 02 	sts	0x0225, r24
    1974:	32 c0       	rjmp	.+100    	; 0x19da <vTaskIncrementTick+0x182>
    1976:	8e 01       	movw	r16, r28
    1978:	0e 5f       	subi	r16, 0xFE	; 254
    197a:	1f 4f       	sbci	r17, 0xFF	; 255
    197c:	c8 01       	movw	r24, r16
    197e:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
    1982:	8c 89       	ldd	r24, Y+20	; 0x14
    1984:	9d 89       	ldd	r25, Y+21	; 0x15
    1986:	00 97       	sbiw	r24, 0x00	; 0
    1988:	21 f0       	breq	.+8      	; 0x1992 <vTaskIncrementTick+0x13a>
    198a:	ce 01       	movw	r24, r28
    198c:	0c 96       	adiw	r24, 0x0c	; 12
    198e:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
    1992:	8e 89       	ldd	r24, Y+22	; 0x16
    1994:	90 91 6d 1a 	lds	r25, 0x1A6D
    1998:	98 17       	cp	r25, r24
    199a:	10 f4       	brcc	.+4      	; 0x19a0 <vTaskIncrementTick+0x148>
    199c:	80 93 6d 1a 	sts	0x1A6D, r24
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	9c 01       	movw	r18, r24
    19a4:	22 0f       	add	r18, r18
    19a6:	33 1f       	adc	r19, r19
    19a8:	22 0f       	add	r18, r18
    19aa:	33 1f       	adc	r19, r19
    19ac:	22 0f       	add	r18, r18
    19ae:	33 1f       	adc	r19, r19
    19b0:	82 0f       	add	r24, r18
    19b2:	93 1f       	adc	r25, r19
    19b4:	89 58       	subi	r24, 0x89	; 137
    19b6:	95 4e       	sbci	r25, 0xE5	; 229
    19b8:	b8 01       	movw	r22, r16
    19ba:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    19be:	e0 91 73 1a 	lds	r30, 0x1A73
    19c2:	f0 91 74 1a 	lds	r31, 0x1A74
    19c6:	80 81       	ld	r24, Z
    19c8:	88 23       	and	r24, r24
    19ca:	09 f0       	breq	.+2      	; 0x19ce <vTaskIncrementTick+0x176>
    19cc:	bd cf       	rjmp	.-134    	; 0x1948 <vTaskIncrementTick+0xf0>
    19ce:	b5 cf       	rjmp	.-150    	; 0x193a <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    19d0:	80 91 6a 1a 	lds	r24, 0x1A6A
    19d4:	8f 5f       	subi	r24, 0xFF	; 255
    19d6:	80 93 6a 1a 	sts	0x1A6A, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    19da:	df 91       	pop	r29
    19dc:	cf 91       	pop	r28
    19de:	1f 91       	pop	r17
    19e0:	0f 91       	pop	r16
    19e2:	08 95       	ret

000019e4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    19e4:	af 92       	push	r10
    19e6:	bf 92       	push	r11
    19e8:	cf 92       	push	r12
    19ea:	df 92       	push	r13
    19ec:	ef 92       	push	r14
    19ee:	ff 92       	push	r15
    19f0:	0f 93       	push	r16
    19f2:	1f 93       	push	r17
    19f4:	cf 93       	push	r28
    19f6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    19f8:	0f b6       	in	r0, 0x3f	; 63
    19fa:	f8 94       	cli
    19fc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    19fe:	80 91 6b 1a 	lds	r24, 0x1A6B
    1a02:	81 50       	subi	r24, 0x01	; 1
    1a04:	80 93 6b 1a 	sts	0x1A6B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a08:	80 91 6b 1a 	lds	r24, 0x1A6B
    1a0c:	88 23       	and	r24, r24
    1a0e:	09 f0       	breq	.+2      	; 0x1a12 <xTaskResumeAll+0x2e>
    1a10:	69 c0       	rjmp	.+210    	; 0x1ae4 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1a12:	80 91 70 1a 	lds	r24, 0x1A70
    1a16:	88 23       	and	r24, r24
    1a18:	81 f5       	brne	.+96     	; 0x1a7a <xTaskResumeAll+0x96>
    1a1a:	67 c0       	rjmp	.+206    	; 0x1aea <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1a1c:	d6 01       	movw	r26, r12
    1a1e:	ed 91       	ld	r30, X+
    1a20:	fc 91       	ld	r31, X
    1a22:	c6 81       	ldd	r28, Z+6	; 0x06
    1a24:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    1a26:	ce 01       	movw	r24, r28
    1a28:	0c 96       	adiw	r24, 0x0c	; 12
    1a2a:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    1a2e:	8e 01       	movw	r16, r28
    1a30:	0e 5f       	subi	r16, 0xFE	; 254
    1a32:	1f 4f       	sbci	r17, 0xFF	; 255
    1a34:	c8 01       	movw	r24, r16
    1a36:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1a3a:	8e 89       	ldd	r24, Y+22	; 0x16
    1a3c:	90 91 6d 1a 	lds	r25, 0x1A6D
    1a40:	98 17       	cp	r25, r24
    1a42:	10 f4       	brcc	.+4      	; 0x1a48 <xTaskResumeAll+0x64>
    1a44:	80 93 6d 1a 	sts	0x1A6D, r24
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	9c 01       	movw	r18, r24
    1a4c:	22 0f       	add	r18, r18
    1a4e:	33 1f       	adc	r19, r19
    1a50:	22 0f       	add	r18, r18
    1a52:	33 1f       	adc	r19, r19
    1a54:	22 0f       	add	r18, r18
    1a56:	33 1f       	adc	r19, r19
    1a58:	82 0f       	add	r24, r18
    1a5a:	93 1f       	adc	r25, r19
    1a5c:	89 58       	subi	r24, 0x89	; 137
    1a5e:	95 4e       	sbci	r25, 0xE5	; 229
    1a60:	b8 01       	movw	r22, r16
    1a62:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1a66:	e0 91 66 1a 	lds	r30, 0x1A66
    1a6a:	f0 91 67 1a 	lds	r31, 0x1A67
    1a6e:	9e 89       	ldd	r25, Y+22	; 0x16
    1a70:	86 89       	ldd	r24, Z+22	; 0x16
    1a72:	98 17       	cp	r25, r24
    1a74:	88 f0       	brcs	.+34     	; 0x1a98 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1a76:	ba 2c       	mov	r11, r10
    1a78:	0f c0       	rjmp	.+30     	; 0x1a98 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1a7a:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1a7c:	0f 2e       	mov	r0, r31
    1a7e:	fd ea       	ldi	r31, 0xAD	; 173
    1a80:	ef 2e       	mov	r14, r31
    1a82:	fa e1       	ldi	r31, 0x1A	; 26
    1a84:	ff 2e       	mov	r15, r31
    1a86:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1a88:	0f 2e       	mov	r0, r31
    1a8a:	f2 eb       	ldi	r31, 0xB2	; 178
    1a8c:	cf 2e       	mov	r12, r31
    1a8e:	fa e1       	ldi	r31, 0x1A	; 26
    1a90:	df 2e       	mov	r13, r31
    1a92:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1a94:	aa 24       	eor	r10, r10
    1a96:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1a98:	f7 01       	movw	r30, r14
    1a9a:	80 81       	ld	r24, Z
    1a9c:	88 23       	and	r24, r24
    1a9e:	09 f0       	breq	.+2      	; 0x1aa2 <xTaskResumeAll+0xbe>
    1aa0:	bd cf       	rjmp	.-134    	; 0x1a1c <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1aa2:	80 91 6a 1a 	lds	r24, 0x1A6A
    1aa6:	88 23       	and	r24, r24
    1aa8:	81 f0       	breq	.+32     	; 0x1aca <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1aaa:	80 91 6a 1a 	lds	r24, 0x1A6A
    1aae:	88 23       	and	r24, r24
    1ab0:	99 f0       	breq	.+38     	; 0x1ad8 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1ab2:	0e 94 2c 0c 	call	0x1858	; 0x1858 <vTaskIncrementTick>
						--uxMissedTicks;
    1ab6:	80 91 6a 1a 	lds	r24, 0x1A6A
    1aba:	81 50       	subi	r24, 0x01	; 1
    1abc:	80 93 6a 1a 	sts	0x1A6A, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ac0:	80 91 6a 1a 	lds	r24, 0x1A6A
    1ac4:	88 23       	and	r24, r24
    1ac6:	a9 f7       	brne	.-22     	; 0x1ab2 <xTaskResumeAll+0xce>
    1ac8:	07 c0       	rjmp	.+14     	; 0x1ad8 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1aca:	f1 e0       	ldi	r31, 0x01	; 1
    1acc:	bf 16       	cp	r11, r31
    1ace:	21 f0       	breq	.+8      	; 0x1ad8 <xTaskResumeAll+0xf4>
    1ad0:	80 91 69 1a 	lds	r24, 0x1A69
    1ad4:	81 30       	cpi	r24, 0x01	; 1
    1ad6:	41 f4       	brne	.+16     	; 0x1ae8 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1ad8:	10 92 69 1a 	sts	0x1A69, r1
					portYIELD_WITHIN_API();
    1adc:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1ae0:	81 e0       	ldi	r24, 0x01	; 1
    1ae2:	03 c0       	rjmp	.+6      	; 0x1aea <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	01 c0       	rjmp	.+2      	; 0x1aea <xTaskResumeAll+0x106>
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1aea:	0f 90       	pop	r0
    1aec:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1aee:	df 91       	pop	r29
    1af0:	cf 91       	pop	r28
    1af2:	1f 91       	pop	r17
    1af4:	0f 91       	pop	r16
    1af6:	ff 90       	pop	r15
    1af8:	ef 90       	pop	r14
    1afa:	df 90       	pop	r13
    1afc:	cf 90       	pop	r12
    1afe:	bf 90       	pop	r11
    1b00:	af 90       	pop	r10
    1b02:	08 95       	ret

00001b04 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1b04:	cf 93       	push	r28
    1b06:	df 93       	push	r29
    1b08:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1b0a:	00 97       	sbiw	r24, 0x00	; 0
    1b0c:	b1 f0       	breq	.+44     	; 0x1b3a <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1b0e:	0e 94 14 0c 	call	0x1828	; 0x1828 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1b12:	80 91 6e 1a 	lds	r24, 0x1A6E
    1b16:	90 91 6f 1a 	lds	r25, 0x1A6F
    1b1a:	c8 0f       	add	r28, r24
    1b1c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1b1e:	80 91 66 1a 	lds	r24, 0x1A66
    1b22:	90 91 67 1a 	lds	r25, 0x1A67
    1b26:	02 96       	adiw	r24, 0x02	; 2
    1b28:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1b32:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1b36:	88 23       	and	r24, r24
    1b38:	11 f4       	brne	.+4      	; 0x1b3e <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1b3a:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
		}
	}
    1b3e:	df 91       	pop	r29
    1b40:	cf 91       	pop	r28
    1b42:	08 95       	ret

00001b44 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1b44:	0f 93       	push	r16
    1b46:	1f 93       	push	r17
    1b48:	cf 93       	push	r28
    1b4a:	df 93       	push	r29
    1b4c:	8c 01       	movw	r16, r24
    1b4e:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1b50:	0e 94 14 0c 	call	0x1828	; 0x1828 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1b54:	f8 01       	movw	r30, r16
    1b56:	80 81       	ld	r24, Z
    1b58:	91 81       	ldd	r25, Z+1	; 0x01
    1b5a:	c8 0f       	add	r28, r24
    1b5c:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1b5e:	20 91 6e 1a 	lds	r18, 0x1A6E
    1b62:	30 91 6f 1a 	lds	r19, 0x1A6F
    1b66:	28 17       	cp	r18, r24
    1b68:	39 07       	cpc	r19, r25
    1b6a:	68 f4       	brcc	.+26     	; 0x1b86 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1b6c:	c8 17       	cp	r28, r24
    1b6e:	d9 07       	cpc	r29, r25
    1b70:	50 f5       	brcc	.+84     	; 0x1bc6 <vTaskDelayUntil+0x82>
    1b72:	80 91 6e 1a 	lds	r24, 0x1A6E
    1b76:	90 91 6f 1a 	lds	r25, 0x1A6F
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1b7a:	d1 83       	std	Z+1, r29	; 0x01
    1b7c:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1b7e:	8c 17       	cp	r24, r28
    1b80:	9d 07       	cpc	r25, r29
    1b82:	b0 f4       	brcc	.+44     	; 0x1bb0 <vTaskDelayUntil+0x6c>
    1b84:	0b c0       	rjmp	.+22     	; 0x1b9c <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1b86:	c8 17       	cp	r28, r24
    1b88:	d9 07       	cpc	r29, r25
    1b8a:	c8 f0       	brcs	.+50     	; 0x1bbe <vTaskDelayUntil+0x7a>
    1b8c:	80 91 6e 1a 	lds	r24, 0x1A6E
    1b90:	90 91 6f 1a 	lds	r25, 0x1A6F
    1b94:	8c 17       	cp	r24, r28
    1b96:	9d 07       	cpc	r25, r29
    1b98:	90 f0       	brcs	.+36     	; 0x1bbe <vTaskDelayUntil+0x7a>
    1b9a:	15 c0       	rjmp	.+42     	; 0x1bc6 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1b9c:	80 91 66 1a 	lds	r24, 0x1A66
    1ba0:	90 91 67 1a 	lds	r25, 0x1A67
    1ba4:	02 96       	adiw	r24, 0x02	; 2
    1ba6:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1baa:	ce 01       	movw	r24, r28
    1bac:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1bb0:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1bb4:	88 23       	and	r24, r24
    1bb6:	59 f4       	brne	.+22     	; 0x1bce <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1bb8:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
    1bbc:	08 c0       	rjmp	.+16     	; 0x1bce <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1bbe:	f8 01       	movw	r30, r16
    1bc0:	d1 83       	std	Z+1, r29	; 0x01
    1bc2:	c0 83       	st	Z, r28
    1bc4:	eb cf       	rjmp	.-42     	; 0x1b9c <vTaskDelayUntil+0x58>
    1bc6:	f8 01       	movw	r30, r16
    1bc8:	d1 83       	std	Z+1, r29	; 0x01
    1bca:	c0 83       	st	Z, r28
    1bcc:	f1 cf       	rjmp	.-30     	; 0x1bb0 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1bce:	df 91       	pop	r29
    1bd0:	cf 91       	pop	r28
    1bd2:	1f 91       	pop	r17
    1bd4:	0f 91       	pop	r16
    1bd6:	08 95       	ret

00001bd8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1bd8:	80 91 6b 1a 	lds	r24, 0x1A6B
    1bdc:	88 23       	and	r24, r24
    1bde:	99 f4       	brne	.+38     	; 0x1c06 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1be0:	80 91 6d 1a 	lds	r24, 0x1A6D
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	fc 01       	movw	r30, r24
    1be8:	ee 0f       	add	r30, r30
    1bea:	ff 1f       	adc	r31, r31
    1bec:	ee 0f       	add	r30, r30
    1bee:	ff 1f       	adc	r31, r31
    1bf0:	ee 0f       	add	r30, r30
    1bf2:	ff 1f       	adc	r31, r31
    1bf4:	8e 0f       	add	r24, r30
    1bf6:	9f 1f       	adc	r25, r31
    1bf8:	fc 01       	movw	r30, r24
    1bfa:	e9 58       	subi	r30, 0x89	; 137
    1bfc:	f5 4e       	sbci	r31, 0xE5	; 229
    1bfe:	80 81       	ld	r24, Z
    1c00:	88 23       	and	r24, r24
    1c02:	29 f0       	breq	.+10     	; 0x1c0e <vTaskSwitchContext+0x36>
    1c04:	1b c0       	rjmp	.+54     	; 0x1c3c <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	80 93 69 1a 	sts	0x1A69, r24
    1c0c:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1c0e:	80 91 6d 1a 	lds	r24, 0x1A6D
    1c12:	81 50       	subi	r24, 0x01	; 1
    1c14:	80 93 6d 1a 	sts	0x1A6D, r24
    1c18:	80 91 6d 1a 	lds	r24, 0x1A6D
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	fc 01       	movw	r30, r24
    1c20:	ee 0f       	add	r30, r30
    1c22:	ff 1f       	adc	r31, r31
    1c24:	ee 0f       	add	r30, r30
    1c26:	ff 1f       	adc	r31, r31
    1c28:	ee 0f       	add	r30, r30
    1c2a:	ff 1f       	adc	r31, r31
    1c2c:	8e 0f       	add	r24, r30
    1c2e:	9f 1f       	adc	r25, r31
    1c30:	fc 01       	movw	r30, r24
    1c32:	e9 58       	subi	r30, 0x89	; 137
    1c34:	f5 4e       	sbci	r31, 0xE5	; 229
    1c36:	80 81       	ld	r24, Z
    1c38:	88 23       	and	r24, r24
    1c3a:	49 f3       	breq	.-46     	; 0x1c0e <vTaskSwitchContext+0x36>
    1c3c:	80 91 6d 1a 	lds	r24, 0x1A6D
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	fc 01       	movw	r30, r24
    1c44:	ee 0f       	add	r30, r30
    1c46:	ff 1f       	adc	r31, r31
    1c48:	ee 0f       	add	r30, r30
    1c4a:	ff 1f       	adc	r31, r31
    1c4c:	ee 0f       	add	r30, r30
    1c4e:	ff 1f       	adc	r31, r31
    1c50:	e8 0f       	add	r30, r24
    1c52:	f9 1f       	adc	r31, r25
    1c54:	e9 58       	subi	r30, 0x89	; 137
    1c56:	f5 4e       	sbci	r31, 0xE5	; 229
    1c58:	a1 81       	ldd	r26, Z+1	; 0x01
    1c5a:	b2 81       	ldd	r27, Z+2	; 0x02
    1c5c:	12 96       	adiw	r26, 0x02	; 2
    1c5e:	0d 90       	ld	r0, X+
    1c60:	bc 91       	ld	r27, X
    1c62:	a0 2d       	mov	r26, r0
    1c64:	b2 83       	std	Z+2, r27	; 0x02
    1c66:	a1 83       	std	Z+1, r26	; 0x01
    1c68:	cf 01       	movw	r24, r30
    1c6a:	03 96       	adiw	r24, 0x03	; 3
    1c6c:	a8 17       	cp	r26, r24
    1c6e:	b9 07       	cpc	r27, r25
    1c70:	31 f4       	brne	.+12     	; 0x1c7e <vTaskSwitchContext+0xa6>
    1c72:	12 96       	adiw	r26, 0x02	; 2
    1c74:	8d 91       	ld	r24, X+
    1c76:	9c 91       	ld	r25, X
    1c78:	13 97       	sbiw	r26, 0x03	; 3
    1c7a:	92 83       	std	Z+2, r25	; 0x02
    1c7c:	81 83       	std	Z+1, r24	; 0x01
    1c7e:	01 80       	ldd	r0, Z+1	; 0x01
    1c80:	f2 81       	ldd	r31, Z+2	; 0x02
    1c82:	e0 2d       	mov	r30, r0
    1c84:	86 81       	ldd	r24, Z+6	; 0x06
    1c86:	97 81       	ldd	r25, Z+7	; 0x07
    1c88:	90 93 67 1a 	sts	0x1A67, r25
    1c8c:	80 93 66 1a 	sts	0x1A66, r24
    1c90:	08 95       	ret

00001c92 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1ca6:	80 91 66 1a 	lds	r24, 0x1A66
    1caa:	90 91 67 1a 	lds	r25, 0x1A67
    1cae:	e8 16       	cp	r14, r24
    1cb0:	f9 06       	cpc	r15, r25
    1cb2:	21 f0       	breq	.+8      	; 0x1cbc <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1cb4:	e1 14       	cp	r14, r1
    1cb6:	f1 04       	cpc	r15, r1
    1cb8:	41 f4       	brne	.+16     	; 0x1cca <vTaskSuspend+0x38>
    1cba:	02 c0       	rjmp	.+4      	; 0x1cc0 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    1cbc:	ee 24       	eor	r14, r14
    1cbe:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1cc0:	c0 91 66 1a 	lds	r28, 0x1A66
    1cc4:	d0 91 67 1a 	lds	r29, 0x1A67
    1cc8:	01 c0       	rjmp	.+2      	; 0x1ccc <vTaskSuspend+0x3a>
    1cca:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1ccc:	8e 01       	movw	r16, r28
    1cce:	0e 5f       	subi	r16, 0xFE	; 254
    1cd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1cd2:	c8 01       	movw	r24, r16
    1cd4:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1cd8:	8c 89       	ldd	r24, Y+20	; 0x14
    1cda:	9d 89       	ldd	r25, Y+21	; 0x15
    1cdc:	00 97       	sbiw	r24, 0x00	; 0
    1cde:	21 f0       	breq	.+8      	; 0x1ce8 <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1ce0:	ce 01       	movw	r24, r28
    1ce2:	0c 96       	adiw	r24, 0x0c	; 12
    1ce4:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1ce8:	86 eb       	ldi	r24, 0xB6	; 182
    1cea:	9a e1       	ldi	r25, 0x1A	; 26
    1cec:	b8 01       	movw	r22, r16
    1cee:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1cf2:	0f 90       	pop	r0
    1cf4:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1cf6:	e1 14       	cp	r14, r1
    1cf8:	f1 04       	cpc	r15, r1
    1cfa:	a1 f4       	brne	.+40     	; 0x1d24 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    1cfc:	80 91 6c 1a 	lds	r24, 0x1A6C
    1d00:	88 23       	and	r24, r24
    1d02:	19 f0       	breq	.+6      	; 0x1d0a <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1d04:	0e 94 c3 05 	call	0xb86	; 0xb86 <vPortYield>
    1d08:	0d c0       	rjmp	.+26     	; 0x1d24 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1d0a:	90 91 b6 1a 	lds	r25, 0x1AB6
    1d0e:	80 91 70 1a 	lds	r24, 0x1A70
    1d12:	98 17       	cp	r25, r24
    1d14:	29 f4       	brne	.+10     	; 0x1d20 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1d16:	10 92 67 1a 	sts	0x1A67, r1
    1d1a:	10 92 66 1a 	sts	0x1A66, r1
    1d1e:	02 c0       	rjmp	.+4      	; 0x1d24 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    1d20:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <vTaskSwitchContext>
				}
			}
		}
	}
    1d24:	df 91       	pop	r29
    1d26:	cf 91       	pop	r28
    1d28:	1f 91       	pop	r17
    1d2a:	0f 91       	pop	r16
    1d2c:	ff 90       	pop	r15
    1d2e:	ef 90       	pop	r14
    1d30:	08 95       	ret

00001d32 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1d32:	cf 93       	push	r28
    1d34:	df 93       	push	r29
    1d36:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1d38:	60 91 66 1a 	lds	r22, 0x1A66
    1d3c:	70 91 67 1a 	lds	r23, 0x1A67
    1d40:	64 5f       	subi	r22, 0xF4	; 244
    1d42:	7f 4f       	sbci	r23, 0xFF	; 255
    1d44:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1d48:	80 91 66 1a 	lds	r24, 0x1A66
    1d4c:	90 91 67 1a 	lds	r25, 0x1A67
    1d50:	02 96       	adiw	r24, 0x02	; 2
    1d52:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1d56:	8f ef       	ldi	r24, 0xFF	; 255
    1d58:	cf 3f       	cpi	r28, 0xFF	; 255
    1d5a:	d8 07       	cpc	r29, r24
    1d5c:	59 f4       	brne	.+22     	; 0x1d74 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d5e:	60 91 66 1a 	lds	r22, 0x1A66
    1d62:	70 91 67 1a 	lds	r23, 0x1A67
    1d66:	6e 5f       	subi	r22, 0xFE	; 254
    1d68:	7f 4f       	sbci	r23, 0xFF	; 255
    1d6a:	86 eb       	ldi	r24, 0xB6	; 182
    1d6c:	9a e1       	ldi	r25, 0x1A	; 26
    1d6e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1d72:	08 c0       	rjmp	.+16     	; 0x1d84 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1d74:	80 91 6e 1a 	lds	r24, 0x1A6E
    1d78:	90 91 6f 1a 	lds	r25, 0x1A6F
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d7c:	8c 0f       	add	r24, r28
    1d7e:	9d 1f       	adc	r25, r29
    1d80:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	08 95       	ret

00001d8a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1d8a:	0f 93       	push	r16
    1d8c:	1f 93       	push	r17
    1d8e:	cf 93       	push	r28
    1d90:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1d92:	dc 01       	movw	r26, r24
    1d94:	15 96       	adiw	r26, 0x05	; 5
    1d96:	ed 91       	ld	r30, X+
    1d98:	fc 91       	ld	r31, X
    1d9a:	16 97       	sbiw	r26, 0x06	; 6
    1d9c:	06 81       	ldd	r16, Z+6	; 0x06
    1d9e:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1da0:	e8 01       	movw	r28, r16
    1da2:	2c 96       	adiw	r28, 0x0c	; 12
    1da4:	ce 01       	movw	r24, r28
    1da6:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1daa:	80 91 6b 1a 	lds	r24, 0x1A6B
    1dae:	88 23       	and	r24, r24
    1db0:	e9 f4       	brne	.+58     	; 0x1dec <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1db2:	e8 01       	movw	r28, r16
    1db4:	22 96       	adiw	r28, 0x02	; 2
    1db6:	ce 01       	movw	r24, r28
    1db8:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1dbc:	f8 01       	movw	r30, r16
    1dbe:	86 89       	ldd	r24, Z+22	; 0x16
    1dc0:	90 91 6d 1a 	lds	r25, 0x1A6D
    1dc4:	98 17       	cp	r25, r24
    1dc6:	10 f4       	brcc	.+4      	; 0x1dcc <xTaskRemoveFromEventList+0x42>
    1dc8:	80 93 6d 1a 	sts	0x1A6D, r24
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
    1dce:	9c 01       	movw	r18, r24
    1dd0:	22 0f       	add	r18, r18
    1dd2:	33 1f       	adc	r19, r19
    1dd4:	22 0f       	add	r18, r18
    1dd6:	33 1f       	adc	r19, r19
    1dd8:	22 0f       	add	r18, r18
    1dda:	33 1f       	adc	r19, r19
    1ddc:	82 0f       	add	r24, r18
    1dde:	93 1f       	adc	r25, r19
    1de0:	89 58       	subi	r24, 0x89	; 137
    1de2:	95 4e       	sbci	r25, 0xE5	; 229
    1de4:	be 01       	movw	r22, r28
    1de6:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1dea:	05 c0       	rjmp	.+10     	; 0x1df6 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1dec:	8d ea       	ldi	r24, 0xAD	; 173
    1dee:	9a e1       	ldi	r25, 0x1A	; 26
    1df0:	be 01       	movw	r22, r28
    1df2:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1df6:	e0 91 66 1a 	lds	r30, 0x1A66
    1dfa:	f0 91 67 1a 	lds	r31, 0x1A67
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1dfe:	81 e0       	ldi	r24, 0x01	; 1
    1e00:	d8 01       	movw	r26, r16
    1e02:	56 96       	adiw	r26, 0x16	; 22
    1e04:	2c 91       	ld	r18, X
    1e06:	56 97       	sbiw	r26, 0x16	; 22
    1e08:	96 89       	ldd	r25, Z+22	; 0x16
    1e0a:	29 17       	cp	r18, r25
    1e0c:	08 f4       	brcc	.+2      	; 0x1e10 <xTaskRemoveFromEventList+0x86>
    1e0e:	80 e0       	ldi	r24, 0x00	; 0
}
    1e10:	df 91       	pop	r29
    1e12:	cf 91       	pop	r28
    1e14:	1f 91       	pop	r17
    1e16:	0f 91       	pop	r16
    1e18:	08 95       	ret

00001e1a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1e1a:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1e1c:	80 91 68 1a 	lds	r24, 0x1A68
    1e20:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1e22:	80 91 6e 1a 	lds	r24, 0x1A6E
    1e26:	90 91 6f 1a 	lds	r25, 0x1A6F
    1e2a:	92 83       	std	Z+2, r25	; 0x02
    1e2c:	81 83       	std	Z+1, r24	; 0x01
}
    1e2e:	08 95       	ret

00001e30 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1e30:	fc 01       	movw	r30, r24
    1e32:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1e3a:	4d 91       	ld	r20, X+
    1e3c:	5c 91       	ld	r21, X
    1e3e:	11 97       	sbiw	r26, 0x01	; 1
    1e40:	6f ef       	ldi	r22, 0xFF	; 255
    1e42:	4f 3f       	cpi	r20, 0xFF	; 255
    1e44:	56 07       	cpc	r21, r22
    1e46:	51 f1       	breq	.+84     	; 0x1e9c <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1e48:	80 91 68 1a 	lds	r24, 0x1A68
    1e4c:	90 81       	ld	r25, Z
    1e4e:	98 17       	cp	r25, r24
    1e50:	49 f0       	breq	.+18     	; 0x1e64 <xTaskCheckForTimeOut+0x34>
    1e52:	20 91 6e 1a 	lds	r18, 0x1A6E
    1e56:	30 91 6f 1a 	lds	r19, 0x1A6F
    1e5a:	81 81       	ldd	r24, Z+1	; 0x01
    1e5c:	92 81       	ldd	r25, Z+2	; 0x02
    1e5e:	28 17       	cp	r18, r24
    1e60:	39 07       	cpc	r19, r25
    1e62:	f0 f4       	brcc	.+60     	; 0x1ea0 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1e64:	80 91 6e 1a 	lds	r24, 0x1A6E
    1e68:	90 91 6f 1a 	lds	r25, 0x1A6F
    1e6c:	21 81       	ldd	r18, Z+1	; 0x01
    1e6e:	32 81       	ldd	r19, Z+2	; 0x02
    1e70:	82 1b       	sub	r24, r18
    1e72:	93 0b       	sbc	r25, r19
    1e74:	84 17       	cp	r24, r20
    1e76:	95 07       	cpc	r25, r21
    1e78:	a8 f4       	brcc	.+42     	; 0x1ea4 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1e7a:	80 91 6e 1a 	lds	r24, 0x1A6E
    1e7e:	90 91 6f 1a 	lds	r25, 0x1A6F
    1e82:	b9 01       	movw	r22, r18
    1e84:	68 1b       	sub	r22, r24
    1e86:	79 0b       	sbc	r23, r25
    1e88:	cb 01       	movw	r24, r22
    1e8a:	84 0f       	add	r24, r20
    1e8c:	95 1f       	adc	r25, r21
    1e8e:	8d 93       	st	X+, r24
    1e90:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1e92:	cf 01       	movw	r24, r30
    1e94:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1e98:	80 e0       	ldi	r24, 0x00	; 0
    1e9a:	05 c0       	rjmp	.+10     	; 0x1ea6 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1e9c:	80 e0       	ldi	r24, 0x00	; 0
    1e9e:	03 c0       	rjmp	.+6      	; 0x1ea6 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	01 c0       	rjmp	.+2      	; 0x1ea6 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1ea4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1ea6:	0f 90       	pop	r0
    1ea8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1eaa:	08 95       	ret

00001eac <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	80 93 69 1a 	sts	0x1A69, r24
}
    1eb2:	08 95       	ret

00001eb4 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1eb4:	00 97       	sbiw	r24, 0x00	; 0
    1eb6:	29 f4       	brne	.+10     	; 0x1ec2 <uxTaskGetStackHighWaterMark+0xe>
    1eb8:	e0 91 66 1a 	lds	r30, 0x1A66
    1ebc:	f0 91 67 1a 	lds	r31, 0x1A67
    1ec0:	01 c0       	rjmp	.+2      	; 0x1ec4 <uxTaskGetStackHighWaterMark+0x10>
    1ec2:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1ec4:	07 88       	ldd	r0, Z+23	; 0x17
    1ec6:	f0 8d       	ldd	r31, Z+24	; 0x18
    1ec8:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1eca:	80 81       	ld	r24, Z
    1ecc:	85 3a       	cpi	r24, 0xA5	; 165
    1ece:	41 f4       	brne	.+16     	; 0x1ee0 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    1ed0:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1ed2:	80 e0       	ldi	r24, 0x00	; 0
    1ed4:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    1ed6:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1ed8:	21 91       	ld	r18, Z+
    1eda:	25 3a       	cpi	r18, 0xA5	; 165
    1edc:	e1 f3       	breq	.-8      	; 0x1ed6 <uxTaskGetStackHighWaterMark+0x22>
    1ede:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1ee0:	80 e0       	ldi	r24, 0x00	; 0
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    1ee4:	08 95       	ret

00001ee6 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1ee6:	80 91 66 1a 	lds	r24, 0x1A66
    1eea:	90 91 67 1a 	lds	r25, 0x1A67

		return xReturn;
	}
    1eee:	08 95       	ret

00001ef0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1ef0:	0f 93       	push	r16
    1ef2:	1f 93       	push	r17
    1ef4:	cf 93       	push	r28
    1ef6:	df 93       	push	r29
    1ef8:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1efa:	00 97       	sbiw	r24, 0x00	; 0
    1efc:	09 f4       	brne	.+2      	; 0x1f00 <vTaskPriorityInherit+0x10>
    1efe:	4d c0       	rjmp	.+154    	; 0x1f9a <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1f00:	8e 89       	ldd	r24, Y+22	; 0x16
    1f02:	e0 91 66 1a 	lds	r30, 0x1A66
    1f06:	f0 91 67 1a 	lds	r31, 0x1A67
    1f0a:	96 89       	ldd	r25, Z+22	; 0x16
    1f0c:	89 17       	cp	r24, r25
    1f0e:	08 f0       	brcs	.+2      	; 0x1f12 <vTaskPriorityInherit+0x22>
    1f10:	44 c0       	rjmp	.+136    	; 0x1f9a <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1f12:	e0 91 66 1a 	lds	r30, 0x1A66
    1f16:	f0 91 67 1a 	lds	r31, 0x1A67
    1f1a:	96 89       	ldd	r25, Z+22	; 0x16
    1f1c:	24 e0       	ldi	r18, 0x04	; 4
    1f1e:	30 e0       	ldi	r19, 0x00	; 0
    1f20:	29 1b       	sub	r18, r25
    1f22:	31 09       	sbc	r19, r1
    1f24:	3d 87       	std	Y+13, r19	; 0x0d
    1f26:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1f28:	90 e0       	ldi	r25, 0x00	; 0
    1f2a:	9c 01       	movw	r18, r24
    1f2c:	22 0f       	add	r18, r18
    1f2e:	33 1f       	adc	r19, r19
    1f30:	22 0f       	add	r18, r18
    1f32:	33 1f       	adc	r19, r19
    1f34:	22 0f       	add	r18, r18
    1f36:	33 1f       	adc	r19, r19
    1f38:	82 0f       	add	r24, r18
    1f3a:	93 1f       	adc	r25, r19
    1f3c:	89 58       	subi	r24, 0x89	; 137
    1f3e:	95 4e       	sbci	r25, 0xE5	; 229
    1f40:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f42:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f44:	28 17       	cp	r18, r24
    1f46:	39 07       	cpc	r19, r25
    1f48:	11 f5       	brne	.+68     	; 0x1f8e <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1f4a:	8e 01       	movw	r16, r28
    1f4c:	0e 5f       	subi	r16, 0xFE	; 254
    1f4e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f50:	c8 01       	movw	r24, r16
    1f52:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f56:	e0 91 66 1a 	lds	r30, 0x1A66
    1f5a:	f0 91 67 1a 	lds	r31, 0x1A67
    1f5e:	86 89       	ldd	r24, Z+22	; 0x16
    1f60:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1f62:	90 91 6d 1a 	lds	r25, 0x1A6D
    1f66:	98 17       	cp	r25, r24
    1f68:	10 f4       	brcc	.+4      	; 0x1f6e <vTaskPriorityInherit+0x7e>
    1f6a:	80 93 6d 1a 	sts	0x1A6D, r24
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	9c 01       	movw	r18, r24
    1f72:	22 0f       	add	r18, r18
    1f74:	33 1f       	adc	r19, r19
    1f76:	22 0f       	add	r18, r18
    1f78:	33 1f       	adc	r19, r19
    1f7a:	22 0f       	add	r18, r18
    1f7c:	33 1f       	adc	r19, r19
    1f7e:	82 0f       	add	r24, r18
    1f80:	93 1f       	adc	r25, r19
    1f82:	89 58       	subi	r24, 0x89	; 137
    1f84:	95 4e       	sbci	r25, 0xE5	; 229
    1f86:	b8 01       	movw	r22, r16
    1f88:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1f8c:	06 c0       	rjmp	.+12     	; 0x1f9a <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f8e:	e0 91 66 1a 	lds	r30, 0x1A66
    1f92:	f0 91 67 1a 	lds	r31, 0x1A67
    1f96:	86 89       	ldd	r24, Z+22	; 0x16
    1f98:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	1f 91       	pop	r17
    1fa0:	0f 91       	pop	r16
    1fa2:	08 95       	ret

00001fa4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1fa4:	0f 93       	push	r16
    1fa6:	1f 93       	push	r17
    1fa8:	cf 93       	push	r28
    1faa:	df 93       	push	r29
    1fac:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1fae:	00 97       	sbiw	r24, 0x00	; 0
    1fb0:	49 f1       	breq	.+82     	; 0x2004 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1fb2:	9e 89       	ldd	r25, Y+22	; 0x16
    1fb4:	89 a5       	lds	r24, 0x69
    1fb6:	98 17       	cp	r25, r24
    1fb8:	29 f1       	breq	.+74     	; 0x2004 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1fba:	8e 01       	movw	r16, r28
    1fbc:	0e 5f       	subi	r16, 0xFE	; 254
    1fbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc0:	c8 01       	movw	r24, r16
    1fc2:	0e 94 c4 04 	call	0x988	; 0x988 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1fc6:	49 a5       	lds	r20, 0x69
    1fc8:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1fca:	24 2f       	mov	r18, r20
    1fcc:	30 e0       	ldi	r19, 0x00	; 0
    1fce:	84 e0       	ldi	r24, 0x04	; 4
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	82 1b       	sub	r24, r18
    1fd4:	93 0b       	sbc	r25, r19
    1fd6:	9d 87       	std	Y+13, r25	; 0x0d
    1fd8:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    1fda:	80 91 6d 1a 	lds	r24, 0x1A6D
    1fde:	84 17       	cp	r24, r20
    1fe0:	10 f4       	brcc	.+4      	; 0x1fe6 <vTaskPriorityDisinherit+0x42>
    1fe2:	40 93 6d 1a 	sts	0x1A6D, r20
    1fe6:	c9 01       	movw	r24, r18
    1fe8:	88 0f       	add	r24, r24
    1fea:	99 1f       	adc	r25, r25
    1fec:	88 0f       	add	r24, r24
    1fee:	99 1f       	adc	r25, r25
    1ff0:	88 0f       	add	r24, r24
    1ff2:	99 1f       	adc	r25, r25
    1ff4:	28 0f       	add	r18, r24
    1ff6:	39 1f       	adc	r19, r25
    1ff8:	c9 01       	movw	r24, r18
    1ffa:	89 58       	subi	r24, 0x89	; 137
    1ffc:	95 4e       	sbci	r25, 0xE5	; 229
    1ffe:	b8 01       	movw	r22, r16
    2000:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
			}
		}
	}
    2004:	df 91       	pop	r29
    2006:	cf 91       	pop	r28
    2008:	1f 91       	pop	r17
    200a:	0f 91       	pop	r16
    200c:	08 95       	ret

0000200e <memcpy>:
    200e:	fb 01       	movw	r30, r22
    2010:	dc 01       	movw	r26, r24
    2012:	02 c0       	rjmp	.+4      	; 0x2018 <memcpy+0xa>
    2014:	01 90       	ld	r0, Z+
    2016:	0d 92       	st	X+, r0
    2018:	41 50       	subi	r20, 0x01	; 1
    201a:	50 40       	sbci	r21, 0x00	; 0
    201c:	d8 f7       	brcc	.-10     	; 0x2014 <memcpy+0x6>
    201e:	08 95       	ret

00002020 <memset>:
    2020:	dc 01       	movw	r26, r24
    2022:	01 c0       	rjmp	.+2      	; 0x2026 <memset+0x6>
    2024:	6d 93       	st	X+, r22
    2026:	41 50       	subi	r20, 0x01	; 1
    2028:	50 40       	sbci	r21, 0x00	; 0
    202a:	e0 f7       	brcc	.-8      	; 0x2024 <memset+0x4>
    202c:	08 95       	ret

0000202e <strncpy>:
    202e:	fb 01       	movw	r30, r22
    2030:	dc 01       	movw	r26, r24
    2032:	41 50       	subi	r20, 0x01	; 1
    2034:	50 40       	sbci	r21, 0x00	; 0
    2036:	48 f0       	brcs	.+18     	; 0x204a <strncpy+0x1c>
    2038:	01 90       	ld	r0, Z+
    203a:	0d 92       	st	X+, r0
    203c:	00 20       	and	r0, r0
    203e:	c9 f7       	brne	.-14     	; 0x2032 <strncpy+0x4>
    2040:	01 c0       	rjmp	.+2      	; 0x2044 <strncpy+0x16>
    2042:	1d 92       	st	X+, r1
    2044:	41 50       	subi	r20, 0x01	; 1
    2046:	50 40       	sbci	r21, 0x00	; 0
    2048:	e0 f7       	brcc	.-8      	; 0x2042 <strncpy+0x14>
    204a:	08 95       	ret

0000204c <_exit>:
    204c:	f8 94       	cli

0000204e <__stop_program>:
    204e:	ff cf       	rjmp	.-2      	; 0x204e <__stop_program>
