
Lab 5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000060  00800200  00003cc8  00003d5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003cc8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018c7  00800260  00800260  00003dbc  2**0
                  ALLOC
  3 .stab         00002dcc  00000000  00000000  00003dbc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ba1  00000000  00000000  00006b88  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000258  00000000  00000000  00007730  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003588  00000000  00000000  00007988  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e9e  00000000  00000000  0000af10  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001622  00000000  00000000  0000bdae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000cf0  00000000  00000000  0000d3d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001330  00000000  00000000  0000e0c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000396d  00000000  00000000  0000f3f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  00012d5d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 81 00 	jmp	0x102	; 0x102 <__ctors_end>
       4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      10:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      14:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      18:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      1c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      20:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      24:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      28:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      2c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      30:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      34:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      38:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      3c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      40:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      44:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      48:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      4c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      50:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      54:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      58:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      5c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      60:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      64:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      68:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      6c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      70:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      74:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      78:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      7c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      80:	0c 94 f0 10 	jmp	0x21e0	; 0x21e0 <__vector_32>
      84:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      88:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      8c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      90:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      94:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      98:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      9c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      ac:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      bc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      cc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      dc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      e0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      e4:	05 a8       	sts	0x85, r16
      e6:	4c cd       	rjmp	.-1384   	; 0xfffffb80 <__eeprom_end+0xff7efb80>
      e8:	b2 d4       	rcall	.+2404   	; 0xa4e <init+0x20>
      ea:	4e b9       	out	0x0e, r20	; 14
      ec:	38 36       	cpi	r19, 0x68	; 104
      ee:	a9 02       	muls	r26, r25
      f0:	0c 50       	subi	r16, 0x0C	; 12
      f2:	b9 91       	ld	r27, Y+
      f4:	86 88       	ldd	r8, Z+22	; 0x16
      f6:	08 3c       	cpi	r16, 0xC8	; 200
      f8:	a6 aa       	sts	0x96, r26
      fa:	aa 2a       	or	r10, r26
      fc:	be 00       	.word	0x00be	; ????
      fe:	00 00       	nop
     100:	80 3f       	cpi	r24, 0xF0	; 240

00000102 <__ctors_end>:
     102:	11 24       	eor	r1, r1
     104:	1f be       	out	0x3f, r1	; 63
     106:	cf ef       	ldi	r28, 0xFF	; 255
     108:	d1 e2       	ldi	r29, 0x21	; 33
     10a:	de bf       	out	0x3e, r29	; 62
     10c:	cd bf       	out	0x3d, r28	; 61
     10e:	00 e0       	ldi	r16, 0x00	; 0
     110:	0c bf       	out	0x3c, r16	; 60

00000112 <__do_copy_data>:
     112:	12 e0       	ldi	r17, 0x02	; 2
     114:	a0 e0       	ldi	r26, 0x00	; 0
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	e8 ec       	ldi	r30, 0xC8	; 200
     11a:	fc e3       	ldi	r31, 0x3C	; 60
     11c:	00 e0       	ldi	r16, 0x00	; 0
     11e:	0b bf       	out	0x3b, r16	; 59
     120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x14>
     122:	07 90       	elpm	r0, Z+
     124:	0d 92       	st	X+, r0
     126:	a0 36       	cpi	r26, 0x60	; 96
     128:	b1 07       	cpc	r27, r17
     12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0x10>
     12c:	1b be       	out	0x3b, r1	; 59

0000012e <__do_clear_bss>:
     12e:	1b e1       	ldi	r17, 0x1B	; 27
     130:	a0 e6       	ldi	r26, 0x60	; 96
     132:	b2 e0       	ldi	r27, 0x02	; 2
     134:	01 c0       	rjmp	.+2      	; 0x138 <.do_clear_bss_start>

00000136 <.do_clear_bss_loop>:
     136:	1d 92       	st	X+, r1

00000138 <.do_clear_bss_start>:
     138:	a7 32       	cpi	r26, 0x27	; 39
     13a:	b1 07       	cpc	r27, r17
     13c:	e1 f7       	brne	.-8      	; 0x136 <.do_clear_bss_loop>
     13e:	0e 94 0b 04 	call	0x816	; 0x816 <main>
     142:	0c 94 62 1e 	jmp	0x3cc4	; 0x3cc4 <_exit>

00000146 <__bad_interrupt>:
     146:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014a <inputTask>:
 *  if the player should turn, accelerate, or both. This task never blocks, so
 *  it should run at the lowest priority above the idle task priority.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void inputTask(void *vParam) {
     14a:	ff cf       	rjmp	.-2      	; 0x14a <inputTask>

0000014c <updateTask>:
 *  If a bullet has been in flight for too long, this task will delete it. This
 *  task runs every 10 milliseconds.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void updateTask(void *vParam) {
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	0f 92       	push	r0
     152:	0f 92       	push	r0
     154:	cd b7       	in	r28, 0x3d	; 61
     156:	de b7       	in	r29, 0x3e	; 62
		ship.vel.x += ship.accel * -sin(ship.angle * DEG_TO_RAD);
		ship.vel.y += ship.accel * -cos(ship.angle * DEG_TO_RAD);
		vel = ship.vel.x * ship.vel.x + ship.vel.y * ship.vel.y;
		if (vel > SHIP_MAX_VEL) {
			ship.vel.x *= SHIP_MAX_VEL / vel;
			ship.vel.y *= SHIP_MAX_VEL / vel;
     158:	89 e6       	ldi	r24, 0x69	; 105
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	04 96       	adiw	r24, 0x04	; 4
     15e:	9a 83       	std	Y+2, r25	; 0x02
     160:	89 83       	std	Y+1, r24	; 0x01
	float vel;
	object *objIter, *objPrev;
	for (;;) {
		
		// spin ship
		ship.angle += ship.a_vel;
     162:	e7 e7       	ldi	r30, 0x77	; 119
     164:	f2 e0       	ldi	r31, 0x02	; 2
     166:	80 81       	ld	r24, Z
     168:	99 27       	eor	r25, r25
     16a:	87 fd       	sbrc	r24, 7
     16c:	90 95       	com	r25
     16e:	32 97       	sbiw	r30, 0x02	; 2
     170:	20 81       	ld	r18, Z
     172:	31 81       	ldd	r19, Z+1	; 0x01
     174:	82 0f       	add	r24, r18
     176:	93 1f       	adc	r25, r19
     178:	91 83       	std	Z+1, r25	; 0x01
     17a:	80 83       	st	Z, r24
		if (ship.angle >= 360)
     17c:	f1 e0       	ldi	r31, 0x01	; 1
     17e:	88 36       	cpi	r24, 0x68	; 104
     180:	9f 07       	cpc	r25, r31
     182:	2c f0       	brlt	.+10     	; 0x18e <updateTask+0x42>
		    ship.angle -= 360;
     184:	88 56       	subi	r24, 0x68	; 104
     186:	91 40       	sbci	r25, 0x01	; 1
     188:	91 83       	std	Z+1, r25	; 0x01
     18a:	80 83       	st	Z, r24
     18c:	08 c0       	rjmp	.+16     	; 0x19e <updateTask+0x52>
		else if (ship.angle < 0)
     18e:	99 23       	and	r25, r25
     190:	34 f4       	brge	.+12     	; 0x19e <updateTask+0x52>
		    ship.angle += 360;
     192:	88 59       	subi	r24, 0x98	; 152
     194:	9e 4f       	sbci	r25, 0xFE	; 254
     196:	e5 e7       	ldi	r30, 0x75	; 117
     198:	f2 e0       	ldi	r31, 0x02	; 2
     19a:	91 83       	std	Z+1, r25	; 0x01
     19c:	80 83       	st	Z, r24
		
		// move ship
		ship.vel.x += ship.accel * -sin(ship.angle * DEG_TO_RAD);
     19e:	e1 e7       	ldi	r30, 0x71	; 113
     1a0:	f2 e0       	ldi	r31, 0x02	; 2
     1a2:	c0 80       	ld	r12, Z
     1a4:	d1 80       	ldd	r13, Z+1	; 0x01
     1a6:	e2 80       	ldd	r14, Z+2	; 0x02
     1a8:	f3 80       	ldd	r15, Z+3	; 0x03
     1aa:	34 96       	adiw	r30, 0x04	; 4
     1ac:	60 81       	ld	r22, Z
     1ae:	71 81       	ldd	r23, Z+1	; 0x01
     1b0:	88 27       	eor	r24, r24
     1b2:	77 fd       	sbrc	r23, 7
     1b4:	80 95       	com	r24
     1b6:	98 2f       	mov	r25, r24
     1b8:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     1bc:	2b ed       	ldi	r18, 0xDB	; 219
     1be:	3f e0       	ldi	r19, 0x0F	; 15
     1c0:	49 e4       	ldi	r20, 0x49	; 73
     1c2:	50 e4       	ldi	r21, 0x40	; 64
     1c4:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     1c8:	20 e0       	ldi	r18, 0x00	; 0
     1ca:	30 e0       	ldi	r19, 0x00	; 0
     1cc:	44 e3       	ldi	r20, 0x34	; 52
     1ce:	53 e4       	ldi	r21, 0x43	; 67
     1d0:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     1d4:	b6 2e       	mov	r11, r22
     1d6:	87 2e       	mov	r8, r23
     1d8:	18 2f       	mov	r17, r24
     1da:	09 2f       	mov	r16, r25
     1dc:	86 2f       	mov	r24, r22
     1de:	98 2d       	mov	r25, r8
     1e0:	a1 2f       	mov	r26, r17
     1e2:	b0 2f       	mov	r27, r16
     1e4:	bc 01       	movw	r22, r24
     1e6:	cd 01       	movw	r24, r26
     1e8:	0e 94 11 1d 	call	0x3a22	; 0x3a22 <sin>
     1ec:	dc 01       	movw	r26, r24
     1ee:	cb 01       	movw	r24, r22
     1f0:	9c 01       	movw	r18, r24
     1f2:	ad 01       	movw	r20, r26
     1f4:	50 58       	subi	r21, 0x80	; 128
     1f6:	c7 01       	movw	r24, r14
     1f8:	b6 01       	movw	r22, r12
     1fa:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     1fe:	e9 e6       	ldi	r30, 0x69	; 105
     200:	f2 e0       	ldi	r31, 0x02	; 2
     202:	20 81       	ld	r18, Z
     204:	31 81       	ldd	r19, Z+1	; 0x01
     206:	42 81       	ldd	r20, Z+2	; 0x02
     208:	53 81       	ldd	r21, Z+3	; 0x03
     20a:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     20e:	46 2e       	mov	r4, r22
     210:	37 2e       	mov	r3, r23
     212:	28 2e       	mov	r2, r24
     214:	79 2e       	mov	r7, r25
     216:	86 2f       	mov	r24, r22
     218:	93 2d       	mov	r25, r3
     21a:	a2 2d       	mov	r26, r2
     21c:	b7 2d       	mov	r27, r7
     21e:	e9 e6       	ldi	r30, 0x69	; 105
     220:	f2 e0       	ldi	r31, 0x02	; 2
     222:	80 83       	st	Z, r24
     224:	91 83       	std	Z+1, r25	; 0x01
     226:	a2 83       	std	Z+2, r26	; 0x02
     228:	b3 83       	std	Z+3, r27	; 0x03
		ship.vel.y += ship.accel * -cos(ship.angle * DEG_TO_RAD);
     22a:	8b 2d       	mov	r24, r11
     22c:	98 2d       	mov	r25, r8
     22e:	a1 2f       	mov	r26, r17
     230:	b0 2f       	mov	r27, r16
     232:	bc 01       	movw	r22, r24
     234:	cd 01       	movw	r24, r26
     236:	0e 94 23 1b 	call	0x3646	; 0x3646 <cos>
     23a:	dc 01       	movw	r26, r24
     23c:	cb 01       	movw	r24, r22
     23e:	9c 01       	movw	r18, r24
     240:	ad 01       	movw	r20, r26
     242:	50 58       	subi	r21, 0x80	; 128
     244:	c7 01       	movw	r24, r14
     246:	b6 01       	movw	r22, r12
     248:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     24c:	ed e6       	ldi	r30, 0x6D	; 109
     24e:	f2 e0       	ldi	r31, 0x02	; 2
     250:	20 81       	ld	r18, Z
     252:	31 81       	ldd	r19, Z+1	; 0x01
     254:	42 81       	ldd	r20, Z+2	; 0x02
     256:	53 81       	ldd	r21, Z+3	; 0x03
     258:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     25c:	66 2e       	mov	r6, r22
     25e:	57 2e       	mov	r5, r23
     260:	f8 2e       	mov	r15, r24
     262:	e9 2e       	mov	r14, r25
     264:	86 2f       	mov	r24, r22
     266:	95 2d       	mov	r25, r5
     268:	af 2d       	mov	r26, r15
     26a:	be 2d       	mov	r27, r14
     26c:	ed e6       	ldi	r30, 0x6D	; 109
     26e:	f2 e0       	ldi	r31, 0x02	; 2
     270:	80 83       	st	Z, r24
     272:	91 83       	std	Z+1, r25	; 0x01
     274:	a2 83       	std	Z+2, r26	; 0x02
     276:	b3 83       	std	Z+3, r27	; 0x03
		vel = ship.vel.x * ship.vel.x + ship.vel.y * ship.vel.y;
     278:	32 2d       	mov	r19, r2
     27a:	84 2d       	mov	r24, r4
     27c:	93 2d       	mov	r25, r3
     27e:	a2 2d       	mov	r26, r2
     280:	b7 2d       	mov	r27, r7
     282:	bc 01       	movw	r22, r24
     284:	cd 01       	movw	r24, r26
     286:	04 2d       	mov	r16, r4
     288:	13 2d       	mov	r17, r3
     28a:	23 2f       	mov	r18, r19
     28c:	3b 2f       	mov	r19, r27
     28e:	a9 01       	movw	r20, r18
     290:	98 01       	movw	r18, r16
     292:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     296:	4b 01       	movw	r8, r22
     298:	5c 01       	movw	r10, r24
     29a:	3f 2d       	mov	r19, r15
     29c:	86 2d       	mov	r24, r6
     29e:	95 2d       	mov	r25, r5
     2a0:	af 2d       	mov	r26, r15
     2a2:	be 2d       	mov	r27, r14
     2a4:	bc 01       	movw	r22, r24
     2a6:	cd 01       	movw	r24, r26
     2a8:	06 2d       	mov	r16, r6
     2aa:	15 2d       	mov	r17, r5
     2ac:	23 2f       	mov	r18, r19
     2ae:	3b 2f       	mov	r19, r27
     2b0:	a9 01       	movw	r20, r18
     2b2:	98 01       	movw	r18, r16
     2b4:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     2b8:	9b 01       	movw	r18, r22
     2ba:	ac 01       	movw	r20, r24
     2bc:	c5 01       	movw	r24, r10
     2be:	b4 01       	movw	r22, r8
     2c0:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     2c4:	16 2f       	mov	r17, r22
     2c6:	07 2f       	mov	r16, r23
     2c8:	c8 2e       	mov	r12, r24
     2ca:	89 2e       	mov	r8, r25
		if (vel > SHIP_MAX_VEL) {
     2cc:	86 2f       	mov	r24, r22
     2ce:	90 2f       	mov	r25, r16
     2d0:	ac 2d       	mov	r26, r12
     2d2:	b8 2d       	mov	r27, r8
     2d4:	bc 01       	movw	r22, r24
     2d6:	cd 01       	movw	r24, r26
     2d8:	20 e0       	ldi	r18, 0x00	; 0
     2da:	30 e0       	ldi	r19, 0x00	; 0
     2dc:	40 e0       	ldi	r20, 0x00	; 0
     2de:	51 e4       	ldi	r21, 0x41	; 65
     2e0:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     2e4:	18 16       	cp	r1, r24
     2e6:	dc f5       	brge	.+118    	; 0x35e <updateTask+0x212>
			ship.vel.x *= SHIP_MAX_VEL / vel;
     2e8:	60 e0       	ldi	r22, 0x00	; 0
     2ea:	70 e0       	ldi	r23, 0x00	; 0
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	91 e4       	ldi	r25, 0x41	; 65
     2f0:	e0 2f       	mov	r30, r16
     2f2:	01 2f       	mov	r16, r17
     2f4:	1e 2f       	mov	r17, r30
     2f6:	2c 2d       	mov	r18, r12
     2f8:	38 2d       	mov	r19, r8
     2fa:	a9 01       	movw	r20, r18
     2fc:	98 01       	movw	r18, r16
     2fe:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     302:	c6 2e       	mov	r12, r22
     304:	87 2e       	mov	r8, r23
     306:	d8 2e       	mov	r13, r24
     308:	b9 2e       	mov	r11, r25
     30a:	84 2d       	mov	r24, r4
     30c:	93 2d       	mov	r25, r3
     30e:	a2 2d       	mov	r26, r2
     310:	b7 2d       	mov	r27, r7
     312:	bc 01       	movw	r22, r24
     314:	cd 01       	movw	r24, r26
     316:	0c 2d       	mov	r16, r12
     318:	18 2d       	mov	r17, r8
     31a:	2d 2d       	mov	r18, r13
     31c:	3b 2d       	mov	r19, r11
     31e:	a9 01       	movw	r20, r18
     320:	98 01       	movw	r18, r16
     322:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     326:	dc 01       	movw	r26, r24
     328:	cb 01       	movw	r24, r22
     32a:	e9 e6       	ldi	r30, 0x69	; 105
     32c:	f2 e0       	ldi	r31, 0x02	; 2
     32e:	80 83       	st	Z, r24
     330:	91 83       	std	Z+1, r25	; 0x01
     332:	a2 83       	std	Z+2, r26	; 0x02
     334:	b3 83       	std	Z+3, r27	; 0x03
			ship.vel.y *= SHIP_MAX_VEL / vel;
     336:	86 2d       	mov	r24, r6
     338:	95 2d       	mov	r25, r5
     33a:	af 2d       	mov	r26, r15
     33c:	be 2d       	mov	r27, r14
     33e:	bc 01       	movw	r22, r24
     340:	cd 01       	movw	r24, r26
     342:	2d 2d       	mov	r18, r13
     344:	3b 2d       	mov	r19, r11
     346:	a9 01       	movw	r20, r18
     348:	98 01       	movw	r18, r16
     34a:	0e 94 ae 1c 	call	0x395c	; 0x395c <__mulsf3>
     34e:	dc 01       	movw	r26, r24
     350:	cb 01       	movw	r24, r22
     352:	e9 81       	ldd	r30, Y+1	; 0x01
     354:	fa 81       	ldd	r31, Y+2	; 0x02
     356:	80 83       	st	Z, r24
     358:	91 83       	std	Z+1, r25	; 0x01
     35a:	a2 83       	std	Z+2, r26	; 0x02
     35c:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		ship.pos.x += ship.vel.x;
     35e:	e1 e6       	ldi	r30, 0x61	; 97
     360:	f2 e0       	ldi	r31, 0x02	; 2
     362:	60 81       	ld	r22, Z
     364:	71 81       	ldd	r23, Z+1	; 0x01
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	38 96       	adiw	r30, 0x08	; 8
     36c:	20 81       	ld	r18, Z
     36e:	31 81       	ldd	r19, Z+1	; 0x01
     370:	42 81       	ldd	r20, Z+2	; 0x02
     372:	53 81       	ldd	r21, Z+3	; 0x03
     374:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     378:	06 2f       	mov	r16, r22
     37a:	17 2f       	mov	r17, r23
     37c:	e8 2e       	mov	r14, r24
     37e:	f9 2e       	mov	r15, r25
     380:	86 2f       	mov	r24, r22
     382:	91 2f       	mov	r25, r17
     384:	ae 2d       	mov	r26, r14
     386:	bf 2d       	mov	r27, r15
     388:	e1 e6       	ldi	r30, 0x61	; 97
     38a:	f2 e0       	ldi	r31, 0x02	; 2
     38c:	80 83       	st	Z, r24
     38e:	91 83       	std	Z+1, r25	; 0x01
     390:	a2 83       	std	Z+2, r26	; 0x02
     392:	b3 83       	std	Z+3, r27	; 0x03
		ship.pos.y += ship.vel.y;
     394:	34 96       	adiw	r30, 0x04	; 4
     396:	60 81       	ld	r22, Z
     398:	71 81       	ldd	r23, Z+1	; 0x01
     39a:	82 81       	ldd	r24, Z+2	; 0x02
     39c:	93 81       	ldd	r25, Z+3	; 0x03
     39e:	38 96       	adiw	r30, 0x08	; 8
     3a0:	20 81       	ld	r18, Z
     3a2:	31 81       	ldd	r19, Z+1	; 0x01
     3a4:	42 81       	ldd	r20, Z+2	; 0x02
     3a6:	53 81       	ldd	r21, Z+3	; 0x03
     3a8:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     3ac:	dc 01       	movw	r26, r24
     3ae:	cb 01       	movw	r24, r22
     3b0:	e5 e6       	ldi	r30, 0x65	; 101
     3b2:	f2 e0       	ldi	r31, 0x02	; 2
     3b4:	80 83       	st	Z, r24
     3b6:	91 83       	std	Z+1, r25	; 0x01
     3b8:	a2 83       	std	Z+2, r26	; 0x02
     3ba:	b3 83       	std	Z+3, r27	; 0x03
		
		if (ship.pos.x < 0.0) {
     3bc:	80 2f       	mov	r24, r16
     3be:	91 2f       	mov	r25, r17
     3c0:	ae 2d       	mov	r26, r14
     3c2:	bf 2d       	mov	r27, r15
     3c4:	bc 01       	movw	r22, r24
     3c6:	cd 01       	movw	r24, r26
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	a9 01       	movw	r20, r18
     3ce:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     3d2:	88 23       	and	r24, r24
     3d4:	ac f4       	brge	.+42     	; 0x400 <updateTask+0x2b4>
			ship.pos.x += SCREEN_W;
     3d6:	80 2f       	mov	r24, r16
     3d8:	91 2f       	mov	r25, r17
     3da:	ae 2d       	mov	r26, r14
     3dc:	bf 2d       	mov	r27, r15
     3de:	bc 01       	movw	r22, r24
     3e0:	cd 01       	movw	r24, r26
     3e2:	20 e0       	ldi	r18, 0x00	; 0
     3e4:	30 e0       	ldi	r19, 0x00	; 0
     3e6:	48 e4       	ldi	r20, 0x48	; 72
     3e8:	54 e4       	ldi	r21, 0x44	; 68
     3ea:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     3ee:	dc 01       	movw	r26, r24
     3f0:	cb 01       	movw	r24, r22
     3f2:	e1 e6       	ldi	r30, 0x61	; 97
     3f4:	f2 e0       	ldi	r31, 0x02	; 2
     3f6:	80 83       	st	Z, r24
     3f8:	91 83       	std	Z+1, r25	; 0x01
     3fa:	a2 83       	std	Z+2, r26	; 0x02
     3fc:	b3 83       	std	Z+3, r27	; 0x03
     3fe:	22 c0       	rjmp	.+68     	; 0x444 <updateTask+0x2f8>
		} else if (ship.pos.x > SCREEN_W) {
     400:	80 2f       	mov	r24, r16
     402:	91 2f       	mov	r25, r17
     404:	ae 2d       	mov	r26, r14
     406:	bf 2d       	mov	r27, r15
     408:	bc 01       	movw	r22, r24
     40a:	cd 01       	movw	r24, r26
     40c:	20 e0       	ldi	r18, 0x00	; 0
     40e:	30 e0       	ldi	r19, 0x00	; 0
     410:	48 e4       	ldi	r20, 0x48	; 72
     412:	54 e4       	ldi	r21, 0x44	; 68
     414:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     418:	18 16       	cp	r1, r24
     41a:	a4 f4       	brge	.+40     	; 0x444 <updateTask+0x2f8>
			ship.pos.x -= SCREEN_W;
     41c:	80 2f       	mov	r24, r16
     41e:	91 2f       	mov	r25, r17
     420:	ae 2d       	mov	r26, r14
     422:	bf 2d       	mov	r27, r15
     424:	bc 01       	movw	r22, r24
     426:	cd 01       	movw	r24, r26
     428:	20 e0       	ldi	r18, 0x00	; 0
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	48 e4       	ldi	r20, 0x48	; 72
     42e:	54 e4       	ldi	r21, 0x44	; 68
     430:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     434:	dc 01       	movw	r26, r24
     436:	cb 01       	movw	r24, r22
     438:	e1 e6       	ldi	r30, 0x61	; 97
     43a:	f2 e0       	ldi	r31, 0x02	; 2
     43c:	80 83       	st	Z, r24
     43e:	91 83       	std	Z+1, r25	; 0x01
     440:	a2 83       	std	Z+2, r26	; 0x02
     442:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		if (ship.pos.y < 0.0) {
     444:	e5 e6       	ldi	r30, 0x65	; 101
     446:	f2 e0       	ldi	r31, 0x02	; 2
     448:	c0 80       	ld	r12, Z
     44a:	d1 80       	ldd	r13, Z+1	; 0x01
     44c:	e2 80       	ldd	r14, Z+2	; 0x02
     44e:	f3 80       	ldd	r15, Z+3	; 0x03
     450:	c7 01       	movw	r24, r14
     452:	b6 01       	movw	r22, r12
     454:	20 e0       	ldi	r18, 0x00	; 0
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	a9 01       	movw	r20, r18
     45a:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     45e:	88 23       	and	r24, r24
     460:	8c f4       	brge	.+34     	; 0x484 <updateTask+0x338>
			ship.pos.y += SCREEN_H;
     462:	c7 01       	movw	r24, r14
     464:	b6 01       	movw	r22, r12
     466:	20 e0       	ldi	r18, 0x00	; 0
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	46 e1       	ldi	r20, 0x16	; 22
     46c:	54 e4       	ldi	r21, 0x44	; 68
     46e:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     472:	dc 01       	movw	r26, r24
     474:	cb 01       	movw	r24, r22
     476:	e5 e6       	ldi	r30, 0x65	; 101
     478:	f2 e0       	ldi	r31, 0x02	; 2
     47a:	80 83       	st	Z, r24
     47c:	91 83       	std	Z+1, r25	; 0x01
     47e:	a2 83       	std	Z+2, r26	; 0x02
     480:	b3 83       	std	Z+3, r27	; 0x03
     482:	1a c0       	rjmp	.+52     	; 0x4b8 <updateTask+0x36c>
		} else if (ship.pos.y > SCREEN_H) {
     484:	c7 01       	movw	r24, r14
     486:	b6 01       	movw	r22, r12
     488:	20 e0       	ldi	r18, 0x00	; 0
     48a:	30 e0       	ldi	r19, 0x00	; 0
     48c:	46 e1       	ldi	r20, 0x16	; 22
     48e:	54 e4       	ldi	r21, 0x44	; 68
     490:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     494:	18 16       	cp	r1, r24
     496:	84 f4       	brge	.+32     	; 0x4b8 <updateTask+0x36c>
			ship.pos.y -= SCREEN_H;
     498:	c7 01       	movw	r24, r14
     49a:	b6 01       	movw	r22, r12
     49c:	20 e0       	ldi	r18, 0x00	; 0
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	46 e1       	ldi	r20, 0x16	; 22
     4a2:	54 e4       	ldi	r21, 0x44	; 68
     4a4:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     4a8:	dc 01       	movw	r26, r24
     4aa:	cb 01       	movw	r24, r22
     4ac:	e5 e6       	ldi	r30, 0x65	; 101
     4ae:	f2 e0       	ldi	r31, 0x02	; 2
     4b0:	80 83       	st	Z, r24
     4b2:	91 83       	std	Z+1, r25	; 0x01
     4b4:	a2 83       	std	Z+2, r26	; 0x02
     4b6:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		// move bullets
		objPrev = NULL;
		objIter = bullets;
     4b8:	80 90 7d 02 	lds	r8, 0x027D
     4bc:	90 90 7e 02 	lds	r9, 0x027E
		while (objIter != NULL) {
     4c0:	81 14       	cp	r8, r1
     4c2:	91 04       	cpc	r9, r1
     4c4:	09 f4       	brne	.+2      	; 0x4c8 <updateTask+0x37c>
     4c6:	f1 c0       	rjmp	.+482    	; 0x6aa <updateTask+0x55e>
		} else if (ship.pos.y > SCREEN_H) {
			ship.pos.y -= SCREEN_H;
		}
		
		// move bullets
		objPrev = NULL;
     4c8:	00 e0       	ldi	r16, 0x00	; 0
     4ca:	10 e0       	ldi	r17, 0x00	; 0
		objIter = bullets;
		while (objIter != NULL) {
			// Kill bullet after a while
			objIter->life += FRAME_DELAY_MS;
     4cc:	f4 01       	movw	r30, r8
     4ce:	81 8d       	ldd	r24, Z+25	; 0x19
     4d0:	92 8d       	ldd	r25, Z+26	; 0x1a
     4d2:	0a 96       	adiw	r24, 0x0a	; 10
     4d4:	92 8f       	std	Z+26, r25	; 0x1a
     4d6:	81 8f       	std	Z+25, r24	; 0x19
			if (objIter->life >= BULLET_LIFE_MS) {
     4d8:	f3 e0       	ldi	r31, 0x03	; 3
     4da:	88 3e       	cpi	r24, 0xE8	; 232
     4dc:	9f 07       	cpc	r25, r31
     4de:	c8 f1       	brcs	.+114    	; 0x552 <updateTask+0x406>
				
				xSemaphoreTake(usartMutex, portMAX_DELAY);
     4e0:	80 91 7f 02 	lds	r24, 0x027F
     4e4:	90 91 80 02 	lds	r25, 0x0280
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	4f ef       	ldi	r20, 0xFF	; 255
     4ee:	5f ef       	ldi	r21, 0xFF	; 255
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	0e 94 30 13 	call	0x2660	; 0x2660 <xQueueGenericReceive>
				vSpriteDelete(objIter->handle);
     4f6:	f4 01       	movw	r30, r8
     4f8:	80 81       	ld	r24, Z
     4fa:	0e 94 4e 0b 	call	0x169c	; 0x169c <vSpriteDelete>
				
				if (objPrev != NULL) {
     4fe:	01 15       	cp	r16, r1
     500:	11 05       	cpc	r17, r1
     502:	69 f0       	breq	.+26     	; 0x51e <updateTask+0x3d2>
					objPrev->next = objIter->next;
     504:	f4 01       	movw	r30, r8
     506:	83 8d       	ldd	r24, Z+27	; 0x1b
     508:	94 8d       	ldd	r25, Z+28	; 0x1c
     50a:	f8 01       	movw	r30, r16
     50c:	94 8f       	std	Z+28, r25	; 0x1c
     50e:	83 8f       	std	Z+27, r24	; 0x1b
					vPortFree(objIter);
     510:	c4 01       	movw	r24, r8
     512:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
					objIter = objPrev->next;
     516:	f8 01       	movw	r30, r16
     518:	83 8c       	ldd	r8, Z+27	; 0x1b
     51a:	94 8c       	ldd	r9, Z+28	; 0x1c
     51c:	0e c0       	rjmp	.+28     	; 0x53a <updateTask+0x3ee>
				} else {
					bullets = objIter->next;
     51e:	f4 01       	movw	r30, r8
     520:	83 8d       	ldd	r24, Z+27	; 0x1b
     522:	94 8d       	ldd	r25, Z+28	; 0x1c
     524:	90 93 7e 02 	sts	0x027E, r25
     528:	80 93 7d 02 	sts	0x027D, r24
					vPortFree(objIter);
     52c:	c4 01       	movw	r24, r8
     52e:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
					objIter = bullets;
     532:	80 90 7d 02 	lds	r8, 0x027D
     536:	90 90 7e 02 	lds	r9, 0x027E
				}
				xSemaphoreGive(usartMutex);
     53a:	80 91 7f 02 	lds	r24, 0x027F
     53e:	90 91 80 02 	lds	r25, 0x0280
     542:	60 e0       	ldi	r22, 0x00	; 0
     544:	70 e0       	ldi	r23, 0x00	; 0
     546:	40 e0       	ldi	r20, 0x00	; 0
     548:	50 e0       	ldi	r21, 0x00	; 0
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	0e 94 33 12 	call	0x2466	; 0x2466 <xQueueGenericSend>
     550:	a8 c0       	rjmp	.+336    	; 0x6a2 <updateTask+0x556>
			} else {
			    objIter->pos.x += objIter->vel.x;
     552:	f4 01       	movw	r30, r8
     554:	61 81       	ldd	r22, Z+1	; 0x01
     556:	72 81       	ldd	r23, Z+2	; 0x02
     558:	83 81       	ldd	r24, Z+3	; 0x03
     55a:	94 81       	ldd	r25, Z+4	; 0x04
     55c:	21 85       	ldd	r18, Z+9	; 0x09
     55e:	32 85       	ldd	r19, Z+10	; 0x0a
     560:	43 85       	ldd	r20, Z+11	; 0x0b
     562:	54 85       	ldd	r21, Z+12	; 0x0c
     564:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     568:	16 2f       	mov	r17, r22
     56a:	07 2f       	mov	r16, r23
     56c:	f8 2e       	mov	r15, r24
     56e:	e9 2e       	mov	r14, r25
     570:	86 2f       	mov	r24, r22
     572:	90 2f       	mov	r25, r16
     574:	af 2d       	mov	r26, r15
     576:	be 2d       	mov	r27, r14
     578:	f4 01       	movw	r30, r8
     57a:	81 83       	std	Z+1, r24	; 0x01
     57c:	92 83       	std	Z+2, r25	; 0x02
     57e:	a3 83       	std	Z+3, r26	; 0x03
     580:	b4 83       	std	Z+4, r27	; 0x04
			    objIter->pos.y += objIter->vel.y;
     582:	65 81       	ldd	r22, Z+5	; 0x05
     584:	76 81       	ldd	r23, Z+6	; 0x06
     586:	87 81       	ldd	r24, Z+7	; 0x07
     588:	90 85       	ldd	r25, Z+8	; 0x08
     58a:	25 85       	ldd	r18, Z+13	; 0x0d
     58c:	36 85       	ldd	r19, Z+14	; 0x0e
     58e:	47 85       	ldd	r20, Z+15	; 0x0f
     590:	50 89       	ldd	r21, Z+16	; 0x10
     592:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     596:	dc 01       	movw	r26, r24
     598:	cb 01       	movw	r24, r22
     59a:	f4 01       	movw	r30, r8
     59c:	85 83       	std	Z+5, r24	; 0x05
     59e:	96 83       	std	Z+6, r25	; 0x06
     5a0:	a7 83       	std	Z+7, r26	; 0x07
     5a2:	b0 87       	std	Z+8, r27	; 0x08
			
			    if (objIter->pos.x < 0.0) {
     5a4:	81 2f       	mov	r24, r17
     5a6:	90 2f       	mov	r25, r16
     5a8:	af 2d       	mov	r26, r15
     5aa:	be 2d       	mov	r27, r14
     5ac:	bc 01       	movw	r22, r24
     5ae:	cd 01       	movw	r24, r26
     5b0:	20 e0       	ldi	r18, 0x00	; 0
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	a9 01       	movw	r20, r18
     5b6:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     5ba:	88 23       	and	r24, r24
     5bc:	a4 f4       	brge	.+40     	; 0x5e6 <updateTask+0x49a>
				    objIter->pos.x += SCREEN_W;
     5be:	81 2f       	mov	r24, r17
     5c0:	90 2f       	mov	r25, r16
     5c2:	af 2d       	mov	r26, r15
     5c4:	be 2d       	mov	r27, r14
     5c6:	bc 01       	movw	r22, r24
     5c8:	cd 01       	movw	r24, r26
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	48 e4       	ldi	r20, 0x48	; 72
     5d0:	54 e4       	ldi	r21, 0x44	; 68
     5d2:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     5d6:	dc 01       	movw	r26, r24
     5d8:	cb 01       	movw	r24, r22
     5da:	f4 01       	movw	r30, r8
     5dc:	81 83       	std	Z+1, r24	; 0x01
     5de:	92 83       	std	Z+2, r25	; 0x02
     5e0:	a3 83       	std	Z+3, r26	; 0x03
     5e2:	b4 83       	std	Z+4, r27	; 0x04
     5e4:	21 c0       	rjmp	.+66     	; 0x628 <updateTask+0x4dc>
			    } else if (objIter->pos.x > SCREEN_W) {
     5e6:	81 2f       	mov	r24, r17
     5e8:	90 2f       	mov	r25, r16
     5ea:	af 2d       	mov	r26, r15
     5ec:	be 2d       	mov	r27, r14
     5ee:	bc 01       	movw	r22, r24
     5f0:	cd 01       	movw	r24, r26
     5f2:	20 e0       	ldi	r18, 0x00	; 0
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	48 e4       	ldi	r20, 0x48	; 72
     5f8:	54 e4       	ldi	r21, 0x44	; 68
     5fa:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     5fe:	18 16       	cp	r1, r24
     600:	9c f4       	brge	.+38     	; 0x628 <updateTask+0x4dc>
				    objIter->pos.x -= SCREEN_W;
     602:	81 2f       	mov	r24, r17
     604:	90 2f       	mov	r25, r16
     606:	af 2d       	mov	r26, r15
     608:	be 2d       	mov	r27, r14
     60a:	bc 01       	movw	r22, r24
     60c:	cd 01       	movw	r24, r26
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	48 e4       	ldi	r20, 0x48	; 72
     614:	54 e4       	ldi	r21, 0x44	; 68
     616:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     61a:	dc 01       	movw	r26, r24
     61c:	cb 01       	movw	r24, r22
     61e:	f4 01       	movw	r30, r8
     620:	81 83       	std	Z+1, r24	; 0x01
     622:	92 83       	std	Z+2, r25	; 0x02
     624:	a3 83       	std	Z+3, r26	; 0x03
     626:	b4 83       	std	Z+4, r27	; 0x04
			    }
			
			    if (objIter->pos.y < 0.0) {
     628:	f4 01       	movw	r30, r8
     62a:	c5 80       	ldd	r12, Z+5	; 0x05
     62c:	d6 80       	ldd	r13, Z+6	; 0x06
     62e:	e7 80       	ldd	r14, Z+7	; 0x07
     630:	f0 84       	ldd	r15, Z+8	; 0x08
     632:	c7 01       	movw	r24, r14
     634:	b6 01       	movw	r22, r12
     636:	20 e0       	ldi	r18, 0x00	; 0
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	a9 01       	movw	r20, r18
     63c:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     640:	88 23       	and	r24, r24
     642:	84 f4       	brge	.+32     	; 0x664 <updateTask+0x518>
				    objIter->pos.y += SCREEN_H;
     644:	c7 01       	movw	r24, r14
     646:	b6 01       	movw	r22, r12
     648:	20 e0       	ldi	r18, 0x00	; 0
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	46 e1       	ldi	r20, 0x16	; 22
     64e:	54 e4       	ldi	r21, 0x44	; 68
     650:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     654:	dc 01       	movw	r26, r24
     656:	cb 01       	movw	r24, r22
     658:	f4 01       	movw	r30, r8
     65a:	85 83       	std	Z+5, r24	; 0x05
     65c:	96 83       	std	Z+6, r25	; 0x06
     65e:	a7 83       	std	Z+7, r26	; 0x07
     660:	b0 87       	std	Z+8, r27	; 0x08
     662:	19 c0       	rjmp	.+50     	; 0x696 <updateTask+0x54a>
			    } else if (objIter->pos.y > SCREEN_H) {
     664:	c7 01       	movw	r24, r14
     666:	b6 01       	movw	r22, r12
     668:	20 e0       	ldi	r18, 0x00	; 0
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	46 e1       	ldi	r20, 0x16	; 22
     66e:	54 e4       	ldi	r21, 0x44	; 68
     670:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     674:	18 16       	cp	r1, r24
     676:	7c f4       	brge	.+30     	; 0x696 <updateTask+0x54a>
				    objIter->pos.y -= SCREEN_H;
     678:	c7 01       	movw	r24, r14
     67a:	b6 01       	movw	r22, r12
     67c:	20 e0       	ldi	r18, 0x00	; 0
     67e:	30 e0       	ldi	r19, 0x00	; 0
     680:	46 e1       	ldi	r20, 0x16	; 22
     682:	54 e4       	ldi	r21, 0x44	; 68
     684:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     688:	dc 01       	movw	r26, r24
     68a:	cb 01       	movw	r24, r22
     68c:	f4 01       	movw	r30, r8
     68e:	85 83       	std	Z+5, r24	; 0x05
     690:	96 83       	std	Z+6, r25	; 0x06
     692:	a7 83       	std	Z+7, r26	; 0x07
     694:	b0 87       	std	Z+8, r27	; 0x08
			    }
			
			    objPrev = objIter;
			    objIter = objIter->next;
     696:	f4 01       	movw	r30, r8
     698:	93 8d       	ldd	r25, Z+27	; 0x1b
     69a:	84 8d       	ldd	r24, Z+28	; 0x1c
     69c:	84 01       	movw	r16, r8
     69e:	89 2e       	mov	r8, r25
     6a0:	98 2e       	mov	r9, r24
		}
		
		// move bullets
		objPrev = NULL;
		objIter = bullets;
		while (objIter != NULL) {
     6a2:	81 14       	cp	r8, r1
     6a4:	91 04       	cpc	r9, r1
     6a6:	09 f0       	breq	.+2      	; 0x6aa <updateTask+0x55e>
     6a8:	11 cf       	rjmp	.-478    	; 0x4cc <updateTask+0x380>
		// move asteroids
        /* 
         * ToDo: Add code to move the asteroids
         */
      objPrev = NULL;
		objIter = asteroids;
     6aa:	80 90 81 02 	lds	r8, 0x0281
     6ae:	90 90 82 02 	lds	r9, 0x0282
		while (objIter != NULL) {
     6b2:	81 14       	cp	r8, r1
     6b4:	91 04       	cpc	r9, r1
     6b6:	09 f4       	brne	.+2      	; 0x6ba <updateTask+0x56e>
     6b8:	a9 c0       	rjmp	.+338    	; 0x80c <updateTask+0x6c0>
          objIter->pos.x += objIter->vel.x;
     6ba:	f4 01       	movw	r30, r8
     6bc:	61 81       	ldd	r22, Z+1	; 0x01
     6be:	72 81       	ldd	r23, Z+2	; 0x02
     6c0:	83 81       	ldd	r24, Z+3	; 0x03
     6c2:	94 81       	ldd	r25, Z+4	; 0x04
     6c4:	21 85       	ldd	r18, Z+9	; 0x09
     6c6:	32 85       	ldd	r19, Z+10	; 0x0a
     6c8:	43 85       	ldd	r20, Z+11	; 0x0b
     6ca:	54 85       	ldd	r21, Z+12	; 0x0c
     6cc:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     6d0:	16 2f       	mov	r17, r22
     6d2:	07 2f       	mov	r16, r23
     6d4:	f8 2e       	mov	r15, r24
     6d6:	e9 2e       	mov	r14, r25
     6d8:	86 2f       	mov	r24, r22
     6da:	90 2f       	mov	r25, r16
     6dc:	af 2d       	mov	r26, r15
     6de:	be 2d       	mov	r27, r14
     6e0:	f4 01       	movw	r30, r8
     6e2:	81 83       	std	Z+1, r24	; 0x01
     6e4:	92 83       	std	Z+2, r25	; 0x02
     6e6:	a3 83       	std	Z+3, r26	; 0x03
     6e8:	b4 83       	std	Z+4, r27	; 0x04
          objIter->pos.y += objIter->vel.y;
     6ea:	65 81       	ldd	r22, Z+5	; 0x05
     6ec:	76 81       	ldd	r23, Z+6	; 0x06
     6ee:	87 81       	ldd	r24, Z+7	; 0x07
     6f0:	90 85       	ldd	r25, Z+8	; 0x08
     6f2:	25 85       	ldd	r18, Z+13	; 0x0d
     6f4:	36 85       	ldd	r19, Z+14	; 0x0e
     6f6:	47 85       	ldd	r20, Z+15	; 0x0f
     6f8:	50 89       	ldd	r21, Z+16	; 0x10
     6fa:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     6fe:	dc 01       	movw	r26, r24
     700:	cb 01       	movw	r24, r22
     702:	f4 01       	movw	r30, r8
     704:	85 83       	std	Z+5, r24	; 0x05
     706:	96 83       	std	Z+6, r25	; 0x06
     708:	a7 83       	std	Z+7, r26	; 0x07
     70a:	b0 87       	std	Z+8, r27	; 0x08
      
          if (objIter->pos.x < 0.0) {
     70c:	81 2f       	mov	r24, r17
     70e:	90 2f       	mov	r25, r16
     710:	af 2d       	mov	r26, r15
     712:	be 2d       	mov	r27, r14
     714:	bc 01       	movw	r22, r24
     716:	cd 01       	movw	r24, r26
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	a9 01       	movw	r20, r18
     71e:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     722:	88 23       	and	r24, r24
     724:	a4 f4       	brge	.+40     	; 0x74e <updateTask+0x602>
             objIter->pos.x += SCREEN_W;
     726:	81 2f       	mov	r24, r17
     728:	90 2f       	mov	r25, r16
     72a:	af 2d       	mov	r26, r15
     72c:	be 2d       	mov	r27, r14
     72e:	bc 01       	movw	r22, r24
     730:	cd 01       	movw	r24, r26
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	48 e4       	ldi	r20, 0x48	; 72
     738:	54 e4       	ldi	r21, 0x44	; 68
     73a:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     73e:	dc 01       	movw	r26, r24
     740:	cb 01       	movw	r24, r22
     742:	f4 01       	movw	r30, r8
     744:	81 83       	std	Z+1, r24	; 0x01
     746:	92 83       	std	Z+2, r25	; 0x02
     748:	a3 83       	std	Z+3, r26	; 0x03
     74a:	b4 83       	std	Z+4, r27	; 0x04
     74c:	21 c0       	rjmp	.+66     	; 0x790 <updateTask+0x644>
          } else if (objIter->pos.x > SCREEN_W) {
     74e:	81 2f       	mov	r24, r17
     750:	90 2f       	mov	r25, r16
     752:	af 2d       	mov	r26, r15
     754:	be 2d       	mov	r27, r14
     756:	bc 01       	movw	r22, r24
     758:	cd 01       	movw	r24, r26
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	48 e4       	ldi	r20, 0x48	; 72
     760:	54 e4       	ldi	r21, 0x44	; 68
     762:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     766:	18 16       	cp	r1, r24
     768:	9c f4       	brge	.+38     	; 0x790 <updateTask+0x644>
             objIter->pos.x -= SCREEN_W;
     76a:	81 2f       	mov	r24, r17
     76c:	90 2f       	mov	r25, r16
     76e:	af 2d       	mov	r26, r15
     770:	be 2d       	mov	r27, r14
     772:	bc 01       	movw	r22, r24
     774:	cd 01       	movw	r24, r26
     776:	20 e0       	ldi	r18, 0x00	; 0
     778:	30 e0       	ldi	r19, 0x00	; 0
     77a:	48 e4       	ldi	r20, 0x48	; 72
     77c:	54 e4       	ldi	r21, 0x44	; 68
     77e:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     782:	dc 01       	movw	r26, r24
     784:	cb 01       	movw	r24, r22
     786:	f4 01       	movw	r30, r8
     788:	81 83       	std	Z+1, r24	; 0x01
     78a:	92 83       	std	Z+2, r25	; 0x02
     78c:	a3 83       	std	Z+3, r26	; 0x03
     78e:	b4 83       	std	Z+4, r27	; 0x04
          }
      
          if (objIter->pos.y < 0.0) {
     790:	f4 01       	movw	r30, r8
     792:	c5 80       	ldd	r12, Z+5	; 0x05
     794:	d6 80       	ldd	r13, Z+6	; 0x06
     796:	e7 80       	ldd	r14, Z+7	; 0x07
     798:	f0 84       	ldd	r15, Z+8	; 0x08
     79a:	c7 01       	movw	r24, r14
     79c:	b6 01       	movw	r22, r12
     79e:	20 e0       	ldi	r18, 0x00	; 0
     7a0:	30 e0       	ldi	r19, 0x00	; 0
     7a2:	a9 01       	movw	r20, r18
     7a4:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     7a8:	88 23       	and	r24, r24
     7aa:	84 f4       	brge	.+32     	; 0x7cc <updateTask+0x680>
             objIter->pos.y += SCREEN_H;
     7ac:	c7 01       	movw	r24, r14
     7ae:	b6 01       	movw	r22, r12
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	30 e0       	ldi	r19, 0x00	; 0
     7b4:	46 e1       	ldi	r20, 0x16	; 22
     7b6:	54 e4       	ldi	r21, 0x44	; 68
     7b8:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     7bc:	dc 01       	movw	r26, r24
     7be:	cb 01       	movw	r24, r22
     7c0:	f4 01       	movw	r30, r8
     7c2:	85 83       	std	Z+5, r24	; 0x05
     7c4:	96 83       	std	Z+6, r25	; 0x06
     7c6:	a7 83       	std	Z+7, r26	; 0x07
     7c8:	b0 87       	std	Z+8, r27	; 0x08
     7ca:	19 c0       	rjmp	.+50     	; 0x7fe <updateTask+0x6b2>
          } else if (objIter->pos.y > SCREEN_H) {
     7cc:	c7 01       	movw	r24, r14
     7ce:	b6 01       	movw	r22, r12
     7d0:	20 e0       	ldi	r18, 0x00	; 0
     7d2:	30 e0       	ldi	r19, 0x00	; 0
     7d4:	46 e1       	ldi	r20, 0x16	; 22
     7d6:	54 e4       	ldi	r21, 0x44	; 68
     7d8:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__gesf2>
     7dc:	18 16       	cp	r1, r24
     7de:	7c f4       	brge	.+30     	; 0x7fe <updateTask+0x6b2>
             objIter->pos.y -= SCREEN_H;
     7e0:	c7 01       	movw	r24, r14
     7e2:	b6 01       	movw	r22, r12
     7e4:	20 e0       	ldi	r18, 0x00	; 0
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	46 e1       	ldi	r20, 0x16	; 22
     7ea:	54 e4       	ldi	r21, 0x44	; 68
     7ec:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     7f0:	dc 01       	movw	r26, r24
     7f2:	cb 01       	movw	r24, r22
     7f4:	f4 01       	movw	r30, r8
     7f6:	85 83       	std	Z+5, r24	; 0x05
     7f8:	96 83       	std	Z+6, r25	; 0x06
     7fa:	a7 83       	std	Z+7, r26	; 0x07
     7fc:	b0 87       	std	Z+8, r27	; 0x08
          }
      
          objPrev = objIter;
          objIter = objIter->next;
     7fe:	f4 01       	movw	r30, r8
     800:	83 8c       	ldd	r8, Z+27	; 0x1b
     802:	94 8c       	ldd	r9, Z+28	; 0x1c
        /* 
         * ToDo: Add code to move the asteroids
         */
      objPrev = NULL;
		objIter = asteroids;
		while (objIter != NULL) {
     804:	81 14       	cp	r8, r1
     806:	91 04       	cpc	r9, r1
     808:	09 f0       	breq	.+2      	; 0x80c <updateTask+0x6c0>
     80a:	57 cf       	rjmp	.-338    	; 0x6ba <updateTask+0x56e>
      
          objPrev = objIter;
          objIter = objIter->next;
      }
		
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
     80c:	8a e0       	ldi	r24, 0x0A	; 10
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <vTaskDelay>
	}
     814:	a6 cc       	rjmp	.-1716   	; 0x162 <updateTask+0x16>

00000816 <main>:
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
	}
}

int main(void) {
	DDRB = 0x00;
     816:	14 b8       	out	0x04, r1	; 4
	TCCR2A = _BV(CS00); 
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	80 93 b0 00 	sts	0x00B0, r24
	
	usartMutex = xSemaphoreCreateMutex();
     81e:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xQueueCreateMutex>
     822:	90 93 80 02 	sts	0x0280, r25
     826:	80 93 7f 02 	sts	0x027F, r24
	
	vWindowCreate(SCREEN_W, SCREEN_H);
     82a:	80 e2       	ldi	r24, 0x20	; 32
     82c:	93 e0       	ldi	r25, 0x03	; 3
     82e:	68 e5       	ldi	r22, 0x58	; 88
     830:	72 e0       	ldi	r23, 0x02	; 2
     832:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <vWindowCreate>
	
	sei();
     836:	78 94       	sei
	
	xTaskCreate(inputTask, (signed char *) "i", 80, NULL, 1, &inputTaskHandle);
     838:	85 ea       	ldi	r24, 0xA5	; 165
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	60 e0       	ldi	r22, 0x00	; 0
     83e:	72 e0       	ldi	r23, 0x02	; 2
     840:	40 e5       	ldi	r20, 0x50	; 80
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	20 e0       	ldi	r18, 0x00	; 0
     846:	30 e0       	ldi	r19, 0x00	; 0
     848:	01 e0       	ldi	r16, 0x01	; 1
     84a:	0f 2e       	mov	r0, r31
     84c:	f7 e8       	ldi	r31, 0x87	; 135
     84e:	ef 2e       	mov	r14, r31
     850:	f2 e0       	ldi	r31, 0x02	; 2
     852:	ff 2e       	mov	r15, r31
     854:	f0 2d       	mov	r31, r0
     856:	cc 24       	eor	r12, r12
     858:	dd 24       	eor	r13, r13
     85a:	aa 24       	eor	r10, r10
     85c:	bb 24       	eor	r11, r11
     85e:	0e 94 91 14 	call	0x2922	; 0x2922 <xTaskGenericCreate>
	xTaskCreate(bulletTask, (signed char *) "b", 130, NULL, 2, &bulletTaskHandle);
     862:	81 ef       	ldi	r24, 0xF1	; 241
     864:	96 e0       	ldi	r25, 0x06	; 6
     866:	62 e0       	ldi	r22, 0x02	; 2
     868:	72 e0       	ldi	r23, 0x02	; 2
     86a:	42 e8       	ldi	r20, 0x82	; 130
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	20 e0       	ldi	r18, 0x00	; 0
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	02 e0       	ldi	r16, 0x02	; 2
     874:	0f 2e       	mov	r0, r31
     876:	f5 e8       	ldi	r31, 0x85	; 133
     878:	ef 2e       	mov	r14, r31
     87a:	f2 e0       	ldi	r31, 0x02	; 2
     87c:	ff 2e       	mov	r15, r31
     87e:	f0 2d       	mov	r31, r0
     880:	0e 94 91 14 	call	0x2922	; 0x2922 <xTaskGenericCreate>
	xTaskCreate(updateTask, (signed char *) "u", 200, NULL, 4, &updateTaskHandle);
     884:	86 ea       	ldi	r24, 0xA6	; 166
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	64 e0       	ldi	r22, 0x04	; 4
     88a:	72 e0       	ldi	r23, 0x02	; 2
     88c:	48 ec       	ldi	r20, 0xC8	; 200
     88e:	50 e0       	ldi	r21, 0x00	; 0
     890:	20 e0       	ldi	r18, 0x00	; 0
     892:	30 e0       	ldi	r19, 0x00	; 0
     894:	04 e0       	ldi	r16, 0x04	; 4
     896:	0f 2e       	mov	r0, r31
     898:	f3 e8       	ldi	r31, 0x83	; 131
     89a:	ef 2e       	mov	r14, r31
     89c:	f2 e0       	ldi	r31, 0x02	; 2
     89e:	ff 2e       	mov	r15, r31
     8a0:	f0 2d       	mov	r31, r0
     8a2:	0e 94 91 14 	call	0x2922	; 0x2922 <xTaskGenericCreate>
	xTaskCreate(drawTask, (signed char *) "d", 230, NULL, 3, NULL);
     8a6:	85 e8       	ldi	r24, 0x85	; 133
     8a8:	98 e0       	ldi	r25, 0x08	; 8
     8aa:	66 e0       	ldi	r22, 0x06	; 6
     8ac:	72 e0       	ldi	r23, 0x02	; 2
     8ae:	46 ee       	ldi	r20, 0xE6	; 230
     8b0:	50 e0       	ldi	r21, 0x00	; 0
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	30 e0       	ldi	r19, 0x00	; 0
     8b6:	03 e0       	ldi	r16, 0x03	; 3
     8b8:	ee 24       	eor	r14, r14
     8ba:	ff 24       	eor	r15, r15
     8bc:	0e 94 91 14 	call	0x2922	; 0x2922 <xTaskGenericCreate>
	//xTaskCreate(USART_Write_Task, (signed char *) "w", 150, NULL, 5, NULL);
	
	vTaskStartScheduler();
     8c0:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <vTaskStartScheduler>
     8c4:	ff cf       	rjmp	.-2      	; 0x8c4 <main+0xae>

000008c6 <reset>:
     *		delete thisObject using a reentrant function
     *		thisObject = nextObject
     *	}
     */
	 
}
     8c6:	08 95       	ret

000008c8 <getRandStartPosVal>:
 *
 * param dimOver2: Half of the dimension of the window for which a random
 *  coordinate value is desired.
 * return: A safe, pseudorandom coordinate value.
 *----------------------------------------------------------------------------*/
int16_t getRandStartPosVal(int16_t dimOver2) {
     8c8:	0f 93       	push	r16
     8ca:	1f 93       	push	r17
     8cc:	cf 93       	push	r28
     8ce:	df 93       	push	r29
     8d0:	ec 01       	movw	r28, r24
	return rand() % (dimOver2 - DEAD_ZONE_OVER_2) + (rand() % 2) * (dimOver2 + DEAD_ZONE_OVER_2);
     8d2:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     8d6:	be 01       	movw	r22, r28
     8d8:	68 57       	subi	r22, 0x78	; 120
     8da:	70 40       	sbci	r23, 0x00	; 0
     8dc:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     8e0:	8c 01       	movw	r16, r24
     8e2:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     8e6:	62 e0       	ldi	r22, 0x02	; 2
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     8ee:	ac 01       	movw	r20, r24
     8f0:	9e 01       	movw	r18, r28
     8f2:	28 58       	subi	r18, 0x88	; 136
     8f4:	3f 4f       	sbci	r19, 0xFF	; 255
     8f6:	42 9f       	mul	r20, r18
     8f8:	c0 01       	movw	r24, r0
     8fa:	43 9f       	mul	r20, r19
     8fc:	90 0d       	add	r25, r0
     8fe:	52 9f       	mul	r21, r18
     900:	90 0d       	add	r25, r0
     902:	11 24       	eor	r1, r1
     904:	80 0f       	add	r24, r16
     906:	91 1f       	adc	r25, r17
}
     908:	df 91       	pop	r29
     90a:	cf 91       	pop	r28
     90c:	1f 91       	pop	r17
     90e:	0f 91       	pop	r16
     910:	08 95       	ret

00000912 <sizeToPix>:
 * param size: A number in the range [1-3]
 * return: A pixel size which may be used to appropriately scale an asteroid
 *  sprite.
 *----------------------------------------------------------------------------*/
uint16_t sizeToPix(int8_t size) {
	switch (size) {
     912:	82 30       	cpi	r24, 0x02	; 2
     914:	71 f0       	breq	.+28     	; 0x932 <sizeToPix+0x20>
     916:	83 30       	cpi	r24, 0x03	; 3
     918:	19 f0       	breq	.+6      	; 0x920 <sizeToPix+0xe>
     91a:	81 30       	cpi	r24, 0x01	; 1
     91c:	39 f4       	brne	.+14     	; 0x92c <sizeToPix+0x1a>
     91e:	03 c0       	rjmp	.+6      	; 0x926 <sizeToPix+0x14>
		case 3:
		    return AST_SIZE_3;
     920:	84 e6       	ldi	r24, 0x64	; 100
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	08 95       	ret
		case 2:
		    return AST_SIZE_2;
		case 1:
		    return AST_SIZE_1;
     926:	8f e0       	ldi	r24, 0x0F	; 15
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	08 95       	ret
		default:
		    return AST_SIZE_3 << 2;
     92c:	80 e9       	ldi	r24, 0x90	; 144
     92e:	91 e0       	ldi	r25, 0x01	; 1
     930:	08 95       	ret
uint16_t sizeToPix(int8_t size) {
	switch (size) {
		case 3:
		    return AST_SIZE_3;
		case 2:
		    return AST_SIZE_2;
     932:	88 e2       	ldi	r24, 0x28	; 40
     934:	90 e0       	ldi	r25, 0x00	; 0
		    return AST_SIZE_1;
		default:
		    return AST_SIZE_3 << 2;
	}
	return AST_SIZE_3 << 2;
}
     936:	08 95       	ret

00000938 <createAsteroid>:
 * param size: The starting size of the asteroid. Must be in the range [1,3].
 * param nxt: A pointer to the next asteroid object in a linked list.
 * return: A pointer to a malloc'd asteroid object. Must be freed by the calling
 *  process.
 *----------------------------------------------------------------------------*/
object *createAsteroid(float x, float y, float velx, float vely, int16_t angle, int8_t avel, int8_t size, object *nxt) {
     938:	4f 92       	push	r4
     93a:	5f 92       	push	r5
     93c:	6f 92       	push	r6
     93e:	7f 92       	push	r7
     940:	8f 92       	push	r8
     942:	9f 92       	push	r9
     944:	af 92       	push	r10
     946:	bf 92       	push	r11
     948:	cf 92       	push	r12
     94a:	df 92       	push	r13
     94c:	ef 92       	push	r14
     94e:	ff 92       	push	r15
     950:	0f 93       	push	r16
     952:	1f 93       	push	r17
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	00 d0       	rcall	.+0      	; 0x95a <createAsteroid+0x22>
     95a:	0f 92       	push	r0
     95c:	cd b7       	in	r28, 0x3d	; 61
     95e:	de b7       	in	r29, 0x3e	; 62
     960:	2b 01       	movw	r4, r22
     962:	3c 01       	movw	r6, r24
     964:	29 83       	std	Y+1, r18	; 0x01
     966:	3a 83       	std	Y+2, r19	; 0x02
     968:	4b 83       	std	Y+3, r20	; 0x03
     96a:	5c 83       	std	Y+4, r21	; 0x04
     96c:	d9 8c       	ldd	r13, Y+25	; 0x19
     * asteroid->next = nxt;
     * Create a new sprite using xSpriteCreate()
     * Add new asteroid to the group "astGroup" using:
     *	vGroupAddSprite() 
     */
      object *newAsteroid = pvPortMalloc(sizeof(object));
     96e:	8d e1       	ldi	r24, 0x1D	; 29
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
     976:	5c 01       	movw	r10, r24
      
      newAsteroid->handle = xSpriteCreate(
         astImages[rand() % 3],  //reference to png filename
     978:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     97c:	8c 01       	movw	r16, r24
     * Add new asteroid to the group "astGroup" using:
     *	vGroupAddSprite() 
     */
      object *newAsteroid = pvPortMalloc(sizeof(object));
      
      newAsteroid->handle = xSpriteCreate(
     97e:	8d 2d       	mov	r24, r13
     980:	0e 94 89 04 	call	0x912	; 0x912 <sizeToPix>
     984:	7c 01       	movw	r14, r24
         astImages[rand() % 3],  //reference to png filename
     986:	c8 01       	movw	r24, r16
     988:	63 e0       	ldi	r22, 0x03	; 3
     98a:	70 e0       	ldi	r23, 0x00	; 0
     98c:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     * Add new asteroid to the group "astGroup" using:
     *	vGroupAddSprite() 
     */
      object *newAsteroid = pvPortMalloc(sizeof(object));
      
      newAsteroid->handle = xSpriteCreate(
     990:	fc 01       	movw	r30, r24
     992:	ee 0f       	add	r30, r30
     994:	ff 1f       	adc	r31, r31
     996:	e4 5b       	subi	r30, 0xB4	; 180
     998:	fd 4f       	sbci	r31, 0xFD	; 253
     99a:	80 81       	ld	r24, Z
     99c:	91 81       	ldd	r25, Z+1	; 0x01
     99e:	60 e9       	ldi	r22, 0x90	; 144
     9a0:	71 e0       	ldi	r23, 0x01	; 1
     9a2:	4c e2       	ldi	r20, 0x2C	; 44
     9a4:	51 e0       	ldi	r21, 0x01	; 1
     9a6:	20 e0       	ldi	r18, 0x00	; 0
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	87 01       	movw	r16, r14
     9ac:	cc 24       	eor	r12, r12
     9ae:	c3 94       	inc	r12
     9b0:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xSpriteCreate>
     9b4:	d5 01       	movw	r26, r10
     9b6:	8c 93       	st	X, r24
         0,                      //rAngle
         sizeToPix(size),        //width
         sizeToPix(size),        //height
         1);                     //depth
      
      newAsteroid->pos.x = x;
     9b8:	f5 01       	movw	r30, r10
     9ba:	41 82       	std	Z+1, r4	; 0x01
     9bc:	52 82       	std	Z+2, r5	; 0x02
     9be:	63 82       	std	Z+3, r6	; 0x03
     9c0:	74 82       	std	Z+4, r7	; 0x04
      newAsteroid->pos.y = y;
     9c2:	89 81       	ldd	r24, Y+1	; 0x01
     9c4:	9a 81       	ldd	r25, Y+2	; 0x02
     9c6:	ab 81       	ldd	r26, Y+3	; 0x03
     9c8:	bc 81       	ldd	r27, Y+4	; 0x04
     9ca:	85 83       	std	Z+5, r24	; 0x05
     9cc:	96 83       	std	Z+6, r25	; 0x06
     9ce:	a7 83       	std	Z+7, r26	; 0x07
     9d0:	b0 87       	std	Z+8, r27	; 0x08
      
      newAsteroid->vel.x = x;
     9d2:	41 86       	std	Z+9, r4	; 0x09
     9d4:	52 86       	std	Z+10, r5	; 0x0a
     9d6:	63 86       	std	Z+11, r6	; 0x0b
     9d8:	74 86       	std	Z+12, r7	; 0x0c
      newAsteroid->vel.y = y;
     9da:	89 81       	ldd	r24, Y+1	; 0x01
     9dc:	9a 81       	ldd	r25, Y+2	; 0x02
     9de:	ab 81       	ldd	r26, Y+3	; 0x03
     9e0:	bc 81       	ldd	r27, Y+4	; 0x04
     9e2:	85 87       	std	Z+13, r24	; 0x0d
     9e4:	96 87       	std	Z+14, r25	; 0x0e
     9e6:	a7 87       	std	Z+15, r26	; 0x0f
     9e8:	b0 8b       	std	Z+16, r27	; 0x10
      
      newAsteroid->angle = angle;
     9ea:	96 8a       	std	Z+22, r9	; 0x16
     9ec:	85 8a       	std	Z+21, r8	; 0x15
      
      newAsteroid->a_vel = avel;
     9ee:	88 8d       	ldd	r24, Y+24	; 0x18
     9f0:	87 8b       	std	Z+23, r24	; 0x17
      
      newAsteroid->size = size;
     9f2:	d0 8e       	std	Z+24, r13	; 0x18
      
      newAsteroid->next = asteroids;
     9f4:	80 91 81 02 	lds	r24, 0x0281
     9f8:	90 91 82 02 	lds	r25, 0x0282
     9fc:	94 8f       	std	Z+28, r25	; 0x1c
     9fe:	83 8f       	std	Z+27, r24	; 0x1b
      
      // newAsteroid->life = NULL;
      // newAsteroid->accel = NULL;
      
      return newAsteroid;
}
     a00:	8a 2d       	mov	r24, r10
     a02:	9b 2d       	mov	r25, r11
     a04:	0f 90       	pop	r0
     a06:	0f 90       	pop	r0
     a08:	0f 90       	pop	r0
     a0a:	0f 90       	pop	r0
     a0c:	df 91       	pop	r29
     a0e:	cf 91       	pop	r28
     a10:	1f 91       	pop	r17
     a12:	0f 91       	pop	r16
     a14:	ff 90       	pop	r15
     a16:	ef 90       	pop	r14
     a18:	df 90       	pop	r13
     a1a:	cf 90       	pop	r12
     a1c:	bf 90       	pop	r11
     a1e:	af 90       	pop	r10
     a20:	9f 90       	pop	r9
     a22:	8f 90       	pop	r8
     a24:	7f 90       	pop	r7
     a26:	6f 90       	pop	r6
     a28:	5f 90       	pop	r5
     a2a:	4f 90       	pop	r4
     a2c:	08 95       	ret

00000a2e <init>:
 * Function: init
 *
 * Description: This function initializes a new game of asteroids. A window
 *  must be created before this function may be called.
 *----------------------------------------------------------------------------*/
void init(void) {
     a2e:	2f 92       	push	r2
     a30:	3f 92       	push	r3
     a32:	4f 92       	push	r4
     a34:	5f 92       	push	r5
     a36:	6f 92       	push	r6
     a38:	7f 92       	push	r7
     a3a:	8f 92       	push	r8
     a3c:	9f 92       	push	r9
     a3e:	af 92       	push	r10
     a40:	bf 92       	push	r11
     a42:	cf 92       	push	r12
     a44:	df 92       	push	r13
     a46:	ef 92       	push	r14
     a48:	ff 92       	push	r15
     a4a:	0f 93       	push	r16
     a4c:	1f 93       	push	r17
     a4e:	cf 93       	push	r28
     a50:	df 93       	push	r29
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
     a56:	28 97       	sbiw	r28, 0x08	; 8
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	de bf       	out	0x3e, r29	; 62
     a5e:	0f be       	out	0x3f, r0	; 63
     a60:	cd bf       	out	0x3d, r28	; 61
	int i;
	
	bullets = NULL;
     a62:	10 92 7e 02 	sts	0x027E, r1
     a66:	10 92 7d 02 	sts	0x027D, r1
	asteroids = NULL;
     a6a:	10 92 82 02 	sts	0x0282, r1
     a6e:	10 92 81 02 	sts	0x0281, r1
	astGroup = ERROR_HANDLE;
     a72:	8f ef       	ldi	r24, 0xFF	; 255
     a74:	80 93 89 02 	sts	0x0289, r24
	
	background = xSpriteCreate("stars.png", SCREEN_W>>1, SCREEN_H>>1, 0, SCREEN_W, SCREEN_H, 0);
     a78:	88 e0       	ldi	r24, 0x08	; 8
     a7a:	92 e0       	ldi	r25, 0x02	; 2
     a7c:	60 e9       	ldi	r22, 0x90	; 144
     a7e:	71 e0       	ldi	r23, 0x01	; 1
     a80:	4c e2       	ldi	r20, 0x2C	; 44
     a82:	51 e0       	ldi	r21, 0x01	; 1
     a84:	20 e0       	ldi	r18, 0x00	; 0
     a86:	30 e0       	ldi	r19, 0x00	; 0
     a88:	00 e2       	ldi	r16, 0x20	; 32
     a8a:	13 e0       	ldi	r17, 0x03	; 3
     a8c:	0f 2e       	mov	r0, r31
     a8e:	f8 e5       	ldi	r31, 0x58	; 88
     a90:	ef 2e       	mov	r14, r31
     a92:	f2 e0       	ldi	r31, 0x02	; 2
     a94:	ff 2e       	mov	r15, r31
     a96:	f0 2d       	mov	r31, r0
     a98:	cc 24       	eor	r12, r12
     a9a:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xSpriteCreate>
     a9e:	80 93 8a 02 	sts	0x028A, r24
	
	srand(TCNT0);
     aa2:	86 b5       	in	r24, 0x26	; 38
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <srand>
	
	astGroup = xGroupCreate();
     aaa:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <xGroupCreate>
     aae:	80 93 89 02 	sts	0x0289, r24
     ab2:	0f 2e       	mov	r0, r31
     ab4:	f5 e0       	ldi	r31, 0x05	; 5
     ab6:	2f 2e       	mov	r2, r31
     ab8:	33 24       	eor	r3, r3
     aba:	f0 2d       	mov	r31, r0
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(getRandStartPosVal(SCREEN_W >> 1),
     abc:	80 e9       	ldi	r24, 0x90	; 144
     abe:	91 e0       	ldi	r25, 0x01	; 1
     ac0:	0e 94 64 04 	call	0x8c8	; 0x8c8 <getRandStartPosVal>
     ac4:	2c 01       	movw	r4, r24
		                           getRandStartPosVal(SCREEN_H >> 1),
     ac6:	8c e2       	ldi	r24, 0x2C	; 44
     ac8:	91 e0       	ldi	r25, 0x01	; 1
     aca:	0e 94 64 04 	call	0x8c8	; 0x8c8 <getRandStartPosVal>
     ace:	7c 01       	movw	r14, r24
		                           (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     ad0:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     ad4:	6c 01       	movw	r12, r24
								   (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     ad6:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     ada:	5c 01       	movw	r10, r24
								   rand() % 360,
     adc:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     ae0:	4c 01       	movw	r8, r24
								   (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
     ae2:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     ae6:	9c 83       	std	Y+4, r25	; 0x04
     ae8:	8b 83       	std	Y+3, r24	; 0x03
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(getRandStartPosVal(SCREEN_W >> 1),
     aea:	00 d0       	rcall	.+0      	; 0xaec <init+0xbe>
     aec:	0f 92       	push	r0
     aee:	2d b7       	in	r18, 0x3d	; 61
     af0:	3e b7       	in	r19, 0x3e	; 62
     af2:	2f 5f       	subi	r18, 0xFF	; 255
     af4:	3f 4f       	sbci	r19, 0xFF	; 255
     af6:	3a 83       	std	Y+2, r19	; 0x02
     af8:	29 83       	std	Y+1, r18	; 0x01
     afa:	b2 01       	movw	r22, r4
     afc:	88 27       	eor	r24, r24
     afe:	77 fd       	sbrc	r23, 7
     b00:	80 95       	com	r24
     b02:	98 2f       	mov	r25, r24
     b04:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     b08:	6d 83       	std	Y+5, r22	; 0x05
     b0a:	7e 83       	std	Y+6, r23	; 0x06
     b0c:	8f 83       	std	Y+7, r24	; 0x07
     b0e:	98 87       	std	Y+8, r25	; 0x08
     b10:	b7 01       	movw	r22, r14
     b12:	88 27       	eor	r24, r24
     b14:	77 fd       	sbrc	r23, 7
     b16:	80 95       	com	r24
     b18:	98 2f       	mov	r25, r24
     b1a:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     b1e:	2b 01       	movw	r4, r22
     b20:	3c 01       	movw	r6, r24
		                           getRandStartPosVal(SCREEN_H >> 1),
		                           (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     b22:	c6 01       	movw	r24, r12
     b24:	64 e1       	ldi	r22, 0x14	; 20
     b26:	70 e0       	ldi	r23, 0x00	; 0
     b28:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     b2c:	fc 01       	movw	r30, r24
     b2e:	bf 01       	movw	r22, r30
     b30:	88 27       	eor	r24, r24
     b32:	77 fd       	sbrc	r23, 7
     b34:	80 95       	com	r24
     b36:	98 2f       	mov	r25, r24
     b38:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     b3c:	20 e0       	ldi	r18, 0x00	; 0
     b3e:	30 e0       	ldi	r19, 0x00	; 0
     b40:	40 ea       	ldi	r20, 0xA0	; 160
     b42:	50 e4       	ldi	r21, 0x40	; 64
     b44:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     b48:	20 e0       	ldi	r18, 0x00	; 0
     b4a:	30 e0       	ldi	r19, 0x00	; 0
     b4c:	40 e0       	ldi	r20, 0x00	; 0
     b4e:	50 e4       	ldi	r21, 0x40	; 64
     b50:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     b54:	7b 01       	movw	r14, r22
     b56:	8c 01       	movw	r16, r24
								   (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     b58:	c5 01       	movw	r24, r10
     b5a:	64 e1       	ldi	r22, 0x14	; 20
     b5c:	70 e0       	ldi	r23, 0x00	; 0
     b5e:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     b62:	9c 01       	movw	r18, r24
     b64:	b9 01       	movw	r22, r18
     b66:	88 27       	eor	r24, r24
     b68:	77 fd       	sbrc	r23, 7
     b6a:	80 95       	com	r24
     b6c:	98 2f       	mov	r25, r24
     b6e:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     b72:	20 e0       	ldi	r18, 0x00	; 0
     b74:	30 e0       	ldi	r19, 0x00	; 0
     b76:	40 ea       	ldi	r20, 0xA0	; 160
     b78:	50 e4       	ldi	r21, 0x40	; 64
     b7a:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     b7e:	20 e0       	ldi	r18, 0x00	; 0
     b80:	30 e0       	ldi	r19, 0x00	; 0
     b82:	40 e0       	ldi	r20, 0x00	; 0
     b84:	50 e4       	ldi	r21, 0x40	; 64
     b86:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     b8a:	5b 01       	movw	r10, r22
     b8c:	6c 01       	movw	r12, r24
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(getRandStartPosVal(SCREEN_W >> 1),
     b8e:	c4 01       	movw	r24, r8
     b90:	68 e6       	ldi	r22, 0x68	; 104
     b92:	71 e0       	ldi	r23, 0x01	; 1
     b94:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     b98:	4c 01       	movw	r8, r24
		                           getRandStartPosVal(SCREEN_H >> 1),
		                           (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
								   (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
								   rand() % 360,
								   (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
     b9a:	8b 81       	ldd	r24, Y+3	; 0x03
     b9c:	9c 81       	ldd	r25, Y+4	; 0x04
     b9e:	6e e1       	ldi	r22, 0x1E	; 30
     ba0:	70 e0       	ldi	r23, 0x00	; 0
     ba2:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     ba6:	fc 01       	movw	r30, r24
     ba8:	bf 01       	movw	r22, r30
     baa:	88 27       	eor	r24, r24
     bac:	77 fd       	sbrc	r23, 7
     bae:	80 95       	com	r24
     bb0:	98 2f       	mov	r25, r24
     bb2:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     bb6:	20 e0       	ldi	r18, 0x00	; 0
     bb8:	30 e0       	ldi	r19, 0x00	; 0
     bba:	40 ea       	ldi	r20, 0xA0	; 160
     bbc:	50 e4       	ldi	r21, 0x40	; 64
     bbe:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     bc2:	20 e0       	ldi	r18, 0x00	; 0
     bc4:	30 e0       	ldi	r19, 0x00	; 0
     bc6:	40 e4       	ldi	r20, 0x40	; 64
     bc8:	50 e4       	ldi	r21, 0x40	; 64
     bca:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(getRandStartPosVal(SCREEN_W >> 1),
     bce:	0e 94 8e 1b 	call	0x371c	; 0x371c <__fixsfsi>
     bd2:	e9 81       	ldd	r30, Y+1	; 0x01
     bd4:	fa 81       	ldd	r31, Y+2	; 0x02
     bd6:	60 83       	st	Z, r22
     bd8:	23 e0       	ldi	r18, 0x03	; 3
     bda:	21 83       	std	Z+1, r18	; 0x01
     bdc:	80 91 81 02 	lds	r24, 0x0281
     be0:	90 91 82 02 	lds	r25, 0x0282
     be4:	93 83       	std	Z+3, r25	; 0x03
     be6:	82 83       	std	Z+2, r24	; 0x02
     be8:	6d 81       	ldd	r22, Y+5	; 0x05
     bea:	7e 81       	ldd	r23, Y+6	; 0x06
     bec:	8f 81       	ldd	r24, Y+7	; 0x07
     bee:	98 85       	ldd	r25, Y+8	; 0x08
     bf0:	a3 01       	movw	r20, r6
     bf2:	92 01       	movw	r18, r4
     bf4:	0e 94 9c 04 	call	0x938	; 0x938 <createAsteroid>
     bf8:	90 93 82 02 	sts	0x0282, r25
     bfc:	80 93 81 02 	sts	0x0281, r24
     c00:	08 94       	sec
     c02:	21 08       	sbc	r2, r1
     c04:	31 08       	sbc	r3, r1
	
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
     c06:	0f 90       	pop	r0
     c08:	0f 90       	pop	r0
     c0a:	0f 90       	pop	r0
     c0c:	0f 90       	pop	r0
     c0e:	21 14       	cp	r2, r1
     c10:	31 04       	cpc	r3, r1
     c12:	09 f0       	breq	.+2      	; 0xc16 <init+0x1e8>
     c14:	53 cf       	rjmp	.-346    	; 0xabc <init+0x8e>
								   (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
								   3,
								   asteroids);
	}
	
	ship.handle = xSpriteCreate("ship.png", SCREEN_W >> 1, SCREEN_H >> 1, 0, SHIP_SIZE, SHIP_SIZE, 1);
     c16:	82 e1       	ldi	r24, 0x12	; 18
     c18:	92 e0       	ldi	r25, 0x02	; 2
     c1a:	60 e9       	ldi	r22, 0x90	; 144
     c1c:	71 e0       	ldi	r23, 0x01	; 1
     c1e:	4c e2       	ldi	r20, 0x2C	; 44
     c20:	51 e0       	ldi	r21, 0x01	; 1
     c22:	20 e0       	ldi	r18, 0x00	; 0
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	08 e1       	ldi	r16, 0x18	; 24
     c28:	10 e0       	ldi	r17, 0x00	; 0
     c2a:	0f 2e       	mov	r0, r31
     c2c:	f8 e1       	ldi	r31, 0x18	; 24
     c2e:	ef 2e       	mov	r14, r31
     c30:	ff 24       	eor	r15, r15
     c32:	f0 2d       	mov	r31, r0
     c34:	cc 24       	eor	r12, r12
     c36:	c3 94       	inc	r12
     c38:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xSpriteCreate>
     c3c:	80 93 60 02 	sts	0x0260, r24
	ship.pos.x = SCREEN_W >> 1;
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	a8 ec       	ldi	r26, 0xC8	; 200
     c46:	b3 e4       	ldi	r27, 0x43	; 67
     c48:	80 93 61 02 	sts	0x0261, r24
     c4c:	90 93 62 02 	sts	0x0262, r25
     c50:	a0 93 63 02 	sts	0x0263, r26
     c54:	b0 93 64 02 	sts	0x0264, r27
	ship.pos.y = SCREEN_H >> 1;
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	a6 e9       	ldi	r26, 0x96	; 150
     c5e:	b3 e4       	ldi	r27, 0x43	; 67
     c60:	80 93 65 02 	sts	0x0265, r24
     c64:	90 93 66 02 	sts	0x0266, r25
     c68:	a0 93 67 02 	sts	0x0267, r26
     c6c:	b0 93 68 02 	sts	0x0268, r27
	ship.vel.x = 0;
     c70:	80 e0       	ldi	r24, 0x00	; 0
     c72:	90 e0       	ldi	r25, 0x00	; 0
     c74:	dc 01       	movw	r26, r24
     c76:	80 93 69 02 	sts	0x0269, r24
     c7a:	90 93 6a 02 	sts	0x026A, r25
     c7e:	a0 93 6b 02 	sts	0x026B, r26
     c82:	b0 93 6c 02 	sts	0x026C, r27
	ship.vel.y = 0;
     c86:	80 93 6d 02 	sts	0x026D, r24
     c8a:	90 93 6e 02 	sts	0x026E, r25
     c8e:	a0 93 6f 02 	sts	0x026F, r26
     c92:	b0 93 70 02 	sts	0x0270, r27
	ship.accel = 0;
     c96:	80 93 71 02 	sts	0x0271, r24
     c9a:	90 93 72 02 	sts	0x0272, r25
     c9e:	a0 93 73 02 	sts	0x0273, r26
     ca2:	b0 93 74 02 	sts	0x0274, r27
	ship.angle = 0;
     ca6:	10 92 76 02 	sts	0x0276, r1
     caa:	10 92 75 02 	sts	0x0275, r1
	ship.a_vel = 0;
     cae:	10 92 77 02 	sts	0x0277, r1
}
     cb2:	28 96       	adiw	r28, 0x08	; 8
     cb4:	0f b6       	in	r0, 0x3f	; 63
     cb6:	f8 94       	cli
     cb8:	de bf       	out	0x3e, r29	; 62
     cba:	0f be       	out	0x3f, r0	; 63
     cbc:	cd bf       	out	0x3d, r28	; 61
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	ff 90       	pop	r15
     cc8:	ef 90       	pop	r14
     cca:	df 90       	pop	r13
     ccc:	cf 90       	pop	r12
     cce:	bf 90       	pop	r11
     cd0:	af 90       	pop	r10
     cd2:	9f 90       	pop	r9
     cd4:	8f 90       	pop	r8
     cd6:	7f 90       	pop	r7
     cd8:	6f 90       	pop	r6
     cda:	5f 90       	pop	r5
     cdc:	4f 90       	pop	r4
     cde:	3f 90       	pop	r3
     ce0:	2f 90       	pop	r2
     ce2:	08 95       	ret

00000ce4 <createBullet>:
 * param vely: The new bullet's y velocity.
 * param nxt: A pointer to the next bullet object in a linked list of bullets.
 * return: A pointer to a malloc'd bullet object. This pointer must be freed by
 *  the caller.
 *----------------------------------------------------------------------------*/
object *createBullet(float x, float y, float velx, float vely, object *nxt) {
     ce4:	4f 92       	push	r4
     ce6:	5f 92       	push	r5
     ce8:	6f 92       	push	r6
     cea:	7f 92       	push	r7
     cec:	8f 92       	push	r8
     cee:	9f 92       	push	r9
     cf0:	af 92       	push	r10
     cf2:	bf 92       	push	r11
     cf4:	cf 92       	push	r12
     cf6:	df 92       	push	r13
     cf8:	ef 92       	push	r14
     cfa:	ff 92       	push	r15
     cfc:	0f 93       	push	r16
     cfe:	1f 93       	push	r17
     d00:	cf 93       	push	r28
     d02:	df 93       	push	r29
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
     d08:	28 97       	sbiw	r28, 0x08	; 8
     d0a:	0f b6       	in	r0, 0x3f	; 63
     d0c:	f8 94       	cli
     d0e:	de bf       	out	0x3e, r29	; 62
     d10:	0f be       	out	0x3f, r0	; 63
     d12:	cd bf       	out	0x3d, r28	; 61
     d14:	2b 01       	movw	r4, r22
     d16:	3c 01       	movw	r6, r24
     d18:	29 83       	std	Y+1, r18	; 0x01
     d1a:	3a 83       	std	Y+2, r19	; 0x02
     d1c:	4b 83       	std	Y+3, r20	; 0x03
     d1e:	5c 83       	std	Y+4, r21	; 0x04
     d20:	ed 82       	std	Y+5, r14	; 0x05
     d22:	fe 82       	std	Y+6, r15	; 0x06
     d24:	0f 83       	std	Y+7, r16	; 0x07
     d26:	18 87       	std	Y+8, r17	; 0x08
     d28:	76 01       	movw	r14, r12
     d2a:	65 01       	movw	r12, r10
     * Setup the pointers in the linked list using:
     bullet->next = nxt;
     * Create a new sprite using xSpriteCreate()
     */
	 
   object *new_bullet = pvPortMalloc(sizeof(object));
     d2c:	8d e1       	ldi	r24, 0x1D	; 29
     d2e:	90 e0       	ldi	r25, 0x00	; 0
     d30:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
     d34:	5c 01       	movw	r10, r24

   new_bullet->pos.x = x;
     d36:	dc 01       	movw	r26, r24
     d38:	11 96       	adiw	r26, 0x01	; 1
     d3a:	4d 92       	st	X+, r4
     d3c:	5d 92       	st	X+, r5
     d3e:	6d 92       	st	X+, r6
     d40:	7c 92       	st	X, r7
     d42:	14 97       	sbiw	r26, 0x04	; 4
   new_bullet->pos.y = y;
     d44:	89 81       	ldd	r24, Y+1	; 0x01
     d46:	9a 81       	ldd	r25, Y+2	; 0x02
     d48:	ab 81       	ldd	r26, Y+3	; 0x03
     d4a:	bc 81       	ldd	r27, Y+4	; 0x04
     d4c:	f5 01       	movw	r30, r10
     d4e:	85 83       	std	Z+5, r24	; 0x05
     d50:	96 83       	std	Z+6, r25	; 0x06
     d52:	a7 83       	std	Z+7, r26	; 0x07
     d54:	b0 87       	std	Z+8, r27	; 0x08
   new_bullet->vel.x = velx;
     d56:	8d 81       	ldd	r24, Y+5	; 0x05
     d58:	9e 81       	ldd	r25, Y+6	; 0x06
     d5a:	af 81       	ldd	r26, Y+7	; 0x07
     d5c:	b8 85       	ldd	r27, Y+8	; 0x08
     d5e:	81 87       	std	Z+9, r24	; 0x09
     d60:	92 87       	std	Z+10, r25	; 0x0a
     d62:	a3 87       	std	Z+11, r26	; 0x0b
     d64:	b4 87       	std	Z+12, r27	; 0x0c
   new_bullet->vel.y = vely;
     d66:	c5 86       	std	Z+13, r12	; 0x0d
     d68:	d6 86       	std	Z+14, r13	; 0x0e
     d6a:	e7 86       	std	Z+15, r14	; 0x0f
     d6c:	f0 8a       	std	Z+16, r15	; 0x10
   new_bullet->next = nxt;
     d6e:	94 8e       	std	Z+28, r9	; 0x1c
     d70:	83 8e       	std	Z+27, r8	; 0x1b

   xSpriteCreate("bullet.png",(uint16_t)new_bullet->pos.x ,(uint16_t)new_bullet->pos.y, 0, BULLET_SIZE, BULLET_SIZE, 1);
     d72:	c3 01       	movw	r24, r6
     d74:	b2 01       	movw	r22, r4
     d76:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
     d7a:	6b 01       	movw	r12, r22
     d7c:	7c 01       	movw	r14, r24
     d7e:	69 81       	ldd	r22, Y+1	; 0x01
     d80:	7a 81       	ldd	r23, Y+2	; 0x02
     d82:	8b 81       	ldd	r24, Y+3	; 0x03
     d84:	9c 81       	ldd	r25, Y+4	; 0x04
     d86:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
     d8a:	8b 01       	movw	r16, r22
     d8c:	9c 01       	movw	r18, r24
     d8e:	8b e1       	ldi	r24, 0x1B	; 27
     d90:	92 e0       	ldi	r25, 0x02	; 2
     d92:	b6 01       	movw	r22, r12
     d94:	a8 01       	movw	r20, r16
     d96:	20 e0       	ldi	r18, 0x00	; 0
     d98:	30 e0       	ldi	r19, 0x00	; 0
     d9a:	06 e0       	ldi	r16, 0x06	; 6
     d9c:	10 e0       	ldi	r17, 0x00	; 0
     d9e:	0f 2e       	mov	r0, r31
     da0:	f6 e0       	ldi	r31, 0x06	; 6
     da2:	ef 2e       	mov	r14, r31
     da4:	ff 24       	eor	r15, r15
     da6:	f0 2d       	mov	r31, r0
     da8:	cc 24       	eor	r12, r12
     daa:	c3 94       	inc	r12
     dac:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xSpriteCreate>
   return (new_bullet); 
}
     db0:	8a 2d       	mov	r24, r10
     db2:	9b 2d       	mov	r25, r11
     db4:	28 96       	adiw	r28, 0x08	; 8
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	f8 94       	cli
     dba:	de bf       	out	0x3e, r29	; 62
     dbc:	0f be       	out	0x3f, r0	; 63
     dbe:	cd bf       	out	0x3d, r28	; 61
     dc0:	df 91       	pop	r29
     dc2:	cf 91       	pop	r28
     dc4:	1f 91       	pop	r17
     dc6:	0f 91       	pop	r16
     dc8:	ff 90       	pop	r15
     dca:	ef 90       	pop	r14
     dcc:	df 90       	pop	r13
     dce:	cf 90       	pop	r12
     dd0:	bf 90       	pop	r11
     dd2:	af 90       	pop	r10
     dd4:	9f 90       	pop	r9
     dd6:	8f 90       	pop	r8
     dd8:	7f 90       	pop	r7
     dda:	6f 90       	pop	r6
     ddc:	5f 90       	pop	r5
     dde:	4f 90       	pop	r4
     de0:	08 95       	ret

00000de2 <bulletTask>:
 *  second to regulate the fire rate.  If a bullet is not fired, the task
 *  blocks for a frame delay (FRAME_DELAY_MS)
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void bulletTask(void *vParam) {
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
     dea:	2a 97       	sbiw	r28, 0x0a	; 10
     dec:	0f b6       	in	r0, 0x3f	; 63
     dee:	f8 94       	cli
     df0:	de bf       	out	0x3e, r29	; 62
     df2:	0f be       	out	0x3f, r0	; 63
     df4:	cd bf       	out	0x3d, r28	; 61
     */
	// variable to hold ticks value of last task run
	portTickType xLastWakeTime;

	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
     df6:	0e 94 83 16 	call	0x2d06	; 0x2d06 <xTaskGetTickCount>
     dfa:	9a 83       	std	Y+2, r25	; 0x02
     dfc:	89 83       	std	Y+1, r24	; 0x01
    while (1) {
		if(SHOOT_BUTTON) {
			bullets = createBullet(ship.pos.x, ship.pos.y, ship.vel.x + BULLET_VEL, ship.vel.y + BULLET_VEL, bullets);
     dfe:	0f 2e       	mov	r0, r31
     e00:	f1 e6       	ldi	r31, 0x61	; 97
     e02:	6f 2e       	mov	r6, r31
     e04:	f2 e0       	ldi	r31, 0x02	; 2
     e06:	7f 2e       	mov	r7, r31
     e08:	f0 2d       	mov	r31, r0
     e0a:	44 24       	eor	r4, r4
     e0c:	55 24       	eor	r5, r5
     e0e:	68 94       	set
     e10:	42 f8       	bld	r4, 2
     e12:	46 0c       	add	r4, r6
     e14:	57 1c       	adc	r5, r7
     e16:	22 24       	eor	r2, r2
     e18:	33 24       	eor	r3, r3
     e1a:	68 94       	set
     e1c:	23 f8       	bld	r2, 3
     e1e:	26 0c       	add	r2, r6
     e20:	37 1c       	adc	r3, r7
     e22:	d3 01       	movw	r26, r6
     e24:	8d 91       	ld	r24, X+
     e26:	9d 91       	ld	r25, X+
     e28:	0d 90       	ld	r0, X+
     e2a:	bc 91       	ld	r27, X
     e2c:	a0 2d       	mov	r26, r0
     e2e:	8b 83       	std	Y+3, r24	; 0x03
     e30:	9c 83       	std	Y+4, r25	; 0x04
     e32:	ad 83       	std	Y+5, r26	; 0x05
     e34:	be 83       	std	Y+6, r27	; 0x06
     e36:	d2 01       	movw	r26, r4
     e38:	8d 91       	ld	r24, X+
     e3a:	9d 91       	ld	r25, X+
     e3c:	0d 90       	ld	r0, X+
     e3e:	bc 91       	ld	r27, X
     e40:	a0 2d       	mov	r26, r0
     e42:	8f 83       	std	Y+7, r24	; 0x07
     e44:	98 87       	std	Y+8, r25	; 0x08
     e46:	a9 87       	std	Y+9, r26	; 0x09
     e48:	ba 87       	std	Y+10, r27	; 0x0a
     e4a:	f1 01       	movw	r30, r2
     e4c:	60 81       	ld	r22, Z
     e4e:	71 81       	ldd	r23, Z+1	; 0x01
     e50:	82 81       	ldd	r24, Z+2	; 0x02
     e52:	93 81       	ldd	r25, Z+3	; 0x03
     e54:	20 e0       	ldi	r18, 0x00	; 0
     e56:	30 e0       	ldi	r19, 0x00	; 0
     e58:	40 ec       	ldi	r20, 0xC0	; 192
     e5a:	50 e4       	ldi	r21, 0x40	; 64
     e5c:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     e60:	7b 01       	movw	r14, r22
     e62:	8c 01       	movw	r16, r24
     e64:	ad e6       	ldi	r26, 0x6D	; 109
     e66:	b2 e0       	ldi	r27, 0x02	; 2
     e68:	6d 91       	ld	r22, X+
     e6a:	7d 91       	ld	r23, X+
     e6c:	8d 91       	ld	r24, X+
     e6e:	9c 91       	ld	r25, X
     e70:	20 e0       	ldi	r18, 0x00	; 0
     e72:	30 e0       	ldi	r19, 0x00	; 0
     e74:	40 ec       	ldi	r20, 0xC0	; 192
     e76:	50 e4       	ldi	r21, 0x40	; 64
     e78:	0e 94 bb 1a 	call	0x3576	; 0x3576 <__addsf3>
     e7c:	5b 01       	movw	r10, r22
     e7e:	6c 01       	movw	r12, r24
     e80:	80 90 7d 02 	lds	r8, 0x027D
     e84:	90 90 7e 02 	lds	r9, 0x027E
     e88:	6b 81       	ldd	r22, Y+3	; 0x03
     e8a:	7c 81       	ldd	r23, Y+4	; 0x04
     e8c:	8d 81       	ldd	r24, Y+5	; 0x05
     e8e:	9e 81       	ldd	r25, Y+6	; 0x06
     e90:	2f 81       	ldd	r18, Y+7	; 0x07
     e92:	38 85       	ldd	r19, Y+8	; 0x08
     e94:	49 85       	ldd	r20, Y+9	; 0x09
     e96:	5a 85       	ldd	r21, Y+10	; 0x0a
     e98:	0e 94 72 06 	call	0xce4	; 0xce4 <createBullet>
     e9c:	90 93 7e 02 	sts	0x027E, r25
     ea0:	80 93 7d 02 	sts	0x027D, r24
						
			vTaskDelay((BULLET_LIFE_MS/2)/portTICK_RATE_MS);
     ea4:	84 ef       	ldi	r24, 0xF4	; 244
     ea6:	91 e0       	ldi	r25, 0x01	; 1
     ea8:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <vTaskDelay>
		}
			
		vTaskDelayUntil(&xLastWakeTime, FRAME_DELAY_MS / portTICK_RATE_MS);
     eac:	ce 01       	movw	r24, r28
     eae:	01 96       	adiw	r24, 0x01	; 1
     eb0:	6a e0       	ldi	r22, 0x0A	; 10
     eb2:	70 e0       	ldi	r23, 0x00	; 0
     eb4:	0e 94 0b 18 	call	0x3016	; 0x3016 <vTaskDelayUntil>
     eb8:	b4 cf       	rjmp	.-152    	; 0xe22 <bulletTask+0x40>

00000eba <spawnAsteroid>:
 *
 * param pos: A pointer to the position at which the new asteroids will be
 *  created.
 * param size: The size of the asteroid being destroyed.
 *----------------------------------------------------------------------------*/
void spawnAsteroid(point *pos, uint8_t size) {
     eba:	3f 92       	push	r3
     ebc:	4f 92       	push	r4
     ebe:	5f 92       	push	r5
     ec0:	6f 92       	push	r6
     ec2:	7f 92       	push	r7
     ec4:	8f 92       	push	r8
     ec6:	9f 92       	push	r9
     ec8:	af 92       	push	r10
     eca:	bf 92       	push	r11
     ecc:	cf 92       	push	r12
     ece:	df 92       	push	r13
     ed0:	ef 92       	push	r14
     ed2:	ff 92       	push	r15
     ed4:	0f 93       	push	r16
     ed6:	1f 93       	push	r17
     ed8:	cf 93       	push	r28
     eda:	df 93       	push	r29
     edc:	cd b7       	in	r28, 0x3d	; 61
     ede:	de b7       	in	r29, 0x3e	; 62
     ee0:	2c 97       	sbiw	r28, 0x0c	; 12
     ee2:	0f b6       	in	r0, 0x3f	; 63
     ee4:	f8 94       	cli
     ee6:	de bf       	out	0x3e, r29	; 62
     ee8:	0f be       	out	0x3f, r0	; 63
     eea:	cd bf       	out	0x3d, r28	; 61
     eec:	9c 01       	movw	r18, r24
     eee:	16 2f       	mov	r17, r22
	/* ToDo:
     * Spawn 3 smaller asteroids, or no asteroids depending on the size of this asteroid
     * Use createAsteroid()
     */
   int vel, accel;
   if (size > 1) {
     ef0:	62 30       	cpi	r22, 0x02	; 2
     ef2:	08 f4       	brcc	.+2      	; 0xef6 <spawnAsteroid+0x3c>
     ef4:	f2 c0       	rjmp	.+484    	; 0x10da <spawnAsteroid+0x220>
      switch (size - 1) {
     ef6:	86 2f       	mov	r24, r22
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	01 97       	sbiw	r24, 0x01	; 1
     efc:	81 30       	cpi	r24, 0x01	; 1
     efe:	91 05       	cpc	r25, r1
     f00:	b1 f0       	breq	.+44     	; 0xf2e <spawnAsteroid+0x74>
     f02:	82 30       	cpi	r24, 0x02	; 2
     f04:	91 05       	cpc	r25, r1
     f06:	51 f4       	brne	.+20     	; 0xf1c <spawnAsteroid+0x62>
         case 2:
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
     f08:	86 e0       	ldi	r24, 0x06	; 6
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	9a 83       	std	Y+2, r25	; 0x02
     f0e:	89 83       	std	Y+1, r24	; 0x01
     */
   int vel, accel;
   if (size > 1) {
      switch (size - 1) {
         case 2:
            vel = AST_MAX_VEL_2;
     f10:	0f 2e       	mov	r0, r31
     f12:	f3 e0       	ldi	r31, 0x03	; 3
     f14:	cf 2e       	mov	r12, r31
     f16:	dd 24       	eor	r13, r13
     f18:	f0 2d       	mov	r31, r0
     f1a:	11 c0       	rjmp	.+34     	; 0xf3e <spawnAsteroid+0x84>
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
            break;
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
     f1c:	a3 e0       	ldi	r26, 0x03	; 3
     f1e:	b0 e0       	ldi	r27, 0x00	; 0
     f20:	ba 83       	std	Y+2, r27	; 0x02
     f22:	a9 83       	std	Y+1, r26	; 0x01
         case 1:
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
            break;
         default:
            vel = AST_MAX_VEL_3;
     f24:	cc 24       	eor	r12, r12
     f26:	dd 24       	eor	r13, r13
     f28:	68 94       	set
     f2a:	c1 f8       	bld	r12, 1
            accel = AST_MAX_AVEL_3;
            break;
     f2c:	08 c0       	rjmp	.+16     	; 0xf3e <spawnAsteroid+0x84>
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
            break;
         case 1:
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
     f2e:	e9 e0       	ldi	r30, 0x09	; 9
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	fa 83       	std	Y+2, r31	; 0x02
     f34:	e9 83       	std	Y+1, r30	; 0x01
         case 2:
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
            break;
         case 1:
            vel = AST_MAX_VEL_1;
     f36:	cc 24       	eor	r12, r12
     f38:	dd 24       	eor	r13, r13
     f3a:	68 94       	set
     f3c:	c2 f8       	bld	r12, 2
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
      asteroids = createAsteroid(
     f3e:	d9 01       	movw	r26, r18
     f40:	8d 91       	ld	r24, X+
     f42:	9d 91       	ld	r25, X+
     f44:	0d 90       	ld	r0, X+
     f46:	bc 91       	ld	r27, X
     f48:	a0 2d       	mov	r26, r0
     f4a:	8b 83       	std	Y+3, r24	; 0x03
     f4c:	9c 83       	std	Y+4, r25	; 0x04
     f4e:	ad 83       	std	Y+5, r26	; 0x05
     f50:	be 83       	std	Y+6, r27	; 0x06
     f52:	d9 01       	movw	r26, r18
     f54:	14 96       	adiw	r26, 0x04	; 4
     f56:	8d 91       	ld	r24, X+
     f58:	9d 91       	ld	r25, X+
     f5a:	0d 90       	ld	r0, X+
     f5c:	bc 91       	ld	r27, X
     f5e:	a0 2d       	mov	r26, r0
     f60:	8f 83       	std	Y+7, r24	; 0x07
     f62:	98 87       	std	Y+8, r25	; 0x08
     f64:	a9 87       	std	Y+9, r26	; 0x09
     f66:	ba 87       	std	Y+10, r27	; 0x0a
         pos->x,                                         //x pos
         pos->y,                                         //y pos
         (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
     f68:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     f6c:	4c 01       	movw	r8, r24
     f6e:	8c 2d       	mov	r24, r12
     f70:	88 0f       	add	r24, r24
     f72:	a8 2e       	mov	r10, r24
     f74:	aa 0c       	add	r10, r10
     f76:	aa 0c       	add	r10, r10
     f78:	8a 0d       	add	r24, r10
     f7a:	a8 2e       	mov	r10, r24
     f7c:	bb 24       	eor	r11, r11
     f7e:	a7 fc       	sbrc	r10, 7
     f80:	b0 94       	com	r11
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
      asteroids = createAsteroid(
     f82:	b6 01       	movw	r22, r12
     f84:	88 27       	eor	r24, r24
     f86:	77 fd       	sbrc	r23, 7
     f88:	80 95       	com	r24
     f8a:	98 2f       	mov	r25, r24
     f8c:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     f90:	6b 01       	movw	r12, r22
     f92:	7c 01       	movw	r14, r24
         pos->x,                                         //x pos
         pos->y,                                         //y pos
         (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
     f94:	c4 01       	movw	r24, r8
     f96:	b5 01       	movw	r22, r10
     f98:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     f9c:	fc 01       	movw	r30, r24
     f9e:	bf 01       	movw	r22, r30
     fa0:	88 27       	eor	r24, r24
     fa2:	77 fd       	sbrc	r23, 7
     fa4:	80 95       	com	r24
     fa6:	98 2f       	mov	r25, r24
     fa8:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     fac:	20 e0       	ldi	r18, 0x00	; 0
     fae:	30 e0       	ldi	r19, 0x00	; 0
     fb0:	40 ea       	ldi	r20, 0xA0	; 160
     fb2:	50 e4       	ldi	r21, 0x40	; 64
     fb4:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     fb8:	a7 01       	movw	r20, r14
     fba:	96 01       	movw	r18, r12
     fbc:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     fc0:	06 2f       	mov	r16, r22
     fc2:	57 2e       	mov	r5, r23
     fc4:	48 2e       	mov	r4, r24
     fc6:	39 2e       	mov	r3, r25
         (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
     fc8:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
     fcc:	b5 01       	movw	r22, r10
     fce:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
     fd2:	9c 01       	movw	r18, r24
     fd4:	b9 01       	movw	r22, r18
     fd6:	88 27       	eor	r24, r24
     fd8:	77 fd       	sbrc	r23, 7
     fda:	80 95       	com	r24
     fdc:	98 2f       	mov	r25, r24
     fde:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
     fe2:	20 e0       	ldi	r18, 0x00	; 0
     fe4:	30 e0       	ldi	r19, 0x00	; 0
     fe6:	40 ea       	ldi	r20, 0xA0	; 160
     fe8:	50 e4       	ldi	r21, 0x40	; 64
     fea:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
     fee:	a7 01       	movw	r20, r14
     ff0:	96 01       	movw	r18, r12
     ff2:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
     ff6:	86 2e       	mov	r8, r22
     ff8:	97 2e       	mov	r9, r23
     ffa:	78 2e       	mov	r7, r24
     ffc:	69 2e       	mov	r6, r25
         rand() % 360,                                   //angle
     ffe:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
    1002:	6c 01       	movw	r12, r24
         (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    1004:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <rand>
    1008:	9c 01       	movw	r18, r24
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
      asteroids = createAsteroid(
    100a:	00 d0       	rcall	.+0      	; 0x100c <spawnAsteroid+0x152>
    100c:	0f 92       	push	r0
    100e:	ad b6       	in	r10, 0x3d	; 61
    1010:	be b6       	in	r11, 0x3e	; 62
    1012:	08 94       	sec
    1014:	a1 1c       	adc	r10, r1
    1016:	b1 1c       	adc	r11, r1
    1018:	c6 01       	movw	r24, r12
    101a:	68 e6       	ldi	r22, 0x68	; 104
    101c:	71 e0       	ldi	r23, 0x01	; 1
    101e:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
    1022:	9c 87       	std	Y+12, r25	; 0x0c
    1024:	8b 87       	std	Y+11, r24	; 0x0b
         pos->x,                                         //x pos
         pos->y,                                         //y pos
         (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
         (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
         rand() % 360,                                   //angle
         (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    1026:	89 81       	ldd	r24, Y+1	; 0x01
    1028:	88 0f       	add	r24, r24
    102a:	68 2f       	mov	r22, r24
    102c:	66 0f       	add	r22, r22
    102e:	66 0f       	add	r22, r22
    1030:	86 0f       	add	r24, r22
    1032:	68 2f       	mov	r22, r24
    1034:	77 27       	eor	r23, r23
    1036:	67 fd       	sbrc	r22, 7
    1038:	70 95       	com	r23
    103a:	c9 01       	movw	r24, r18
    103c:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <__divmodhi4>
    1040:	dc 01       	movw	r26, r24
    1042:	bd 01       	movw	r22, r26
    1044:	88 27       	eor	r24, r24
    1046:	77 fd       	sbrc	r23, 7
    1048:	80 95       	com	r24
    104a:	98 2f       	mov	r25, r24
    104c:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
    1050:	20 e0       	ldi	r18, 0x00	; 0
    1052:	30 e0       	ldi	r19, 0x00	; 0
    1054:	40 ea       	ldi	r20, 0xA0	; 160
    1056:	50 e4       	ldi	r21, 0x40	; 64
    1058:	0e 94 26 1b 	call	0x364c	; 0x364c <__divsf3>
    105c:	6b 01       	movw	r12, r22
    105e:	7c 01       	movw	r14, r24
    1060:	e9 81       	ldd	r30, Y+1	; 0x01
    1062:	fa 81       	ldd	r31, Y+2	; 0x02
    1064:	bf 01       	movw	r22, r30
    1066:	88 27       	eor	r24, r24
    1068:	77 fd       	sbrc	r23, 7
    106a:	80 95       	com	r24
    106c:	98 2f       	mov	r25, r24
    106e:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__floatsisf>
    1072:	9b 01       	movw	r18, r22
    1074:	ac 01       	movw	r20, r24
    1076:	c7 01       	movw	r24, r14
    1078:	b6 01       	movw	r22, r12
    107a:	0e 94 ba 1a 	call	0x3574	; 0x3574 <__subsf3>
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
      asteroids = createAsteroid(
    107e:	0e 94 8e 1b 	call	0x371c	; 0x371c <__fixsfsi>
    1082:	d5 01       	movw	r26, r10
    1084:	6c 93       	st	X, r22
    1086:	11 50       	subi	r17, 0x01	; 1
    1088:	11 96       	adiw	r26, 0x01	; 1
    108a:	1c 93       	st	X, r17
    108c:	11 97       	sbiw	r26, 0x01	; 1
    108e:	80 91 81 02 	lds	r24, 0x0281
    1092:	90 91 82 02 	lds	r25, 0x0282
    1096:	13 96       	adiw	r26, 0x03	; 3
    1098:	9c 93       	st	X, r25
    109a:	8e 93       	st	-X, r24
    109c:	12 97       	sbiw	r26, 0x02	; 2
    109e:	6b 81       	ldd	r22, Y+3	; 0x03
    10a0:	7c 81       	ldd	r23, Y+4	; 0x04
    10a2:	8d 81       	ldd	r24, Y+5	; 0x05
    10a4:	9e 81       	ldd	r25, Y+6	; 0x06
    10a6:	2f 81       	ldd	r18, Y+7	; 0x07
    10a8:	38 85       	ldd	r19, Y+8	; 0x08
    10aa:	49 85       	ldd	r20, Y+9	; 0x09
    10ac:	5a 85       	ldd	r21, Y+10	; 0x0a
    10ae:	c0 2e       	mov	r12, r16
    10b0:	d5 2c       	mov	r13, r5
    10b2:	e4 2c       	mov	r14, r4
    10b4:	f3 2c       	mov	r15, r3
    10b6:	87 01       	movw	r16, r14
    10b8:	76 01       	movw	r14, r12
    10ba:	a7 2c       	mov	r10, r7
    10bc:	b6 2c       	mov	r11, r6
    10be:	65 01       	movw	r12, r10
    10c0:	54 01       	movw	r10, r8
    10c2:	8b 84       	ldd	r8, Y+11	; 0x0b
    10c4:	9c 84       	ldd	r9, Y+12	; 0x0c
    10c6:	0e 94 9c 04 	call	0x938	; 0x938 <createAsteroid>
    10ca:	90 93 82 02 	sts	0x0282, r25
    10ce:	80 93 81 02 	sts	0x0281, r24
    10d2:	0f 90       	pop	r0
    10d4:	0f 90       	pop	r0
    10d6:	0f 90       	pop	r0
    10d8:	0f 90       	pop	r0
         rand() % 360,                                   //angle
         (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
         size - 1,                                       //size
         asteroids);                                     //next asteroid
   }
}
    10da:	2c 96       	adiw	r28, 0x0c	; 12
    10dc:	0f b6       	in	r0, 0x3f	; 63
    10de:	f8 94       	cli
    10e0:	de bf       	out	0x3e, r29	; 62
    10e2:	0f be       	out	0x3f, r0	; 63
    10e4:	cd bf       	out	0x3d, r28	; 61
    10e6:	df 91       	pop	r29
    10e8:	cf 91       	pop	r28
    10ea:	1f 91       	pop	r17
    10ec:	0f 91       	pop	r16
    10ee:	ff 90       	pop	r15
    10f0:	ef 90       	pop	r14
    10f2:	df 90       	pop	r13
    10f4:	cf 90       	pop	r12
    10f6:	bf 90       	pop	r11
    10f8:	af 90       	pop	r10
    10fa:	9f 90       	pop	r9
    10fc:	8f 90       	pop	r8
    10fe:	7f 90       	pop	r7
    1100:	6f 90       	pop	r6
    1102:	5f 90       	pop	r5
    1104:	4f 90       	pop	r4
    1106:	3f 90       	pop	r3
    1108:	08 95       	ret

0000110a <drawTask>:
 *  checks collisions and performs the proper action based on the types of the
 *  colliding objects.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void drawTask(void *vParam) {
    110a:	cf 93       	push	r28
    110c:	df 93       	push	r29
    110e:	cd b7       	in	r28, 0x3d	; 61
    1110:	de b7       	in	r29, 0x3e	; 62
    1112:	29 97       	sbiw	r28, 0x09	; 9
    1114:	0f b6       	in	r0, 0x3f	; 63
    1116:	f8 94       	cli
    1118:	de bf       	out	0x3e, r29	; 62
    111a:	0f be       	out	0x3f, r0	; 63
    111c:	cd bf       	out	0x3d, r28	; 61
	object *objIter, *objPrev, *astIter, *astPrev, *objTemp;
	xSpriteHandle hit, handle;
	point pos;
	uint8_t size;
	
	vTaskSuspend(updateTaskHandle);
    111e:	80 91 83 02 	lds	r24, 0x0283
    1122:	90 91 84 02 	lds	r25, 0x0284
    1126:	0e 94 b2 18 	call	0x3164	; 0x3164 <vTaskSuspend>
	vTaskSuspend(bulletTaskHandle);
    112a:	80 91 85 02 	lds	r24, 0x0285
    112e:	90 91 86 02 	lds	r25, 0x0286
    1132:	0e 94 b2 18 	call	0x3164	; 0x3164 <vTaskSuspend>
	vTaskSuspend(inputTaskHandle);
    1136:	80 91 87 02 	lds	r24, 0x0287
    113a:	90 91 88 02 	lds	r25, 0x0288
    113e:	0e 94 b2 18 	call	0x3164	; 0x3164 <vTaskSuspend>
	init();
    1142:	0e 94 17 05 	call	0xa2e	; 0xa2e <init>
	vTaskResume(updateTaskHandle);
    1146:	80 91 83 02 	lds	r24, 0x0283
    114a:	90 91 84 02 	lds	r25, 0x0284
    114e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <vTaskResume>
	vTaskResume(bulletTaskHandle);
    1152:	80 91 85 02 	lds	r24, 0x0285
    1156:	90 91 86 02 	lds	r25, 0x0286
    115a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <vTaskResume>
	vTaskResume(inputTaskHandle);
    115e:	80 91 87 02 	lds	r24, 0x0287
    1162:	90 91 88 02 	lds	r25, 0x0288
    1166:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <vTaskResume>
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
    116a:	0f 2e       	mov	r0, r31
    116c:	f0 e6       	ldi	r31, 0x60	; 96
    116e:	4f 2e       	mov	r4, r31
    1170:	f2 e0       	ldi	r31, 0x02	; 2
    1172:	5f 2e       	mov	r5, r31
    1174:	f0 2d       	mov	r31, r0
    1176:	0f 2e       	mov	r0, r31
    1178:	f5 e1       	ldi	r31, 0x15	; 21
    117a:	2f 2e       	mov	r2, r31
    117c:	33 24       	eor	r3, r3
    117e:	f0 2d       	mov	r31, r0
    1180:	24 0c       	add	r2, r4
    1182:	35 1c       	adc	r3, r5
	vTaskResume(updateTaskHandle);
	vTaskResume(bulletTaskHandle);
	vTaskResume(inputTaskHandle);
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
    1184:	80 91 7f 02 	lds	r24, 0x027F
    1188:	90 91 80 02 	lds	r25, 0x0280
    118c:	60 e0       	ldi	r22, 0x00	; 0
    118e:	70 e0       	ldi	r23, 0x00	; 0
    1190:	4f ef       	ldi	r20, 0xFF	; 255
    1192:	5f ef       	ldi	r21, 0xFF	; 255
    1194:	20 e0       	ldi	r18, 0x00	; 0
    1196:	0e 94 30 13 	call	0x2660	; 0x2660 <xQueueGenericReceive>
		
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
    119a:	f1 01       	movw	r30, r2
    119c:	60 81       	ld	r22, Z
    119e:	71 81       	ldd	r23, Z+1	; 0x01
    11a0:	f2 01       	movw	r30, r4
    11a2:	80 81       	ld	r24, Z
    11a4:	0e 94 06 0b 	call	0x160c	; 0x160c <vSpriteSetRotation>
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);
    11a8:	e1 e6       	ldi	r30, 0x61	; 97
    11aa:	f2 e0       	ldi	r31, 0x02	; 2
    11ac:	60 81       	ld	r22, Z
    11ae:	71 81       	ldd	r23, Z+1	; 0x01
    11b0:	82 81       	ldd	r24, Z+2	; 0x02
    11b2:	93 81       	ldd	r25, Z+3	; 0x03
    11b4:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
    11b8:	6b 01       	movw	r12, r22
    11ba:	7c 01       	movw	r14, r24
    11bc:	e5 e6       	ldi	r30, 0x65	; 101
    11be:	f2 e0       	ldi	r31, 0x02	; 2
    11c0:	60 81       	ld	r22, Z
    11c2:	71 81       	ldd	r23, Z+1	; 0x01
    11c4:	82 81       	ldd	r24, Z+2	; 0x02
    11c6:	93 81       	ldd	r25, Z+3	; 0x03
    11c8:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
    11cc:	8b 01       	movw	r16, r22
    11ce:	9c 01       	movw	r18, r24
    11d0:	f2 01       	movw	r30, r4
    11d2:	80 81       	ld	r24, Z
    11d4:	b6 01       	movw	r22, r12
    11d6:	a8 01       	movw	r20, r16
    11d8:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <vSpriteSetPosition>

		objPrev = NULL;
		objIter = bullets;
    11dc:	e0 90 7d 02 	lds	r14, 0x027D
    11e0:	f0 90 7e 02 	lds	r15, 0x027E
		while (objIter != NULL) {
    11e4:	e1 14       	cp	r14, r1
    11e6:	f1 04       	cpc	r15, r1
    11e8:	09 f4       	brne	.+2      	; 0x11ec <drawTask+0xe2>
    11ea:	98 c0       	rjmp	.+304    	; 0x131c <drawTask+0x212>
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);

		objPrev = NULL;
    11ec:	66 24       	eor	r6, r6
    11ee:	77 24       	eor	r7, r7
		objIter = bullets;
		while (objIter != NULL) {
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
    11f0:	f7 01       	movw	r30, r14
    11f2:	61 81       	ldd	r22, Z+1	; 0x01
    11f4:	72 81       	ldd	r23, Z+2	; 0x02
    11f6:	83 81       	ldd	r24, Z+3	; 0x03
    11f8:	94 81       	ldd	r25, Z+4	; 0x04
    11fa:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
    11fe:	4b 01       	movw	r8, r22
    1200:	5c 01       	movw	r10, r24
    1202:	f7 01       	movw	r30, r14
    1204:	65 81       	ldd	r22, Z+5	; 0x05
    1206:	76 81       	ldd	r23, Z+6	; 0x06
    1208:	87 81       	ldd	r24, Z+7	; 0x07
    120a:	90 85       	ldd	r25, Z+8	; 0x08
    120c:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
    1210:	8b 01       	movw	r16, r22
    1212:	9c 01       	movw	r18, r24
    1214:	f7 01       	movw	r30, r14
    1216:	80 81       	ld	r24, Z
    1218:	b4 01       	movw	r22, r8
    121a:	a8 01       	movw	r20, r16
    121c:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <vSpriteSetPosition>
			if (uCollide(objIter->handle, astGroup, &hit, 1) > 0) {
    1220:	f7 01       	movw	r30, r14
    1222:	80 81       	ld	r24, Z
    1224:	60 91 89 02 	lds	r22, 0x0289
    1228:	ae 01       	movw	r20, r28
    122a:	4f 5f       	subi	r20, 0xFF	; 255
    122c:	5f 4f       	sbci	r21, 0xFF	; 255
    122e:	21 e0       	ldi	r18, 0x01	; 1
    1230:	0e 94 88 0b 	call	0x1710	; 0x1710 <uCollide>
    1234:	88 23       	and	r24, r24
    1236:	09 f4       	brne	.+2      	; 0x123a <drawTask+0x130>
    1238:	67 c0       	rjmp	.+206    	; 0x1308 <drawTask+0x1fe>
				vSpriteDelete(objIter->handle);
    123a:	f7 01       	movw	r30, r14
    123c:	80 81       	ld	r24, Z
    123e:	0e 94 4e 0b 	call	0x169c	; 0x169c <vSpriteDelete>
				
				if (objPrev != NULL) {
    1242:	61 14       	cp	r6, r1
    1244:	71 04       	cpc	r7, r1
    1246:	69 f0       	breq	.+26     	; 0x1262 <drawTask+0x158>
					objPrev->next = objIter->next;
    1248:	f7 01       	movw	r30, r14
    124a:	83 8d       	ldd	r24, Z+27	; 0x1b
    124c:	94 8d       	ldd	r25, Z+28	; 0x1c
    124e:	f3 01       	movw	r30, r6
    1250:	94 8f       	std	Z+28, r25	; 0x1c
    1252:	83 8f       	std	Z+27, r24	; 0x1b
					vPortFree(objIter);
    1254:	c7 01       	movw	r24, r14
    1256:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
					objIter = objPrev->next;
    125a:	f3 01       	movw	r30, r6
    125c:	e3 8c       	ldd	r14, Z+27	; 0x1b
    125e:	f4 8c       	ldd	r15, Z+28	; 0x1c
    1260:	0e c0       	rjmp	.+28     	; 0x127e <drawTask+0x174>
				} else {
					bullets = objIter->next;
    1262:	f7 01       	movw	r30, r14
    1264:	83 8d       	ldd	r24, Z+27	; 0x1b
    1266:	94 8d       	ldd	r25, Z+28	; 0x1c
    1268:	90 93 7e 02 	sts	0x027E, r25
    126c:	80 93 7d 02 	sts	0x027D, r24
					vPortFree(objIter);
    1270:	c7 01       	movw	r24, r14
    1272:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
					objIter = bullets;
    1276:	e0 90 7d 02 	lds	r14, 0x027D
    127a:	f0 90 7e 02 	lds	r15, 0x027E
				}
				astPrev = NULL;
				astIter = asteroids;
    127e:	c0 90 81 02 	lds	r12, 0x0281
    1282:	d0 90 82 02 	lds	r13, 0x0282
				while (astIter != NULL) {
    1286:	c1 14       	cp	r12, r1
    1288:	d1 04       	cpc	r13, r1
    128a:	09 f4       	brne	.+2      	; 0x128e <drawTask+0x184>
    128c:	43 c0       	rjmp	.+134    	; 0x1314 <drawTask+0x20a>
					if (astIter->handle == hit) {
    128e:	99 81       	ldd	r25, Y+1	; 0x01
    1290:	f6 01       	movw	r30, r12
    1292:	80 81       	ld	r24, Z
    1294:	89 17       	cp	r24, r25
    1296:	89 f5       	brne	.+98     	; 0x12fa <drawTask+0x1f0>
    1298:	f1 c0       	rjmp	.+482    	; 0x147c <drawTask+0x372>
    129a:	f8 01       	movw	r30, r16
    129c:	80 81       	ld	r24, Z
    129e:	89 17       	cp	r24, r25
    12a0:	59 f5       	brne	.+86     	; 0x12f8 <drawTask+0x1ee>
						spawnAsteroid(&pos, size);
						break;					
						
					} else {
						astPrev = astIter;
						astIter = astIter->next;
    12a2:	48 01       	movw	r8, r16
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
					if (astIter->handle == hit) {
						pos = astIter->pos;
    12a4:	de 01       	movw	r26, r28
    12a6:	12 96       	adiw	r26, 0x02	; 2
    12a8:	31 96       	adiw	r30, 0x01	; 1
    12aa:	88 e0       	ldi	r24, 0x08	; 8
    12ac:	01 90       	ld	r0, Z+
    12ae:	0d 92       	st	X+, r0
    12b0:	81 50       	subi	r24, 0x01	; 1
    12b2:	e1 f7       	brne	.-8      	; 0x12ac <drawTask+0x1a2>
						size = astIter->size;
    12b4:	f4 01       	movw	r30, r8
    12b6:	b0 8c       	ldd	r11, Z+24	; 0x18
						vSpriteDelete(astIter->handle);
    12b8:	80 81       	ld	r24, Z
    12ba:	0e 94 4e 0b 	call	0x169c	; 0x169c <vSpriteDelete>
						if (astPrev != NULL) {
    12be:	c1 14       	cp	r12, r1
    12c0:	d1 04       	cpc	r13, r1
    12c2:	51 f0       	breq	.+20     	; 0x12d8 <drawTask+0x1ce>
					        astPrev->next = astIter->next;
    12c4:	f4 01       	movw	r30, r8
    12c6:	83 8d       	ldd	r24, Z+27	; 0x1b
    12c8:	94 8d       	ldd	r25, Z+28	; 0x1c
    12ca:	f6 01       	movw	r30, r12
    12cc:	94 8f       	std	Z+28, r25	; 0x1c
    12ce:	83 8f       	std	Z+27, r24	; 0x1b
					        vPortFree(astIter);
    12d0:	c4 01       	movw	r24, r8
    12d2:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
    12d6:	0a c0       	rjmp	.+20     	; 0x12ec <drawTask+0x1e2>
					        astIter = astPrev->next;
				        } else {
					        asteroids = astIter->next;
    12d8:	f8 01       	movw	r30, r16
    12da:	83 8d       	ldd	r24, Z+27	; 0x1b
    12dc:	94 8d       	ldd	r25, Z+28	; 0x1c
    12de:	90 93 82 02 	sts	0x0282, r25
    12e2:	80 93 81 02 	sts	0x0281, r24
					        vPortFree(astIter);
    12e6:	c8 01       	movw	r24, r16
    12e8:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
				        }
						spawnAsteroid(&pos, size);
    12ec:	ce 01       	movw	r24, r28
    12ee:	02 96       	adiw	r24, 0x02	; 2
    12f0:	6b 2d       	mov	r22, r11
    12f2:	0e 94 5d 07 	call	0xeba	; 0xeba <spawnAsteroid>
						break;					
    12f6:	0e c0       	rjmp	.+28     	; 0x1314 <drawTask+0x20a>
						
					} else {
						astPrev = astIter;
						astIter = astIter->next;
    12f8:	68 01       	movw	r12, r16
    12fa:	f6 01       	movw	r30, r12
    12fc:	03 8d       	ldd	r16, Z+27	; 0x1b
    12fe:	14 8d       	ldd	r17, Z+28	; 0x1c
					vPortFree(objIter);
					objIter = bullets;
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
    1300:	01 15       	cp	r16, r1
    1302:	11 05       	cpc	r17, r1
    1304:	51 f6       	brne	.-108    	; 0x129a <drawTask+0x190>
    1306:	06 c0       	rjmp	.+12     	; 0x1314 <drawTask+0x20a>
					}
				}
				
			} else {
				objPrev = objIter;
			    objIter = objIter->next;
    1308:	f7 01       	movw	r30, r14
    130a:	93 8d       	ldd	r25, Z+27	; 0x1b
    130c:	84 8d       	ldd	r24, Z+28	; 0x1c
    130e:	37 01       	movw	r6, r14
    1310:	e9 2e       	mov	r14, r25
    1312:	f8 2e       	mov	r15, r24
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);

		objPrev = NULL;
		objIter = bullets;
		while (objIter != NULL) {
    1314:	e1 14       	cp	r14, r1
    1316:	f1 04       	cpc	r15, r1
    1318:	09 f0       	breq	.+2      	; 0x131c <drawTask+0x212>
    131a:	6a cf       	rjmp	.-300    	; 0x11f0 <drawTask+0xe6>
				objPrev = objIter;
			    objIter = objIter->next;
			}			
		}
		
		objIter = asteroids;
    131c:	00 91 81 02 	lds	r16, 0x0281
    1320:	10 91 82 02 	lds	r17, 0x0282
		while (objIter != NULL) {
    1324:	01 15       	cp	r16, r1
    1326:	11 05       	cpc	r17, r1
    1328:	21 f1       	breq	.+72     	; 0x1372 <drawTask+0x268>
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
    132a:	f8 01       	movw	r30, r16
    132c:	61 81       	ldd	r22, Z+1	; 0x01
    132e:	72 81       	ldd	r23, Z+2	; 0x02
    1330:	83 81       	ldd	r24, Z+3	; 0x03
    1332:	94 81       	ldd	r25, Z+4	; 0x04
    1334:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
    1338:	4b 01       	movw	r8, r22
    133a:	5c 01       	movw	r10, r24
    133c:	f8 01       	movw	r30, r16
    133e:	65 81       	ldd	r22, Z+5	; 0x05
    1340:	76 81       	ldd	r23, Z+6	; 0x06
    1342:	87 81       	ldd	r24, Z+7	; 0x07
    1344:	90 85       	ldd	r25, Z+8	; 0x08
    1346:	0e 94 93 1b 	call	0x3726	; 0x3726 <__fixunssfsi>
    134a:	6b 01       	movw	r12, r22
    134c:	7c 01       	movw	r14, r24
    134e:	f8 01       	movw	r30, r16
    1350:	80 81       	ld	r24, Z
    1352:	b4 01       	movw	r22, r8
    1354:	a6 01       	movw	r20, r12
    1356:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <vSpriteSetPosition>
			vSpriteSetRotation(objIter->handle, objIter->angle);
    135a:	f8 01       	movw	r30, r16
    135c:	65 89       	ldd	r22, Z+21	; 0x15
    135e:	76 89       	ldd	r23, Z+22	; 0x16
    1360:	80 81       	ld	r24, Z
    1362:	0e 94 06 0b 	call	0x160c	; 0x160c <vSpriteSetRotation>
			objIter = objIter->next;
    1366:	f8 01       	movw	r30, r16
    1368:	03 8d       	ldd	r16, Z+27	; 0x1b
    136a:	14 8d       	ldd	r17, Z+28	; 0x1c
			    objIter = objIter->next;
			}			
		}
		
		objIter = asteroids;
		while (objIter != NULL) {
    136c:	01 15       	cp	r16, r1
    136e:	11 05       	cpc	r17, r1
    1370:	e1 f6       	brne	.-72     	; 0x132a <drawTask+0x220>
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
			vSpriteSetRotation(objIter->handle, objIter->angle);
			objIter = objIter->next;
		}			
				
		if (uCollide(ship.handle, astGroup, &hit, 1) > 0 || asteroids == NULL) {
    1372:	f2 01       	movw	r30, r4
    1374:	80 81       	ld	r24, Z
    1376:	60 91 89 02 	lds	r22, 0x0289
    137a:	ae 01       	movw	r20, r28
    137c:	4f 5f       	subi	r20, 0xFF	; 255
    137e:	5f 4f       	sbci	r21, 0xFF	; 255
    1380:	21 e0       	ldi	r18, 0x01	; 1
    1382:	0e 94 88 0b 	call	0x1710	; 0x1710 <uCollide>
    1386:	88 23       	and	r24, r24
    1388:	39 f4       	brne	.+14     	; 0x1398 <drawTask+0x28e>
    138a:	80 91 81 02 	lds	r24, 0x0281
    138e:	90 91 82 02 	lds	r25, 0x0282
    1392:	00 97       	sbiw	r24, 0x00	; 0
    1394:	09 f0       	breq	.+2      	; 0x1398 <drawTask+0x28e>
    1396:	62 c0       	rjmp	.+196    	; 0x145c <drawTask+0x352>
			vTaskSuspend(updateTaskHandle);
    1398:	80 91 83 02 	lds	r24, 0x0283
    139c:	90 91 84 02 	lds	r25, 0x0284
    13a0:	0e 94 b2 18 	call	0x3164	; 0x3164 <vTaskSuspend>
			vTaskSuspend(bulletTaskHandle);
    13a4:	80 91 85 02 	lds	r24, 0x0285
    13a8:	90 91 86 02 	lds	r25, 0x0286
    13ac:	0e 94 b2 18 	call	0x3164	; 0x3164 <vTaskSuspend>
			vTaskSuspend(inputTaskHandle);
    13b0:	80 91 87 02 	lds	r24, 0x0287
    13b4:	90 91 88 02 	lds	r25, 0x0288
    13b8:	0e 94 b2 18 	call	0x3164	; 0x3164 <vTaskSuspend>
			
			if (asteroids == NULL)
    13bc:	80 91 81 02 	lds	r24, 0x0281
    13c0:	90 91 82 02 	lds	r25, 0x0282
    13c4:	00 97       	sbiw	r24, 0x00	; 0
    13c6:	c1 f4       	brne	.+48     	; 0x13f8 <drawTask+0x2ee>
			    handle = xSpriteCreate("win.png", SCREEN_W>>1, SCREEN_H>>1, 20, SCREEN_W>>1, SCREEN_H>>1, 100);
    13c8:	86 e2       	ldi	r24, 0x26	; 38
    13ca:	92 e0       	ldi	r25, 0x02	; 2
    13cc:	60 e9       	ldi	r22, 0x90	; 144
    13ce:	71 e0       	ldi	r23, 0x01	; 1
    13d0:	4c e2       	ldi	r20, 0x2C	; 44
    13d2:	51 e0       	ldi	r21, 0x01	; 1
    13d4:	24 e1       	ldi	r18, 0x14	; 20
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	00 e9       	ldi	r16, 0x90	; 144
    13da:	11 e0       	ldi	r17, 0x01	; 1
    13dc:	0f 2e       	mov	r0, r31
    13de:	fc e2       	ldi	r31, 0x2C	; 44
    13e0:	ef 2e       	mov	r14, r31
    13e2:	f1 e0       	ldi	r31, 0x01	; 1
    13e4:	ff 2e       	mov	r15, r31
    13e6:	f0 2d       	mov	r31, r0
    13e8:	0f 2e       	mov	r0, r31
    13ea:	f4 e6       	ldi	r31, 0x64	; 100
    13ec:	cf 2e       	mov	r12, r31
    13ee:	f0 2d       	mov	r31, r0
    13f0:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xSpriteCreate>
    13f4:	08 2f       	mov	r16, r24
    13f6:	17 c0       	rjmp	.+46     	; 0x1426 <drawTask+0x31c>
			else
			    handle = xSpriteCreate("lose.png", SCREEN_W>>1, SCREEN_H>>1, 0, SCREEN_W>>1, SCREEN_H>>1, 100);
    13f8:	8e e2       	ldi	r24, 0x2E	; 46
    13fa:	92 e0       	ldi	r25, 0x02	; 2
    13fc:	60 e9       	ldi	r22, 0x90	; 144
    13fe:	71 e0       	ldi	r23, 0x01	; 1
    1400:	4c e2       	ldi	r20, 0x2C	; 44
    1402:	51 e0       	ldi	r21, 0x01	; 1
    1404:	20 e0       	ldi	r18, 0x00	; 0
    1406:	30 e0       	ldi	r19, 0x00	; 0
    1408:	00 e9       	ldi	r16, 0x90	; 144
    140a:	11 e0       	ldi	r17, 0x01	; 1
    140c:	0f 2e       	mov	r0, r31
    140e:	fc e2       	ldi	r31, 0x2C	; 44
    1410:	ef 2e       	mov	r14, r31
    1412:	f1 e0       	ldi	r31, 0x01	; 1
    1414:	ff 2e       	mov	r15, r31
    1416:	f0 2d       	mov	r31, r0
    1418:	0f 2e       	mov	r0, r31
    141a:	f4 e6       	ldi	r31, 0x64	; 100
    141c:	cf 2e       	mov	r12, r31
    141e:	f0 2d       	mov	r31, r0
    1420:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xSpriteCreate>
    1424:	08 2f       	mov	r16, r24
				
			vTaskDelay(3000 / portTICK_RATE_MS);
    1426:	88 eb       	ldi	r24, 0xB8	; 184
    1428:	9b e0       	ldi	r25, 0x0B	; 11
    142a:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <vTaskDelay>
			vSpriteDelete(handle);
    142e:	80 2f       	mov	r24, r16
    1430:	0e 94 4e 0b 	call	0x169c	; 0x169c <vSpriteDelete>
			
			reset();
			init();
    1434:	0e 94 17 05 	call	0xa2e	; 0xa2e <init>
			
			vTaskResume(updateTaskHandle);
    1438:	80 91 83 02 	lds	r24, 0x0283
    143c:	90 91 84 02 	lds	r25, 0x0284
    1440:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <vTaskResume>
			vTaskResume(bulletTaskHandle);
    1444:	80 91 85 02 	lds	r24, 0x0285
    1448:	90 91 86 02 	lds	r25, 0x0286
    144c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <vTaskResume>
			vTaskResume(inputTaskHandle);
    1450:	80 91 87 02 	lds	r24, 0x0287
    1454:	90 91 88 02 	lds	r25, 0x0288
    1458:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <vTaskResume>
		}
		
		xSemaphoreGive(usartMutex);
    145c:	80 91 7f 02 	lds	r24, 0x027F
    1460:	90 91 80 02 	lds	r25, 0x0280
    1464:	60 e0       	ldi	r22, 0x00	; 0
    1466:	70 e0       	ldi	r23, 0x00	; 0
    1468:	40 e0       	ldi	r20, 0x00	; 0
    146a:	50 e0       	ldi	r21, 0x00	; 0
    146c:	20 e0       	ldi	r18, 0x00	; 0
    146e:	0e 94 33 12 	call	0x2466	; 0x2466 <xQueueGenericSend>
		
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
    1472:	8a e0       	ldi	r24, 0x0A	; 10
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <vTaskDelay>
	}
    147a:	84 ce       	rjmp	.-760    	; 0x1184 <drawTask+0x7a>
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
					if (astIter->handle == hit) {
						pos = astIter->pos;
    147c:	de 01       	movw	r26, r28
    147e:	12 96       	adiw	r26, 0x02	; 2
    1480:	f6 01       	movw	r30, r12
    1482:	31 96       	adiw	r30, 0x01	; 1
    1484:	88 e0       	ldi	r24, 0x08	; 8
    1486:	01 90       	ld	r0, Z+
    1488:	0d 92       	st	X+, r0
    148a:	81 50       	subi	r24, 0x01	; 1
    148c:	e1 f7       	brne	.-8      	; 0x1486 <drawTask+0x37c>
						size = astIter->size;
    148e:	f6 01       	movw	r30, r12
    1490:	b0 8c       	ldd	r11, Z+24	; 0x18
						vSpriteDelete(astIter->handle);
    1492:	80 81       	ld	r24, Z
    1494:	0e 94 4e 0b 	call	0x169c	; 0x169c <vSpriteDelete>
					bullets = objIter->next;
					vPortFree(objIter);
					objIter = bullets;
				}
				astPrev = NULL;
				astIter = asteroids;
    1498:	86 01       	movw	r16, r12
    149a:	1e cf       	rjmp	.-452    	; 0x12d8 <drawTask+0x1ce>

0000149c <vPrint>:
* Description: Prints the supplied string to the python terminal.  Useful for 
*  debugging.
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
    149c:	cf 93       	push	r28
    149e:	df 93       	push	r29
    14a0:	ec 01       	movw	r28, r24
	USART_Write(PYTHON_PRINT);
    14a2:	8b e0       	ldi	r24, 0x0B	; 11
    14a4:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	while (*s != '\0') {
    14a8:	88 81       	ld	r24, Y
    14aa:	88 23       	and	r24, r24
    14ac:	31 f0       	breq	.+12     	; 0x14ba <vPrint+0x1e>
* Description: Prints the supplied string to the python terminal.  Useful for 
*  debugging.
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
    14ae:	21 96       	adiw	r28, 0x01	; 1
	USART_Write(PYTHON_PRINT);
	while (*s != '\0') {
		USART_Write((uint8_t)*s++);
    14b0:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
	USART_Write(PYTHON_PRINT);
	while (*s != '\0') {
    14b4:	89 91       	ld	r24, Y+
    14b6:	88 23       	and	r24, r24
    14b8:	d9 f7       	brne	.-10     	; 0x14b0 <vPrint+0x14>
		USART_Write((uint8_t)*s++);
	}
	USART_Write(0x00);  /* string is null-terminated */
    14ba:	80 e0       	ldi	r24, 0x00	; 0
    14bc:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	08 95       	ret

000014c6 <vWindowCreate>:
*  context and opens a window for drawing with the specified dimensions.
*
* param width: Desired width of the window in pixels
* param height: Desired height of the window in pixels
*******************************************************************************/
void vWindowCreate(uint16_t width, uint16_t height) {
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	18 2f       	mov	r17, r24
    14d0:	09 2f       	mov	r16, r25
    14d2:	c6 2f       	mov	r28, r22
    14d4:	d7 2f       	mov	r29, r23
	USART_Init(BAUD_RATE, configCPU_CLOCK_HZ);
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	96 e9       	ldi	r25, 0x96	; 150
    14da:	40 e0       	ldi	r20, 0x00	; 0
    14dc:	54 e2       	ldi	r21, 0x24	; 36
    14de:	64 ef       	ldi	r22, 0xF4	; 244
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <USART_Init>

	USART_Read();
    14e6:	0e 94 b2 1a 	call	0x3564	; 0x3564 <USART_Read>
	USART_Write_Unprotected(0xFF);
    14ea:	8f ef       	ldi	r24, 0xFF	; 255
    14ec:	0e 94 aa 1a 	call	0x3554	; 0x3554 <USART_Write_Unprotected>
	
	USART_Write_Unprotected(CREATE_WINDOW);
    14f0:	8a e0       	ldi	r24, 0x0A	; 10
    14f2:	0e 94 aa 1a 	call	0x3554	; 0x3554 <USART_Write_Unprotected>
	USART_Write_Unprotected(width >> 8);
    14f6:	80 2f       	mov	r24, r16
    14f8:	0e 94 aa 1a 	call	0x3554	; 0x3554 <USART_Write_Unprotected>
	USART_Write_Unprotected(width & 0x00FF);
    14fc:	81 2f       	mov	r24, r17
    14fe:	0e 94 aa 1a 	call	0x3554	; 0x3554 <USART_Write_Unprotected>
	USART_Write_Unprotected(height >> 8);
    1502:	8d 2f       	mov	r24, r29
    1504:	0e 94 aa 1a 	call	0x3554	; 0x3554 <USART_Write_Unprotected>
	USART_Write_Unprotected(height & 0x00FF);
    1508:	8c 2f       	mov	r24, r28
    150a:	0e 94 aa 1a 	call	0x3554	; 0x3554 <USART_Write_Unprotected>
}
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	08 95       	ret

00001518 <xSpriteCreate>:
* param height: Initial, unrotated height of the sprite in pixels
* param depth: Initial draw depth of the sprite (larger numbers are in front)
* return: A valid handle to the new sprite on success; ERROR_HANDLE otherwise
*******************************************************************************/
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
    1518:	7f 92       	push	r7
    151a:	8f 92       	push	r8
    151c:	9f 92       	push	r9
    151e:	af 92       	push	r10
    1520:	bf 92       	push	r11
    1522:	cf 92       	push	r12
    1524:	df 92       	push	r13
    1526:	ef 92       	push	r14
    1528:	ff 92       	push	r15
    152a:	0f 93       	push	r16
    152c:	1f 93       	push	r17
    152e:	cf 93       	push	r28
    1530:	df 93       	push	r29
    1532:	ec 01       	movw	r28, r24
    1534:	b6 2e       	mov	r11, r22
    1536:	d7 2e       	mov	r13, r23
    1538:	94 2e       	mov	r9, r20
    153a:	a5 2e       	mov	r10, r21
    153c:	72 2e       	mov	r7, r18
    153e:	83 2e       	mov	r8, r19
	
	USART_Write(CREATE_SPRITE);
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>

	while (*filename != '\0') {
    1546:	88 81       	ld	r24, Y
    1548:	88 23       	and	r24, r24
    154a:	31 f0       	breq	.+12     	; 0x1558 <xSpriteCreate+0x40>
* param width: Initial, unrotated width of the sprite in pixels
* param height: Initial, unrotated height of the sprite in pixels
* param depth: Initial draw depth of the sprite (larger numbers are in front)
* return: A valid handle to the new sprite on success; ERROR_HANDLE otherwise
*******************************************************************************/
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
    154c:	21 96       	adiw	r28, 0x01	; 1
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
	
	USART_Write(CREATE_SPRITE);

	while (*filename != '\0') {
		USART_Write((uint8_t)*filename++);
    154e:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
	
	USART_Write(CREATE_SPRITE);

	while (*filename != '\0') {
    1552:	89 91       	ld	r24, Y+
    1554:	88 23       	and	r24, r24
    1556:	d9 f7       	brne	.-10     	; 0x154e <xSpriteCreate+0x36>
		USART_Write((uint8_t)*filename++);
	}
	USART_Write(0x00);  /* Filename is null-terminated */
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>

	USART_Write(xPos >> 8);
    155e:	8d 2d       	mov	r24, r13
    1560:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(xPos & 0x00FF);
    1564:	8b 2d       	mov	r24, r11
    1566:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(yPos >> 8);
    156a:	8a 2d       	mov	r24, r10
    156c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(yPos & 0x00FF);
    1570:	89 2d       	mov	r24, r9
    1572:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(rAngle >> 8);
    1576:	88 2d       	mov	r24, r8
    1578:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(rAngle & 0x00FF);
    157c:	87 2d       	mov	r24, r7
    157e:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(width >> 8);
    1582:	81 2f       	mov	r24, r17
    1584:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(width & 0x00FF);
    1588:	80 2f       	mov	r24, r16
    158a:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(height >> 8);
    158e:	8f 2d       	mov	r24, r15
    1590:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(height & 0x00FF);
    1594:	8e 2d       	mov	r24, r14
    1596:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(depth);
    159a:	8c 2d       	mov	r24, r12
    159c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	
	PORTA = 0xAA;
    15a0:	8a ea       	ldi	r24, 0xAA	; 170
    15a2:	82 b9       	out	0x02, r24	; 2
	xSpriteHandle result = (xSpriteHandle)USART_Read();
    15a4:	0e 94 b2 1a 	call	0x3564	; 0x3564 <USART_Read>
	PORTA = 0xFF;
    15a8:	9f ef       	ldi	r25, 0xFF	; 255
    15aa:	92 b9       	out	0x02, r25	; 2
	
	return result;
}
    15ac:	df 91       	pop	r29
    15ae:	cf 91       	pop	r28
    15b0:	1f 91       	pop	r17
    15b2:	0f 91       	pop	r16
    15b4:	ff 90       	pop	r15
    15b6:	ef 90       	pop	r14
    15b8:	df 90       	pop	r13
    15ba:	cf 90       	pop	r12
    15bc:	bf 90       	pop	r11
    15be:	af 90       	pop	r10
    15c0:	9f 90       	pop	r9
    15c2:	8f 90       	pop	r8
    15c4:	7f 90       	pop	r7
    15c6:	08 95       	ret

000015c8 <vSpriteSetPosition>:
*
* param sprite: The handle to the sprite
* param x: New x-position of the sprite's center in window coordinates
* param y: New y-position of the sprite's center in window coordinates
*******************************************************************************/
void vSpriteSetPosition(xSpriteHandle sprite, uint16_t x, uint16_t y) {
    15c8:	ff 92       	push	r15
    15ca:	0f 93       	push	r16
    15cc:	1f 93       	push	r17
    15ce:	cf 93       	push	r28
    15d0:	df 93       	push	r29
    15d2:	f8 2e       	mov	r15, r24
    15d4:	16 2f       	mov	r17, r22
    15d6:	07 2f       	mov	r16, r23
    15d8:	c4 2f       	mov	r28, r20
    15da:	d5 2f       	mov	r29, r21
	USART_Write(SET_POS);
    15dc:	82 e0       	ldi	r24, 0x02	; 2
    15de:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    15e2:	8f 2d       	mov	r24, r15
    15e4:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(x >> 8);
    15e8:	80 2f       	mov	r24, r16
    15ea:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(x & 0x00FF);
    15ee:	81 2f       	mov	r24, r17
    15f0:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(y >> 8);
    15f4:	8d 2f       	mov	r24, r29
    15f6:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(y & 0x00FF);
    15fa:	8c 2f       	mov	r24, r28
    15fc:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    1600:	df 91       	pop	r29
    1602:	cf 91       	pop	r28
    1604:	1f 91       	pop	r17
    1606:	0f 91       	pop	r16
    1608:	ff 90       	pop	r15
    160a:	08 95       	ret

0000160c <vSpriteSetRotation>:
* Description: Sets the given sprite's rotation.
*
* param sprite: The handle to the sprite
* param angle: Angle in degrees to rotate the sprite CCW about its center
*******************************************************************************/
void vSpriteSetRotation(xSpriteHandle sprite, uint16_t angle) {
    160c:	1f 93       	push	r17
    160e:	cf 93       	push	r28
    1610:	df 93       	push	r29
    1612:	18 2f       	mov	r17, r24
    1614:	c6 2f       	mov	r28, r22
    1616:	d7 2f       	mov	r29, r23
	USART_Write(SET_ROT);
    1618:	83 e0       	ldi	r24, 0x03	; 3
    161a:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    161e:	81 2f       	mov	r24, r17
    1620:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(angle >> 8);
    1624:	8d 2f       	mov	r24, r29
    1626:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(angle & 0x00FF);
    162a:	8c 2f       	mov	r24, r28
    162c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    1630:	df 91       	pop	r29
    1632:	cf 91       	pop	r28
    1634:	1f 91       	pop	r17
    1636:	08 95       	ret

00001638 <vSpriteSetSize>:
*
* param sprite: The handle to the sprite
* param width: New width of the sprite in pixels before applying rotation
* param height: New height of the sprite in pixels before applying rotation
*******************************************************************************/
void vSpriteSetSize(xSpriteHandle sprite, uint16_t width, uint16_t height) {
    1638:	ff 92       	push	r15
    163a:	0f 93       	push	r16
    163c:	1f 93       	push	r17
    163e:	cf 93       	push	r28
    1640:	df 93       	push	r29
    1642:	f8 2e       	mov	r15, r24
    1644:	16 2f       	mov	r17, r22
    1646:	07 2f       	mov	r16, r23
    1648:	c4 2f       	mov	r28, r20
    164a:	d5 2f       	mov	r29, r21
	USART_Write(SET_SIZE);
    164c:	8d e0       	ldi	r24, 0x0D	; 13
    164e:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    1652:	8f 2d       	mov	r24, r15
    1654:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(width >> 8);
    1658:	80 2f       	mov	r24, r16
    165a:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(width & 0x00FF);
    165e:	81 2f       	mov	r24, r17
    1660:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(height >> 8);
    1664:	8d 2f       	mov	r24, r29
    1666:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(height & 0x00FF);
    166a:	8c 2f       	mov	r24, r28
    166c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    1670:	df 91       	pop	r29
    1672:	cf 91       	pop	r28
    1674:	1f 91       	pop	r17
    1676:	0f 91       	pop	r16
    1678:	ff 90       	pop	r15
    167a:	08 95       	ret

0000167c <vSpriteSetDepth>:
* Description: Sets the draw depth of the given sprite.
*
* param sprite: The handle to the sprite
* param depth: New draw depth (larger depths are in front of smaller depths)
*******************************************************************************/
void vSpriteSetDepth(xSpriteHandle sprite, uint8_t depth) {
    167c:	cf 93       	push	r28
    167e:	df 93       	push	r29
    1680:	d8 2f       	mov	r29, r24
    1682:	c6 2f       	mov	r28, r22
	USART_Write(SET_ORDER);
    1684:	8c e0       	ldi	r24, 0x0C	; 12
    1686:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    168a:	8d 2f       	mov	r24, r29
    168c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(depth);
    1690:	8c 2f       	mov	r24, r28
    1692:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	08 95       	ret

0000169c <vSpriteDelete>:
* Description: Removes the sprite from the window and invalidates the given
*  handle.
*
* param sprite: The handle to the sprite to be deleted
*******************************************************************************/
void vSpriteDelete(xSpriteHandle sprite) {
    169c:	cf 93       	push	r28
    169e:	c8 2f       	mov	r28, r24
	USART_Write(DELETE_SPRITE);
    16a0:	84 e0       	ldi	r24, 0x04	; 4
    16a2:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    16a6:	8c 2f       	mov	r24, r28
    16a8:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    16ac:	cf 91       	pop	r28
    16ae:	08 95       	ret

000016b0 <xGroupCreate>:
*  collision tests (see bCollide).
*
* return: A valid handle to the new group on success; ERROR_HANDLE otherwise
*******************************************************************************/
xGroupHandle xGroupCreate(void) {
	USART_Write(CREATE_GROUP);
    16b0:	85 e0       	ldi	r24, 0x05	; 5
    16b2:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	xGroupHandle result = (xGroupHandle)USART_Read();
    16b6:	0e 94 b2 1a 	call	0x3564	; 0x3564 <USART_Read>
	
	return result;
}
    16ba:	08 95       	ret

000016bc <vGroupAddSprite>:
* Description: Adds the given sprite to the given group.
*
* param group: The handle to the group to add the sprite to
* param sprite: The handle to the sprite to add to the group
*******************************************************************************/
void vGroupAddSprite(xGroupHandle group, xSpriteHandle sprite) {
    16bc:	cf 93       	push	r28
    16be:	df 93       	push	r29
    16c0:	d8 2f       	mov	r29, r24
    16c2:	c6 2f       	mov	r28, r22
	USART_Write(ADD_TO_GROUP);
    16c4:	86 e0       	ldi	r24, 0x06	; 6
    16c6:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(group);
    16ca:	8d 2f       	mov	r24, r29
    16cc:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    16d0:	8c 2f       	mov	r24, r28
    16d2:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	08 95       	ret

000016dc <vGroupRemoveSprite>:
* Description: Removes the given sprite from the given group.
*
* param group: The handle to the group to remove the sprite from
* param sprite: The handle to the sprite to remove from the group
*******************************************************************************/
void vGroupRemoveSprite(xGroupHandle group, xSpriteHandle sprite) {
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	d8 2f       	mov	r29, r24
    16e2:	c6 2f       	mov	r28, r22
	USART_Write(REMOVE_FROM_GROUP);
    16e4:	87 e0       	ldi	r24, 0x07	; 7
    16e6:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(group);
    16ea:	8d 2f       	mov	r24, r29
    16ec:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    16f0:	8c 2f       	mov	r24, r28
    16f2:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    16f6:	df 91       	pop	r29
    16f8:	cf 91       	pop	r28
    16fa:	08 95       	ret

000016fc <vGroupDelete>:
* Description: Invalidates the given group handle and removes all the sprites
*  it contains from it.
*
* param group: The handle to the group to be deleted
*******************************************************************************/
void vGroupDelete(xGroupHandle group) {
    16fc:	cf 93       	push	r28
    16fe:	c8 2f       	mov	r28, r24
	USART_Write(DELETE_GROUP);
    1700:	88 e0       	ldi	r24, 0x08	; 8
    1702:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(group);
    1706:	8c 2f       	mov	r24, r28
    1708:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
}
    170c:	cf 91       	pop	r28
    170e:	08 95       	ret

00001710 <uCollide>:
*  sprite collided with
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
    1710:	ff 92       	push	r15
    1712:	0f 93       	push	r16
    1714:	1f 93       	push	r17
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	d8 2f       	mov	r29, r24
    171c:	c6 2f       	mov	r28, r22
    171e:	04 2f       	mov	r16, r20
    1720:	f5 2e       	mov	r15, r21
    1722:	12 2f       	mov	r17, r18
	uint8_t hitCount = 0;
	
	USART_Write(COLLIDE);
    1724:	89 e0       	ldi	r24, 0x09	; 9
    1726:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(sprite);
    172a:	8d 2f       	mov	r24, r29
    172c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	USART_Write(group);
    1730:	8c 2f       	mov	r24, r28
    1732:	0e 94 a2 1a 	call	0x3544	; 0x3544 <USART_Write>
	
	while (hitCount < hitsSize) {
    1736:	11 23       	and	r17, r17
    1738:	61 f0       	breq	.+24     	; 0x1752 <uCollide+0x42>
    173a:	c0 2f       	mov	r28, r16
    173c:	df 2d       	mov	r29, r15
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
	uint8_t hitCount = 0;
    173e:	00 e0       	ldi	r16, 0x00	; 0
	USART_Write(COLLIDE);
	USART_Write(sprite);
	USART_Write(group);
	
	while (hitCount < hitsSize) {
		hits[hitCount] = USART_Read();
    1740:	0e 94 b2 1a 	call	0x3564	; 0x3564 <USART_Read>
    1744:	89 93       	st	Y+, r24
		if (hits[hitCount] == ERROR_HANDLE) {
    1746:	8f 3f       	cpi	r24, 0xFF	; 255
    1748:	59 f0       	breq	.+22     	; 0x1760 <uCollide+0x50>
			return hitCount;
		}
		hitCount++;
    174a:	0f 5f       	subi	r16, 0xFF	; 255
	
	USART_Write(COLLIDE);
	USART_Write(sprite);
	USART_Write(group);
	
	while (hitCount < hitsSize) {
    174c:	01 17       	cp	r16, r17
    174e:	c1 f7       	brne	.-16     	; 0x1740 <uCollide+0x30>
    1750:	03 c0       	rjmp	.+6      	; 0x1758 <uCollide+0x48>
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
	uint8_t hitCount = 0;
    1752:	00 e0       	ldi	r16, 0x00	; 0
    1754:	01 c0       	rjmp	.+2      	; 0x1758 <uCollide+0x48>
		}
		hitCount++;
	}
	
	while (USART_Read() != ERROR_HANDLE)
	    hitCount++;
    1756:	0f 5f       	subi	r16, 0xFF	; 255
			return hitCount;
		}
		hitCount++;
	}
	
	while (USART_Read() != ERROR_HANDLE)
    1758:	0e 94 b2 1a 	call	0x3564	; 0x3564 <USART_Read>
    175c:	8f 3f       	cpi	r24, 0xFF	; 255
    175e:	d9 f7       	brne	.-10     	; 0x1756 <uCollide+0x46>
	    hitCount++;
		
	return hitCount;
    1760:	80 2f       	mov	r24, r16
    1762:	df 91       	pop	r29
    1764:	cf 91       	pop	r28
    1766:	1f 91       	pop	r17
    1768:	0f 91       	pop	r16
    176a:	ff 90       	pop	r15
    176c:	08 95       	ret

0000176e <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    176e:	0f 93       	push	r16
    1770:	1f 93       	push	r17
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
    1776:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1778:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    177c:	80 91 8b 02 	lds	r24, 0x028B
    1780:	88 23       	and	r24, r24
    1782:	f9 f4       	brne	.+62     	; 0x17c2 <pvPortMalloc+0x54>
		{
			prvHeapInit();
    1784:	80 e9       	ldi	r24, 0x90	; 144
    1786:	92 e0       	ldi	r25, 0x02	; 2
    1788:	90 93 8d 02 	sts	0x028D, r25
    178c:	80 93 8c 02 	sts	0x028C, r24
    1790:	10 92 8f 02 	sts	0x028F, r1
    1794:	10 92 8e 02 	sts	0x028E, r1
    1798:	80 e0       	ldi	r24, 0x00	; 0
    179a:	98 e1       	ldi	r25, 0x18	; 24
    179c:	90 93 93 1a 	sts	0x1A93, r25
    17a0:	80 93 92 1a 	sts	0x1A92, r24
    17a4:	e2 e9       	ldi	r30, 0x92	; 146
    17a6:	fa e1       	ldi	r31, 0x1A	; 26
    17a8:	12 92       	st	-Z, r1
    17aa:	12 92       	st	-Z, r1
    17ac:	90 93 93 02 	sts	0x0293, r25
    17b0:	80 93 92 02 	sts	0x0292, r24
    17b4:	f0 93 91 02 	sts	0x0291, r31
    17b8:	e0 93 90 02 	sts	0x0290, r30
			xHeapHasBeenInitialised = pdTRUE;
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	80 93 8b 02 	sts	0x028B, r24
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    17c2:	20 97       	sbiw	r28, 0x00	; 0
    17c4:	09 f4       	brne	.+2      	; 0x17c8 <pvPortMalloc+0x5a>
    17c6:	62 c0       	rjmp	.+196    	; 0x188c <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    17c8:	9e 01       	movw	r18, r28
    17ca:	2b 5f       	subi	r18, 0xFB	; 251
    17cc:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    17ce:	24 96       	adiw	r28, 0x04	; 4
    17d0:	87 e1       	ldi	r24, 0x17	; 23
    17d2:	cf 3f       	cpi	r28, 0xFF	; 255
    17d4:	d8 07       	cpc	r29, r24
    17d6:	08 f0       	brcs	.+2      	; 0x17da <pvPortMalloc+0x6c>
    17d8:	5c c0       	rjmp	.+184    	; 0x1892 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    17da:	e0 91 8c 02 	lds	r30, 0x028C
    17de:	f0 91 8d 02 	lds	r31, 0x028D

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    17e2:	ac e8       	ldi	r26, 0x8C	; 140
    17e4:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17e6:	02 c0       	rjmp	.+4      	; 0x17ec <pvPortMalloc+0x7e>
    17e8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    17ea:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17ec:	82 81       	ldd	r24, Z+2	; 0x02
    17ee:	93 81       	ldd	r25, Z+3	; 0x03
    17f0:	82 17       	cp	r24, r18
    17f2:	93 07       	cpc	r25, r19
    17f4:	20 f4       	brcc	.+8      	; 0x17fe <pvPortMalloc+0x90>
    17f6:	80 81       	ld	r24, Z
    17f8:	91 81       	ldd	r25, Z+1	; 0x01
    17fa:	00 97       	sbiw	r24, 0x00	; 0
    17fc:	a9 f7       	brne	.-22     	; 0x17e8 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    17fe:	ca e1       	ldi	r28, 0x1A	; 26
    1800:	e0 39       	cpi	r30, 0x90	; 144
    1802:	fc 07       	cpc	r31, r28
    1804:	09 f4       	brne	.+2      	; 0x1808 <pvPortMalloc+0x9a>
    1806:	48 c0       	rjmp	.+144    	; 0x1898 <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1808:	8d 91       	ld	r24, X+
    180a:	9c 91       	ld	r25, X
    180c:	11 97       	sbiw	r26, 0x01	; 1
    180e:	8c 01       	movw	r16, r24
    1810:	0b 5f       	subi	r16, 0xFB	; 251
    1812:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1814:	80 81       	ld	r24, Z
    1816:	91 81       	ldd	r25, Z+1	; 0x01
    1818:	11 96       	adiw	r26, 0x01	; 1
    181a:	9c 93       	st	X, r25
    181c:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    181e:	82 81       	ldd	r24, Z+2	; 0x02
    1820:	93 81       	ldd	r25, Z+3	; 0x03
    1822:	82 1b       	sub	r24, r18
    1824:	93 0b       	sbc	r25, r19
    1826:	8b 30       	cpi	r24, 0x0B	; 11
    1828:	91 05       	cpc	r25, r1
    182a:	18 f1       	brcs	.+70     	; 0x1872 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    182c:	af 01       	movw	r20, r30
    182e:	42 0f       	add	r20, r18
    1830:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1832:	da 01       	movw	r26, r20
    1834:	13 96       	adiw	r26, 0x03	; 3
    1836:	9c 93       	st	X, r25
    1838:	8e 93       	st	-X, r24
    183a:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
    183c:	33 83       	std	Z+3, r19	; 0x03
    183e:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1840:	12 96       	adiw	r26, 0x02	; 2
    1842:	2d 91       	ld	r18, X+
    1844:	3c 91       	ld	r19, X
    1846:	13 97       	sbiw	r26, 0x03	; 3
    1848:	6c e8       	ldi	r22, 0x8C	; 140
    184a:	72 e0       	ldi	r23, 0x02	; 2
    184c:	01 c0       	rjmp	.+2      	; 0x1850 <pvPortMalloc+0xe2>
    184e:	bd 01       	movw	r22, r26
    1850:	eb 01       	movw	r28, r22
    1852:	a8 81       	ld	r26, Y
    1854:	b9 81       	ldd	r27, Y+1	; 0x01
    1856:	12 96       	adiw	r26, 0x02	; 2
    1858:	8d 91       	ld	r24, X+
    185a:	9c 91       	ld	r25, X
    185c:	13 97       	sbiw	r26, 0x03	; 3
    185e:	82 17       	cp	r24, r18
    1860:	93 07       	cpc	r25, r19
    1862:	a8 f3       	brcs	.-22     	; 0x184e <pvPortMalloc+0xe0>
    1864:	ea 01       	movw	r28, r20
    1866:	b9 83       	std	Y+1, r27	; 0x01
    1868:	a8 83       	st	Y, r26
    186a:	db 01       	movw	r26, r22
    186c:	11 96       	adiw	r26, 0x01	; 1
    186e:	5c 93       	st	X, r21
    1870:	4e 93       	st	-X, r20
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1872:	80 91 52 02 	lds	r24, 0x0252
    1876:	90 91 53 02 	lds	r25, 0x0253
    187a:	22 81       	ldd	r18, Z+2	; 0x02
    187c:	33 81       	ldd	r19, Z+3	; 0x03
    187e:	82 1b       	sub	r24, r18
    1880:	93 0b       	sbc	r25, r19
    1882:	90 93 53 02 	sts	0x0253, r25
    1886:	80 93 52 02 	sts	0x0252, r24
    188a:	08 c0       	rjmp	.+16     	; 0x189c <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    188c:	00 e0       	ldi	r16, 0x00	; 0
    188e:	10 e0       	ldi	r17, 0x00	; 0
    1890:	05 c0       	rjmp	.+10     	; 0x189c <pvPortMalloc+0x12e>
    1892:	00 e0       	ldi	r16, 0x00	; 0
    1894:	10 e0       	ldi	r17, 0x00	; 0
    1896:	02 c0       	rjmp	.+4      	; 0x189c <pvPortMalloc+0x12e>
    1898:	00 e0       	ldi	r16, 0x00	; 0
    189a:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    189c:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    18a0:	80 2f       	mov	r24, r16
    18a2:	91 2f       	mov	r25, r17
    18a4:	df 91       	pop	r29
    18a6:	cf 91       	pop	r28
    18a8:	1f 91       	pop	r17
    18aa:	0f 91       	pop	r16
    18ac:	08 95       	ret

000018ae <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    18ae:	0f 93       	push	r16
    18b0:	1f 93       	push	r17
    18b2:	cf 93       	push	r28
    18b4:	df 93       	push	r29
    18b6:	ec 01       	movw	r28, r24
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    18b8:	00 97       	sbiw	r24, 0x00	; 0
    18ba:	39 f1       	breq	.+78     	; 0x190a <vPortFree+0x5c>
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
    18bc:	8c 01       	movw	r16, r24
    18be:	05 50       	subi	r16, 0x05	; 5
    18c0:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
    18c2:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    18c6:	f8 01       	movw	r30, r16
    18c8:	22 81       	ldd	r18, Z+2	; 0x02
    18ca:	33 81       	ldd	r19, Z+3	; 0x03
    18cc:	ac e8       	ldi	r26, 0x8C	; 140
    18ce:	b2 e0       	ldi	r27, 0x02	; 2
    18d0:	01 c0       	rjmp	.+2      	; 0x18d4 <vPortFree+0x26>
    18d2:	df 01       	movw	r26, r30
    18d4:	ed 91       	ld	r30, X+
    18d6:	fc 91       	ld	r31, X
    18d8:	11 97       	sbiw	r26, 0x01	; 1
    18da:	82 81       	ldd	r24, Z+2	; 0x02
    18dc:	93 81       	ldd	r25, Z+3	; 0x03
    18de:	82 17       	cp	r24, r18
    18e0:	93 07       	cpc	r25, r19
    18e2:	b8 f3       	brcs	.-18     	; 0x18d2 <vPortFree+0x24>
    18e4:	25 97       	sbiw	r28, 0x05	; 5
    18e6:	f9 83       	std	Y+1, r31	; 0x01
    18e8:	e8 83       	st	Y, r30
    18ea:	0d 93       	st	X+, r16
    18ec:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    18ee:	80 91 52 02 	lds	r24, 0x0252
    18f2:	90 91 53 02 	lds	r25, 0x0253
    18f6:	2a 81       	ldd	r18, Y+2	; 0x02
    18f8:	3b 81       	ldd	r19, Y+3	; 0x03
    18fa:	82 0f       	add	r24, r18
    18fc:	93 1f       	adc	r25, r19
    18fe:	90 93 53 02 	sts	0x0253, r25
    1902:	80 93 52 02 	sts	0x0252, r24
		}
		xTaskResumeAll();
    1906:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
	}
}
    190a:	df 91       	pop	r29
    190c:	cf 91       	pop	r28
    190e:	1f 91       	pop	r17
    1910:	0f 91       	pop	r16
    1912:	08 95       	ret

00001914 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1914:	80 91 52 02 	lds	r24, 0x0252
    1918:	90 91 53 02 	lds	r25, 0x0253
    191c:	08 95       	ret

0000191e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
    191e:	08 95       	ret

00001920 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1920:	af 92       	push	r10
    1922:	bf 92       	push	r11
    1924:	cf 92       	push	r12
    1926:	df 92       	push	r13
    1928:	ef 92       	push	r14
    192a:	ff 92       	push	r15
    192c:	0f 93       	push	r16
    192e:	1f 93       	push	r17
    1930:	cf 93       	push	r28
    1932:	df 93       	push	r29
    1934:	6c 01       	movw	r12, r24
    1936:	e6 2e       	mov	r14, r22
    1938:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    193a:	8a e1       	ldi	r24, 0x1A	; 26
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
    1942:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
    1944:	00 97       	sbiw	r24, 0x00	; 0
    1946:	09 f4       	brne	.+2      	; 0x194a <xCoRoutineCreate+0x2a>
    1948:	62 c0       	rjmp	.+196    	; 0x1a0e <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    194a:	80 91 94 1a 	lds	r24, 0x1A94
    194e:	90 91 95 1a 	lds	r25, 0x1A95
    1952:	00 97       	sbiw	r24, 0x00	; 0
    1954:	39 f5       	brne	.+78     	; 0x19a4 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1956:	10 93 95 1a 	sts	0x1A95, r17
    195a:	00 93 94 1a 	sts	0x1A94, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    195e:	c7 e9       	ldi	r28, 0x97	; 151
    1960:	da e1       	ldi	r29, 0x1A	; 26
    1962:	ce 01       	movw	r24, r28
    1964:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
    1968:	ce 01       	movw	r24, r28
    196a:	09 96       	adiw	r24, 0x09	; 9
    196c:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1970:	c9 ea       	ldi	r28, 0xA9	; 169
    1972:	da e1       	ldi	r29, 0x1A	; 26
    1974:	ce 01       	movw	r24, r28
    1976:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    197a:	0f 2e       	mov	r0, r31
    197c:	f2 eb       	ldi	r31, 0xB2	; 178
    197e:	af 2e       	mov	r10, r31
    1980:	fa e1       	ldi	r31, 0x1A	; 26
    1982:	bf 2e       	mov	r11, r31
    1984:	f0 2d       	mov	r31, r0
    1986:	c5 01       	movw	r24, r10
    1988:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    198c:	8b eb       	ldi	r24, 0xBB	; 187
    198e:	9a e1       	ldi	r25, 0x1A	; 26
    1990:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1994:	d0 93 c5 1a 	sts	0x1AC5, r29
    1998:	c0 93 c4 1a 	sts	0x1AC4, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    199c:	b0 92 c7 1a 	sts	0x1AC7, r11
    19a0:	a0 92 c6 1a 	sts	0x1AC6, r10
    19a4:	ce 2d       	mov	r28, r14
    19a6:	e1 10       	cpse	r14, r1
    19a8:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    19aa:	f8 01       	movw	r30, r16
    19ac:	11 8e       	std	Z+25, r1	; 0x19
    19ae:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    19b0:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    19b2:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    19b4:	c1 92       	st	Z+, r12
    19b6:	d1 92       	st	Z+, r13
    19b8:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    19ba:	cf 01       	movw	r24, r30
    19bc:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    19c0:	c8 01       	movw	r24, r16
    19c2:	0c 96       	adiw	r24, 0x0c	; 12
    19c4:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    19c8:	f8 01       	movw	r30, r16
    19ca:	11 87       	std	Z+9, r17	; 0x09
    19cc:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    19ce:	13 8b       	std	Z+19, r17	; 0x13
    19d0:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    19d2:	84 e0       	ldi	r24, 0x04	; 4
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	8c 1b       	sub	r24, r28
    19d8:	91 09       	sbc	r25, r1
    19da:	95 87       	std	Z+13, r25	; 0x0d
    19dc:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    19de:	86 89       	ldd	r24, Z+22	; 0x16
    19e0:	90 91 96 1a 	lds	r25, 0x1A96
    19e4:	98 17       	cp	r25, r24
    19e6:	10 f4       	brcc	.+4      	; 0x19ec <xCoRoutineCreate+0xcc>
    19e8:	80 93 96 1a 	sts	0x1A96, r24
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	9c 01       	movw	r18, r24
    19f0:	22 0f       	add	r18, r18
    19f2:	33 1f       	adc	r19, r19
    19f4:	22 0f       	add	r18, r18
    19f6:	33 1f       	adc	r19, r19
    19f8:	22 0f       	add	r18, r18
    19fa:	33 1f       	adc	r19, r19
    19fc:	82 0f       	add	r24, r18
    19fe:	93 1f       	adc	r25, r19
    1a00:	89 56       	subi	r24, 0x69	; 105
    1a02:	95 4e       	sbci	r25, 0xE5	; 229
    1a04:	b7 01       	movw	r22, r14
    1a06:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>

		xReturn = pdPASS;
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	01 c0       	rjmp	.+2      	; 0x1a10 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a0e:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	1f 91       	pop	r17
    1a16:	0f 91       	pop	r16
    1a18:	ff 90       	pop	r15
    1a1a:	ef 90       	pop	r14
    1a1c:	df 90       	pop	r13
    1a1e:	cf 90       	pop	r12
    1a20:	bf 90       	pop	r11
    1a22:	af 90       	pop	r10
    1a24:	08 95       	ret

00001a26 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1a26:	0f 93       	push	r16
    1a28:	1f 93       	push	r17
    1a2a:	cf 93       	push	r28
    1a2c:	df 93       	push	r29
    1a2e:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1a30:	c0 91 c8 1a 	lds	r28, 0x1AC8
    1a34:	d0 91 c9 1a 	lds	r29, 0x1AC9
    1a38:	c8 0f       	add	r28, r24
    1a3a:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1a3c:	80 91 94 1a 	lds	r24, 0x1A94
    1a40:	90 91 95 1a 	lds	r25, 0x1A95
    1a44:	02 96       	adiw	r24, 0x02	; 2
    1a46:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1a4a:	e0 91 94 1a 	lds	r30, 0x1A94
    1a4e:	f0 91 95 1a 	lds	r31, 0x1A95
    1a52:	d3 83       	std	Z+3, r29	; 0x03
    1a54:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1a56:	80 91 c8 1a 	lds	r24, 0x1AC8
    1a5a:	90 91 c9 1a 	lds	r25, 0x1AC9
    1a5e:	c8 17       	cp	r28, r24
    1a60:	d9 07       	cpc	r29, r25
    1a62:	50 f4       	brcc	.+20     	; 0x1a78 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1a64:	bf 01       	movw	r22, r30
    1a66:	6e 5f       	subi	r22, 0xFE	; 254
    1a68:	7f 4f       	sbci	r23, 0xFF	; 255
    1a6a:	80 91 c6 1a 	lds	r24, 0x1AC6
    1a6e:	90 91 c7 1a 	lds	r25, 0x1AC7
    1a72:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vListInsert>
    1a76:	09 c0       	rjmp	.+18     	; 0x1a8a <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1a78:	bf 01       	movw	r22, r30
    1a7a:	6e 5f       	subi	r22, 0xFE	; 254
    1a7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a7e:	80 91 c4 1a 	lds	r24, 0x1AC4
    1a82:	90 91 c5 1a 	lds	r25, 0x1AC5
    1a86:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vListInsert>
	}

	if( pxEventList )
    1a8a:	01 15       	cp	r16, r1
    1a8c:	11 05       	cpc	r17, r1
    1a8e:	49 f0       	breq	.+18     	; 0x1aa2 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1a90:	60 91 94 1a 	lds	r22, 0x1A94
    1a94:	70 91 95 1a 	lds	r23, 0x1A95
    1a98:	64 5f       	subi	r22, 0xF4	; 244
    1a9a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a9c:	c8 01       	movw	r24, r16
    1a9e:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vListInsert>
	}
}
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	1f 91       	pop	r17
    1aa8:	0f 91       	pop	r16
    1aaa:	08 95       	ret

00001aac <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1aac:	cf 92       	push	r12
    1aae:	df 92       	push	r13
    1ab0:	ef 92       	push	r14
    1ab2:	ff 92       	push	r15
    1ab4:	0f 93       	push	r16
    1ab6:	1f 93       	push	r17
    1ab8:	cf 93       	push	r28
    1aba:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1abc:	80 91 bb 1a 	lds	r24, 0x1ABB
    1ac0:	88 23       	and	r24, r24
    1ac2:	b9 f1       	breq	.+110    	; 0x1b32 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1ac4:	0f 2e       	mov	r0, r31
    1ac6:	f0 ec       	ldi	r31, 0xC0	; 192
    1ac8:	ef 2e       	mov	r14, r31
    1aca:	fa e1       	ldi	r31, 0x1A	; 26
    1acc:	ff 2e       	mov	r15, r31
    1ace:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1ad0:	0f 2e       	mov	r0, r31
    1ad2:	fb eb       	ldi	r31, 0xBB	; 187
    1ad4:	cf 2e       	mov	r12, r31
    1ad6:	fa e1       	ldi	r31, 0x1A	; 26
    1ad8:	df 2e       	mov	r13, r31
    1ada:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1adc:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1ade:	d7 01       	movw	r26, r14
    1ae0:	ed 91       	ld	r30, X+
    1ae2:	fc 91       	ld	r31, X
    1ae4:	c6 81       	ldd	r28, Z+6	; 0x06
    1ae6:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1ae8:	ce 01       	movw	r24, r28
    1aea:	0c 96       	adiw	r24, 0x0c	; 12
    1aec:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1af0:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1af2:	8e 01       	movw	r16, r28
    1af4:	0e 5f       	subi	r16, 0xFE	; 254
    1af6:	1f 4f       	sbci	r17, 0xFF	; 255
    1af8:	c8 01       	movw	r24, r16
    1afa:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1afe:	8e 89       	ldd	r24, Y+22	; 0x16
    1b00:	90 91 96 1a 	lds	r25, 0x1A96
    1b04:	98 17       	cp	r25, r24
    1b06:	10 f4       	brcc	.+4      	; 0x1b0c <vCoRoutineSchedule+0x60>
    1b08:	80 93 96 1a 	sts	0x1A96, r24
    1b0c:	90 e0       	ldi	r25, 0x00	; 0
    1b0e:	9c 01       	movw	r18, r24
    1b10:	22 0f       	add	r18, r18
    1b12:	33 1f       	adc	r19, r19
    1b14:	22 0f       	add	r18, r18
    1b16:	33 1f       	adc	r19, r19
    1b18:	22 0f       	add	r18, r18
    1b1a:	33 1f       	adc	r19, r19
    1b1c:	82 0f       	add	r24, r18
    1b1e:	93 1f       	adc	r25, r19
    1b20:	89 56       	subi	r24, 0x69	; 105
    1b22:	95 4e       	sbci	r25, 0xE5	; 229
    1b24:	b8 01       	movw	r22, r16
    1b26:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1b2a:	f6 01       	movw	r30, r12
    1b2c:	80 81       	ld	r24, Z
    1b2e:	88 23       	and	r24, r24
    1b30:	a9 f6       	brne	.-86     	; 0x1adc <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1b32:	0e 94 83 16 	call	0x2d06	; 0x2d06 <xTaskGetTickCount>
    1b36:	20 91 ca 1a 	lds	r18, 0x1ACA
    1b3a:	30 91 cb 1a 	lds	r19, 0x1ACB
    1b3e:	82 1b       	sub	r24, r18
    1b40:	93 0b       	sbc	r25, r19
    1b42:	90 93 cd 1a 	sts	0x1ACD, r25
    1b46:	80 93 cc 1a 	sts	0x1ACC, r24
    1b4a:	74 c0       	rjmp	.+232    	; 0x1c34 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1b4c:	20 91 c8 1a 	lds	r18, 0x1AC8
    1b50:	30 91 c9 1a 	lds	r19, 0x1AC9
    1b54:	2f 5f       	subi	r18, 0xFF	; 255
    1b56:	3f 4f       	sbci	r19, 0xFF	; 255
    1b58:	30 93 c9 1a 	sts	0x1AC9, r19
    1b5c:	20 93 c8 1a 	sts	0x1AC8, r18
		xPassedTicks--;
    1b60:	01 97       	sbiw	r24, 0x01	; 1
    1b62:	90 93 cd 1a 	sts	0x1ACD, r25
    1b66:	80 93 cc 1a 	sts	0x1ACC, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1b6a:	21 15       	cp	r18, r1
    1b6c:	31 05       	cpc	r19, r1
    1b6e:	81 f4       	brne	.+32     	; 0x1b90 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1b70:	80 91 c4 1a 	lds	r24, 0x1AC4
    1b74:	90 91 c5 1a 	lds	r25, 0x1AC5
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1b78:	20 91 c6 1a 	lds	r18, 0x1AC6
    1b7c:	30 91 c7 1a 	lds	r19, 0x1AC7
    1b80:	30 93 c5 1a 	sts	0x1AC5, r19
    1b84:	20 93 c4 1a 	sts	0x1AC4, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    1b88:	90 93 c7 1a 	sts	0x1AC7, r25
    1b8c:	80 93 c6 1a 	sts	0x1AC6, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1b90:	e0 91 c4 1a 	lds	r30, 0x1AC4
    1b94:	f0 91 c5 1a 	lds	r31, 0x1AC5
    1b98:	80 81       	ld	r24, Z
    1b9a:	88 23       	and	r24, r24
    1b9c:	09 f4       	brne	.+2      	; 0x1ba0 <vCoRoutineSchedule+0xf4>
    1b9e:	4a c0       	rjmp	.+148    	; 0x1c34 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1ba0:	05 80       	ldd	r0, Z+5	; 0x05
    1ba2:	f6 81       	ldd	r31, Z+6	; 0x06
    1ba4:	e0 2d       	mov	r30, r0
    1ba6:	c6 81       	ldd	r28, Z+6	; 0x06
    1ba8:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1baa:	2a 81       	ldd	r18, Y+2	; 0x02
    1bac:	3b 81       	ldd	r19, Y+3	; 0x03
    1bae:	80 91 c8 1a 	lds	r24, 0x1AC8
    1bb2:	90 91 c9 1a 	lds	r25, 0x1AC9
    1bb6:	82 17       	cp	r24, r18
    1bb8:	93 07       	cpc	r25, r19
    1bba:	78 f4       	brcc	.+30     	; 0x1bda <vCoRoutineSchedule+0x12e>
    1bbc:	3b c0       	rjmp	.+118    	; 0x1c34 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1bbe:	05 80       	ldd	r0, Z+5	; 0x05
    1bc0:	f6 81       	ldd	r31, Z+6	; 0x06
    1bc2:	e0 2d       	mov	r30, r0
    1bc4:	c6 81       	ldd	r28, Z+6	; 0x06
    1bc6:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1bc8:	2a 81       	ldd	r18, Y+2	; 0x02
    1bca:	3b 81       	ldd	r19, Y+3	; 0x03
    1bcc:	80 91 c8 1a 	lds	r24, 0x1AC8
    1bd0:	90 91 c9 1a 	lds	r25, 0x1AC9
    1bd4:	82 17       	cp	r24, r18
    1bd6:	93 07       	cpc	r25, r19
    1bd8:	68 f1       	brcs	.+90     	; 0x1c34 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1bda:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    1bdc:	8e 01       	movw	r16, r28
    1bde:	0e 5f       	subi	r16, 0xFE	; 254
    1be0:	1f 4f       	sbci	r17, 0xFF	; 255
    1be2:	c8 01       	movw	r24, r16
    1be4:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1be8:	8c 89       	ldd	r24, Y+20	; 0x14
    1bea:	9d 89       	ldd	r25, Y+21	; 0x15
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	21 f0       	breq	.+8      	; 0x1bf8 <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	0c 96       	adiw	r24, 0x0c	; 12
    1bf4:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1bf8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1bfa:	8e 89       	ldd	r24, Y+22	; 0x16
    1bfc:	90 91 96 1a 	lds	r25, 0x1A96
    1c00:	98 17       	cp	r25, r24
    1c02:	10 f4       	brcc	.+4      	; 0x1c08 <vCoRoutineSchedule+0x15c>
    1c04:	80 93 96 1a 	sts	0x1A96, r24
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	9c 01       	movw	r18, r24
    1c0c:	22 0f       	add	r18, r18
    1c0e:	33 1f       	adc	r19, r19
    1c10:	22 0f       	add	r18, r18
    1c12:	33 1f       	adc	r19, r19
    1c14:	22 0f       	add	r18, r18
    1c16:	33 1f       	adc	r19, r19
    1c18:	82 0f       	add	r24, r18
    1c1a:	93 1f       	adc	r25, r19
    1c1c:	89 56       	subi	r24, 0x69	; 105
    1c1e:	95 4e       	sbci	r25, 0xE5	; 229
    1c20:	b8 01       	movw	r22, r16
    1c22:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1c26:	e0 91 c4 1a 	lds	r30, 0x1AC4
    1c2a:	f0 91 c5 1a 	lds	r31, 0x1AC5
    1c2e:	80 81       	ld	r24, Z
    1c30:	88 23       	and	r24, r24
    1c32:	29 f6       	brne	.-118    	; 0x1bbe <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1c34:	80 91 cc 1a 	lds	r24, 0x1ACC
    1c38:	90 91 cd 1a 	lds	r25, 0x1ACD
    1c3c:	00 97       	sbiw	r24, 0x00	; 0
    1c3e:	09 f0       	breq	.+2      	; 0x1c42 <vCoRoutineSchedule+0x196>
    1c40:	85 cf       	rjmp	.-246    	; 0x1b4c <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1c42:	80 91 c8 1a 	lds	r24, 0x1AC8
    1c46:	90 91 c9 1a 	lds	r25, 0x1AC9
    1c4a:	90 93 cb 1a 	sts	0x1ACB, r25
    1c4e:	80 93 ca 1a 	sts	0x1ACA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1c52:	20 91 96 1a 	lds	r18, 0x1A96
    1c56:	82 2f       	mov	r24, r18
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	fc 01       	movw	r30, r24
    1c5c:	ee 0f       	add	r30, r30
    1c5e:	ff 1f       	adc	r31, r31
    1c60:	ee 0f       	add	r30, r30
    1c62:	ff 1f       	adc	r31, r31
    1c64:	ee 0f       	add	r30, r30
    1c66:	ff 1f       	adc	r31, r31
    1c68:	e8 0f       	add	r30, r24
    1c6a:	f9 1f       	adc	r31, r25
    1c6c:	e9 56       	subi	r30, 0x69	; 105
    1c6e:	f5 4e       	sbci	r31, 0xE5	; 229
    1c70:	30 81       	ld	r19, Z
    1c72:	33 23       	and	r19, r19
    1c74:	d9 f4       	brne	.+54     	; 0x1cac <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1c76:	22 23       	and	r18, r18
    1c78:	31 f4       	brne	.+12     	; 0x1c86 <vCoRoutineSchedule+0x1da>
    1c7a:	47 c0       	rjmp	.+142    	; 0x1d0a <vCoRoutineSchedule+0x25e>
    1c7c:	22 23       	and	r18, r18
    1c7e:	19 f4       	brne	.+6      	; 0x1c86 <vCoRoutineSchedule+0x1da>
    1c80:	20 93 96 1a 	sts	0x1A96, r18
    1c84:	42 c0       	rjmp	.+132    	; 0x1d0a <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1c86:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1c88:	82 2f       	mov	r24, r18
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	fc 01       	movw	r30, r24
    1c8e:	ee 0f       	add	r30, r30
    1c90:	ff 1f       	adc	r31, r31
    1c92:	ee 0f       	add	r30, r30
    1c94:	ff 1f       	adc	r31, r31
    1c96:	ee 0f       	add	r30, r30
    1c98:	ff 1f       	adc	r31, r31
    1c9a:	e8 0f       	add	r30, r24
    1c9c:	f9 1f       	adc	r31, r25
    1c9e:	e9 56       	subi	r30, 0x69	; 105
    1ca0:	f5 4e       	sbci	r31, 0xE5	; 229
    1ca2:	30 81       	ld	r19, Z
    1ca4:	33 23       	and	r19, r19
    1ca6:	51 f3       	breq	.-44     	; 0x1c7c <vCoRoutineSchedule+0x1d0>
    1ca8:	20 93 96 1a 	sts	0x1A96, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1cac:	fc 01       	movw	r30, r24
    1cae:	ee 0f       	add	r30, r30
    1cb0:	ff 1f       	adc	r31, r31
    1cb2:	ee 0f       	add	r30, r30
    1cb4:	ff 1f       	adc	r31, r31
    1cb6:	ee 0f       	add	r30, r30
    1cb8:	ff 1f       	adc	r31, r31
    1cba:	8e 0f       	add	r24, r30
    1cbc:	9f 1f       	adc	r25, r31
    1cbe:	fc 01       	movw	r30, r24
    1cc0:	e9 56       	subi	r30, 0x69	; 105
    1cc2:	f5 4e       	sbci	r31, 0xE5	; 229
    1cc4:	a1 81       	ldd	r26, Z+1	; 0x01
    1cc6:	b2 81       	ldd	r27, Z+2	; 0x02
    1cc8:	12 96       	adiw	r26, 0x02	; 2
    1cca:	0d 90       	ld	r0, X+
    1ccc:	bc 91       	ld	r27, X
    1cce:	a0 2d       	mov	r26, r0
    1cd0:	b2 83       	std	Z+2, r27	; 0x02
    1cd2:	a1 83       	std	Z+1, r26	; 0x01
    1cd4:	cf 01       	movw	r24, r30
    1cd6:	03 96       	adiw	r24, 0x03	; 3
    1cd8:	a8 17       	cp	r26, r24
    1cda:	b9 07       	cpc	r27, r25
    1cdc:	31 f4       	brne	.+12     	; 0x1cea <vCoRoutineSchedule+0x23e>
    1cde:	12 96       	adiw	r26, 0x02	; 2
    1ce0:	8d 91       	ld	r24, X+
    1ce2:	9c 91       	ld	r25, X
    1ce4:	13 97       	sbiw	r26, 0x03	; 3
    1ce6:	92 83       	std	Z+2, r25	; 0x02
    1ce8:	81 83       	std	Z+1, r24	; 0x01
    1cea:	01 80       	ldd	r0, Z+1	; 0x01
    1cec:	f2 81       	ldd	r31, Z+2	; 0x02
    1cee:	e0 2d       	mov	r30, r0
    1cf0:	a6 81       	ldd	r26, Z+6	; 0x06
    1cf2:	b7 81       	ldd	r27, Z+7	; 0x07
    1cf4:	b0 93 95 1a 	sts	0x1A95, r27
    1cf8:	a0 93 94 1a 	sts	0x1A94, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1cfc:	ed 91       	ld	r30, X+
    1cfe:	fc 91       	ld	r31, X
    1d00:	11 97       	sbiw	r26, 0x01	; 1
    1d02:	cd 01       	movw	r24, r26
    1d04:	57 96       	adiw	r26, 0x17	; 23
    1d06:	6c 91       	ld	r22, X
    1d08:	19 95       	eicall

	return;
}
    1d0a:	df 91       	pop	r29
    1d0c:	cf 91       	pop	r28
    1d0e:	1f 91       	pop	r17
    1d10:	0f 91       	pop	r16
    1d12:	ff 90       	pop	r15
    1d14:	ef 90       	pop	r14
    1d16:	df 90       	pop	r13
    1d18:	cf 90       	pop	r12
    1d1a:	08 95       	ret

00001d1c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1d1c:	0f 93       	push	r16
    1d1e:	1f 93       	push	r17
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1d24:	dc 01       	movw	r26, r24
    1d26:	15 96       	adiw	r26, 0x05	; 5
    1d28:	ed 91       	ld	r30, X+
    1d2a:	fc 91       	ld	r31, X
    1d2c:	16 97       	sbiw	r26, 0x06	; 6
    1d2e:	06 81       	ldd	r16, Z+6	; 0x06
    1d30:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1d32:	e8 01       	movw	r28, r16
    1d34:	2c 96       	adiw	r28, 0x0c	; 12
    1d36:	ce 01       	movw	r24, r28
    1d38:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1d3c:	8b eb       	ldi	r24, 0xBB	; 187
    1d3e:	9a e1       	ldi	r25, 0x1A	; 26
    1d40:	be 01       	movw	r22, r28
    1d42:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1d46:	e0 91 94 1a 	lds	r30, 0x1A94
    1d4a:	f0 91 95 1a 	lds	r31, 0x1A95
	{
		xReturn = pdTRUE;
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	d8 01       	movw	r26, r16
    1d52:	56 96       	adiw	r26, 0x16	; 22
    1d54:	2c 91       	ld	r18, X
    1d56:	56 97       	sbiw	r26, 0x16	; 22
    1d58:	96 89       	ldd	r25, Z+22	; 0x16
    1d5a:	29 17       	cp	r18, r25
    1d5c:	08 f4       	brcc	.+2      	; 0x1d60 <xCoRoutineRemoveFromEventList+0x44>
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1d60:	df 91       	pop	r29
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	08 95       	ret

00001d6a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1d6a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1d6c:	03 96       	adiw	r24, 0x03	; 3
    1d6e:	92 83       	std	Z+2, r25	; 0x02
    1d70:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1d72:	2f ef       	ldi	r18, 0xFF	; 255
    1d74:	3f ef       	ldi	r19, 0xFF	; 255
    1d76:	34 83       	std	Z+4, r19	; 0x04
    1d78:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1d7a:	96 83       	std	Z+6, r25	; 0x06
    1d7c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1d7e:	90 87       	std	Z+8, r25	; 0x08
    1d80:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1d82:	10 82       	st	Z, r1
}
    1d84:	08 95       	ret

00001d86 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1d86:	fc 01       	movw	r30, r24
    1d88:	11 86       	std	Z+9, r1	; 0x09
    1d8a:	10 86       	std	Z+8, r1	; 0x08
}
    1d8c:	08 95       	ret

00001d8e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1d8e:	cf 93       	push	r28
    1d90:	df 93       	push	r29
    1d92:	ec 01       	movw	r28, r24
    1d94:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1d96:	89 81       	ldd	r24, Y+1	; 0x01
    1d98:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1d9a:	dc 01       	movw	r26, r24
    1d9c:	12 96       	adiw	r26, 0x02	; 2
    1d9e:	2d 91       	ld	r18, X+
    1da0:	3c 91       	ld	r19, X
    1da2:	13 97       	sbiw	r26, 0x03	; 3
    1da4:	33 83       	std	Z+3, r19	; 0x03
    1da6:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1da8:	29 81       	ldd	r18, Y+1	; 0x01
    1daa:	3a 81       	ldd	r19, Y+2	; 0x02
    1dac:	35 83       	std	Z+5, r19	; 0x05
    1dae:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1db0:	12 96       	adiw	r26, 0x02	; 2
    1db2:	2d 91       	ld	r18, X+
    1db4:	3c 91       	ld	r19, X
    1db6:	13 97       	sbiw	r26, 0x03	; 3
    1db8:	d9 01       	movw	r26, r18
    1dba:	15 96       	adiw	r26, 0x05	; 5
    1dbc:	7c 93       	st	X, r23
    1dbe:	6e 93       	st	-X, r22
    1dc0:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1dc2:	dc 01       	movw	r26, r24
    1dc4:	13 96       	adiw	r26, 0x03	; 3
    1dc6:	7c 93       	st	X, r23
    1dc8:	6e 93       	st	-X, r22
    1dca:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1dcc:	7a 83       	std	Y+2, r23	; 0x02
    1dce:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1dd0:	d1 87       	std	Z+9, r29	; 0x09
    1dd2:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
    1dd4:	88 81       	ld	r24, Y
    1dd6:	8f 5f       	subi	r24, 0xFF	; 255
    1dd8:	88 83       	st	Y, r24
}
    1dda:	df 91       	pop	r29
    1ddc:	cf 91       	pop	r28
    1dde:	08 95       	ret

00001de0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
    1de4:	ac 01       	movw	r20, r24
    1de6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1de8:	28 81       	ld	r18, Y
    1dea:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1dec:	8f ef       	ldi	r24, 0xFF	; 255
    1dee:	2f 3f       	cpi	r18, 0xFF	; 255
    1df0:	38 07       	cpc	r19, r24
    1df2:	21 f4       	brne	.+8      	; 0x1dfc <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1df4:	fa 01       	movw	r30, r20
    1df6:	a7 81       	ldd	r26, Z+7	; 0x07
    1df8:	b0 85       	ldd	r27, Z+8	; 0x08
    1dfa:	18 c0       	rjmp	.+48     	; 0x1e2c <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1dfc:	da 01       	movw	r26, r20
    1dfe:	13 96       	adiw	r26, 0x03	; 3
    1e00:	fa 01       	movw	r30, r20
    1e02:	85 81       	ldd	r24, Z+5	; 0x05
    1e04:	96 81       	ldd	r25, Z+6	; 0x06
    1e06:	fc 01       	movw	r30, r24
    1e08:	80 81       	ld	r24, Z
    1e0a:	91 81       	ldd	r25, Z+1	; 0x01
    1e0c:	28 17       	cp	r18, r24
    1e0e:	39 07       	cpc	r19, r25
    1e10:	68 f0       	brcs	.+26     	; 0x1e2c <vListInsert+0x4c>
    1e12:	12 96       	adiw	r26, 0x02	; 2
    1e14:	0d 90       	ld	r0, X+
    1e16:	bc 91       	ld	r27, X
    1e18:	a0 2d       	mov	r26, r0
    1e1a:	12 96       	adiw	r26, 0x02	; 2
    1e1c:	ed 91       	ld	r30, X+
    1e1e:	fc 91       	ld	r31, X
    1e20:	13 97       	sbiw	r26, 0x03	; 3
    1e22:	80 81       	ld	r24, Z
    1e24:	91 81       	ldd	r25, Z+1	; 0x01
    1e26:	28 17       	cp	r18, r24
    1e28:	39 07       	cpc	r19, r25
    1e2a:	98 f7       	brcc	.-26     	; 0x1e12 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1e2c:	12 96       	adiw	r26, 0x02	; 2
    1e2e:	ed 91       	ld	r30, X+
    1e30:	fc 91       	ld	r31, X
    1e32:	13 97       	sbiw	r26, 0x03	; 3
    1e34:	fb 83       	std	Y+3, r31	; 0x03
    1e36:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1e38:	d5 83       	std	Z+5, r29	; 0x05
    1e3a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1e3c:	bd 83       	std	Y+5, r27	; 0x05
    1e3e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1e40:	13 96       	adiw	r26, 0x03	; 3
    1e42:	dc 93       	st	X, r29
    1e44:	ce 93       	st	-X, r28
    1e46:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e48:	59 87       	std	Y+9, r21	; 0x09
    1e4a:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    1e4c:	fa 01       	movw	r30, r20
    1e4e:	80 81       	ld	r24, Z
    1e50:	8f 5f       	subi	r24, 0xFF	; 255
    1e52:	80 83       	st	Z, r24
}
    1e54:	df 91       	pop	r29
    1e56:	cf 91       	pop	r28
    1e58:	08 95       	ret

00001e5a <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    1e5a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e5c:	a2 81       	ldd	r26, Z+2	; 0x02
    1e5e:	b3 81       	ldd	r27, Z+3	; 0x03
    1e60:	84 81       	ldd	r24, Z+4	; 0x04
    1e62:	95 81       	ldd	r25, Z+5	; 0x05
    1e64:	15 96       	adiw	r26, 0x05	; 5
    1e66:	9c 93       	st	X, r25
    1e68:	8e 93       	st	-X, r24
    1e6a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e6c:	a4 81       	ldd	r26, Z+4	; 0x04
    1e6e:	b5 81       	ldd	r27, Z+5	; 0x05
    1e70:	82 81       	ldd	r24, Z+2	; 0x02
    1e72:	93 81       	ldd	r25, Z+3	; 0x03
    1e74:	13 96       	adiw	r26, 0x03	; 3
    1e76:	9c 93       	st	X, r25
    1e78:	8e 93       	st	-X, r24
    1e7a:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1e7c:	a0 85       	ldd	r26, Z+8	; 0x08
    1e7e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1e80:	11 96       	adiw	r26, 0x01	; 1
    1e82:	8d 91       	ld	r24, X+
    1e84:	9c 91       	ld	r25, X
    1e86:	12 97       	sbiw	r26, 0x02	; 2
    1e88:	8e 17       	cp	r24, r30
    1e8a:	9f 07       	cpc	r25, r31
    1e8c:	31 f4       	brne	.+12     	; 0x1e9a <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e8e:	84 81       	ldd	r24, Z+4	; 0x04
    1e90:	95 81       	ldd	r25, Z+5	; 0x05
    1e92:	12 96       	adiw	r26, 0x02	; 2
    1e94:	9c 93       	st	X, r25
    1e96:	8e 93       	st	-X, r24
    1e98:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1e9a:	11 86       	std	Z+9, r1	; 0x09
    1e9c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1e9e:	8c 91       	ld	r24, X
    1ea0:	81 50       	subi	r24, 0x01	; 1
    1ea2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1ea4:	8c 91       	ld	r24, X
}
    1ea6:	08 95       	ret

00001ea8 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1ea8:	21 e1       	ldi	r18, 0x11	; 17
    1eaa:	fc 01       	movw	r30, r24
    1eac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1eae:	31 97       	sbiw	r30, 0x01	; 1
    1eb0:	32 e2       	ldi	r19, 0x22	; 34
    1eb2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1eb4:	fc 01       	movw	r30, r24
    1eb6:	32 97       	sbiw	r30, 0x02	; 2
    1eb8:	a3 e3       	ldi	r26, 0x33	; 51
    1eba:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	33 97       	sbiw	r30, 0x03	; 3
    1ec0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    1ec2:	fc 01       	movw	r30, r24
    1ec4:	34 97       	sbiw	r30, 0x04	; 4
    1ec6:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    1ec8:	fc 01       	movw	r30, r24
    1eca:	35 97       	sbiw	r30, 0x05	; 5
    1ecc:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1ece:	fc 01       	movw	r30, r24
    1ed0:	36 97       	sbiw	r30, 0x06	; 6
    1ed2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	37 97       	sbiw	r30, 0x07	; 7
    1ed8:	60 e8       	ldi	r22, 0x80	; 128
    1eda:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    1edc:	fc 01       	movw	r30, r24
    1ede:	38 97       	sbiw	r30, 0x08	; 8
    1ee0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    1ee2:	fc 01       	movw	r30, r24
    1ee4:	39 97       	sbiw	r30, 0x09	; 9
    1ee6:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1ee8:	fc 01       	movw	r30, r24
    1eea:	3a 97       	sbiw	r30, 0x0a	; 10
    1eec:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1eee:	fc 01       	movw	r30, r24
    1ef0:	3b 97       	sbiw	r30, 0x0b	; 11
    1ef2:	62 e0       	ldi	r22, 0x02	; 2
    1ef4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1ef6:	fc 01       	movw	r30, r24
    1ef8:	3c 97       	sbiw	r30, 0x0c	; 12
    1efa:	63 e0       	ldi	r22, 0x03	; 3
    1efc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1efe:	fc 01       	movw	r30, r24
    1f00:	3d 97       	sbiw	r30, 0x0d	; 13
    1f02:	64 e0       	ldi	r22, 0x04	; 4
    1f04:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1f06:	fc 01       	movw	r30, r24
    1f08:	3e 97       	sbiw	r30, 0x0e	; 14
    1f0a:	65 e0       	ldi	r22, 0x05	; 5
    1f0c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1f0e:	fc 01       	movw	r30, r24
    1f10:	3f 97       	sbiw	r30, 0x0f	; 15
    1f12:	66 e0       	ldi	r22, 0x06	; 6
    1f14:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1f16:	fc 01       	movw	r30, r24
    1f18:	70 97       	sbiw	r30, 0x10	; 16
    1f1a:	67 e0       	ldi	r22, 0x07	; 7
    1f1c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1f1e:	fc 01       	movw	r30, r24
    1f20:	71 97       	sbiw	r30, 0x11	; 17
    1f22:	68 e0       	ldi	r22, 0x08	; 8
    1f24:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1f26:	fc 01       	movw	r30, r24
    1f28:	72 97       	sbiw	r30, 0x12	; 18
    1f2a:	69 e0       	ldi	r22, 0x09	; 9
    1f2c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1f2e:	fc 01       	movw	r30, r24
    1f30:	73 97       	sbiw	r30, 0x13	; 19
    1f32:	60 e1       	ldi	r22, 0x10	; 16
    1f34:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1f36:	fc 01       	movw	r30, r24
    1f38:	74 97       	sbiw	r30, 0x14	; 20
    1f3a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1f3c:	fc 01       	movw	r30, r24
    1f3e:	75 97       	sbiw	r30, 0x15	; 21
    1f40:	22 e1       	ldi	r18, 0x12	; 18
    1f42:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1f44:	fc 01       	movw	r30, r24
    1f46:	76 97       	sbiw	r30, 0x16	; 22
    1f48:	23 e1       	ldi	r18, 0x13	; 19
    1f4a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1f4c:	fc 01       	movw	r30, r24
    1f4e:	77 97       	sbiw	r30, 0x17	; 23
    1f50:	24 e1       	ldi	r18, 0x14	; 20
    1f52:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1f54:	fc 01       	movw	r30, r24
    1f56:	78 97       	sbiw	r30, 0x18	; 24
    1f58:	25 e1       	ldi	r18, 0x15	; 21
    1f5a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1f5c:	fc 01       	movw	r30, r24
    1f5e:	79 97       	sbiw	r30, 0x19	; 25
    1f60:	26 e1       	ldi	r18, 0x16	; 22
    1f62:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1f64:	fc 01       	movw	r30, r24
    1f66:	7a 97       	sbiw	r30, 0x1a	; 26
    1f68:	27 e1       	ldi	r18, 0x17	; 23
    1f6a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1f6c:	fc 01       	movw	r30, r24
    1f6e:	7b 97       	sbiw	r30, 0x1b	; 27
    1f70:	28 e1       	ldi	r18, 0x18	; 24
    1f72:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1f74:	fc 01       	movw	r30, r24
    1f76:	7c 97       	sbiw	r30, 0x1c	; 28
    1f78:	29 e1       	ldi	r18, 0x19	; 25
    1f7a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1f7c:	fc 01       	movw	r30, r24
    1f7e:	7d 97       	sbiw	r30, 0x1d	; 29
    1f80:	20 e2       	ldi	r18, 0x20	; 32
    1f82:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1f84:	fc 01       	movw	r30, r24
    1f86:	7e 97       	sbiw	r30, 0x1e	; 30
    1f88:	21 e2       	ldi	r18, 0x21	; 33
    1f8a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	7f 97       	sbiw	r30, 0x1f	; 31
    1f90:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1f92:	fc 01       	movw	r30, r24
    1f94:	b0 97       	sbiw	r30, 0x20	; 32
    1f96:	23 e2       	ldi	r18, 0x23	; 35
    1f98:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	b1 97       	sbiw	r30, 0x21	; 33
    1f9e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1fa0:	fc 01       	movw	r30, r24
    1fa2:	b2 97       	sbiw	r30, 0x22	; 34
    1fa4:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1fa6:	fc 01       	movw	r30, r24
    1fa8:	b3 97       	sbiw	r30, 0x23	; 35
    1faa:	26 e2       	ldi	r18, 0x26	; 38
    1fac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1fae:	fc 01       	movw	r30, r24
    1fb0:	b4 97       	sbiw	r30, 0x24	; 36
    1fb2:	27 e2       	ldi	r18, 0x27	; 39
    1fb4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1fb6:	fc 01       	movw	r30, r24
    1fb8:	b5 97       	sbiw	r30, 0x25	; 37
    1fba:	28 e2       	ldi	r18, 0x28	; 40
    1fbc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1fbe:	fc 01       	movw	r30, r24
    1fc0:	b6 97       	sbiw	r30, 0x26	; 38
    1fc2:	29 e2       	ldi	r18, 0x29	; 41
    1fc4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	b7 97       	sbiw	r30, 0x27	; 39
    1fca:	20 e3       	ldi	r18, 0x30	; 48
    1fcc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1fce:	fc 01       	movw	r30, r24
    1fd0:	b8 97       	sbiw	r30, 0x28	; 40
    1fd2:	21 e3       	ldi	r18, 0x31	; 49
    1fd4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1fd6:	89 97       	sbiw	r24, 0x29	; 41
}
    1fd8:	08 95       	ret

00001fda <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
    1fda:	10 92 99 00 	sts	0x0099, r1

#endif

    portOCRL = ucLowByte;
    1fde:	89 ef       	ldi	r24, 0xF9	; 249
    1fe0:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
    1fe4:	8b e0       	ldi	r24, 0x0B	; 11
    1fe6:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    1fea:	e1 e7       	ldi	r30, 0x71	; 113
    1fec:	f0 e0       	ldi	r31, 0x00	; 0
    1fee:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1ff0:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
    1ff2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1ff4:	a0 91 ce 1a 	lds	r26, 0x1ACE
    1ff8:	b0 91 cf 1a 	lds	r27, 0x1ACF
    1ffc:	cd 91       	ld	r28, X+
    1ffe:	cd bf       	out	0x3d, r28	; 61
    2000:	dd 91       	ld	r29, X+
    2002:	de bf       	out	0x3e, r29	; 62
    2004:	ff 91       	pop	r31
    2006:	ef 91       	pop	r30
    2008:	df 91       	pop	r29
    200a:	cf 91       	pop	r28
    200c:	bf 91       	pop	r27
    200e:	af 91       	pop	r26
    2010:	9f 91       	pop	r25
    2012:	8f 91       	pop	r24
    2014:	7f 91       	pop	r23
    2016:	6f 91       	pop	r22
    2018:	5f 91       	pop	r21
    201a:	4f 91       	pop	r20
    201c:	3f 91       	pop	r19
    201e:	2f 91       	pop	r18
    2020:	1f 91       	pop	r17
    2022:	0f 91       	pop	r16
    2024:	ff 90       	pop	r15
    2026:	ef 90       	pop	r14
    2028:	df 90       	pop	r13
    202a:	cf 90       	pop	r12
    202c:	bf 90       	pop	r11
    202e:	af 90       	pop	r10
    2030:	9f 90       	pop	r9
    2032:	8f 90       	pop	r8
    2034:	7f 90       	pop	r7
    2036:	6f 90       	pop	r6
    2038:	5f 90       	pop	r5
    203a:	4f 90       	pop	r4
    203c:	3f 90       	pop	r3
    203e:	2f 90       	pop	r2
    2040:	1f 90       	pop	r1
    2042:	0f 90       	pop	r0
    2044:	0c be       	out	0x3c, r0	; 60
    2046:	0f 90       	pop	r0
    2048:	0b be       	out	0x3b, r0	; 59
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2050:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2052:	81 e0       	ldi	r24, 0x01	; 1
    2054:	08 95       	ret

00002056 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2056:	08 95       	ret

00002058 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2058:	0f 92       	push	r0
    205a:	0f b6       	in	r0, 0x3f	; 63
    205c:	f8 94       	cli
    205e:	0f 92       	push	r0
    2060:	0b b6       	in	r0, 0x3b	; 59
    2062:	0f 92       	push	r0
    2064:	0c b6       	in	r0, 0x3c	; 60
    2066:	0f 92       	push	r0
    2068:	1f 92       	push	r1
    206a:	11 24       	eor	r1, r1
    206c:	2f 92       	push	r2
    206e:	3f 92       	push	r3
    2070:	4f 92       	push	r4
    2072:	5f 92       	push	r5
    2074:	6f 92       	push	r6
    2076:	7f 92       	push	r7
    2078:	8f 92       	push	r8
    207a:	9f 92       	push	r9
    207c:	af 92       	push	r10
    207e:	bf 92       	push	r11
    2080:	cf 92       	push	r12
    2082:	df 92       	push	r13
    2084:	ef 92       	push	r14
    2086:	ff 92       	push	r15
    2088:	0f 93       	push	r16
    208a:	1f 93       	push	r17
    208c:	2f 93       	push	r18
    208e:	3f 93       	push	r19
    2090:	4f 93       	push	r20
    2092:	5f 93       	push	r21
    2094:	6f 93       	push	r22
    2096:	7f 93       	push	r23
    2098:	8f 93       	push	r24
    209a:	9f 93       	push	r25
    209c:	af 93       	push	r26
    209e:	bf 93       	push	r27
    20a0:	cf 93       	push	r28
    20a2:	df 93       	push	r29
    20a4:	ef 93       	push	r30
    20a6:	ff 93       	push	r31
    20a8:	a0 91 ce 1a 	lds	r26, 0x1ACE
    20ac:	b0 91 cf 1a 	lds	r27, 0x1ACF
    20b0:	0d b6       	in	r0, 0x3d	; 61
    20b2:	0d 92       	st	X+, r0
    20b4:	0e b6       	in	r0, 0x3e	; 62
    20b6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    20b8:	0e 94 55 18 	call	0x30aa	; 0x30aa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    20bc:	a0 91 ce 1a 	lds	r26, 0x1ACE
    20c0:	b0 91 cf 1a 	lds	r27, 0x1ACF
    20c4:	cd 91       	ld	r28, X+
    20c6:	cd bf       	out	0x3d, r28	; 61
    20c8:	dd 91       	ld	r29, X+
    20ca:	de bf       	out	0x3e, r29	; 62
    20cc:	ff 91       	pop	r31
    20ce:	ef 91       	pop	r30
    20d0:	df 91       	pop	r29
    20d2:	cf 91       	pop	r28
    20d4:	bf 91       	pop	r27
    20d6:	af 91       	pop	r26
    20d8:	9f 91       	pop	r25
    20da:	8f 91       	pop	r24
    20dc:	7f 91       	pop	r23
    20de:	6f 91       	pop	r22
    20e0:	5f 91       	pop	r21
    20e2:	4f 91       	pop	r20
    20e4:	3f 91       	pop	r19
    20e6:	2f 91       	pop	r18
    20e8:	1f 91       	pop	r17
    20ea:	0f 91       	pop	r16
    20ec:	ff 90       	pop	r15
    20ee:	ef 90       	pop	r14
    20f0:	df 90       	pop	r13
    20f2:	cf 90       	pop	r12
    20f4:	bf 90       	pop	r11
    20f6:	af 90       	pop	r10
    20f8:	9f 90       	pop	r9
    20fa:	8f 90       	pop	r8
    20fc:	7f 90       	pop	r7
    20fe:	6f 90       	pop	r6
    2100:	5f 90       	pop	r5
    2102:	4f 90       	pop	r4
    2104:	3f 90       	pop	r3
    2106:	2f 90       	pop	r2
    2108:	1f 90       	pop	r1
    210a:	0f 90       	pop	r0
    210c:	0c be       	out	0x3c, r0	; 60
    210e:	0f 90       	pop	r0
    2110:	0b be       	out	0x3b, r0	; 59
    2112:	0f 90       	pop	r0
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2118:	08 95       	ret

0000211a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    211a:	0f 92       	push	r0
    211c:	0f b6       	in	r0, 0x3f	; 63
    211e:	f8 94       	cli
    2120:	0f 92       	push	r0
    2122:	0b b6       	in	r0, 0x3b	; 59
    2124:	0f 92       	push	r0
    2126:	0c b6       	in	r0, 0x3c	; 60
    2128:	0f 92       	push	r0
    212a:	1f 92       	push	r1
    212c:	11 24       	eor	r1, r1
    212e:	2f 92       	push	r2
    2130:	3f 92       	push	r3
    2132:	4f 92       	push	r4
    2134:	5f 92       	push	r5
    2136:	6f 92       	push	r6
    2138:	7f 92       	push	r7
    213a:	8f 92       	push	r8
    213c:	9f 92       	push	r9
    213e:	af 92       	push	r10
    2140:	bf 92       	push	r11
    2142:	cf 92       	push	r12
    2144:	df 92       	push	r13
    2146:	ef 92       	push	r14
    2148:	ff 92       	push	r15
    214a:	0f 93       	push	r16
    214c:	1f 93       	push	r17
    214e:	2f 93       	push	r18
    2150:	3f 93       	push	r19
    2152:	4f 93       	push	r20
    2154:	5f 93       	push	r21
    2156:	6f 93       	push	r22
    2158:	7f 93       	push	r23
    215a:	8f 93       	push	r24
    215c:	9f 93       	push	r25
    215e:	af 93       	push	r26
    2160:	bf 93       	push	r27
    2162:	cf 93       	push	r28
    2164:	df 93       	push	r29
    2166:	ef 93       	push	r30
    2168:	ff 93       	push	r31
    216a:	a0 91 ce 1a 	lds	r26, 0x1ACE
    216e:	b0 91 cf 1a 	lds	r27, 0x1ACF
    2172:	0d b6       	in	r0, 0x3d	; 61
    2174:	0d 92       	st	X+, r0
    2176:	0e b6       	in	r0, 0x3e	; 62
    2178:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    217a:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <vTaskIncrementTick>
	vTaskSwitchContext();
    217e:	0e 94 55 18 	call	0x30aa	; 0x30aa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2182:	a0 91 ce 1a 	lds	r26, 0x1ACE
    2186:	b0 91 cf 1a 	lds	r27, 0x1ACF
    218a:	cd 91       	ld	r28, X+
    218c:	cd bf       	out	0x3d, r28	; 61
    218e:	dd 91       	ld	r29, X+
    2190:	de bf       	out	0x3e, r29	; 62
    2192:	ff 91       	pop	r31
    2194:	ef 91       	pop	r30
    2196:	df 91       	pop	r29
    2198:	cf 91       	pop	r28
    219a:	bf 91       	pop	r27
    219c:	af 91       	pop	r26
    219e:	9f 91       	pop	r25
    21a0:	8f 91       	pop	r24
    21a2:	7f 91       	pop	r23
    21a4:	6f 91       	pop	r22
    21a6:	5f 91       	pop	r21
    21a8:	4f 91       	pop	r20
    21aa:	3f 91       	pop	r19
    21ac:	2f 91       	pop	r18
    21ae:	1f 91       	pop	r17
    21b0:	0f 91       	pop	r16
    21b2:	ff 90       	pop	r15
    21b4:	ef 90       	pop	r14
    21b6:	df 90       	pop	r13
    21b8:	cf 90       	pop	r12
    21ba:	bf 90       	pop	r11
    21bc:	af 90       	pop	r10
    21be:	9f 90       	pop	r9
    21c0:	8f 90       	pop	r8
    21c2:	7f 90       	pop	r7
    21c4:	6f 90       	pop	r6
    21c6:	5f 90       	pop	r5
    21c8:	4f 90       	pop	r4
    21ca:	3f 90       	pop	r3
    21cc:	2f 90       	pop	r2
    21ce:	1f 90       	pop	r1
    21d0:	0f 90       	pop	r0
    21d2:	0c be       	out	0x3c, r0	; 60
    21d4:	0f 90       	pop	r0
    21d6:	0b be       	out	0x3b, r0	; 59
    21d8:	0f 90       	pop	r0
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    21de:	08 95       	ret

000021e0 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    21e0:	0e 94 8d 10 	call	0x211a	; 0x211a <vPortYieldFromTick>
			asm volatile ( "reti" );
    21e4:	18 95       	reti

000021e6 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    21e6:	cf 93       	push	r28
    21e8:	df 93       	push	r29
    21ea:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    21ec:	cd 91       	ld	r28, X+
    21ee:	dc 91       	ld	r29, X
    21f0:	11 97       	sbiw	r26, 0x01	; 1
    21f2:	20 97       	sbiw	r28, 0x00	; 0
    21f4:	21 f1       	breq	.+72     	; 0x223e <__stack+0x3f>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    21f6:	5c 96       	adiw	r26, 0x1c	; 28
    21f8:	4c 91       	ld	r20, X
    21fa:	5c 97       	sbiw	r26, 0x1c	; 28
    21fc:	16 96       	adiw	r26, 0x06	; 6
    21fe:	2d 91       	ld	r18, X+
    2200:	3c 91       	ld	r19, X
    2202:	17 97       	sbiw	r26, 0x07	; 7
    2204:	24 0f       	add	r18, r20
    2206:	31 1d       	adc	r19, r1
    2208:	17 96       	adiw	r26, 0x07	; 7
    220a:	3c 93       	st	X, r19
    220c:	2e 93       	st	-X, r18
    220e:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2210:	12 96       	adiw	r26, 0x02	; 2
    2212:	ed 91       	ld	r30, X+
    2214:	fc 91       	ld	r31, X
    2216:	13 97       	sbiw	r26, 0x03	; 3
    2218:	2e 17       	cp	r18, r30
    221a:	3f 07       	cpc	r19, r31
    221c:	20 f0       	brcs	.+8      	; 0x2226 <__stack+0x27>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    221e:	17 96       	adiw	r26, 0x07	; 7
    2220:	dc 93       	st	X, r29
    2222:	ce 93       	st	-X, r28
    2224:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2226:	16 96       	adiw	r26, 0x06	; 6
    2228:	3c 91       	ld	r19, X
    222a:	16 97       	sbiw	r26, 0x06	; 6
    222c:	17 96       	adiw	r26, 0x07	; 7
    222e:	2c 91       	ld	r18, X
    2230:	86 2f       	mov	r24, r22
    2232:	97 2f       	mov	r25, r23
    2234:	63 2f       	mov	r22, r19
    2236:	72 2f       	mov	r23, r18
    2238:	50 e0       	ldi	r21, 0x00	; 0
    223a:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <memcpy>
	}
}
    223e:	df 91       	pop	r29
    2240:	cf 91       	pop	r28
    2242:	08 95       	ret

00002244 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    2244:	0f 93       	push	r16
    2246:	1f 93       	push	r17
    2248:	cf 93       	push	r28
    224a:	df 93       	push	r29
    224c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2254:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2256:	18 16       	cp	r1, r24
    2258:	c4 f4       	brge	.+48     	; 0x228a <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    225a:	89 89       	ldd	r24, Y+17	; 0x11
    225c:	88 23       	and	r24, r24
    225e:	29 f4       	brne	.+10     	; 0x226a <prvUnlockQueue+0x26>
    2260:	14 c0       	rjmp	.+40     	; 0x228a <prvUnlockQueue+0x46>
    2262:	89 89       	ldd	r24, Y+17	; 0x11
    2264:	88 23       	and	r24, r24
    2266:	21 f4       	brne	.+8      	; 0x2270 <prvUnlockQueue+0x2c>
    2268:	10 c0       	rjmp	.+32     	; 0x228a <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    226a:	8e 01       	movw	r16, r28
    226c:	0f 5e       	subi	r16, 0xEF	; 239
    226e:	1f 4f       	sbci	r17, 0xFF	; 255
    2270:	c8 01       	movw	r24, r16
    2272:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    2276:	88 23       	and	r24, r24
    2278:	11 f0       	breq	.+4      	; 0x227e <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    227a:	0e 94 bf 19 	call	0x337e	; 0x337e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    227e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2280:	81 50       	subi	r24, 0x01	; 1
    2282:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2284:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2286:	18 16       	cp	r1, r24
    2288:	64 f3       	brlt	.-40     	; 0x2262 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    228a:	8f ef       	ldi	r24, 0xFF	; 255
    228c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    228e:	0f 90       	pop	r0
    2290:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2292:	0f b6       	in	r0, 0x3f	; 63
    2294:	f8 94       	cli
    2296:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2298:	8d 8d       	ldd	r24, Y+29	; 0x1d
    229a:	18 16       	cp	r1, r24
    229c:	c4 f4       	brge	.+48     	; 0x22ce <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    229e:	88 85       	ldd	r24, Y+8	; 0x08
    22a0:	88 23       	and	r24, r24
    22a2:	29 f4       	brne	.+10     	; 0x22ae <prvUnlockQueue+0x6a>
    22a4:	14 c0       	rjmp	.+40     	; 0x22ce <prvUnlockQueue+0x8a>
    22a6:	88 85       	ldd	r24, Y+8	; 0x08
    22a8:	88 23       	and	r24, r24
    22aa:	21 f4       	brne	.+8      	; 0x22b4 <prvUnlockQueue+0x70>
    22ac:	10 c0       	rjmp	.+32     	; 0x22ce <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22ae:	8e 01       	movw	r16, r28
    22b0:	08 5f       	subi	r16, 0xF8	; 248
    22b2:	1f 4f       	sbci	r17, 0xFF	; 255
    22b4:	c8 01       	movw	r24, r16
    22b6:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    22ba:	88 23       	and	r24, r24
    22bc:	11 f0       	breq	.+4      	; 0x22c2 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    22be:	0e 94 bf 19 	call	0x337e	; 0x337e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    22c2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    22c4:	81 50       	subi	r24, 0x01	; 1
    22c6:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22c8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    22ca:	18 16       	cp	r1, r24
    22cc:	64 f3       	brlt	.-40     	; 0x22a6 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    22ce:	8f ef       	ldi	r24, 0xFF	; 255
    22d0:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63
}
    22d6:	df 91       	pop	r29
    22d8:	cf 91       	pop	r28
    22da:	1f 91       	pop	r17
    22dc:	0f 91       	pop	r16
    22de:	08 95       	ret

000022e0 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    22e0:	cf 93       	push	r28
    22e2:	df 93       	push	r29
    22e4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    22e6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    22e8:	22 23       	and	r18, r18
    22ea:	59 f4       	brne	.+22     	; 0x2302 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    22ec:	88 81       	ld	r24, Y
    22ee:	99 81       	ldd	r25, Y+1	; 0x01
    22f0:	00 97       	sbiw	r24, 0x00	; 0
    22f2:	e1 f5       	brne	.+120    	; 0x236c <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    22f4:	8a 81       	ldd	r24, Y+2	; 0x02
    22f6:	9b 81       	ldd	r25, Y+3	; 0x03
    22f8:	0e 94 3b 1a 	call	0x3476	; 0x3476 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    22fc:	1b 82       	std	Y+3, r1	; 0x03
    22fe:	1a 82       	std	Y+2, r1	; 0x02
    2300:	35 c0       	rjmp	.+106    	; 0x236c <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2302:	44 23       	and	r20, r20
    2304:	b9 f4       	brne	.+46     	; 0x2334 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2306:	8c 81       	ldd	r24, Y+4	; 0x04
    2308:	9d 81       	ldd	r25, Y+5	; 0x05
    230a:	42 2f       	mov	r20, r18
    230c:	50 e0       	ldi	r21, 0x00	; 0
    230e:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2312:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2314:	8c 81       	ldd	r24, Y+4	; 0x04
    2316:	9d 81       	ldd	r25, Y+5	; 0x05
    2318:	82 0f       	add	r24, r18
    231a:	91 1d       	adc	r25, r1
    231c:	9d 83       	std	Y+5, r25	; 0x05
    231e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2320:	2a 81       	ldd	r18, Y+2	; 0x02
    2322:	3b 81       	ldd	r19, Y+3	; 0x03
    2324:	82 17       	cp	r24, r18
    2326:	93 07       	cpc	r25, r19
    2328:	08 f1       	brcs	.+66     	; 0x236c <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    232a:	88 81       	ld	r24, Y
    232c:	99 81       	ldd	r25, Y+1	; 0x01
    232e:	9d 83       	std	Y+5, r25	; 0x05
    2330:	8c 83       	std	Y+4, r24	; 0x04
    2332:	1c c0       	rjmp	.+56     	; 0x236c <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2334:	8e 81       	ldd	r24, Y+6	; 0x06
    2336:	9f 81       	ldd	r25, Y+7	; 0x07
    2338:	42 2f       	mov	r20, r18
    233a:	50 e0       	ldi	r21, 0x00	; 0
    233c:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2340:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2342:	50 e0       	ldi	r21, 0x00	; 0
    2344:	50 95       	com	r21
    2346:	41 95       	neg	r20
    2348:	5f 4f       	sbci	r21, 0xFF	; 255
    234a:	8e 81       	ldd	r24, Y+6	; 0x06
    234c:	9f 81       	ldd	r25, Y+7	; 0x07
    234e:	84 0f       	add	r24, r20
    2350:	95 1f       	adc	r25, r21
    2352:	9f 83       	std	Y+7, r25	; 0x07
    2354:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2356:	28 81       	ld	r18, Y
    2358:	39 81       	ldd	r19, Y+1	; 0x01
    235a:	82 17       	cp	r24, r18
    235c:	93 07       	cpc	r25, r19
    235e:	30 f4       	brcc	.+12     	; 0x236c <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2360:	8a 81       	ldd	r24, Y+2	; 0x02
    2362:	9b 81       	ldd	r25, Y+3	; 0x03
    2364:	48 0f       	add	r20, r24
    2366:	59 1f       	adc	r21, r25
    2368:	5f 83       	std	Y+7, r21	; 0x07
    236a:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    236c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    236e:	8f 5f       	subi	r24, 0xFF	; 255
    2370:	8a 8f       	std	Y+26, r24	; 0x1a
}
    2372:	df 91       	pop	r29
    2374:	cf 91       	pop	r28
    2376:	08 95       	ret

00002378 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    2378:	cf 93       	push	r28
    237a:	df 93       	push	r29
    237c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    237e:	0f b6       	in	r0, 0x3f	; 63
    2380:	f8 94       	cli
    2382:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2384:	48 81       	ld	r20, Y
    2386:	59 81       	ldd	r21, Y+1	; 0x01
    2388:	2b 8d       	ldd	r18, Y+27	; 0x1b
    238a:	30 e0       	ldi	r19, 0x00	; 0
    238c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    238e:	f0 e0       	ldi	r31, 0x00	; 0
    2390:	2e 9f       	mul	r18, r30
    2392:	c0 01       	movw	r24, r0
    2394:	2f 9f       	mul	r18, r31
    2396:	90 0d       	add	r25, r0
    2398:	3e 9f       	mul	r19, r30
    239a:	90 0d       	add	r25, r0
    239c:	11 24       	eor	r1, r1
    239e:	84 0f       	add	r24, r20
    23a0:	95 1f       	adc	r25, r21
    23a2:	9b 83       	std	Y+3, r25	; 0x03
    23a4:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    23a6:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    23a8:	5d 83       	std	Y+5, r21	; 0x05
    23aa:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    23ac:	c9 01       	movw	r24, r18
    23ae:	01 97       	sbiw	r24, 0x01	; 1
    23b0:	e8 9f       	mul	r30, r24
    23b2:	90 01       	movw	r18, r0
    23b4:	e9 9f       	mul	r30, r25
    23b6:	30 0d       	add	r19, r0
    23b8:	f8 9f       	mul	r31, r24
    23ba:	30 0d       	add	r19, r0
    23bc:	11 24       	eor	r1, r1
    23be:	24 0f       	add	r18, r20
    23c0:	35 1f       	adc	r19, r21
    23c2:	3f 83       	std	Y+7, r19	; 0x07
    23c4:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    23c6:	8f ef       	ldi	r24, 0xFF	; 255
    23c8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    23ca:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    23cc:	66 23       	and	r22, r22
    23ce:	61 f4       	brne	.+24     	; 0x23e8 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23d0:	88 85       	ldd	r24, Y+8	; 0x08
    23d2:	88 23       	and	r24, r24
    23d4:	89 f0       	breq	.+34     	; 0x23f8 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    23d6:	ce 01       	movw	r24, r28
    23d8:	08 96       	adiw	r24, 0x08	; 8
    23da:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    23de:	81 30       	cpi	r24, 0x01	; 1
    23e0:	59 f4       	brne	.+22     	; 0x23f8 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    23e2:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    23e6:	08 c0       	rjmp	.+16     	; 0x23f8 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    23e8:	ce 01       	movw	r24, r28
    23ea:	08 96       	adiw	r24, 0x08	; 8
    23ec:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    23f0:	ce 01       	movw	r24, r28
    23f2:	41 96       	adiw	r24, 0x11	; 17
    23f4:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    23f8:	0f 90       	pop	r0
    23fa:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	df 91       	pop	r29
    2400:	cf 91       	pop	r28
    2402:	08 95       	ret

00002404 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    2404:	0f 93       	push	r16
    2406:	1f 93       	push	r17
    2408:	cf 93       	push	r28
    240a:	df 93       	push	r29
    240c:	18 2f       	mov	r17, r24
    240e:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2410:	88 23       	and	r24, r24
    2412:	f9 f0       	breq	.+62     	; 0x2452 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2414:	8f e1       	ldi	r24, 0x1F	; 31
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
    241c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    241e:	00 97       	sbiw	r24, 0x00	; 0
    2420:	d9 f0       	breq	.+54     	; 0x2458 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2422:	01 9f       	mul	r16, r17
    2424:	c0 01       	movw	r24, r0
    2426:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2428:	01 96       	adiw	r24, 0x01	; 1
    242a:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
    242e:	99 83       	std	Y+1, r25	; 0x01
    2430:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    2432:	00 97       	sbiw	r24, 0x00	; 0
    2434:	41 f0       	breq	.+16     	; 0x2446 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2436:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2438:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    243a:	ce 01       	movw	r24, r28
    243c:	61 e0       	ldi	r22, 0x01	; 1
    243e:	0e 94 bc 11 	call	0x2378	; 0x2378 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2442:	ce 01       	movw	r24, r28
    2444:	0b c0       	rjmp	.+22     	; 0x245c <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2446:	ce 01       	movw	r24, r28
    2448:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    244c:	80 e0       	ldi	r24, 0x00	; 0
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	05 c0       	rjmp	.+10     	; 0x245c <xQueueGenericCreate+0x58>
    2452:	80 e0       	ldi	r24, 0x00	; 0
    2454:	90 e0       	ldi	r25, 0x00	; 0
    2456:	02 c0       	rjmp	.+4      	; 0x245c <xQueueGenericCreate+0x58>
    2458:	80 e0       	ldi	r24, 0x00	; 0
    245a:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    245c:	df 91       	pop	r29
    245e:	cf 91       	pop	r28
    2460:	1f 91       	pop	r17
    2462:	0f 91       	pop	r16
    2464:	08 95       	ret

00002466 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2466:	8f 92       	push	r8
    2468:	9f 92       	push	r9
    246a:	bf 92       	push	r11
    246c:	cf 92       	push	r12
    246e:	df 92       	push	r13
    2470:	ef 92       	push	r14
    2472:	ff 92       	push	r15
    2474:	0f 93       	push	r16
    2476:	1f 93       	push	r17
    2478:	cf 93       	push	r28
    247a:	df 93       	push	r29
    247c:	00 d0       	rcall	.+0      	; 0x247e <xQueueGenericSend+0x18>
    247e:	0f 92       	push	r0
    2480:	0f 92       	push	r0
    2482:	cd b7       	in	r28, 0x3d	; 61
    2484:	de b7       	in	r29, 0x3e	; 62
    2486:	8c 01       	movw	r16, r24
    2488:	4b 01       	movw	r8, r22
    248a:	5d 83       	std	Y+5, r21	; 0x05
    248c:	4c 83       	std	Y+4, r20	; 0x04
    248e:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2490:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2492:	ee 24       	eor	r14, r14
    2494:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2496:	cc 24       	eor	r12, r12
    2498:	dd 24       	eor	r13, r13
    249a:	68 94       	set
    249c:	c3 f8       	bld	r12, 3
    249e:	c8 0e       	add	r12, r24
    24a0:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    24a8:	f8 01       	movw	r30, r16
    24aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    24ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    24ae:	98 17       	cp	r25, r24
    24b0:	a8 f4       	brcc	.+42     	; 0x24dc <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    24b2:	c8 01       	movw	r24, r16
    24b4:	b4 01       	movw	r22, r8
    24b6:	4b 2d       	mov	r20, r11
    24b8:	0e 94 70 11 	call	0x22e0	; 0x22e0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24bc:	f8 01       	movw	r30, r16
    24be:	81 89       	ldd	r24, Z+17	; 0x11
    24c0:	88 23       	and	r24, r24
    24c2:	41 f0       	breq	.+16     	; 0x24d4 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    24c4:	c8 01       	movw	r24, r16
    24c6:	41 96       	adiw	r24, 0x11	; 17
    24c8:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    24cc:	81 30       	cpi	r24, 0x01	; 1
    24ce:	11 f4       	brne	.+4      	; 0x24d4 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    24d0:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    24d4:	0f 90       	pop	r0
    24d6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    24d8:	81 e0       	ldi	r24, 0x01	; 1
    24da:	52 c0       	rjmp	.+164    	; 0x2580 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    24dc:	8c 81       	ldd	r24, Y+4	; 0x04
    24de:	9d 81       	ldd	r25, Y+5	; 0x05
    24e0:	00 97       	sbiw	r24, 0x00	; 0
    24e2:	21 f4       	brne	.+8      	; 0x24ec <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    24e4:	0f 90       	pop	r0
    24e6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    24e8:	80 e0       	ldi	r24, 0x00	; 0
    24ea:	4a c0       	rjmp	.+148    	; 0x2580 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    24ec:	ff 20       	and	r15, r15
    24ee:	29 f4       	brne	.+10     	; 0x24fa <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    24f0:	ce 01       	movw	r24, r28
    24f2:	01 96       	adiw	r24, 0x01	; 1
    24f4:	0e 94 76 19 	call	0x32ec	; 0x32ec <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    24f8:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    24fa:	0f 90       	pop	r0
    24fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    24fe:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2502:	0f b6       	in	r0, 0x3f	; 63
    2504:	f8 94       	cli
    2506:	0f 92       	push	r0
    2508:	f8 01       	movw	r30, r16
    250a:	85 8d       	ldd	r24, Z+29	; 0x1d
    250c:	8f 3f       	cpi	r24, 0xFF	; 255
    250e:	09 f4       	brne	.+2      	; 0x2512 <xQueueGenericSend+0xac>
    2510:	15 8e       	std	Z+29, r1	; 0x1d
    2512:	f8 01       	movw	r30, r16
    2514:	86 8d       	ldd	r24, Z+30	; 0x1e
    2516:	8f 3f       	cpi	r24, 0xFF	; 255
    2518:	09 f4       	brne	.+2      	; 0x251c <xQueueGenericSend+0xb6>
    251a:	16 8e       	std	Z+30, r1	; 0x1e
    251c:	0f 90       	pop	r0
    251e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2520:	ce 01       	movw	r24, r28
    2522:	01 96       	adiw	r24, 0x01	; 1
    2524:	be 01       	movw	r22, r28
    2526:	6c 5f       	subi	r22, 0xFC	; 252
    2528:	7f 4f       	sbci	r23, 0xFF	; 255
    252a:	0e 94 81 19 	call	0x3302	; 0x3302 <xTaskCheckForTimeOut>
    252e:	88 23       	and	r24, r24
    2530:	09 f5       	brne	.+66     	; 0x2574 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2532:	0f b6       	in	r0, 0x3f	; 63
    2534:	f8 94       	cli
    2536:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2538:	f8 01       	movw	r30, r16
    253a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    253c:	0f 90       	pop	r0
    253e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2540:	f8 01       	movw	r30, r16
    2542:	83 8d       	ldd	r24, Z+27	; 0x1b
    2544:	98 17       	cp	r25, r24
    2546:	81 f4       	brne	.+32     	; 0x2568 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2548:	6c 81       	ldd	r22, Y+4	; 0x04
    254a:	7d 81       	ldd	r23, Y+5	; 0x05
    254c:	c6 01       	movw	r24, r12
    254e:	0e 94 02 19 	call	0x3204	; 0x3204 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2552:	c8 01       	movw	r24, r16
    2554:	0e 94 22 11 	call	0x2244	; 0x2244 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2558:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
    255c:	88 23       	and	r24, r24
    255e:	09 f0       	breq	.+2      	; 0x2562 <xQueueGenericSend+0xfc>
    2560:	a0 cf       	rjmp	.-192    	; 0x24a2 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    2562:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    2566:	9d cf       	rjmp	.-198    	; 0x24a2 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2568:	c8 01       	movw	r24, r16
    256a:	0e 94 22 11 	call	0x2244	; 0x2244 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    256e:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
    2572:	97 cf       	rjmp	.-210    	; 0x24a2 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2574:	c8 01       	movw	r24, r16
    2576:	0e 94 22 11 	call	0x2244	; 0x2244 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    257a:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    257e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2580:	0f 90       	pop	r0
    2582:	0f 90       	pop	r0
    2584:	0f 90       	pop	r0
    2586:	0f 90       	pop	r0
    2588:	0f 90       	pop	r0
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	1f 91       	pop	r17
    2590:	0f 91       	pop	r16
    2592:	ff 90       	pop	r15
    2594:	ef 90       	pop	r14
    2596:	df 90       	pop	r13
    2598:	cf 90       	pop	r12
    259a:	bf 90       	pop	r11
    259c:	9f 90       	pop	r9
    259e:	8f 90       	pop	r8
    25a0:	08 95       	ret

000025a2 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    25a6:	8f e1       	ldi	r24, 0x1F	; 31
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
    25ae:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    25b0:	00 97       	sbiw	r24, 0x00	; 0
    25b2:	f9 f0       	breq	.+62     	; 0x25f2 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    25b4:	1b 82       	std	Y+3, r1	; 0x03
    25b6:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    25b8:	19 82       	std	Y+1, r1	; 0x01
    25ba:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    25bc:	1d 82       	std	Y+5, r1	; 0x05
    25be:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    25c0:	1f 82       	std	Y+7, r1	; 0x07
    25c2:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    25c4:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    25ca:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    25cc:	8f ef       	ldi	r24, 0xFF	; 255
    25ce:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    25d0:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    25d2:	ce 01       	movw	r24, r28
    25d4:	08 96       	adiw	r24, 0x08	; 8
    25d6:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    25da:	ce 01       	movw	r24, r28
    25dc:	41 96       	adiw	r24, 0x11	; 17
    25de:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    25e2:	ce 01       	movw	r24, r28
    25e4:	60 e0       	ldi	r22, 0x00	; 0
    25e6:	70 e0       	ldi	r23, 0x00	; 0
    25e8:	40 e0       	ldi	r20, 0x00	; 0
    25ea:	50 e0       	ldi	r21, 0x00	; 0
    25ec:	20 e0       	ldi	r18, 0x00	; 0
    25ee:	0e 94 33 12 	call	0x2466	; 0x2466 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    25f2:	8c 2f       	mov	r24, r28
    25f4:	9d 2f       	mov	r25, r29
    25f6:	df 91       	pop	r29
    25f8:	cf 91       	pop	r28
    25fa:	08 95       	ret

000025fc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    25fc:	0f 93       	push	r16
    25fe:	1f 93       	push	r17
    2600:	cf 93       	push	r28
    2602:	df 93       	push	r29
    2604:	ec 01       	movw	r28, r24
    2606:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2608:	9a 8d       	ldd	r25, Y+26	; 0x1a
    260a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    260c:	98 17       	cp	r25, r24
    260e:	e0 f4       	brcc	.+56     	; 0x2648 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2610:	ce 01       	movw	r24, r28
    2612:	42 2f       	mov	r20, r18
    2614:	0e 94 70 11 	call	0x22e0	; 0x22e0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2618:	8e 8d       	ldd	r24, Y+30	; 0x1e
    261a:	8f 3f       	cpi	r24, 0xFF	; 255
    261c:	81 f4       	brne	.+32     	; 0x263e <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    261e:	89 89       	ldd	r24, Y+17	; 0x11
    2620:	88 23       	and	r24, r24
    2622:	a1 f0       	breq	.+40     	; 0x264c <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2624:	ce 01       	movw	r24, r28
    2626:	41 96       	adiw	r24, 0x11	; 17
    2628:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    262c:	88 23       	and	r24, r24
    262e:	81 f0       	breq	.+32     	; 0x2650 <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    2630:	01 15       	cp	r16, r1
    2632:	11 05       	cpc	r17, r1
    2634:	79 f0       	breq	.+30     	; 0x2654 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2636:	81 e0       	ldi	r24, 0x01	; 1
    2638:	f8 01       	movw	r30, r16
    263a:	80 83       	st	Z, r24
    263c:	0c c0       	rjmp	.+24     	; 0x2656 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    263e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2640:	8f 5f       	subi	r24, 0xFF	; 255
    2642:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	07 c0       	rjmp	.+14     	; 0x2656 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2648:	80 e0       	ldi	r24, 0x00	; 0
    264a:	05 c0       	rjmp	.+10     	; 0x2656 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	03 c0       	rjmp	.+6      	; 0x2656 <xQueueGenericSendFromISR+0x5a>
    2650:	81 e0       	ldi	r24, 0x01	; 1
    2652:	01 c0       	rjmp	.+2      	; 0x2656 <xQueueGenericSendFromISR+0x5a>
    2654:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2656:	df 91       	pop	r29
    2658:	cf 91       	pop	r28
    265a:	1f 91       	pop	r17
    265c:	0f 91       	pop	r16
    265e:	08 95       	ret

00002660 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2660:	8f 92       	push	r8
    2662:	9f 92       	push	r9
    2664:	bf 92       	push	r11
    2666:	cf 92       	push	r12
    2668:	df 92       	push	r13
    266a:	ef 92       	push	r14
    266c:	ff 92       	push	r15
    266e:	0f 93       	push	r16
    2670:	1f 93       	push	r17
    2672:	cf 93       	push	r28
    2674:	df 93       	push	r29
    2676:	00 d0       	rcall	.+0      	; 0x2678 <xQueueGenericReceive+0x18>
    2678:	0f 92       	push	r0
    267a:	0f 92       	push	r0
    267c:	cd b7       	in	r28, 0x3d	; 61
    267e:	de b7       	in	r29, 0x3e	; 62
    2680:	8c 01       	movw	r16, r24
    2682:	4b 01       	movw	r8, r22
    2684:	5d 83       	std	Y+5, r21	; 0x05
    2686:	4c 83       	std	Y+4, r20	; 0x04
    2688:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    268a:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    268c:	ee 24       	eor	r14, r14
    268e:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2690:	0f 2e       	mov	r0, r31
    2692:	f1 e1       	ldi	r31, 0x11	; 17
    2694:	cf 2e       	mov	r12, r31
    2696:	dd 24       	eor	r13, r13
    2698:	f0 2d       	mov	r31, r0
    269a:	c8 0e       	add	r12, r24
    269c:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    269e:	0f b6       	in	r0, 0x3f	; 63
    26a0:	f8 94       	cli
    26a2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    26a4:	f8 01       	movw	r30, r16
    26a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26a8:	88 23       	and	r24, r24
    26aa:	a1 f1       	breq	.+104    	; 0x2714 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    26ac:	e6 80       	ldd	r14, Z+6	; 0x06
    26ae:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    26b0:	c8 01       	movw	r24, r16
    26b2:	b4 01       	movw	r22, r8
    26b4:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    26b8:	bb 20       	and	r11, r11
    26ba:	d1 f4       	brne	.+52     	; 0x26f0 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    26bc:	f8 01       	movw	r30, r16
    26be:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c0:	81 50       	subi	r24, 0x01	; 1
    26c2:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    26c4:	80 81       	ld	r24, Z
    26c6:	91 81       	ldd	r25, Z+1	; 0x01
    26c8:	00 97       	sbiw	r24, 0x00	; 0
    26ca:	29 f4       	brne	.+10     	; 0x26d6 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    26cc:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <xTaskGetCurrentTaskHandle>
    26d0:	f8 01       	movw	r30, r16
    26d2:	93 83       	std	Z+3, r25	; 0x03
    26d4:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26d6:	f8 01       	movw	r30, r16
    26d8:	80 85       	ldd	r24, Z+8	; 0x08
    26da:	88 23       	and	r24, r24
    26dc:	b9 f0       	breq	.+46     	; 0x270c <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    26de:	c8 01       	movw	r24, r16
    26e0:	08 96       	adiw	r24, 0x08	; 8
    26e2:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    26e6:	81 30       	cpi	r24, 0x01	; 1
    26e8:	89 f4       	brne	.+34     	; 0x270c <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    26ea:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    26ee:	0e c0       	rjmp	.+28     	; 0x270c <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    26f0:	f8 01       	movw	r30, r16
    26f2:	f7 82       	std	Z+7, r15	; 0x07
    26f4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26f6:	81 89       	ldd	r24, Z+17	; 0x11
    26f8:	88 23       	and	r24, r24
    26fa:	41 f0       	breq	.+16     	; 0x270c <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26fc:	c8 01       	movw	r24, r16
    26fe:	41 96       	adiw	r24, 0x11	; 17
    2700:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    2704:	88 23       	and	r24, r24
    2706:	11 f0       	breq	.+4      	; 0x270c <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2708:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    270c:	0f 90       	pop	r0
    270e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2710:	81 e0       	ldi	r24, 0x01	; 1
    2712:	5f c0       	rjmp	.+190    	; 0x27d2 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2714:	8c 81       	ldd	r24, Y+4	; 0x04
    2716:	9d 81       	ldd	r25, Y+5	; 0x05
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	21 f4       	brne	.+8      	; 0x2724 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    271c:	0f 90       	pop	r0
    271e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2720:	80 e0       	ldi	r24, 0x00	; 0
    2722:	57 c0       	rjmp	.+174    	; 0x27d2 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    2724:	ff 20       	and	r15, r15
    2726:	29 f4       	brne	.+10     	; 0x2732 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2728:	ce 01       	movw	r24, r28
    272a:	01 96       	adiw	r24, 0x01	; 1
    272c:	0e 94 76 19 	call	0x32ec	; 0x32ec <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2730:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    2732:	0f 90       	pop	r0
    2734:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2736:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	0f 92       	push	r0
    2740:	f8 01       	movw	r30, r16
    2742:	85 8d       	ldd	r24, Z+29	; 0x1d
    2744:	8f 3f       	cpi	r24, 0xFF	; 255
    2746:	09 f4       	brne	.+2      	; 0x274a <xQueueGenericReceive+0xea>
    2748:	15 8e       	std	Z+29, r1	; 0x1d
    274a:	f8 01       	movw	r30, r16
    274c:	86 8d       	ldd	r24, Z+30	; 0x1e
    274e:	8f 3f       	cpi	r24, 0xFF	; 255
    2750:	09 f4       	brne	.+2      	; 0x2754 <xQueueGenericReceive+0xf4>
    2752:	16 8e       	std	Z+30, r1	; 0x1e
    2754:	0f 90       	pop	r0
    2756:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2758:	ce 01       	movw	r24, r28
    275a:	01 96       	adiw	r24, 0x01	; 1
    275c:	be 01       	movw	r22, r28
    275e:	6c 5f       	subi	r22, 0xFC	; 252
    2760:	7f 4f       	sbci	r23, 0xFF	; 255
    2762:	0e 94 81 19 	call	0x3302	; 0x3302 <xTaskCheckForTimeOut>
    2766:	88 23       	and	r24, r24
    2768:	71 f5       	brne	.+92     	; 0x27c6 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    276a:	0f b6       	in	r0, 0x3f	; 63
    276c:	f8 94       	cli
    276e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2770:	f8 01       	movw	r30, r16
    2772:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2774:	0f 90       	pop	r0
    2776:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2778:	88 23       	and	r24, r24
    277a:	f9 f4       	brne	.+62     	; 0x27ba <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    277c:	f8 01       	movw	r30, r16
    277e:	80 81       	ld	r24, Z
    2780:	91 81       	ldd	r25, Z+1	; 0x01
    2782:	00 97       	sbiw	r24, 0x00	; 0
    2784:	51 f4       	brne	.+20     	; 0x279a <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    2786:	0f b6       	in	r0, 0x3f	; 63
    2788:	f8 94       	cli
    278a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    278c:	f8 01       	movw	r30, r16
    278e:	82 81       	ldd	r24, Z+2	; 0x02
    2790:	93 81       	ldd	r25, Z+3	; 0x03
    2792:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2796:	0f 90       	pop	r0
    2798:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    279a:	6c 81       	ldd	r22, Y+4	; 0x04
    279c:	7d 81       	ldd	r23, Y+5	; 0x05
    279e:	c6 01       	movw	r24, r12
    27a0:	0e 94 02 19 	call	0x3204	; 0x3204 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    27a4:	c8 01       	movw	r24, r16
    27a6:	0e 94 22 11 	call	0x2244	; 0x2244 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    27aa:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
    27ae:	88 23       	and	r24, r24
    27b0:	09 f0       	breq	.+2      	; 0x27b4 <xQueueGenericReceive+0x154>
    27b2:	75 cf       	rjmp	.-278    	; 0x269e <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    27b4:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    27b8:	72 cf       	rjmp	.-284    	; 0x269e <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    27ba:	c8 01       	movw	r24, r16
    27bc:	0e 94 22 11 	call	0x2244	; 0x2244 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    27c0:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
    27c4:	6c cf       	rjmp	.-296    	; 0x269e <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    27c6:	c8 01       	movw	r24, r16
    27c8:	0e 94 22 11 	call	0x2244	; 0x2244 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    27cc:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    27d0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    27d2:	0f 90       	pop	r0
    27d4:	0f 90       	pop	r0
    27d6:	0f 90       	pop	r0
    27d8:	0f 90       	pop	r0
    27da:	0f 90       	pop	r0
    27dc:	df 91       	pop	r29
    27de:	cf 91       	pop	r28
    27e0:	1f 91       	pop	r17
    27e2:	0f 91       	pop	r16
    27e4:	ff 90       	pop	r15
    27e6:	ef 90       	pop	r14
    27e8:	df 90       	pop	r13
    27ea:	cf 90       	pop	r12
    27ec:	bf 90       	pop	r11
    27ee:	9f 90       	pop	r9
    27f0:	8f 90       	pop	r8
    27f2:	08 95       	ret

000027f4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    27f4:	0f 93       	push	r16
    27f6:	1f 93       	push	r17
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
    27fc:	ec 01       	movw	r28, r24
    27fe:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2800:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2802:	88 23       	and	r24, r24
    2804:	f1 f0       	breq	.+60     	; 0x2842 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2806:	ce 01       	movw	r24, r28
    2808:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    280c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    280e:	81 50       	subi	r24, 0x01	; 1
    2810:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2812:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2814:	8f 3f       	cpi	r24, 0xFF	; 255
    2816:	81 f4       	brne	.+32     	; 0x2838 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2818:	88 85       	ldd	r24, Y+8	; 0x08
    281a:	88 23       	and	r24, r24
    281c:	a1 f0       	breq	.+40     	; 0x2846 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    281e:	ce 01       	movw	r24, r28
    2820:	08 96       	adiw	r24, 0x08	; 8
    2822:	0e 94 2e 19 	call	0x325c	; 0x325c <xTaskRemoveFromEventList>
    2826:	88 23       	and	r24, r24
    2828:	81 f0       	breq	.+32     	; 0x284a <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    282a:	01 15       	cp	r16, r1
    282c:	11 05       	cpc	r17, r1
    282e:	79 f0       	breq	.+30     	; 0x284e <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	f8 01       	movw	r30, r16
    2834:	80 83       	st	Z, r24
    2836:	0c c0       	rjmp	.+24     	; 0x2850 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2838:	8d 8d       	ldd	r24, Y+29	; 0x1d
    283a:	8f 5f       	subi	r24, 0xFF	; 255
    283c:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    283e:	81 e0       	ldi	r24, 0x01	; 1
    2840:	07 c0       	rjmp	.+14     	; 0x2850 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    2842:	80 e0       	ldi	r24, 0x00	; 0
    2844:	05 c0       	rjmp	.+10     	; 0x2850 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2846:	81 e0       	ldi	r24, 0x01	; 1
    2848:	03 c0       	rjmp	.+6      	; 0x2850 <xQueueReceiveFromISR+0x5c>
    284a:	81 e0       	ldi	r24, 0x01	; 1
    284c:	01 c0       	rjmp	.+2      	; 0x2850 <xQueueReceiveFromISR+0x5c>
    284e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2850:	df 91       	pop	r29
    2852:	cf 91       	pop	r28
    2854:	1f 91       	pop	r17
    2856:	0f 91       	pop	r16
    2858:	08 95       	ret

0000285a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    285a:	0f b6       	in	r0, 0x3f	; 63
    285c:	f8 94       	cli
    285e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2860:	fc 01       	movw	r30, r24
    2862:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2864:	0f 90       	pop	r0
    2866:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2868:	08 95       	ret

0000286a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    286a:	fc 01       	movw	r30, r24
    286c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    286e:	08 95       	ret

00002870 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2870:	cf 93       	push	r28
    2872:	df 93       	push	r29
    2874:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2876:	88 81       	ld	r24, Y
    2878:	99 81       	ldd	r25, Y+1	; 0x01
    287a:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
	vPortFree( pxQueue );
    287e:	ce 01       	movw	r24, r28
    2880:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
}
    2884:	df 91       	pop	r29
    2886:	cf 91       	pop	r28
    2888:	08 95       	ret

0000288a <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    288a:	fc 01       	movw	r30, r24
    288c:	92 8d       	ldd	r25, Z+26	; 0x1a
    288e:	81 e0       	ldi	r24, 0x01	; 1
    2890:	91 11       	cpse	r25, r1
    2892:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    2894:	08 95       	ret

00002896 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2896:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2898:	22 8d       	ldd	r18, Z+26	; 0x1a
    289a:	81 e0       	ldi	r24, 0x01	; 1
    289c:	93 8d       	ldd	r25, Z+27	; 0x1b
    289e:	29 13       	cpse	r18, r25
    28a0:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    28a2:	08 95       	ret

000028a4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    28a4:	cf 93       	push	r28
    28a6:	df 93       	push	r29
    28a8:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    28aa:	e0 91 ce 1a 	lds	r30, 0x1ACE
    28ae:	f0 91 cf 1a 	lds	r31, 0x1ACF
    28b2:	93 83       	std	Z+3, r25	; 0x03
    28b4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    28b6:	80 91 d6 1a 	lds	r24, 0x1AD6
    28ba:	90 91 d7 1a 	lds	r25, 0x1AD7
    28be:	c8 17       	cp	r28, r24
    28c0:	d9 07       	cpc	r29, r25
    28c2:	68 f4       	brcc	.+26     	; 0x28de <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28c4:	80 91 d9 1a 	lds	r24, 0x1AD9
    28c8:	90 91 da 1a 	lds	r25, 0x1ADA
    28cc:	60 91 ce 1a 	lds	r22, 0x1ACE
    28d0:	70 91 cf 1a 	lds	r23, 0x1ACF
    28d4:	6e 5f       	subi	r22, 0xFE	; 254
    28d6:	7f 4f       	sbci	r23, 0xFF	; 255
    28d8:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vListInsert>
    28dc:	17 c0       	rjmp	.+46     	; 0x290c <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28de:	80 91 db 1a 	lds	r24, 0x1ADB
    28e2:	90 91 dc 1a 	lds	r25, 0x1ADC
    28e6:	60 91 ce 1a 	lds	r22, 0x1ACE
    28ea:	70 91 cf 1a 	lds	r23, 0x1ACF
    28ee:	6e 5f       	subi	r22, 0xFE	; 254
    28f0:	7f 4f       	sbci	r23, 0xFF	; 255
    28f2:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    28f6:	80 91 59 02 	lds	r24, 0x0259
    28fa:	90 91 5a 02 	lds	r25, 0x025A
    28fe:	c8 17       	cp	r28, r24
    2900:	d9 07       	cpc	r29, r25
    2902:	20 f4       	brcc	.+8      	; 0x290c <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2904:	d0 93 5a 02 	sts	0x025A, r29
    2908:	c0 93 59 02 	sts	0x0259, r28
		}
	}
}
    290c:	df 91       	pop	r29
    290e:	cf 91       	pop	r28
    2910:	08 95       	ret

00002912 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2912:	cf ed       	ldi	r28, 0xDF	; 223
    2914:	da e1       	ldi	r29, 0x1A	; 26
    2916:	88 81       	ld	r24, Y
    2918:	82 30       	cpi	r24, 0x02	; 2
    291a:	e8 f3       	brcs	.-6      	; 0x2916 <prvIdleTask+0x4>
			{
				taskYIELD();
    291c:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    2920:	fa cf       	rjmp	.-12     	; 0x2916 <prvIdleTask+0x4>

00002922 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2922:	4f 92       	push	r4
    2924:	5f 92       	push	r5
    2926:	6f 92       	push	r6
    2928:	7f 92       	push	r7
    292a:	8f 92       	push	r8
    292c:	9f 92       	push	r9
    292e:	bf 92       	push	r11
    2930:	cf 92       	push	r12
    2932:	df 92       	push	r13
    2934:	ef 92       	push	r14
    2936:	ff 92       	push	r15
    2938:	0f 93       	push	r16
    293a:	1f 93       	push	r17
    293c:	cf 93       	push	r28
    293e:	df 93       	push	r29
    2940:	2c 01       	movw	r4, r24
    2942:	4b 01       	movw	r8, r22
    2944:	ea 01       	movw	r28, r20
    2946:	39 01       	movw	r6, r18
    2948:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    294a:	8a e2       	ldi	r24, 0x2A	; 42
    294c:	90 e0       	ldi	r25, 0x00	; 0
    294e:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
    2952:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    2954:	00 97       	sbiw	r24, 0x00	; 0
    2956:	09 f4       	brne	.+2      	; 0x295a <xTaskGenericCreate+0x38>
    2958:	e3 c0       	rjmp	.+454    	; 0x2b20 <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    295a:	c1 14       	cp	r12, r1
    295c:	d1 04       	cpc	r13, r1
    295e:	09 f0       	breq	.+2      	; 0x2962 <xTaskGenericCreate+0x40>
    2960:	f4 c0       	rjmp	.+488    	; 0x2b4a <xTaskGenericCreate+0x228>
    2962:	ce 01       	movw	r24, r28
    2964:	0e 94 b7 0b 	call	0x176e	; 0x176e <pvPortMalloc>
    2968:	6c 01       	movw	r12, r24
    296a:	f8 01       	movw	r30, r16
    296c:	90 8f       	std	Z+24, r25	; 0x18
    296e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2970:	00 97       	sbiw	r24, 0x00	; 0
    2972:	29 f4       	brne	.+10     	; 0x297e <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2974:	c8 01       	movw	r24, r16
    2976:	0e 94 57 0c 	call	0x18ae	; 0x18ae <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    297a:	8f ef       	ldi	r24, 0xFF	; 255
    297c:	d6 c0       	rjmp	.+428    	; 0x2b2a <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    297e:	c6 01       	movw	r24, r12
    2980:	65 ea       	ldi	r22, 0xA5	; 165
    2982:	70 e0       	ldi	r23, 0x00	; 0
    2984:	ae 01       	movw	r20, r28
    2986:	0e 94 12 1e 	call	0x3c24	; 0x3c24 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    298a:	9e 01       	movw	r18, r28
    298c:	21 50       	subi	r18, 0x01	; 1
    298e:	30 40       	sbci	r19, 0x00	; 0
    2990:	f8 01       	movw	r30, r16
    2992:	87 89       	ldd	r24, Z+23	; 0x17
    2994:	90 8d       	ldd	r25, Z+24	; 0x18
    2996:	6c 01       	movw	r12, r24
    2998:	c2 0e       	add	r12, r18
    299a:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    299c:	c8 01       	movw	r24, r16
    299e:	49 96       	adiw	r24, 0x19	; 25
    29a0:	b4 01       	movw	r22, r8
    29a2:	40 e1       	ldi	r20, 0x10	; 16
    29a4:	50 e0       	ldi	r21, 0x00	; 0
    29a6:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    29aa:	f8 01       	movw	r30, r16
    29ac:	10 a6       	lds	r17, 0xb0
    29ae:	cb 2d       	mov	r28, r11
    29b0:	f3 e0       	ldi	r31, 0x03	; 3
    29b2:	fb 15       	cp	r31, r11
    29b4:	08 f4       	brcc	.+2      	; 0x29b8 <xTaskGenericCreate+0x96>
    29b6:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    29b8:	f8 01       	movw	r30, r16
    29ba:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    29bc:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    29be:	88 24       	eor	r8, r8
    29c0:	99 24       	eor	r9, r9
    29c2:	68 94       	set
    29c4:	81 f8       	bld	r8, 1
    29c6:	80 0e       	add	r8, r16
    29c8:	91 1e       	adc	r9, r17
    29ca:	c4 01       	movw	r24, r8
    29cc:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    29d0:	c8 01       	movw	r24, r16
    29d2:	0c 96       	adiw	r24, 0x0c	; 12
    29d4:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    29d8:	f8 01       	movw	r30, r16
    29da:	11 87       	std	Z+9, r17	; 0x09
    29dc:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    29de:	84 e0       	ldi	r24, 0x04	; 4
    29e0:	90 e0       	ldi	r25, 0x00	; 0
    29e2:	8c 1b       	sub	r24, r28
    29e4:	91 09       	sbc	r25, r1
    29e6:	95 87       	std	Z+13, r25	; 0x0d
    29e8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    29ea:	13 8b       	std	Z+19, r17	; 0x13
    29ec:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    29ee:	c6 01       	movw	r24, r12
    29f0:	b2 01       	movw	r22, r4
    29f2:	a3 01       	movw	r20, r6
    29f4:	0e 94 54 0f 	call	0x1ea8	; 0x1ea8 <pxPortInitialiseStack>
    29f8:	f8 01       	movw	r30, r16
    29fa:	91 83       	std	Z+1, r25	; 0x01
    29fc:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    29fe:	e1 14       	cp	r14, r1
    2a00:	f1 04       	cpc	r15, r1
    2a02:	19 f0       	breq	.+6      	; 0x2a0a <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2a04:	f7 01       	movw	r30, r14
    2a06:	11 83       	std	Z+1, r17	; 0x01
    2a08:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2a0a:	0f b6       	in	r0, 0x3f	; 63
    2a0c:	f8 94       	cli
    2a0e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2a10:	80 91 d8 1a 	lds	r24, 0x1AD8
    2a14:	8f 5f       	subi	r24, 0xFF	; 255
    2a16:	80 93 d8 1a 	sts	0x1AD8, r24
			if( pxCurrentTCB == NULL )
    2a1a:	80 91 ce 1a 	lds	r24, 0x1ACE
    2a1e:	90 91 cf 1a 	lds	r25, 0x1ACF
    2a22:	00 97       	sbiw	r24, 0x00	; 0
    2a24:	d9 f5       	brne	.+118    	; 0x2a9c <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2a26:	10 93 cf 1a 	sts	0x1ACF, r17
    2a2a:	00 93 ce 1a 	sts	0x1ACE, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2a2e:	80 91 d8 1a 	lds	r24, 0x1AD8
    2a32:	81 30       	cpi	r24, 0x01	; 1
    2a34:	09 f0       	breq	.+2      	; 0x2a38 <xTaskGenericCreate+0x116>
    2a36:	41 c0       	rjmp	.+130    	; 0x2aba <xTaskGenericCreate+0x198>
    2a38:	c0 e0       	ldi	r28, 0x00	; 0
    2a3a:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2a3c:	ce 01       	movw	r24, r28
    2a3e:	88 0f       	add	r24, r24
    2a40:	99 1f       	adc	r25, r25
    2a42:	88 0f       	add	r24, r24
    2a44:	99 1f       	adc	r25, r25
    2a46:	88 0f       	add	r24, r24
    2a48:	99 1f       	adc	r25, r25
    2a4a:	8c 0f       	add	r24, r28
    2a4c:	9d 1f       	adc	r25, r29
    2a4e:	81 52       	subi	r24, 0x21	; 33
    2a50:	95 4e       	sbci	r25, 0xE5	; 229
    2a52:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
    2a56:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2a58:	c4 30       	cpi	r28, 0x04	; 4
    2a5a:	d1 05       	cpc	r29, r1
    2a5c:	79 f7       	brne	.-34     	; 0x2a3c <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2a5e:	c3 e0       	ldi	r28, 0x03	; 3
    2a60:	db e1       	ldi	r29, 0x1B	; 27
    2a62:	ce 01       	movw	r24, r28
    2a64:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2a68:	0f 2e       	mov	r0, r31
    2a6a:	fc e0       	ldi	r31, 0x0C	; 12
    2a6c:	ef 2e       	mov	r14, r31
    2a6e:	fb e1       	ldi	r31, 0x1B	; 27
    2a70:	ff 2e       	mov	r15, r31
    2a72:	f0 2d       	mov	r31, r0
    2a74:	c7 01       	movw	r24, r14
    2a76:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2a7a:	85 e1       	ldi	r24, 0x15	; 21
    2a7c:	9b e1       	ldi	r25, 0x1B	; 27
    2a7e:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    2a82:	8e e1       	ldi	r24, 0x1E	; 30
    2a84:	9b e1       	ldi	r25, 0x1B	; 27
    2a86:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2a8a:	d0 93 dc 1a 	sts	0x1ADC, r29
    2a8e:	c0 93 db 1a 	sts	0x1ADB, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2a92:	f0 92 da 1a 	sts	0x1ADA, r15
    2a96:	e0 92 d9 1a 	sts	0x1AD9, r14
    2a9a:	0f c0       	rjmp	.+30     	; 0x2aba <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2a9c:	80 91 d4 1a 	lds	r24, 0x1AD4
    2aa0:	88 23       	and	r24, r24
    2aa2:	59 f4       	brne	.+22     	; 0x2aba <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2aa4:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2aa8:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2aac:	86 89       	ldd	r24, Z+22	; 0x16
    2aae:	b8 16       	cp	r11, r24
    2ab0:	20 f0       	brcs	.+8      	; 0x2aba <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    2ab2:	10 93 cf 1a 	sts	0x1ACF, r17
    2ab6:	00 93 ce 1a 	sts	0x1ACE, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2aba:	f8 01       	movw	r30, r16
    2abc:	86 89       	ldd	r24, Z+22	; 0x16
    2abe:	90 91 dd 1a 	lds	r25, 0x1ADD
    2ac2:	98 17       	cp	r25, r24
    2ac4:	10 f4       	brcc	.+4      	; 0x2aca <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2ac6:	80 93 dd 1a 	sts	0x1ADD, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2aca:	90 91 de 1a 	lds	r25, 0x1ADE
    2ace:	9f 5f       	subi	r25, 0xFF	; 255
    2ad0:	90 93 de 1a 	sts	0x1ADE, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    2ad4:	90 91 d5 1a 	lds	r25, 0x1AD5
    2ad8:	98 17       	cp	r25, r24
    2ada:	10 f4       	brcc	.+4      	; 0x2ae0 <xTaskGenericCreate+0x1be>
    2adc:	80 93 d5 1a 	sts	0x1AD5, r24
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	9c 01       	movw	r18, r24
    2ae4:	22 0f       	add	r18, r18
    2ae6:	33 1f       	adc	r19, r19
    2ae8:	22 0f       	add	r18, r18
    2aea:	33 1f       	adc	r19, r19
    2aec:	22 0f       	add	r18, r18
    2aee:	33 1f       	adc	r19, r19
    2af0:	82 0f       	add	r24, r18
    2af2:	93 1f       	adc	r25, r19
    2af4:	81 52       	subi	r24, 0x21	; 33
    2af6:	95 4e       	sbci	r25, 0xE5	; 229
    2af8:	b4 01       	movw	r22, r8
    2afa:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2afe:	0f 90       	pop	r0
    2b00:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2b02:	80 91 d4 1a 	lds	r24, 0x1AD4
    2b06:	88 23       	and	r24, r24
    2b08:	69 f0       	breq	.+26     	; 0x2b24 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2b0a:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2b0e:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2b12:	86 89       	ldd	r24, Z+22	; 0x16
    2b14:	8b 15       	cp	r24, r11
    2b16:	40 f4       	brcc	.+16     	; 0x2b28 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    2b18:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2b1c:	81 e0       	ldi	r24, 0x01	; 1
    2b1e:	05 c0       	rjmp	.+10     	; 0x2b2a <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2b20:	8f ef       	ldi	r24, 0xFF	; 255
    2b22:	03 c0       	rjmp	.+6      	; 0x2b2a <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	01 c0       	rjmp	.+2      	; 0x2b2a <xTaskGenericCreate+0x208>
    2b28:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2b2a:	df 91       	pop	r29
    2b2c:	cf 91       	pop	r28
    2b2e:	1f 91       	pop	r17
    2b30:	0f 91       	pop	r16
    2b32:	ff 90       	pop	r15
    2b34:	ef 90       	pop	r14
    2b36:	df 90       	pop	r13
    2b38:	cf 90       	pop	r12
    2b3a:	bf 90       	pop	r11
    2b3c:	9f 90       	pop	r9
    2b3e:	8f 90       	pop	r8
    2b40:	7f 90       	pop	r7
    2b42:	6f 90       	pop	r6
    2b44:	5f 90       	pop	r5
    2b46:	4f 90       	pop	r4
    2b48:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2b4a:	fc 01       	movw	r30, r24
    2b4c:	d0 8e       	std	Z+24, r13	; 0x18
    2b4e:	c7 8a       	std	Z+23, r12	; 0x17
    2b50:	16 cf       	rjmp	.-468    	; 0x297e <xTaskGenericCreate+0x5c>

00002b52 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2b52:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2b54:	82 85       	ldd	r24, Z+10	; 0x0a
    2b56:	93 85       	ldd	r25, Z+11	; 0x0b
    2b58:	2b e1       	ldi	r18, 0x1B	; 27
    2b5a:	8e 31       	cpi	r24, 0x1E	; 30
    2b5c:	92 07       	cpc	r25, r18
    2b5e:	61 f4       	brne	.+24     	; 0x2b78 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    2b60:	24 89       	ldd	r18, Z+20	; 0x14
    2b62:	35 89       	ldd	r19, Z+21	; 0x15
    2b64:	8b e1       	ldi	r24, 0x1B	; 27
    2b66:	25 31       	cpi	r18, 0x15	; 21
    2b68:	38 07       	cpc	r19, r24
    2b6a:	41 f0       	breq	.+16     	; 0x2b7c <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    2b6c:	81 e0       	ldi	r24, 0x01	; 1
    2b6e:	21 15       	cp	r18, r1
    2b70:	31 05       	cpc	r19, r1
    2b72:	29 f0       	breq	.+10     	; 0x2b7e <xTaskIsTaskSuspended+0x2c>
    2b74:	80 e0       	ldi	r24, 0x00	; 0
    2b76:	08 95       	ret
    2b78:	80 e0       	ldi	r24, 0x00	; 0
    2b7a:	08 95       	ret
    2b7c:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    2b7e:	08 95       	ret

00002b80 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    2b80:	0f 93       	push	r16
    2b82:	1f 93       	push	r17
    2b84:	cf 93       	push	r28
    2b86:	df 93       	push	r29
    2b88:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    2b8a:	00 97       	sbiw	r24, 0x00	; 0
    2b8c:	b9 f1       	breq	.+110    	; 0x2bfc <vTaskResume+0x7c>
    2b8e:	80 91 ce 1a 	lds	r24, 0x1ACE
    2b92:	90 91 cf 1a 	lds	r25, 0x1ACF
    2b96:	c8 17       	cp	r28, r24
    2b98:	d9 07       	cpc	r29, r25
    2b9a:	81 f1       	breq	.+96     	; 0x2bfc <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    2b9c:	0f b6       	in	r0, 0x3f	; 63
    2b9e:	f8 94       	cli
    2ba0:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2ba2:	ce 01       	movw	r24, r28
    2ba4:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <xTaskIsTaskSuspended>
    2ba8:	81 30       	cpi	r24, 0x01	; 1
    2baa:	31 f5       	brne	.+76     	; 0x2bf8 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    2bac:	8e 01       	movw	r16, r28
    2bae:	0e 5f       	subi	r16, 0xFE	; 254
    2bb0:	1f 4f       	sbci	r17, 0xFF	; 255
    2bb2:	c8 01       	movw	r24, r16
    2bb4:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2bb8:	8e 89       	ldd	r24, Y+22	; 0x16
    2bba:	90 91 d5 1a 	lds	r25, 0x1AD5
    2bbe:	98 17       	cp	r25, r24
    2bc0:	10 f4       	brcc	.+4      	; 0x2bc6 <vTaskResume+0x46>
    2bc2:	80 93 d5 1a 	sts	0x1AD5, r24
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	9c 01       	movw	r18, r24
    2bca:	22 0f       	add	r18, r18
    2bcc:	33 1f       	adc	r19, r19
    2bce:	22 0f       	add	r18, r18
    2bd0:	33 1f       	adc	r19, r19
    2bd2:	22 0f       	add	r18, r18
    2bd4:	33 1f       	adc	r19, r19
    2bd6:	82 0f       	add	r24, r18
    2bd8:	93 1f       	adc	r25, r19
    2bda:	81 52       	subi	r24, 0x21	; 33
    2bdc:	95 4e       	sbci	r25, 0xE5	; 229
    2bde:	b8 01       	movw	r22, r16
    2be0:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2be4:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2be8:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2bec:	9e 89       	ldd	r25, Y+22	; 0x16
    2bee:	86 89       	ldd	r24, Z+22	; 0x16
    2bf0:	98 17       	cp	r25, r24
    2bf2:	10 f0       	brcs	.+4      	; 0x2bf8 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    2bf4:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    2bf8:	0f 90       	pop	r0
    2bfa:	0f be       	out	0x3f, r0	; 63
		}
	}
    2bfc:	df 91       	pop	r29
    2bfe:	cf 91       	pop	r28
    2c00:	1f 91       	pop	r17
    2c02:	0f 91       	pop	r16
    2c04:	08 95       	ret

00002c06 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    2c06:	ef 92       	push	r14
    2c08:	ff 92       	push	r15
    2c0a:	1f 93       	push	r17
    2c0c:	cf 93       	push	r28
    2c0e:	df 93       	push	r29
    2c10:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2c12:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <xTaskIsTaskSuspended>
    2c16:	81 30       	cpi	r24, 0x01	; 1
    2c18:	b9 f5       	brne	.+110    	; 0x2c88 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c1a:	80 91 d3 1a 	lds	r24, 0x1AD3
    2c1e:	88 23       	and	r24, r24
    2c20:	51 f5       	brne	.+84     	; 0x2c76 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    2c22:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2c26:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2c2a:	11 e0       	ldi	r17, 0x01	; 1
    2c2c:	9e 89       	ldd	r25, Y+22	; 0x16
    2c2e:	86 89       	ldd	r24, Z+22	; 0x16
    2c30:	98 17       	cp	r25, r24
    2c32:	08 f4       	brcc	.+2      	; 0x2c36 <xTaskResumeFromISR+0x30>
    2c34:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    2c36:	ee 24       	eor	r14, r14
    2c38:	ff 24       	eor	r15, r15
    2c3a:	68 94       	set
    2c3c:	e1 f8       	bld	r14, 1
    2c3e:	ec 0e       	add	r14, r28
    2c40:	fd 1e       	adc	r15, r29
    2c42:	c7 01       	movw	r24, r14
    2c44:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2c48:	8e 89       	ldd	r24, Y+22	; 0x16
    2c4a:	90 91 d5 1a 	lds	r25, 0x1AD5
    2c4e:	98 17       	cp	r25, r24
    2c50:	10 f4       	brcc	.+4      	; 0x2c56 <xTaskResumeFromISR+0x50>
    2c52:	80 93 d5 1a 	sts	0x1AD5, r24
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	9c 01       	movw	r18, r24
    2c5a:	22 0f       	add	r18, r18
    2c5c:	33 1f       	adc	r19, r19
    2c5e:	22 0f       	add	r18, r18
    2c60:	33 1f       	adc	r19, r19
    2c62:	22 0f       	add	r18, r18
    2c64:	33 1f       	adc	r19, r19
    2c66:	82 0f       	add	r24, r18
    2c68:	93 1f       	adc	r25, r19
    2c6a:	81 52       	subi	r24, 0x21	; 33
    2c6c:	95 4e       	sbci	r25, 0xE5	; 229
    2c6e:	b7 01       	movw	r22, r14
    2c70:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
    2c74:	0a c0       	rjmp	.+20     	; 0x2c8a <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2c76:	be 01       	movw	r22, r28
    2c78:	64 5f       	subi	r22, 0xF4	; 244
    2c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7c:	85 e1       	ldi	r24, 0x15	; 21
    2c7e:	9b e1       	ldi	r25, 0x1B	; 27
    2c80:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    2c84:	10 e0       	ldi	r17, 0x00	; 0
    2c86:	01 c0       	rjmp	.+2      	; 0x2c8a <xTaskResumeFromISR+0x84>
    2c88:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    2c8a:	81 2f       	mov	r24, r17
    2c8c:	df 91       	pop	r29
    2c8e:	cf 91       	pop	r28
    2c90:	1f 91       	pop	r17
    2c92:	ff 90       	pop	r15
    2c94:	ef 90       	pop	r14
    2c96:	08 95       	ret

00002c98 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2c98:	af 92       	push	r10
    2c9a:	bf 92       	push	r11
    2c9c:	cf 92       	push	r12
    2c9e:	df 92       	push	r13
    2ca0:	ef 92       	push	r14
    2ca2:	ff 92       	push	r15
    2ca4:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2ca6:	89 e8       	ldi	r24, 0x89	; 137
    2ca8:	94 e1       	ldi	r25, 0x14	; 20
    2caa:	64 e5       	ldi	r22, 0x54	; 84
    2cac:	72 e0       	ldi	r23, 0x02	; 2
    2cae:	45 e5       	ldi	r20, 0x55	; 85
    2cb0:	50 e0       	ldi	r21, 0x00	; 0
    2cb2:	20 e0       	ldi	r18, 0x00	; 0
    2cb4:	30 e0       	ldi	r19, 0x00	; 0
    2cb6:	00 e0       	ldi	r16, 0x00	; 0
    2cb8:	ee 24       	eor	r14, r14
    2cba:	ff 24       	eor	r15, r15
    2cbc:	cc 24       	eor	r12, r12
    2cbe:	dd 24       	eor	r13, r13
    2cc0:	aa 24       	eor	r10, r10
    2cc2:	bb 24       	eor	r11, r11
    2cc4:	0e 94 91 14 	call	0x2922	; 0x2922 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2cc8:	81 30       	cpi	r24, 0x01	; 1
    2cca:	49 f4       	brne	.+18     	; 0x2cde <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2ccc:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2cce:	80 93 d4 1a 	sts	0x1AD4, r24
		xTickCount = ( portTickType ) 0U;
    2cd2:	10 92 d7 1a 	sts	0x1AD7, r1
    2cd6:	10 92 d6 1a 	sts	0x1AD6, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2cda:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2cde:	0f 91       	pop	r16
    2ce0:	ff 90       	pop	r15
    2ce2:	ef 90       	pop	r14
    2ce4:	df 90       	pop	r13
    2ce6:	cf 90       	pop	r12
    2ce8:	bf 90       	pop	r11
    2cea:	af 90       	pop	r10
    2cec:	08 95       	ret

00002cee <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2cee:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2cf0:	10 92 d4 1a 	sts	0x1AD4, r1
	vPortEndScheduler();
    2cf4:	0e 94 2b 10 	call	0x2056	; 0x2056 <vPortEndScheduler>
}
    2cf8:	08 95       	ret

00002cfa <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2cfa:	80 91 d3 1a 	lds	r24, 0x1AD3
    2cfe:	8f 5f       	subi	r24, 0xFF	; 255
    2d00:	80 93 d3 1a 	sts	0x1AD3, r24
}
    2d04:	08 95       	ret

00002d06 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2d06:	0f b6       	in	r0, 0x3f	; 63
    2d08:	f8 94       	cli
    2d0a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2d0c:	80 91 d6 1a 	lds	r24, 0x1AD6
    2d10:	90 91 d7 1a 	lds	r25, 0x1AD7
	}
	taskEXIT_CRITICAL();
    2d14:	0f 90       	pop	r0
    2d16:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2d18:	08 95       	ret

00002d1a <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    2d1a:	80 91 d6 1a 	lds	r24, 0x1AD6
    2d1e:	90 91 d7 1a 	lds	r25, 0x1AD7
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2d22:	08 95       	ret

00002d24 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2d24:	80 91 d8 1a 	lds	r24, 0x1AD8
}
    2d28:	08 95       	ret

00002d2a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2d2a:	0f 93       	push	r16
    2d2c:	1f 93       	push	r17
    2d2e:	cf 93       	push	r28
    2d30:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d32:	80 91 d3 1a 	lds	r24, 0x1AD3
    2d36:	88 23       	and	r24, r24
    2d38:	09 f0       	breq	.+2      	; 0x2d3c <vTaskIncrementTick+0x12>
    2d3a:	b3 c0       	rjmp	.+358    	; 0x2ea2 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    2d3c:	80 91 d6 1a 	lds	r24, 0x1AD6
    2d40:	90 91 d7 1a 	lds	r25, 0x1AD7
    2d44:	01 96       	adiw	r24, 0x01	; 1
    2d46:	90 93 d7 1a 	sts	0x1AD7, r25
    2d4a:	80 93 d6 1a 	sts	0x1AD6, r24
		if( xTickCount == ( portTickType ) 0U )
    2d4e:	80 91 d6 1a 	lds	r24, 0x1AD6
    2d52:	90 91 d7 1a 	lds	r25, 0x1AD7
    2d56:	00 97       	sbiw	r24, 0x00	; 0
    2d58:	99 f5       	brne	.+102    	; 0x2dc0 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    2d5a:	80 91 db 1a 	lds	r24, 0x1ADB
    2d5e:	90 91 dc 1a 	lds	r25, 0x1ADC
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2d62:	20 91 d9 1a 	lds	r18, 0x1AD9
    2d66:	30 91 da 1a 	lds	r19, 0x1ADA
    2d6a:	30 93 dc 1a 	sts	0x1ADC, r19
    2d6e:	20 93 db 1a 	sts	0x1ADB, r18
			pxOverflowDelayedTaskList = pxTemp;
    2d72:	90 93 da 1a 	sts	0x1ADA, r25
    2d76:	80 93 d9 1a 	sts	0x1AD9, r24
			xNumOfOverflows++;
    2d7a:	80 91 d0 1a 	lds	r24, 0x1AD0
    2d7e:	8f 5f       	subi	r24, 0xFF	; 255
    2d80:	80 93 d0 1a 	sts	0x1AD0, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2d84:	e0 91 db 1a 	lds	r30, 0x1ADB
    2d88:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2d8c:	80 81       	ld	r24, Z
    2d8e:	88 23       	and	r24, r24
    2d90:	39 f4       	brne	.+14     	; 0x2da0 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2d92:	8f ef       	ldi	r24, 0xFF	; 255
    2d94:	9f ef       	ldi	r25, 0xFF	; 255
    2d96:	90 93 5a 02 	sts	0x025A, r25
    2d9a:	80 93 59 02 	sts	0x0259, r24
    2d9e:	10 c0       	rjmp	.+32     	; 0x2dc0 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2da0:	e0 91 db 1a 	lds	r30, 0x1ADB
    2da4:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2da8:	05 80       	ldd	r0, Z+5	; 0x05
    2daa:	f6 81       	ldd	r31, Z+6	; 0x06
    2dac:	e0 2d       	mov	r30, r0
    2dae:	06 80       	ldd	r0, Z+6	; 0x06
    2db0:	f7 81       	ldd	r31, Z+7	; 0x07
    2db2:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2db4:	82 81       	ldd	r24, Z+2	; 0x02
    2db6:	93 81       	ldd	r25, Z+3	; 0x03
    2db8:	90 93 5a 02 	sts	0x025A, r25
    2dbc:	80 93 59 02 	sts	0x0259, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2dc0:	20 91 d6 1a 	lds	r18, 0x1AD6
    2dc4:	30 91 d7 1a 	lds	r19, 0x1AD7
    2dc8:	80 91 59 02 	lds	r24, 0x0259
    2dcc:	90 91 5a 02 	lds	r25, 0x025A
    2dd0:	28 17       	cp	r18, r24
    2dd2:	39 07       	cpc	r19, r25
    2dd4:	08 f4       	brcc	.+2      	; 0x2dd8 <vTaskIncrementTick+0xae>
    2dd6:	6a c0       	rjmp	.+212    	; 0x2eac <vTaskIncrementTick+0x182>
    2dd8:	e0 91 db 1a 	lds	r30, 0x1ADB
    2ddc:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2de0:	80 81       	ld	r24, Z
    2de2:	88 23       	and	r24, r24
    2de4:	99 f0       	breq	.+38     	; 0x2e0c <vTaskIncrementTick+0xe2>
    2de6:	e0 91 db 1a 	lds	r30, 0x1ADB
    2dea:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2dee:	05 80       	ldd	r0, Z+5	; 0x05
    2df0:	f6 81       	ldd	r31, Z+6	; 0x06
    2df2:	e0 2d       	mov	r30, r0
    2df4:	c6 81       	ldd	r28, Z+6	; 0x06
    2df6:	d7 81       	ldd	r29, Z+7	; 0x07
    2df8:	8a 81       	ldd	r24, Y+2	; 0x02
    2dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    2dfc:	20 91 d6 1a 	lds	r18, 0x1AD6
    2e00:	30 91 d7 1a 	lds	r19, 0x1AD7
    2e04:	28 17       	cp	r18, r24
    2e06:	39 07       	cpc	r19, r25
    2e08:	f8 f4       	brcc	.+62     	; 0x2e48 <vTaskIncrementTick+0x11e>
    2e0a:	19 c0       	rjmp	.+50     	; 0x2e3e <vTaskIncrementTick+0x114>
    2e0c:	8f ef       	ldi	r24, 0xFF	; 255
    2e0e:	9f ef       	ldi	r25, 0xFF	; 255
    2e10:	90 93 5a 02 	sts	0x025A, r25
    2e14:	80 93 59 02 	sts	0x0259, r24
    2e18:	49 c0       	rjmp	.+146    	; 0x2eac <vTaskIncrementTick+0x182>
    2e1a:	e0 91 db 1a 	lds	r30, 0x1ADB
    2e1e:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2e22:	05 80       	ldd	r0, Z+5	; 0x05
    2e24:	f6 81       	ldd	r31, Z+6	; 0x06
    2e26:	e0 2d       	mov	r30, r0
    2e28:	c6 81       	ldd	r28, Z+6	; 0x06
    2e2a:	d7 81       	ldd	r29, Z+7	; 0x07
    2e2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e2e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e30:	20 91 d6 1a 	lds	r18, 0x1AD6
    2e34:	30 91 d7 1a 	lds	r19, 0x1AD7
    2e38:	28 17       	cp	r18, r24
    2e3a:	39 07       	cpc	r19, r25
    2e3c:	28 f4       	brcc	.+10     	; 0x2e48 <vTaskIncrementTick+0x11e>
    2e3e:	90 93 5a 02 	sts	0x025A, r25
    2e42:	80 93 59 02 	sts	0x0259, r24
    2e46:	32 c0       	rjmp	.+100    	; 0x2eac <vTaskIncrementTick+0x182>
    2e48:	8e 01       	movw	r16, r28
    2e4a:	0e 5f       	subi	r16, 0xFE	; 254
    2e4c:	1f 4f       	sbci	r17, 0xFF	; 255
    2e4e:	c8 01       	movw	r24, r16
    2e50:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
    2e54:	8c 89       	ldd	r24, Y+20	; 0x14
    2e56:	9d 89       	ldd	r25, Y+21	; 0x15
    2e58:	00 97       	sbiw	r24, 0x00	; 0
    2e5a:	21 f0       	breq	.+8      	; 0x2e64 <vTaskIncrementTick+0x13a>
    2e5c:	ce 01       	movw	r24, r28
    2e5e:	0c 96       	adiw	r24, 0x0c	; 12
    2e60:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
    2e64:	8e 89       	ldd	r24, Y+22	; 0x16
    2e66:	90 91 d5 1a 	lds	r25, 0x1AD5
    2e6a:	98 17       	cp	r25, r24
    2e6c:	10 f4       	brcc	.+4      	; 0x2e72 <vTaskIncrementTick+0x148>
    2e6e:	80 93 d5 1a 	sts	0x1AD5, r24
    2e72:	90 e0       	ldi	r25, 0x00	; 0
    2e74:	9c 01       	movw	r18, r24
    2e76:	22 0f       	add	r18, r18
    2e78:	33 1f       	adc	r19, r19
    2e7a:	22 0f       	add	r18, r18
    2e7c:	33 1f       	adc	r19, r19
    2e7e:	22 0f       	add	r18, r18
    2e80:	33 1f       	adc	r19, r19
    2e82:	82 0f       	add	r24, r18
    2e84:	93 1f       	adc	r25, r19
    2e86:	81 52       	subi	r24, 0x21	; 33
    2e88:	95 4e       	sbci	r25, 0xE5	; 229
    2e8a:	b8 01       	movw	r22, r16
    2e8c:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
    2e90:	e0 91 db 1a 	lds	r30, 0x1ADB
    2e94:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2e98:	80 81       	ld	r24, Z
    2e9a:	88 23       	and	r24, r24
    2e9c:	09 f0       	breq	.+2      	; 0x2ea0 <vTaskIncrementTick+0x176>
    2e9e:	bd cf       	rjmp	.-134    	; 0x2e1a <vTaskIncrementTick+0xf0>
    2ea0:	b5 cf       	rjmp	.-150    	; 0x2e0c <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    2ea2:	80 91 d2 1a 	lds	r24, 0x1AD2
    2ea6:	8f 5f       	subi	r24, 0xFF	; 255
    2ea8:	80 93 d2 1a 	sts	0x1AD2, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    2eac:	df 91       	pop	r29
    2eae:	cf 91       	pop	r28
    2eb0:	1f 91       	pop	r17
    2eb2:	0f 91       	pop	r16
    2eb4:	08 95       	ret

00002eb6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2eb6:	af 92       	push	r10
    2eb8:	bf 92       	push	r11
    2eba:	cf 92       	push	r12
    2ebc:	df 92       	push	r13
    2ebe:	ef 92       	push	r14
    2ec0:	ff 92       	push	r15
    2ec2:	0f 93       	push	r16
    2ec4:	1f 93       	push	r17
    2ec6:	cf 93       	push	r28
    2ec8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2eca:	0f b6       	in	r0, 0x3f	; 63
    2ecc:	f8 94       	cli
    2ece:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2ed0:	80 91 d3 1a 	lds	r24, 0x1AD3
    2ed4:	81 50       	subi	r24, 0x01	; 1
    2ed6:	80 93 d3 1a 	sts	0x1AD3, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2eda:	80 91 d3 1a 	lds	r24, 0x1AD3
    2ede:	88 23       	and	r24, r24
    2ee0:	09 f0       	breq	.+2      	; 0x2ee4 <xTaskResumeAll+0x2e>
    2ee2:	69 c0       	rjmp	.+210    	; 0x2fb6 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2ee4:	80 91 d8 1a 	lds	r24, 0x1AD8
    2ee8:	88 23       	and	r24, r24
    2eea:	81 f5       	brne	.+96     	; 0x2f4c <xTaskResumeAll+0x96>
    2eec:	67 c0       	rjmp	.+206    	; 0x2fbc <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2eee:	d6 01       	movw	r26, r12
    2ef0:	ed 91       	ld	r30, X+
    2ef2:	fc 91       	ld	r31, X
    2ef4:	c6 81       	ldd	r28, Z+6	; 0x06
    2ef6:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    2ef8:	ce 01       	movw	r24, r28
    2efa:	0c 96       	adiw	r24, 0x0c	; 12
    2efc:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    2f00:	8e 01       	movw	r16, r28
    2f02:	0e 5f       	subi	r16, 0xFE	; 254
    2f04:	1f 4f       	sbci	r17, 0xFF	; 255
    2f06:	c8 01       	movw	r24, r16
    2f08:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2f0c:	8e 89       	ldd	r24, Y+22	; 0x16
    2f0e:	90 91 d5 1a 	lds	r25, 0x1AD5
    2f12:	98 17       	cp	r25, r24
    2f14:	10 f4       	brcc	.+4      	; 0x2f1a <xTaskResumeAll+0x64>
    2f16:	80 93 d5 1a 	sts	0x1AD5, r24
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	9c 01       	movw	r18, r24
    2f1e:	22 0f       	add	r18, r18
    2f20:	33 1f       	adc	r19, r19
    2f22:	22 0f       	add	r18, r18
    2f24:	33 1f       	adc	r19, r19
    2f26:	22 0f       	add	r18, r18
    2f28:	33 1f       	adc	r19, r19
    2f2a:	82 0f       	add	r24, r18
    2f2c:	93 1f       	adc	r25, r19
    2f2e:	81 52       	subi	r24, 0x21	; 33
    2f30:	95 4e       	sbci	r25, 0xE5	; 229
    2f32:	b8 01       	movw	r22, r16
    2f34:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2f38:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2f3c:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2f40:	9e 89       	ldd	r25, Y+22	; 0x16
    2f42:	86 89       	ldd	r24, Z+22	; 0x16
    2f44:	98 17       	cp	r25, r24
    2f46:	88 f0       	brcs	.+34     	; 0x2f6a <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    2f48:	ba 2c       	mov	r11, r10
    2f4a:	0f c0       	rjmp	.+30     	; 0x2f6a <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2f4c:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2f4e:	0f 2e       	mov	r0, r31
    2f50:	f5 e1       	ldi	r31, 0x15	; 21
    2f52:	ef 2e       	mov	r14, r31
    2f54:	fb e1       	ldi	r31, 0x1B	; 27
    2f56:	ff 2e       	mov	r15, r31
    2f58:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2f5a:	0f 2e       	mov	r0, r31
    2f5c:	fa e1       	ldi	r31, 0x1A	; 26
    2f5e:	cf 2e       	mov	r12, r31
    2f60:	fb e1       	ldi	r31, 0x1B	; 27
    2f62:	df 2e       	mov	r13, r31
    2f64:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    2f66:	aa 24       	eor	r10, r10
    2f68:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2f6a:	f7 01       	movw	r30, r14
    2f6c:	80 81       	ld	r24, Z
    2f6e:	88 23       	and	r24, r24
    2f70:	09 f0       	breq	.+2      	; 0x2f74 <xTaskResumeAll+0xbe>
    2f72:	bd cf       	rjmp	.-134    	; 0x2eee <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f74:	80 91 d2 1a 	lds	r24, 0x1AD2
    2f78:	88 23       	and	r24, r24
    2f7a:	81 f0       	breq	.+32     	; 0x2f9c <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f7c:	80 91 d2 1a 	lds	r24, 0x1AD2
    2f80:	88 23       	and	r24, r24
    2f82:	99 f0       	breq	.+38     	; 0x2faa <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    2f84:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <vTaskIncrementTick>
						--uxMissedTicks;
    2f88:	80 91 d2 1a 	lds	r24, 0x1AD2
    2f8c:	81 50       	subi	r24, 0x01	; 1
    2f8e:	80 93 d2 1a 	sts	0x1AD2, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f92:	80 91 d2 1a 	lds	r24, 0x1AD2
    2f96:	88 23       	and	r24, r24
    2f98:	a9 f7       	brne	.-22     	; 0x2f84 <xTaskResumeAll+0xce>
    2f9a:	07 c0       	rjmp	.+14     	; 0x2faa <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2f9c:	f1 e0       	ldi	r31, 0x01	; 1
    2f9e:	bf 16       	cp	r11, r31
    2fa0:	21 f0       	breq	.+8      	; 0x2faa <xTaskResumeAll+0xf4>
    2fa2:	80 91 d1 1a 	lds	r24, 0x1AD1
    2fa6:	81 30       	cpi	r24, 0x01	; 1
    2fa8:	41 f4       	brne	.+16     	; 0x2fba <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2faa:	10 92 d1 1a 	sts	0x1AD1, r1
					portYIELD_WITHIN_API();
    2fae:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2fb2:	81 e0       	ldi	r24, 0x01	; 1
    2fb4:	03 c0       	rjmp	.+6      	; 0x2fbc <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2fb6:	80 e0       	ldi	r24, 0x00	; 0
    2fb8:	01 c0       	rjmp	.+2      	; 0x2fbc <xTaskResumeAll+0x106>
    2fba:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2fbc:	0f 90       	pop	r0
    2fbe:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2fc0:	df 91       	pop	r29
    2fc2:	cf 91       	pop	r28
    2fc4:	1f 91       	pop	r17
    2fc6:	0f 91       	pop	r16
    2fc8:	ff 90       	pop	r15
    2fca:	ef 90       	pop	r14
    2fcc:	df 90       	pop	r13
    2fce:	cf 90       	pop	r12
    2fd0:	bf 90       	pop	r11
    2fd2:	af 90       	pop	r10
    2fd4:	08 95       	ret

00002fd6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2fd6:	cf 93       	push	r28
    2fd8:	df 93       	push	r29
    2fda:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2fdc:	00 97       	sbiw	r24, 0x00	; 0
    2fde:	b1 f0       	breq	.+44     	; 0x300c <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    2fe0:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2fe4:	80 91 d6 1a 	lds	r24, 0x1AD6
    2fe8:	90 91 d7 1a 	lds	r25, 0x1AD7
    2fec:	c8 0f       	add	r28, r24
    2fee:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    2ff0:	80 91 ce 1a 	lds	r24, 0x1ACE
    2ff4:	90 91 cf 1a 	lds	r25, 0x1ACF
    2ff8:	02 96       	adiw	r24, 0x02	; 2
    2ffa:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ffe:	ce 01       	movw	r24, r28
    3000:	0e 94 52 14 	call	0x28a4	; 0x28a4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3004:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3008:	88 23       	and	r24, r24
    300a:	11 f4       	brne	.+4      	; 0x3010 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    300c:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
		}
	}
    3010:	df 91       	pop	r29
    3012:	cf 91       	pop	r28
    3014:	08 95       	ret

00003016 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3016:	0f 93       	push	r16
    3018:	1f 93       	push	r17
    301a:	cf 93       	push	r28
    301c:	df 93       	push	r29
    301e:	8c 01       	movw	r16, r24
    3020:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3022:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3026:	f8 01       	movw	r30, r16
    3028:	80 81       	ld	r24, Z
    302a:	91 81       	ldd	r25, Z+1	; 0x01
    302c:	c8 0f       	add	r28, r24
    302e:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    3030:	20 91 d6 1a 	lds	r18, 0x1AD6
    3034:	30 91 d7 1a 	lds	r19, 0x1AD7
    3038:	28 17       	cp	r18, r24
    303a:	39 07       	cpc	r19, r25
    303c:	68 f4       	brcc	.+26     	; 0x3058 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    303e:	c8 17       	cp	r28, r24
    3040:	d9 07       	cpc	r29, r25
    3042:	50 f5       	brcc	.+84     	; 0x3098 <vTaskDelayUntil+0x82>
    3044:	80 91 d6 1a 	lds	r24, 0x1AD6
    3048:	90 91 d7 1a 	lds	r25, 0x1AD7
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    304c:	d1 83       	std	Z+1, r29	; 0x01
    304e:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    3050:	8c 17       	cp	r24, r28
    3052:	9d 07       	cpc	r25, r29
    3054:	b0 f4       	brcc	.+44     	; 0x3082 <vTaskDelayUntil+0x6c>
    3056:	0b c0       	rjmp	.+22     	; 0x306e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3058:	c8 17       	cp	r28, r24
    305a:	d9 07       	cpc	r29, r25
    305c:	c8 f0       	brcs	.+50     	; 0x3090 <vTaskDelayUntil+0x7a>
    305e:	80 91 d6 1a 	lds	r24, 0x1AD6
    3062:	90 91 d7 1a 	lds	r25, 0x1AD7
    3066:	8c 17       	cp	r24, r28
    3068:	9d 07       	cpc	r25, r29
    306a:	90 f0       	brcs	.+36     	; 0x3090 <vTaskDelayUntil+0x7a>
    306c:	15 c0       	rjmp	.+42     	; 0x3098 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    306e:	80 91 ce 1a 	lds	r24, 0x1ACE
    3072:	90 91 cf 1a 	lds	r25, 0x1ACF
    3076:	02 96       	adiw	r24, 0x02	; 2
    3078:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    307c:	ce 01       	movw	r24, r28
    307e:	0e 94 52 14 	call	0x28a4	; 0x28a4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3082:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3086:	88 23       	and	r24, r24
    3088:	59 f4       	brne	.+22     	; 0x30a0 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    308a:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    308e:	08 c0       	rjmp	.+16     	; 0x30a0 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3090:	f8 01       	movw	r30, r16
    3092:	d1 83       	std	Z+1, r29	; 0x01
    3094:	c0 83       	st	Z, r28
    3096:	eb cf       	rjmp	.-42     	; 0x306e <vTaskDelayUntil+0x58>
    3098:	f8 01       	movw	r30, r16
    309a:	d1 83       	std	Z+1, r29	; 0x01
    309c:	c0 83       	st	Z, r28
    309e:	f1 cf       	rjmp	.-30     	; 0x3082 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    30a0:	df 91       	pop	r29
    30a2:	cf 91       	pop	r28
    30a4:	1f 91       	pop	r17
    30a6:	0f 91       	pop	r16
    30a8:	08 95       	ret

000030aa <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    30aa:	80 91 d3 1a 	lds	r24, 0x1AD3
    30ae:	88 23       	and	r24, r24
    30b0:	99 f4       	brne	.+38     	; 0x30d8 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    30b2:	80 91 d5 1a 	lds	r24, 0x1AD5
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	fc 01       	movw	r30, r24
    30ba:	ee 0f       	add	r30, r30
    30bc:	ff 1f       	adc	r31, r31
    30be:	ee 0f       	add	r30, r30
    30c0:	ff 1f       	adc	r31, r31
    30c2:	ee 0f       	add	r30, r30
    30c4:	ff 1f       	adc	r31, r31
    30c6:	8e 0f       	add	r24, r30
    30c8:	9f 1f       	adc	r25, r31
    30ca:	fc 01       	movw	r30, r24
    30cc:	e1 52       	subi	r30, 0x21	; 33
    30ce:	f5 4e       	sbci	r31, 0xE5	; 229
    30d0:	80 81       	ld	r24, Z
    30d2:	88 23       	and	r24, r24
    30d4:	29 f0       	breq	.+10     	; 0x30e0 <vTaskSwitchContext+0x36>
    30d6:	1b c0       	rjmp	.+54     	; 0x310e <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    30d8:	81 e0       	ldi	r24, 0x01	; 1
    30da:	80 93 d1 1a 	sts	0x1AD1, r24
    30de:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    30e0:	80 91 d5 1a 	lds	r24, 0x1AD5
    30e4:	81 50       	subi	r24, 0x01	; 1
    30e6:	80 93 d5 1a 	sts	0x1AD5, r24
    30ea:	80 91 d5 1a 	lds	r24, 0x1AD5
    30ee:	90 e0       	ldi	r25, 0x00	; 0
    30f0:	fc 01       	movw	r30, r24
    30f2:	ee 0f       	add	r30, r30
    30f4:	ff 1f       	adc	r31, r31
    30f6:	ee 0f       	add	r30, r30
    30f8:	ff 1f       	adc	r31, r31
    30fa:	ee 0f       	add	r30, r30
    30fc:	ff 1f       	adc	r31, r31
    30fe:	8e 0f       	add	r24, r30
    3100:	9f 1f       	adc	r25, r31
    3102:	fc 01       	movw	r30, r24
    3104:	e1 52       	subi	r30, 0x21	; 33
    3106:	f5 4e       	sbci	r31, 0xE5	; 229
    3108:	80 81       	ld	r24, Z
    310a:	88 23       	and	r24, r24
    310c:	49 f3       	breq	.-46     	; 0x30e0 <vTaskSwitchContext+0x36>
    310e:	80 91 d5 1a 	lds	r24, 0x1AD5
    3112:	90 e0       	ldi	r25, 0x00	; 0
    3114:	fc 01       	movw	r30, r24
    3116:	ee 0f       	add	r30, r30
    3118:	ff 1f       	adc	r31, r31
    311a:	ee 0f       	add	r30, r30
    311c:	ff 1f       	adc	r31, r31
    311e:	ee 0f       	add	r30, r30
    3120:	ff 1f       	adc	r31, r31
    3122:	e8 0f       	add	r30, r24
    3124:	f9 1f       	adc	r31, r25
    3126:	e1 52       	subi	r30, 0x21	; 33
    3128:	f5 4e       	sbci	r31, 0xE5	; 229
    312a:	a1 81       	ldd	r26, Z+1	; 0x01
    312c:	b2 81       	ldd	r27, Z+2	; 0x02
    312e:	12 96       	adiw	r26, 0x02	; 2
    3130:	0d 90       	ld	r0, X+
    3132:	bc 91       	ld	r27, X
    3134:	a0 2d       	mov	r26, r0
    3136:	b2 83       	std	Z+2, r27	; 0x02
    3138:	a1 83       	std	Z+1, r26	; 0x01
    313a:	cf 01       	movw	r24, r30
    313c:	03 96       	adiw	r24, 0x03	; 3
    313e:	a8 17       	cp	r26, r24
    3140:	b9 07       	cpc	r27, r25
    3142:	31 f4       	brne	.+12     	; 0x3150 <vTaskSwitchContext+0xa6>
    3144:	12 96       	adiw	r26, 0x02	; 2
    3146:	8d 91       	ld	r24, X+
    3148:	9c 91       	ld	r25, X
    314a:	13 97       	sbiw	r26, 0x03	; 3
    314c:	92 83       	std	Z+2, r25	; 0x02
    314e:	81 83       	std	Z+1, r24	; 0x01
    3150:	01 80       	ldd	r0, Z+1	; 0x01
    3152:	f2 81       	ldd	r31, Z+2	; 0x02
    3154:	e0 2d       	mov	r30, r0
    3156:	86 81       	ldd	r24, Z+6	; 0x06
    3158:	97 81       	ldd	r25, Z+7	; 0x07
    315a:	90 93 cf 1a 	sts	0x1ACF, r25
    315e:	80 93 ce 1a 	sts	0x1ACE, r24
    3162:	08 95       	ret

00003164 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    3164:	ef 92       	push	r14
    3166:	ff 92       	push	r15
    3168:	0f 93       	push	r16
    316a:	1f 93       	push	r17
    316c:	cf 93       	push	r28
    316e:	df 93       	push	r29
    3170:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3172:	0f b6       	in	r0, 0x3f	; 63
    3174:	f8 94       	cli
    3176:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    3178:	80 91 ce 1a 	lds	r24, 0x1ACE
    317c:	90 91 cf 1a 	lds	r25, 0x1ACF
    3180:	e8 16       	cp	r14, r24
    3182:	f9 06       	cpc	r15, r25
    3184:	21 f0       	breq	.+8      	; 0x318e <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    3186:	e1 14       	cp	r14, r1
    3188:	f1 04       	cpc	r15, r1
    318a:	41 f4       	brne	.+16     	; 0x319c <vTaskSuspend+0x38>
    318c:	02 c0       	rjmp	.+4      	; 0x3192 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    318e:	ee 24       	eor	r14, r14
    3190:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    3192:	c0 91 ce 1a 	lds	r28, 0x1ACE
    3196:	d0 91 cf 1a 	lds	r29, 0x1ACF
    319a:	01 c0       	rjmp	.+2      	; 0x319e <vTaskSuspend+0x3a>
    319c:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    319e:	8e 01       	movw	r16, r28
    31a0:	0e 5f       	subi	r16, 0xFE	; 254
    31a2:	1f 4f       	sbci	r17, 0xFF	; 255
    31a4:	c8 01       	movw	r24, r16
    31a6:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    31aa:	8c 89       	ldd	r24, Y+20	; 0x14
    31ac:	9d 89       	ldd	r25, Y+21	; 0x15
    31ae:	00 97       	sbiw	r24, 0x00	; 0
    31b0:	21 f0       	breq	.+8      	; 0x31ba <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    31b2:	ce 01       	movw	r24, r28
    31b4:	0c 96       	adiw	r24, 0x0c	; 12
    31b6:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    31ba:	8e e1       	ldi	r24, 0x1E	; 30
    31bc:	9b e1       	ldi	r25, 0x1B	; 27
    31be:	b8 01       	movw	r22, r16
    31c0:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    31c4:	0f 90       	pop	r0
    31c6:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    31c8:	e1 14       	cp	r14, r1
    31ca:	f1 04       	cpc	r15, r1
    31cc:	a1 f4       	brne	.+40     	; 0x31f6 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    31ce:	80 91 d4 1a 	lds	r24, 0x1AD4
    31d2:	88 23       	and	r24, r24
    31d4:	19 f0       	breq	.+6      	; 0x31dc <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    31d6:	0e 94 2c 10 	call	0x2058	; 0x2058 <vPortYield>
    31da:	0d c0       	rjmp	.+26     	; 0x31f6 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    31dc:	90 91 1e 1b 	lds	r25, 0x1B1E
    31e0:	80 91 d8 1a 	lds	r24, 0x1AD8
    31e4:	98 17       	cp	r25, r24
    31e6:	29 f4       	brne	.+10     	; 0x31f2 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    31e8:	10 92 cf 1a 	sts	0x1ACF, r1
    31ec:	10 92 ce 1a 	sts	0x1ACE, r1
    31f0:	02 c0       	rjmp	.+4      	; 0x31f6 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    31f2:	0e 94 55 18 	call	0x30aa	; 0x30aa <vTaskSwitchContext>
				}
			}
		}
	}
    31f6:	df 91       	pop	r29
    31f8:	cf 91       	pop	r28
    31fa:	1f 91       	pop	r17
    31fc:	0f 91       	pop	r16
    31fe:	ff 90       	pop	r15
    3200:	ef 90       	pop	r14
    3202:	08 95       	ret

00003204 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3204:	cf 93       	push	r28
    3206:	df 93       	push	r29
    3208:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    320a:	60 91 ce 1a 	lds	r22, 0x1ACE
    320e:	70 91 cf 1a 	lds	r23, 0x1ACF
    3212:	64 5f       	subi	r22, 0xF4	; 244
    3214:	7f 4f       	sbci	r23, 0xFF	; 255
    3216:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    321a:	80 91 ce 1a 	lds	r24, 0x1ACE
    321e:	90 91 cf 1a 	lds	r25, 0x1ACF
    3222:	02 96       	adiw	r24, 0x02	; 2
    3224:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3228:	8f ef       	ldi	r24, 0xFF	; 255
    322a:	cf 3f       	cpi	r28, 0xFF	; 255
    322c:	d8 07       	cpc	r29, r24
    322e:	59 f4       	brne	.+22     	; 0x3246 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3230:	60 91 ce 1a 	lds	r22, 0x1ACE
    3234:	70 91 cf 1a 	lds	r23, 0x1ACF
    3238:	6e 5f       	subi	r22, 0xFE	; 254
    323a:	7f 4f       	sbci	r23, 0xFF	; 255
    323c:	8e e1       	ldi	r24, 0x1E	; 30
    323e:	9b e1       	ldi	r25, 0x1B	; 27
    3240:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
    3244:	08 c0       	rjmp	.+16     	; 0x3256 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3246:	80 91 d6 1a 	lds	r24, 0x1AD6
    324a:	90 91 d7 1a 	lds	r25, 0x1AD7
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    324e:	8c 0f       	add	r24, r28
    3250:	9d 1f       	adc	r25, r29
    3252:	0e 94 52 14 	call	0x28a4	; 0x28a4 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    3256:	df 91       	pop	r29
    3258:	cf 91       	pop	r28
    325a:	08 95       	ret

0000325c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    325c:	0f 93       	push	r16
    325e:	1f 93       	push	r17
    3260:	cf 93       	push	r28
    3262:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3264:	dc 01       	movw	r26, r24
    3266:	15 96       	adiw	r26, 0x05	; 5
    3268:	ed 91       	ld	r30, X+
    326a:	fc 91       	ld	r31, X
    326c:	16 97       	sbiw	r26, 0x06	; 6
    326e:	06 81       	ldd	r16, Z+6	; 0x06
    3270:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3272:	e8 01       	movw	r28, r16
    3274:	2c 96       	adiw	r28, 0x0c	; 12
    3276:	ce 01       	movw	r24, r28
    3278:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    327c:	80 91 d3 1a 	lds	r24, 0x1AD3
    3280:	88 23       	and	r24, r24
    3282:	e9 f4       	brne	.+58     	; 0x32be <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3284:	e8 01       	movw	r28, r16
    3286:	22 96       	adiw	r28, 0x02	; 2
    3288:	ce 01       	movw	r24, r28
    328a:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    328e:	f8 01       	movw	r30, r16
    3290:	86 89       	ldd	r24, Z+22	; 0x16
    3292:	90 91 d5 1a 	lds	r25, 0x1AD5
    3296:	98 17       	cp	r25, r24
    3298:	10 f4       	brcc	.+4      	; 0x329e <xTaskRemoveFromEventList+0x42>
    329a:	80 93 d5 1a 	sts	0x1AD5, r24
    329e:	90 e0       	ldi	r25, 0x00	; 0
    32a0:	9c 01       	movw	r18, r24
    32a2:	22 0f       	add	r18, r18
    32a4:	33 1f       	adc	r19, r19
    32a6:	22 0f       	add	r18, r18
    32a8:	33 1f       	adc	r19, r19
    32aa:	22 0f       	add	r18, r18
    32ac:	33 1f       	adc	r19, r19
    32ae:	82 0f       	add	r24, r18
    32b0:	93 1f       	adc	r25, r19
    32b2:	81 52       	subi	r24, 0x21	; 33
    32b4:	95 4e       	sbci	r25, 0xE5	; 229
    32b6:	be 01       	movw	r22, r28
    32b8:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
    32bc:	05 c0       	rjmp	.+10     	; 0x32c8 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    32be:	85 e1       	ldi	r24, 0x15	; 21
    32c0:	9b e1       	ldi	r25, 0x1B	; 27
    32c2:	be 01       	movw	r22, r28
    32c4:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    32c8:	e0 91 ce 1a 	lds	r30, 0x1ACE
    32cc:	f0 91 cf 1a 	lds	r31, 0x1ACF
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    32d0:	81 e0       	ldi	r24, 0x01	; 1
    32d2:	d8 01       	movw	r26, r16
    32d4:	56 96       	adiw	r26, 0x16	; 22
    32d6:	2c 91       	ld	r18, X
    32d8:	56 97       	sbiw	r26, 0x16	; 22
    32da:	96 89       	ldd	r25, Z+22	; 0x16
    32dc:	29 17       	cp	r18, r25
    32de:	08 f4       	brcc	.+2      	; 0x32e2 <xTaskRemoveFromEventList+0x86>
    32e0:	80 e0       	ldi	r24, 0x00	; 0
}
    32e2:	df 91       	pop	r29
    32e4:	cf 91       	pop	r28
    32e6:	1f 91       	pop	r17
    32e8:	0f 91       	pop	r16
    32ea:	08 95       	ret

000032ec <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    32ec:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    32ee:	80 91 d0 1a 	lds	r24, 0x1AD0
    32f2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    32f4:	80 91 d6 1a 	lds	r24, 0x1AD6
    32f8:	90 91 d7 1a 	lds	r25, 0x1AD7
    32fc:	92 83       	std	Z+2, r25	; 0x02
    32fe:	81 83       	std	Z+1, r24	; 0x01
}
    3300:	08 95       	ret

00003302 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3302:	fc 01       	movw	r30, r24
    3304:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3306:	0f b6       	in	r0, 0x3f	; 63
    3308:	f8 94       	cli
    330a:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    330c:	4d 91       	ld	r20, X+
    330e:	5c 91       	ld	r21, X
    3310:	11 97       	sbiw	r26, 0x01	; 1
    3312:	6f ef       	ldi	r22, 0xFF	; 255
    3314:	4f 3f       	cpi	r20, 0xFF	; 255
    3316:	56 07       	cpc	r21, r22
    3318:	51 f1       	breq	.+84     	; 0x336e <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    331a:	80 91 d0 1a 	lds	r24, 0x1AD0
    331e:	90 81       	ld	r25, Z
    3320:	98 17       	cp	r25, r24
    3322:	49 f0       	breq	.+18     	; 0x3336 <xTaskCheckForTimeOut+0x34>
    3324:	20 91 d6 1a 	lds	r18, 0x1AD6
    3328:	30 91 d7 1a 	lds	r19, 0x1AD7
    332c:	81 81       	ldd	r24, Z+1	; 0x01
    332e:	92 81       	ldd	r25, Z+2	; 0x02
    3330:	28 17       	cp	r18, r24
    3332:	39 07       	cpc	r19, r25
    3334:	f0 f4       	brcc	.+60     	; 0x3372 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3336:	80 91 d6 1a 	lds	r24, 0x1AD6
    333a:	90 91 d7 1a 	lds	r25, 0x1AD7
    333e:	21 81       	ldd	r18, Z+1	; 0x01
    3340:	32 81       	ldd	r19, Z+2	; 0x02
    3342:	82 1b       	sub	r24, r18
    3344:	93 0b       	sbc	r25, r19
    3346:	84 17       	cp	r24, r20
    3348:	95 07       	cpc	r25, r21
    334a:	a8 f4       	brcc	.+42     	; 0x3376 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    334c:	80 91 d6 1a 	lds	r24, 0x1AD6
    3350:	90 91 d7 1a 	lds	r25, 0x1AD7
    3354:	b9 01       	movw	r22, r18
    3356:	68 1b       	sub	r22, r24
    3358:	79 0b       	sbc	r23, r25
    335a:	cb 01       	movw	r24, r22
    335c:	84 0f       	add	r24, r20
    335e:	95 1f       	adc	r25, r21
    3360:	8d 93       	st	X+, r24
    3362:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    3364:	cf 01       	movw	r24, r30
    3366:	0e 94 76 19 	call	0x32ec	; 0x32ec <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    336a:	80 e0       	ldi	r24, 0x00	; 0
    336c:	05 c0       	rjmp	.+10     	; 0x3378 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    336e:	80 e0       	ldi	r24, 0x00	; 0
    3370:	03 c0       	rjmp	.+6      	; 0x3378 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3372:	81 e0       	ldi	r24, 0x01	; 1
    3374:	01 c0       	rjmp	.+2      	; 0x3378 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    3376:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    3378:	0f 90       	pop	r0
    337a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    337c:	08 95       	ret

0000337e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    337e:	81 e0       	ldi	r24, 0x01	; 1
    3380:	80 93 d1 1a 	sts	0x1AD1, r24
}
    3384:	08 95       	ret

00003386 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3386:	00 97       	sbiw	r24, 0x00	; 0
    3388:	29 f4       	brne	.+10     	; 0x3394 <uxTaskGetStackHighWaterMark+0xe>
    338a:	e0 91 ce 1a 	lds	r30, 0x1ACE
    338e:	f0 91 cf 1a 	lds	r31, 0x1ACF
    3392:	01 c0       	rjmp	.+2      	; 0x3396 <uxTaskGetStackHighWaterMark+0x10>
    3394:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    3396:	07 88       	ldd	r0, Z+23	; 0x17
    3398:	f0 8d       	ldd	r31, Z+24	; 0x18
    339a:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    339c:	80 81       	ld	r24, Z
    339e:	85 3a       	cpi	r24, 0xA5	; 165
    33a0:	41 f4       	brne	.+16     	; 0x33b2 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    33a2:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    33a4:	80 e0       	ldi	r24, 0x00	; 0
    33a6:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    33a8:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    33aa:	21 91       	ld	r18, Z+
    33ac:	25 3a       	cpi	r18, 0xA5	; 165
    33ae:	e1 f3       	breq	.-8      	; 0x33a8 <uxTaskGetStackHighWaterMark+0x22>
    33b0:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    33b2:	80 e0       	ldi	r24, 0x00	; 0
    33b4:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    33b6:	08 95       	ret

000033b8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    33b8:	80 91 ce 1a 	lds	r24, 0x1ACE
    33bc:	90 91 cf 1a 	lds	r25, 0x1ACF

		return xReturn;
	}
    33c0:	08 95       	ret

000033c2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    33c2:	0f 93       	push	r16
    33c4:	1f 93       	push	r17
    33c6:	cf 93       	push	r28
    33c8:	df 93       	push	r29
    33ca:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    33cc:	00 97       	sbiw	r24, 0x00	; 0
    33ce:	09 f4       	brne	.+2      	; 0x33d2 <vTaskPriorityInherit+0x10>
    33d0:	4d c0       	rjmp	.+154    	; 0x346c <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    33d2:	8e 89       	ldd	r24, Y+22	; 0x16
    33d4:	e0 91 ce 1a 	lds	r30, 0x1ACE
    33d8:	f0 91 cf 1a 	lds	r31, 0x1ACF
    33dc:	96 89       	ldd	r25, Z+22	; 0x16
    33de:	89 17       	cp	r24, r25
    33e0:	08 f0       	brcs	.+2      	; 0x33e4 <vTaskPriorityInherit+0x22>
    33e2:	44 c0       	rjmp	.+136    	; 0x346c <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    33e4:	e0 91 ce 1a 	lds	r30, 0x1ACE
    33e8:	f0 91 cf 1a 	lds	r31, 0x1ACF
    33ec:	96 89       	ldd	r25, Z+22	; 0x16
    33ee:	24 e0       	ldi	r18, 0x04	; 4
    33f0:	30 e0       	ldi	r19, 0x00	; 0
    33f2:	29 1b       	sub	r18, r25
    33f4:	31 09       	sbc	r19, r1
    33f6:	3d 87       	std	Y+13, r19	; 0x0d
    33f8:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    33fa:	90 e0       	ldi	r25, 0x00	; 0
    33fc:	9c 01       	movw	r18, r24
    33fe:	22 0f       	add	r18, r18
    3400:	33 1f       	adc	r19, r19
    3402:	22 0f       	add	r18, r18
    3404:	33 1f       	adc	r19, r19
    3406:	22 0f       	add	r18, r18
    3408:	33 1f       	adc	r19, r19
    340a:	82 0f       	add	r24, r18
    340c:	93 1f       	adc	r25, r19
    340e:	81 52       	subi	r24, 0x21	; 33
    3410:	95 4e       	sbci	r25, 0xE5	; 229
    3412:	2a 85       	ldd	r18, Y+10	; 0x0a
    3414:	3b 85       	ldd	r19, Y+11	; 0x0b
    3416:	28 17       	cp	r18, r24
    3418:	39 07       	cpc	r19, r25
    341a:	11 f5       	brne	.+68     	; 0x3460 <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    341c:	8e 01       	movw	r16, r28
    341e:	0e 5f       	subi	r16, 0xFE	; 254
    3420:	1f 4f       	sbci	r17, 0xFF	; 255
    3422:	c8 01       	movw	r24, r16
    3424:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3428:	e0 91 ce 1a 	lds	r30, 0x1ACE
    342c:	f0 91 cf 1a 	lds	r31, 0x1ACF
    3430:	86 89       	ldd	r24, Z+22	; 0x16
    3432:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    3434:	90 91 d5 1a 	lds	r25, 0x1AD5
    3438:	98 17       	cp	r25, r24
    343a:	10 f4       	brcc	.+4      	; 0x3440 <vTaskPriorityInherit+0x7e>
    343c:	80 93 d5 1a 	sts	0x1AD5, r24
    3440:	90 e0       	ldi	r25, 0x00	; 0
    3442:	9c 01       	movw	r18, r24
    3444:	22 0f       	add	r18, r18
    3446:	33 1f       	adc	r19, r19
    3448:	22 0f       	add	r18, r18
    344a:	33 1f       	adc	r19, r19
    344c:	22 0f       	add	r18, r18
    344e:	33 1f       	adc	r19, r19
    3450:	82 0f       	add	r24, r18
    3452:	93 1f       	adc	r25, r19
    3454:	81 52       	subi	r24, 0x21	; 33
    3456:	95 4e       	sbci	r25, 0xE5	; 229
    3458:	b8 01       	movw	r22, r16
    345a:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
    345e:	06 c0       	rjmp	.+12     	; 0x346c <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3460:	e0 91 ce 1a 	lds	r30, 0x1ACE
    3464:	f0 91 cf 1a 	lds	r31, 0x1ACF
    3468:	86 89       	ldd	r24, Z+22	; 0x16
    346a:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    346c:	df 91       	pop	r29
    346e:	cf 91       	pop	r28
    3470:	1f 91       	pop	r17
    3472:	0f 91       	pop	r16
    3474:	08 95       	ret

00003476 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    3476:	0f 93       	push	r16
    3478:	1f 93       	push	r17
    347a:	cf 93       	push	r28
    347c:	df 93       	push	r29
    347e:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3480:	00 97       	sbiw	r24, 0x00	; 0
    3482:	49 f1       	breq	.+82     	; 0x34d6 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3484:	9e 89       	ldd	r25, Y+22	; 0x16
    3486:	89 a5       	lds	r24, 0x69
    3488:	98 17       	cp	r25, r24
    348a:	29 f1       	breq	.+74     	; 0x34d6 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    348c:	8e 01       	movw	r16, r28
    348e:	0e 5f       	subi	r16, 0xFE	; 254
    3490:	1f 4f       	sbci	r17, 0xFF	; 255
    3492:	c8 01       	movw	r24, r16
    3494:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    3498:	49 a5       	lds	r20, 0x69
    349a:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    349c:	24 2f       	mov	r18, r20
    349e:	30 e0       	ldi	r19, 0x00	; 0
    34a0:	84 e0       	ldi	r24, 0x04	; 4
    34a2:	90 e0       	ldi	r25, 0x00	; 0
    34a4:	82 1b       	sub	r24, r18
    34a6:	93 0b       	sbc	r25, r19
    34a8:	9d 87       	std	Y+13, r25	; 0x0d
    34aa:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    34ac:	80 91 d5 1a 	lds	r24, 0x1AD5
    34b0:	84 17       	cp	r24, r20
    34b2:	10 f4       	brcc	.+4      	; 0x34b8 <vTaskPriorityDisinherit+0x42>
    34b4:	40 93 d5 1a 	sts	0x1AD5, r20
    34b8:	c9 01       	movw	r24, r18
    34ba:	88 0f       	add	r24, r24
    34bc:	99 1f       	adc	r25, r25
    34be:	88 0f       	add	r24, r24
    34c0:	99 1f       	adc	r25, r25
    34c2:	88 0f       	add	r24, r24
    34c4:	99 1f       	adc	r25, r25
    34c6:	28 0f       	add	r18, r24
    34c8:	39 1f       	adc	r19, r25
    34ca:	c9 01       	movw	r24, r18
    34cc:	81 52       	subi	r24, 0x21	; 33
    34ce:	95 4e       	sbci	r25, 0xE5	; 229
    34d0:	b8 01       	movw	r22, r16
    34d2:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <vListInsertEnd>
			}
		}
	}
    34d6:	df 91       	pop	r29
    34d8:	cf 91       	pop	r28
    34da:	1f 91       	pop	r17
    34dc:	0f 91       	pop	r16
    34de:	08 95       	ret

000034e0 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    34e0:	cf 92       	push	r12
    34e2:	df 92       	push	r13
    34e4:	ef 92       	push	r14
    34e6:	ff 92       	push	r15
    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    34e8:	6a 01       	movw	r12, r20
    34ea:	7b 01       	movw	r14, r22
    34ec:	68 94       	set
    34ee:	13 f8       	bld	r1, 3
    34f0:	f6 94       	lsr	r15
    34f2:	e7 94       	ror	r14
    34f4:	d7 94       	ror	r13
    34f6:	c7 94       	ror	r12
    34f8:	16 94       	lsr	r1
    34fa:	d1 f7       	brne	.-12     	; 0x34f0 <USART_Init+0x10>
    34fc:	9c 01       	movw	r18, r24
    34fe:	40 e0       	ldi	r20, 0x00	; 0
    3500:	50 e0       	ldi	r21, 0x00	; 0
    3502:	c7 01       	movw	r24, r14
    3504:	b6 01       	movw	r22, r12
    3506:	0e 94 6e 1d 	call	0x3adc	; 0x3adc <__udivmodsi4>
    350a:	da 01       	movw	r26, r20
    350c:	c9 01       	movw	r24, r18
    350e:	01 97       	sbiw	r24, 0x01	; 1
    3510:	a1 09       	sbc	r26, r1
    3512:	b1 09       	sbc	r27, r1
    UBRR0H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    3514:	49 2f       	mov	r20, r25
    3516:	5a 2f       	mov	r21, r26
    3518:	6b 2f       	mov	r22, r27
    351a:	77 27       	eor	r23, r23
    351c:	40 93 c5 00 	sts	0x00C5, r20
    UBRR0L = (unsigned char)ubrr;
    3520:	80 93 c4 00 	sts	0x00C4, r24
    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    3524:	88 e1       	ldi	r24, 0x18	; 24
    3526:	80 93 c1 00 	sts	0x00C1, r24
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    352a:	86 e0       	ldi	r24, 0x06	; 6
    352c:	80 93 c2 00 	sts	0x00C2, r24
	// clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    3530:	e0 ec       	ldi	r30, 0xC0	; 192
    3532:	f0 e0       	ldi	r31, 0x00	; 0
    3534:	80 81       	ld	r24, Z
    3536:	8d 7f       	andi	r24, 0xFD	; 253
    3538:	80 83       	st	Z, r24
}
    353a:	ff 90       	pop	r15
    353c:	ef 90       	pop	r14
    353e:	df 90       	pop	r13
    3540:	cf 90       	pop	r12
    3542:	08 95       	ret

00003544 <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    3544:	e0 ec       	ldi	r30, 0xC0	; 192
    3546:	f0 e0       	ldi	r31, 0x00	; 0
    3548:	90 81       	ld	r25, Z
    354a:	95 ff       	sbrs	r25, 5
    354c:	fd cf       	rjmp	.-6      	; 0x3548 <USART_Write+0x4>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    354e:	80 93 c6 00 	sts	0x00C6, r24
}
    3552:	08 95       	ret

00003554 <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    3554:	e0 ec       	ldi	r30, 0xC0	; 192
    3556:	f0 e0       	ldi	r31, 0x00	; 0
    3558:	90 81       	ld	r25, Z
    355a:	95 ff       	sbrs	r25, 5
    355c:	fd cf       	rjmp	.-6      	; 0x3558 <USART_Write_Unprotected+0x4>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    355e:	80 93 c6 00 	sts	0x00C6, r24
}
    3562:	08 95       	ret

00003564 <USART_Read>:
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    3564:	e0 ec       	ldi	r30, 0xC0	; 192
    3566:	f0 e0       	ldi	r31, 0x00	; 0
    3568:	80 81       	ld	r24, Z
    356a:	88 23       	and	r24, r24
    356c:	ec f7       	brge	.-6      	; 0x3568 <USART_Read+0x4>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    356e:	80 91 c6 00 	lds	r24, 0x00C6
}
    3572:	08 95       	ret

00003574 <__subsf3>:
    3574:	50 58       	subi	r21, 0x80	; 128

00003576 <__addsf3>:
    3576:	bb 27       	eor	r27, r27
    3578:	aa 27       	eor	r26, r26
    357a:	0e d0       	rcall	.+28     	; 0x3598 <__addsf3x>
    357c:	a0 c1       	rjmp	.+832    	; 0x38be <__fp_round>
    357e:	69 d1       	rcall	.+722    	; 0x3852 <__fp_pscA>
    3580:	30 f0       	brcs	.+12     	; 0x358e <__addsf3+0x18>
    3582:	6e d1       	rcall	.+732    	; 0x3860 <__fp_pscB>
    3584:	20 f0       	brcs	.+8      	; 0x358e <__addsf3+0x18>
    3586:	31 f4       	brne	.+12     	; 0x3594 <__addsf3+0x1e>
    3588:	9f 3f       	cpi	r25, 0xFF	; 255
    358a:	11 f4       	brne	.+4      	; 0x3590 <__addsf3+0x1a>
    358c:	1e f4       	brtc	.+6      	; 0x3594 <__addsf3+0x1e>
    358e:	5e c1       	rjmp	.+700    	; 0x384c <__fp_nan>
    3590:	0e f4       	brtc	.+2      	; 0x3594 <__addsf3+0x1e>
    3592:	e0 95       	com	r30
    3594:	e7 fb       	bst	r30, 7
    3596:	54 c1       	rjmp	.+680    	; 0x3840 <__fp_inf>

00003598 <__addsf3x>:
    3598:	e9 2f       	mov	r30, r25
    359a:	b3 d1       	rcall	.+870    	; 0x3902 <__fp_split3>
    359c:	80 f3       	brcs	.-32     	; 0x357e <__addsf3+0x8>
    359e:	ba 17       	cp	r27, r26
    35a0:	62 07       	cpc	r22, r18
    35a2:	73 07       	cpc	r23, r19
    35a4:	84 07       	cpc	r24, r20
    35a6:	95 07       	cpc	r25, r21
    35a8:	18 f0       	brcs	.+6      	; 0x35b0 <__addsf3x+0x18>
    35aa:	71 f4       	brne	.+28     	; 0x35c8 <__addsf3x+0x30>
    35ac:	9e f5       	brtc	.+102    	; 0x3614 <__addsf3x+0x7c>
    35ae:	cb c1       	rjmp	.+918    	; 0x3946 <__fp_zero>
    35b0:	0e f4       	brtc	.+2      	; 0x35b4 <__addsf3x+0x1c>
    35b2:	e0 95       	com	r30
    35b4:	0b 2e       	mov	r0, r27
    35b6:	ba 2f       	mov	r27, r26
    35b8:	a0 2d       	mov	r26, r0
    35ba:	0b 01       	movw	r0, r22
    35bc:	b9 01       	movw	r22, r18
    35be:	90 01       	movw	r18, r0
    35c0:	0c 01       	movw	r0, r24
    35c2:	ca 01       	movw	r24, r20
    35c4:	a0 01       	movw	r20, r0
    35c6:	11 24       	eor	r1, r1
    35c8:	ff 27       	eor	r31, r31
    35ca:	59 1b       	sub	r21, r25
    35cc:	99 f0       	breq	.+38     	; 0x35f4 <__addsf3x+0x5c>
    35ce:	59 3f       	cpi	r21, 0xF9	; 249
    35d0:	50 f4       	brcc	.+20     	; 0x35e6 <__addsf3x+0x4e>
    35d2:	50 3e       	cpi	r21, 0xE0	; 224
    35d4:	68 f1       	brcs	.+90     	; 0x3630 <__addsf3x+0x98>
    35d6:	1a 16       	cp	r1, r26
    35d8:	f0 40       	sbci	r31, 0x00	; 0
    35da:	a2 2f       	mov	r26, r18
    35dc:	23 2f       	mov	r18, r19
    35de:	34 2f       	mov	r19, r20
    35e0:	44 27       	eor	r20, r20
    35e2:	58 5f       	subi	r21, 0xF8	; 248
    35e4:	f3 cf       	rjmp	.-26     	; 0x35cc <__addsf3x+0x34>
    35e6:	46 95       	lsr	r20
    35e8:	37 95       	ror	r19
    35ea:	27 95       	ror	r18
    35ec:	a7 95       	ror	r26
    35ee:	f0 40       	sbci	r31, 0x00	; 0
    35f0:	53 95       	inc	r21
    35f2:	c9 f7       	brne	.-14     	; 0x35e6 <__addsf3x+0x4e>
    35f4:	7e f4       	brtc	.+30     	; 0x3614 <__addsf3x+0x7c>
    35f6:	1f 16       	cp	r1, r31
    35f8:	ba 0b       	sbc	r27, r26
    35fa:	62 0b       	sbc	r22, r18
    35fc:	73 0b       	sbc	r23, r19
    35fe:	84 0b       	sbc	r24, r20
    3600:	ba f0       	brmi	.+46     	; 0x3630 <__addsf3x+0x98>
    3602:	91 50       	subi	r25, 0x01	; 1
    3604:	a1 f0       	breq	.+40     	; 0x362e <__addsf3x+0x96>
    3606:	ff 0f       	add	r31, r31
    3608:	bb 1f       	adc	r27, r27
    360a:	66 1f       	adc	r22, r22
    360c:	77 1f       	adc	r23, r23
    360e:	88 1f       	adc	r24, r24
    3610:	c2 f7       	brpl	.-16     	; 0x3602 <__addsf3x+0x6a>
    3612:	0e c0       	rjmp	.+28     	; 0x3630 <__addsf3x+0x98>
    3614:	ba 0f       	add	r27, r26
    3616:	62 1f       	adc	r22, r18
    3618:	73 1f       	adc	r23, r19
    361a:	84 1f       	adc	r24, r20
    361c:	48 f4       	brcc	.+18     	; 0x3630 <__addsf3x+0x98>
    361e:	87 95       	ror	r24
    3620:	77 95       	ror	r23
    3622:	67 95       	ror	r22
    3624:	b7 95       	ror	r27
    3626:	f7 95       	ror	r31
    3628:	9e 3f       	cpi	r25, 0xFE	; 254
    362a:	08 f0       	brcs	.+2      	; 0x362e <__addsf3x+0x96>
    362c:	b3 cf       	rjmp	.-154    	; 0x3594 <__addsf3+0x1e>
    362e:	93 95       	inc	r25
    3630:	88 0f       	add	r24, r24
    3632:	08 f0       	brcs	.+2      	; 0x3636 <__addsf3x+0x9e>
    3634:	99 27       	eor	r25, r25
    3636:	ee 0f       	add	r30, r30
    3638:	97 95       	ror	r25
    363a:	87 95       	ror	r24
    363c:	08 95       	ret

0000363e <__cmpsf2>:
    363e:	dc d0       	rcall	.+440    	; 0x37f8 <__fp_cmp>
    3640:	08 f4       	brcc	.+2      	; 0x3644 <__cmpsf2+0x6>
    3642:	81 e0       	ldi	r24, 0x01	; 1
    3644:	08 95       	ret

00003646 <cos>:
    3646:	14 d1       	rcall	.+552    	; 0x3870 <__fp_rempio2>
    3648:	e3 95       	inc	r30
    364a:	4a c1       	rjmp	.+660    	; 0x38e0 <__fp_sinus>

0000364c <__divsf3>:
    364c:	0c d0       	rcall	.+24     	; 0x3666 <__divsf3x>
    364e:	37 c1       	rjmp	.+622    	; 0x38be <__fp_round>
    3650:	07 d1       	rcall	.+526    	; 0x3860 <__fp_pscB>
    3652:	40 f0       	brcs	.+16     	; 0x3664 <__divsf3+0x18>
    3654:	fe d0       	rcall	.+508    	; 0x3852 <__fp_pscA>
    3656:	30 f0       	brcs	.+12     	; 0x3664 <__divsf3+0x18>
    3658:	21 f4       	brne	.+8      	; 0x3662 <__divsf3+0x16>
    365a:	5f 3f       	cpi	r21, 0xFF	; 255
    365c:	19 f0       	breq	.+6      	; 0x3664 <__divsf3+0x18>
    365e:	f0 c0       	rjmp	.+480    	; 0x3840 <__fp_inf>
    3660:	51 11       	cpse	r21, r1
    3662:	72 c1       	rjmp	.+740    	; 0x3948 <__fp_szero>
    3664:	f3 c0       	rjmp	.+486    	; 0x384c <__fp_nan>

00003666 <__divsf3x>:
    3666:	4d d1       	rcall	.+666    	; 0x3902 <__fp_split3>
    3668:	98 f3       	brcs	.-26     	; 0x3650 <__divsf3+0x4>

0000366a <__divsf3_pse>:
    366a:	99 23       	and	r25, r25
    366c:	c9 f3       	breq	.-14     	; 0x3660 <__divsf3+0x14>
    366e:	55 23       	and	r21, r21
    3670:	b1 f3       	breq	.-20     	; 0x365e <__divsf3+0x12>
    3672:	95 1b       	sub	r25, r21
    3674:	55 0b       	sbc	r21, r21
    3676:	bb 27       	eor	r27, r27
    3678:	aa 27       	eor	r26, r26
    367a:	62 17       	cp	r22, r18
    367c:	73 07       	cpc	r23, r19
    367e:	84 07       	cpc	r24, r20
    3680:	38 f0       	brcs	.+14     	; 0x3690 <__divsf3_pse+0x26>
    3682:	9f 5f       	subi	r25, 0xFF	; 255
    3684:	5f 4f       	sbci	r21, 0xFF	; 255
    3686:	22 0f       	add	r18, r18
    3688:	33 1f       	adc	r19, r19
    368a:	44 1f       	adc	r20, r20
    368c:	aa 1f       	adc	r26, r26
    368e:	a9 f3       	breq	.-22     	; 0x367a <__divsf3_pse+0x10>
    3690:	33 d0       	rcall	.+102    	; 0x36f8 <__divsf3_pse+0x8e>
    3692:	0e 2e       	mov	r0, r30
    3694:	3a f0       	brmi	.+14     	; 0x36a4 <__divsf3_pse+0x3a>
    3696:	e0 e8       	ldi	r30, 0x80	; 128
    3698:	30 d0       	rcall	.+96     	; 0x36fa <__divsf3_pse+0x90>
    369a:	91 50       	subi	r25, 0x01	; 1
    369c:	50 40       	sbci	r21, 0x00	; 0
    369e:	e6 95       	lsr	r30
    36a0:	00 1c       	adc	r0, r0
    36a2:	ca f7       	brpl	.-14     	; 0x3696 <__divsf3_pse+0x2c>
    36a4:	29 d0       	rcall	.+82     	; 0x36f8 <__divsf3_pse+0x8e>
    36a6:	fe 2f       	mov	r31, r30
    36a8:	27 d0       	rcall	.+78     	; 0x36f8 <__divsf3_pse+0x8e>
    36aa:	66 0f       	add	r22, r22
    36ac:	77 1f       	adc	r23, r23
    36ae:	88 1f       	adc	r24, r24
    36b0:	bb 1f       	adc	r27, r27
    36b2:	26 17       	cp	r18, r22
    36b4:	37 07       	cpc	r19, r23
    36b6:	48 07       	cpc	r20, r24
    36b8:	ab 07       	cpc	r26, r27
    36ba:	b0 e8       	ldi	r27, 0x80	; 128
    36bc:	09 f0       	breq	.+2      	; 0x36c0 <__divsf3_pse+0x56>
    36be:	bb 0b       	sbc	r27, r27
    36c0:	80 2d       	mov	r24, r0
    36c2:	bf 01       	movw	r22, r30
    36c4:	ff 27       	eor	r31, r31
    36c6:	93 58       	subi	r25, 0x83	; 131
    36c8:	5f 4f       	sbci	r21, 0xFF	; 255
    36ca:	2a f0       	brmi	.+10     	; 0x36d6 <__divsf3_pse+0x6c>
    36cc:	9e 3f       	cpi	r25, 0xFE	; 254
    36ce:	51 05       	cpc	r21, r1
    36d0:	68 f0       	brcs	.+26     	; 0x36ec <__divsf3_pse+0x82>
    36d2:	b6 c0       	rjmp	.+364    	; 0x3840 <__fp_inf>
    36d4:	39 c1       	rjmp	.+626    	; 0x3948 <__fp_szero>
    36d6:	5f 3f       	cpi	r21, 0xFF	; 255
    36d8:	ec f3       	brlt	.-6      	; 0x36d4 <__divsf3_pse+0x6a>
    36da:	98 3e       	cpi	r25, 0xE8	; 232
    36dc:	dc f3       	brlt	.-10     	; 0x36d4 <__divsf3_pse+0x6a>
    36de:	86 95       	lsr	r24
    36e0:	77 95       	ror	r23
    36e2:	67 95       	ror	r22
    36e4:	b7 95       	ror	r27
    36e6:	f7 95       	ror	r31
    36e8:	9f 5f       	subi	r25, 0xFF	; 255
    36ea:	c9 f7       	brne	.-14     	; 0x36de <__divsf3_pse+0x74>
    36ec:	88 0f       	add	r24, r24
    36ee:	91 1d       	adc	r25, r1
    36f0:	96 95       	lsr	r25
    36f2:	87 95       	ror	r24
    36f4:	97 f9       	bld	r25, 7
    36f6:	08 95       	ret
    36f8:	e1 e0       	ldi	r30, 0x01	; 1
    36fa:	66 0f       	add	r22, r22
    36fc:	77 1f       	adc	r23, r23
    36fe:	88 1f       	adc	r24, r24
    3700:	bb 1f       	adc	r27, r27
    3702:	62 17       	cp	r22, r18
    3704:	73 07       	cpc	r23, r19
    3706:	84 07       	cpc	r24, r20
    3708:	ba 07       	cpc	r27, r26
    370a:	20 f0       	brcs	.+8      	; 0x3714 <__divsf3_pse+0xaa>
    370c:	62 1b       	sub	r22, r18
    370e:	73 0b       	sbc	r23, r19
    3710:	84 0b       	sbc	r24, r20
    3712:	ba 0b       	sbc	r27, r26
    3714:	ee 1f       	adc	r30, r30
    3716:	88 f7       	brcc	.-30     	; 0x36fa <__divsf3_pse+0x90>
    3718:	e0 95       	com	r30
    371a:	08 95       	ret

0000371c <__fixsfsi>:
    371c:	04 d0       	rcall	.+8      	; 0x3726 <__fixunssfsi>
    371e:	68 94       	set
    3720:	b1 11       	cpse	r27, r1
    3722:	12 c1       	rjmp	.+548    	; 0x3948 <__fp_szero>
    3724:	08 95       	ret

00003726 <__fixunssfsi>:
    3726:	f5 d0       	rcall	.+490    	; 0x3912 <__fp_splitA>
    3728:	88 f0       	brcs	.+34     	; 0x374c <__fixunssfsi+0x26>
    372a:	9f 57       	subi	r25, 0x7F	; 127
    372c:	90 f0       	brcs	.+36     	; 0x3752 <__fixunssfsi+0x2c>
    372e:	b9 2f       	mov	r27, r25
    3730:	99 27       	eor	r25, r25
    3732:	b7 51       	subi	r27, 0x17	; 23
    3734:	a0 f0       	brcs	.+40     	; 0x375e <__fixunssfsi+0x38>
    3736:	d1 f0       	breq	.+52     	; 0x376c <__fixunssfsi+0x46>
    3738:	66 0f       	add	r22, r22
    373a:	77 1f       	adc	r23, r23
    373c:	88 1f       	adc	r24, r24
    373e:	99 1f       	adc	r25, r25
    3740:	1a f0       	brmi	.+6      	; 0x3748 <__fixunssfsi+0x22>
    3742:	ba 95       	dec	r27
    3744:	c9 f7       	brne	.-14     	; 0x3738 <__fixunssfsi+0x12>
    3746:	12 c0       	rjmp	.+36     	; 0x376c <__fixunssfsi+0x46>
    3748:	b1 30       	cpi	r27, 0x01	; 1
    374a:	81 f0       	breq	.+32     	; 0x376c <__fixunssfsi+0x46>
    374c:	fc d0       	rcall	.+504    	; 0x3946 <__fp_zero>
    374e:	b1 e0       	ldi	r27, 0x01	; 1
    3750:	08 95       	ret
    3752:	f9 c0       	rjmp	.+498    	; 0x3946 <__fp_zero>
    3754:	67 2f       	mov	r22, r23
    3756:	78 2f       	mov	r23, r24
    3758:	88 27       	eor	r24, r24
    375a:	b8 5f       	subi	r27, 0xF8	; 248
    375c:	39 f0       	breq	.+14     	; 0x376c <__fixunssfsi+0x46>
    375e:	b9 3f       	cpi	r27, 0xF9	; 249
    3760:	cc f3       	brlt	.-14     	; 0x3754 <__fixunssfsi+0x2e>
    3762:	86 95       	lsr	r24
    3764:	77 95       	ror	r23
    3766:	67 95       	ror	r22
    3768:	b3 95       	inc	r27
    376a:	d9 f7       	brne	.-10     	; 0x3762 <__fixunssfsi+0x3c>
    376c:	3e f4       	brtc	.+14     	; 0x377c <__fixunssfsi+0x56>
    376e:	90 95       	com	r25
    3770:	80 95       	com	r24
    3772:	70 95       	com	r23
    3774:	61 95       	neg	r22
    3776:	7f 4f       	sbci	r23, 0xFF	; 255
    3778:	8f 4f       	sbci	r24, 0xFF	; 255
    377a:	9f 4f       	sbci	r25, 0xFF	; 255
    377c:	08 95       	ret

0000377e <__floatunsisf>:
    377e:	e8 94       	clt
    3780:	09 c0       	rjmp	.+18     	; 0x3794 <__floatsisf+0x12>

00003782 <__floatsisf>:
    3782:	97 fb       	bst	r25, 7
    3784:	3e f4       	brtc	.+14     	; 0x3794 <__floatsisf+0x12>
    3786:	90 95       	com	r25
    3788:	80 95       	com	r24
    378a:	70 95       	com	r23
    378c:	61 95       	neg	r22
    378e:	7f 4f       	sbci	r23, 0xFF	; 255
    3790:	8f 4f       	sbci	r24, 0xFF	; 255
    3792:	9f 4f       	sbci	r25, 0xFF	; 255
    3794:	99 23       	and	r25, r25
    3796:	a9 f0       	breq	.+42     	; 0x37c2 <__floatsisf+0x40>
    3798:	f9 2f       	mov	r31, r25
    379a:	96 e9       	ldi	r25, 0x96	; 150
    379c:	bb 27       	eor	r27, r27
    379e:	93 95       	inc	r25
    37a0:	f6 95       	lsr	r31
    37a2:	87 95       	ror	r24
    37a4:	77 95       	ror	r23
    37a6:	67 95       	ror	r22
    37a8:	b7 95       	ror	r27
    37aa:	f1 11       	cpse	r31, r1
    37ac:	f8 cf       	rjmp	.-16     	; 0x379e <__floatsisf+0x1c>
    37ae:	fa f4       	brpl	.+62     	; 0x37ee <__floatsisf+0x6c>
    37b0:	bb 0f       	add	r27, r27
    37b2:	11 f4       	brne	.+4      	; 0x37b8 <__floatsisf+0x36>
    37b4:	60 ff       	sbrs	r22, 0
    37b6:	1b c0       	rjmp	.+54     	; 0x37ee <__floatsisf+0x6c>
    37b8:	6f 5f       	subi	r22, 0xFF	; 255
    37ba:	7f 4f       	sbci	r23, 0xFF	; 255
    37bc:	8f 4f       	sbci	r24, 0xFF	; 255
    37be:	9f 4f       	sbci	r25, 0xFF	; 255
    37c0:	16 c0       	rjmp	.+44     	; 0x37ee <__floatsisf+0x6c>
    37c2:	88 23       	and	r24, r24
    37c4:	11 f0       	breq	.+4      	; 0x37ca <__floatsisf+0x48>
    37c6:	96 e9       	ldi	r25, 0x96	; 150
    37c8:	11 c0       	rjmp	.+34     	; 0x37ec <__floatsisf+0x6a>
    37ca:	77 23       	and	r23, r23
    37cc:	21 f0       	breq	.+8      	; 0x37d6 <__floatsisf+0x54>
    37ce:	9e e8       	ldi	r25, 0x8E	; 142
    37d0:	87 2f       	mov	r24, r23
    37d2:	76 2f       	mov	r23, r22
    37d4:	05 c0       	rjmp	.+10     	; 0x37e0 <__floatsisf+0x5e>
    37d6:	66 23       	and	r22, r22
    37d8:	71 f0       	breq	.+28     	; 0x37f6 <__floatsisf+0x74>
    37da:	96 e8       	ldi	r25, 0x86	; 134
    37dc:	86 2f       	mov	r24, r22
    37de:	70 e0       	ldi	r23, 0x00	; 0
    37e0:	60 e0       	ldi	r22, 0x00	; 0
    37e2:	2a f0       	brmi	.+10     	; 0x37ee <__floatsisf+0x6c>
    37e4:	9a 95       	dec	r25
    37e6:	66 0f       	add	r22, r22
    37e8:	77 1f       	adc	r23, r23
    37ea:	88 1f       	adc	r24, r24
    37ec:	da f7       	brpl	.-10     	; 0x37e4 <__floatsisf+0x62>
    37ee:	88 0f       	add	r24, r24
    37f0:	96 95       	lsr	r25
    37f2:	87 95       	ror	r24
    37f4:	97 f9       	bld	r25, 7
    37f6:	08 95       	ret

000037f8 <__fp_cmp>:
    37f8:	99 0f       	add	r25, r25
    37fa:	00 08       	sbc	r0, r0
    37fc:	55 0f       	add	r21, r21
    37fe:	aa 0b       	sbc	r26, r26
    3800:	e0 e8       	ldi	r30, 0x80	; 128
    3802:	fe ef       	ldi	r31, 0xFE	; 254
    3804:	16 16       	cp	r1, r22
    3806:	17 06       	cpc	r1, r23
    3808:	e8 07       	cpc	r30, r24
    380a:	f9 07       	cpc	r31, r25
    380c:	c0 f0       	brcs	.+48     	; 0x383e <__fp_cmp+0x46>
    380e:	12 16       	cp	r1, r18
    3810:	13 06       	cpc	r1, r19
    3812:	e4 07       	cpc	r30, r20
    3814:	f5 07       	cpc	r31, r21
    3816:	98 f0       	brcs	.+38     	; 0x383e <__fp_cmp+0x46>
    3818:	62 1b       	sub	r22, r18
    381a:	73 0b       	sbc	r23, r19
    381c:	84 0b       	sbc	r24, r20
    381e:	95 0b       	sbc	r25, r21
    3820:	39 f4       	brne	.+14     	; 0x3830 <__fp_cmp+0x38>
    3822:	0a 26       	eor	r0, r26
    3824:	61 f0       	breq	.+24     	; 0x383e <__fp_cmp+0x46>
    3826:	23 2b       	or	r18, r19
    3828:	24 2b       	or	r18, r20
    382a:	25 2b       	or	r18, r21
    382c:	21 f4       	brne	.+8      	; 0x3836 <__fp_cmp+0x3e>
    382e:	08 95       	ret
    3830:	0a 26       	eor	r0, r26
    3832:	09 f4       	brne	.+2      	; 0x3836 <__fp_cmp+0x3e>
    3834:	a1 40       	sbci	r26, 0x01	; 1
    3836:	a6 95       	lsr	r26
    3838:	8f ef       	ldi	r24, 0xFF	; 255
    383a:	81 1d       	adc	r24, r1
    383c:	81 1d       	adc	r24, r1
    383e:	08 95       	ret

00003840 <__fp_inf>:
    3840:	97 f9       	bld	r25, 7
    3842:	9f 67       	ori	r25, 0x7F	; 127
    3844:	80 e8       	ldi	r24, 0x80	; 128
    3846:	70 e0       	ldi	r23, 0x00	; 0
    3848:	60 e0       	ldi	r22, 0x00	; 0
    384a:	08 95       	ret

0000384c <__fp_nan>:
    384c:	9f ef       	ldi	r25, 0xFF	; 255
    384e:	80 ec       	ldi	r24, 0xC0	; 192
    3850:	08 95       	ret

00003852 <__fp_pscA>:
    3852:	00 24       	eor	r0, r0
    3854:	0a 94       	dec	r0
    3856:	16 16       	cp	r1, r22
    3858:	17 06       	cpc	r1, r23
    385a:	18 06       	cpc	r1, r24
    385c:	09 06       	cpc	r0, r25
    385e:	08 95       	ret

00003860 <__fp_pscB>:
    3860:	00 24       	eor	r0, r0
    3862:	0a 94       	dec	r0
    3864:	12 16       	cp	r1, r18
    3866:	13 06       	cpc	r1, r19
    3868:	14 06       	cpc	r1, r20
    386a:	05 06       	cpc	r0, r21
    386c:	08 95       	ret
    386e:	ee cf       	rjmp	.-36     	; 0x384c <__fp_nan>

00003870 <__fp_rempio2>:
    3870:	50 d0       	rcall	.+160    	; 0x3912 <__fp_splitA>
    3872:	e8 f3       	brcs	.-6      	; 0x386e <__fp_pscB+0xe>
    3874:	e8 94       	clt
    3876:	e0 e0       	ldi	r30, 0x00	; 0
    3878:	bb 27       	eor	r27, r27
    387a:	9f 57       	subi	r25, 0x7F	; 127
    387c:	f0 f0       	brcs	.+60     	; 0x38ba <__fp_rempio2+0x4a>
    387e:	2a ed       	ldi	r18, 0xDA	; 218
    3880:	3f e0       	ldi	r19, 0x0F	; 15
    3882:	49 ec       	ldi	r20, 0xC9	; 201
    3884:	06 c0       	rjmp	.+12     	; 0x3892 <__fp_rempio2+0x22>
    3886:	ee 0f       	add	r30, r30
    3888:	bb 0f       	add	r27, r27
    388a:	66 1f       	adc	r22, r22
    388c:	77 1f       	adc	r23, r23
    388e:	88 1f       	adc	r24, r24
    3890:	28 f0       	brcs	.+10     	; 0x389c <__fp_rempio2+0x2c>
    3892:	b2 3a       	cpi	r27, 0xA2	; 162
    3894:	62 07       	cpc	r22, r18
    3896:	73 07       	cpc	r23, r19
    3898:	84 07       	cpc	r24, r20
    389a:	28 f0       	brcs	.+10     	; 0x38a6 <__fp_rempio2+0x36>
    389c:	b2 5a       	subi	r27, 0xA2	; 162
    389e:	62 0b       	sbc	r22, r18
    38a0:	73 0b       	sbc	r23, r19
    38a2:	84 0b       	sbc	r24, r20
    38a4:	e3 95       	inc	r30
    38a6:	9a 95       	dec	r25
    38a8:	72 f7       	brpl	.-36     	; 0x3886 <__fp_rempio2+0x16>
    38aa:	80 38       	cpi	r24, 0x80	; 128
    38ac:	30 f4       	brcc	.+12     	; 0x38ba <__fp_rempio2+0x4a>
    38ae:	9a 95       	dec	r25
    38b0:	bb 0f       	add	r27, r27
    38b2:	66 1f       	adc	r22, r22
    38b4:	77 1f       	adc	r23, r23
    38b6:	88 1f       	adc	r24, r24
    38b8:	d2 f7       	brpl	.-12     	; 0x38ae <__fp_rempio2+0x3e>
    38ba:	90 48       	sbci	r25, 0x80	; 128
    38bc:	ba c0       	rjmp	.+372    	; 0x3a32 <__fp_mpack_finite>

000038be <__fp_round>:
    38be:	09 2e       	mov	r0, r25
    38c0:	03 94       	inc	r0
    38c2:	00 0c       	add	r0, r0
    38c4:	11 f4       	brne	.+4      	; 0x38ca <__fp_round+0xc>
    38c6:	88 23       	and	r24, r24
    38c8:	52 f0       	brmi	.+20     	; 0x38de <__fp_round+0x20>
    38ca:	bb 0f       	add	r27, r27
    38cc:	40 f4       	brcc	.+16     	; 0x38de <__fp_round+0x20>
    38ce:	bf 2b       	or	r27, r31
    38d0:	11 f4       	brne	.+4      	; 0x38d6 <__fp_round+0x18>
    38d2:	60 ff       	sbrs	r22, 0
    38d4:	04 c0       	rjmp	.+8      	; 0x38de <__fp_round+0x20>
    38d6:	6f 5f       	subi	r22, 0xFF	; 255
    38d8:	7f 4f       	sbci	r23, 0xFF	; 255
    38da:	8f 4f       	sbci	r24, 0xFF	; 255
    38dc:	9f 4f       	sbci	r25, 0xFF	; 255
    38de:	08 95       	ret

000038e0 <__fp_sinus>:
    38e0:	ef 93       	push	r30
    38e2:	e0 ff       	sbrs	r30, 0
    38e4:	06 c0       	rjmp	.+12     	; 0x38f2 <__fp_sinus+0x12>
    38e6:	a2 ea       	ldi	r26, 0xA2	; 162
    38e8:	2a ed       	ldi	r18, 0xDA	; 218
    38ea:	3f e0       	ldi	r19, 0x0F	; 15
    38ec:	49 ec       	ldi	r20, 0xC9	; 201
    38ee:	5f eb       	ldi	r21, 0xBF	; 191
    38f0:	53 de       	rcall	.-858    	; 0x3598 <__addsf3x>
    38f2:	e5 df       	rcall	.-54     	; 0x38be <__fp_round>
    38f4:	0f 90       	pop	r0
    38f6:	03 94       	inc	r0
    38f8:	01 fc       	sbrc	r0, 1
    38fa:	90 58       	subi	r25, 0x80	; 128
    38fc:	e4 ee       	ldi	r30, 0xE4	; 228
    38fe:	f0 e0       	ldi	r31, 0x00	; 0
    3900:	a4 c0       	rjmp	.+328    	; 0x3a4a <__fp_powsodd>

00003902 <__fp_split3>:
    3902:	57 fd       	sbrc	r21, 7
    3904:	90 58       	subi	r25, 0x80	; 128
    3906:	44 0f       	add	r20, r20
    3908:	55 1f       	adc	r21, r21
    390a:	59 f0       	breq	.+22     	; 0x3922 <__fp_splitA+0x10>
    390c:	5f 3f       	cpi	r21, 0xFF	; 255
    390e:	71 f0       	breq	.+28     	; 0x392c <__fp_splitA+0x1a>
    3910:	47 95       	ror	r20

00003912 <__fp_splitA>:
    3912:	88 0f       	add	r24, r24
    3914:	97 fb       	bst	r25, 7
    3916:	99 1f       	adc	r25, r25
    3918:	61 f0       	breq	.+24     	; 0x3932 <__fp_splitA+0x20>
    391a:	9f 3f       	cpi	r25, 0xFF	; 255
    391c:	79 f0       	breq	.+30     	; 0x393c <__fp_splitA+0x2a>
    391e:	87 95       	ror	r24
    3920:	08 95       	ret
    3922:	12 16       	cp	r1, r18
    3924:	13 06       	cpc	r1, r19
    3926:	14 06       	cpc	r1, r20
    3928:	55 1f       	adc	r21, r21
    392a:	f2 cf       	rjmp	.-28     	; 0x3910 <__fp_split3+0xe>
    392c:	46 95       	lsr	r20
    392e:	f1 df       	rcall	.-30     	; 0x3912 <__fp_splitA>
    3930:	08 c0       	rjmp	.+16     	; 0x3942 <__fp_splitA+0x30>
    3932:	16 16       	cp	r1, r22
    3934:	17 06       	cpc	r1, r23
    3936:	18 06       	cpc	r1, r24
    3938:	99 1f       	adc	r25, r25
    393a:	f1 cf       	rjmp	.-30     	; 0x391e <__fp_splitA+0xc>
    393c:	86 95       	lsr	r24
    393e:	71 05       	cpc	r23, r1
    3940:	61 05       	cpc	r22, r1
    3942:	08 94       	sec
    3944:	08 95       	ret

00003946 <__fp_zero>:
    3946:	e8 94       	clt

00003948 <__fp_szero>:
    3948:	bb 27       	eor	r27, r27
    394a:	66 27       	eor	r22, r22
    394c:	77 27       	eor	r23, r23
    394e:	cb 01       	movw	r24, r22
    3950:	97 f9       	bld	r25, 7
    3952:	08 95       	ret

00003954 <__gesf2>:
    3954:	51 df       	rcall	.-350    	; 0x37f8 <__fp_cmp>
    3956:	08 f4       	brcc	.+2      	; 0x395a <__gesf2+0x6>
    3958:	8f ef       	ldi	r24, 0xFF	; 255
    395a:	08 95       	ret

0000395c <__mulsf3>:
    395c:	0b d0       	rcall	.+22     	; 0x3974 <__mulsf3x>
    395e:	af cf       	rjmp	.-162    	; 0x38be <__fp_round>
    3960:	78 df       	rcall	.-272    	; 0x3852 <__fp_pscA>
    3962:	28 f0       	brcs	.+10     	; 0x396e <__mulsf3+0x12>
    3964:	7d df       	rcall	.-262    	; 0x3860 <__fp_pscB>
    3966:	18 f0       	brcs	.+6      	; 0x396e <__mulsf3+0x12>
    3968:	95 23       	and	r25, r21
    396a:	09 f0       	breq	.+2      	; 0x396e <__mulsf3+0x12>
    396c:	69 cf       	rjmp	.-302    	; 0x3840 <__fp_inf>
    396e:	6e cf       	rjmp	.-292    	; 0x384c <__fp_nan>
    3970:	11 24       	eor	r1, r1
    3972:	ea cf       	rjmp	.-44     	; 0x3948 <__fp_szero>

00003974 <__mulsf3x>:
    3974:	c6 df       	rcall	.-116    	; 0x3902 <__fp_split3>
    3976:	a0 f3       	brcs	.-24     	; 0x3960 <__mulsf3+0x4>

00003978 <__mulsf3_pse>:
    3978:	95 9f       	mul	r25, r21
    397a:	d1 f3       	breq	.-12     	; 0x3970 <__mulsf3+0x14>
    397c:	95 0f       	add	r25, r21
    397e:	50 e0       	ldi	r21, 0x00	; 0
    3980:	55 1f       	adc	r21, r21
    3982:	62 9f       	mul	r22, r18
    3984:	f0 01       	movw	r30, r0
    3986:	72 9f       	mul	r23, r18
    3988:	bb 27       	eor	r27, r27
    398a:	f0 0d       	add	r31, r0
    398c:	b1 1d       	adc	r27, r1
    398e:	63 9f       	mul	r22, r19
    3990:	aa 27       	eor	r26, r26
    3992:	f0 0d       	add	r31, r0
    3994:	b1 1d       	adc	r27, r1
    3996:	aa 1f       	adc	r26, r26
    3998:	64 9f       	mul	r22, r20
    399a:	66 27       	eor	r22, r22
    399c:	b0 0d       	add	r27, r0
    399e:	a1 1d       	adc	r26, r1
    39a0:	66 1f       	adc	r22, r22
    39a2:	82 9f       	mul	r24, r18
    39a4:	22 27       	eor	r18, r18
    39a6:	b0 0d       	add	r27, r0
    39a8:	a1 1d       	adc	r26, r1
    39aa:	62 1f       	adc	r22, r18
    39ac:	73 9f       	mul	r23, r19
    39ae:	b0 0d       	add	r27, r0
    39b0:	a1 1d       	adc	r26, r1
    39b2:	62 1f       	adc	r22, r18
    39b4:	83 9f       	mul	r24, r19
    39b6:	a0 0d       	add	r26, r0
    39b8:	61 1d       	adc	r22, r1
    39ba:	22 1f       	adc	r18, r18
    39bc:	74 9f       	mul	r23, r20
    39be:	33 27       	eor	r19, r19
    39c0:	a0 0d       	add	r26, r0
    39c2:	61 1d       	adc	r22, r1
    39c4:	23 1f       	adc	r18, r19
    39c6:	84 9f       	mul	r24, r20
    39c8:	60 0d       	add	r22, r0
    39ca:	21 1d       	adc	r18, r1
    39cc:	82 2f       	mov	r24, r18
    39ce:	76 2f       	mov	r23, r22
    39d0:	6a 2f       	mov	r22, r26
    39d2:	11 24       	eor	r1, r1
    39d4:	9f 57       	subi	r25, 0x7F	; 127
    39d6:	50 40       	sbci	r21, 0x00	; 0
    39d8:	8a f0       	brmi	.+34     	; 0x39fc <__mulsf3_pse+0x84>
    39da:	e1 f0       	breq	.+56     	; 0x3a14 <__mulsf3_pse+0x9c>
    39dc:	88 23       	and	r24, r24
    39de:	4a f0       	brmi	.+18     	; 0x39f2 <__mulsf3_pse+0x7a>
    39e0:	ee 0f       	add	r30, r30
    39e2:	ff 1f       	adc	r31, r31
    39e4:	bb 1f       	adc	r27, r27
    39e6:	66 1f       	adc	r22, r22
    39e8:	77 1f       	adc	r23, r23
    39ea:	88 1f       	adc	r24, r24
    39ec:	91 50       	subi	r25, 0x01	; 1
    39ee:	50 40       	sbci	r21, 0x00	; 0
    39f0:	a9 f7       	brne	.-22     	; 0x39dc <__mulsf3_pse+0x64>
    39f2:	9e 3f       	cpi	r25, 0xFE	; 254
    39f4:	51 05       	cpc	r21, r1
    39f6:	70 f0       	brcs	.+28     	; 0x3a14 <__mulsf3_pse+0x9c>
    39f8:	23 cf       	rjmp	.-442    	; 0x3840 <__fp_inf>
    39fa:	a6 cf       	rjmp	.-180    	; 0x3948 <__fp_szero>
    39fc:	5f 3f       	cpi	r21, 0xFF	; 255
    39fe:	ec f3       	brlt	.-6      	; 0x39fa <__mulsf3_pse+0x82>
    3a00:	98 3e       	cpi	r25, 0xE8	; 232
    3a02:	dc f3       	brlt	.-10     	; 0x39fa <__mulsf3_pse+0x82>
    3a04:	86 95       	lsr	r24
    3a06:	77 95       	ror	r23
    3a08:	67 95       	ror	r22
    3a0a:	b7 95       	ror	r27
    3a0c:	f7 95       	ror	r31
    3a0e:	e7 95       	ror	r30
    3a10:	9f 5f       	subi	r25, 0xFF	; 255
    3a12:	c1 f7       	brne	.-16     	; 0x3a04 <__mulsf3_pse+0x8c>
    3a14:	fe 2b       	or	r31, r30
    3a16:	88 0f       	add	r24, r24
    3a18:	91 1d       	adc	r25, r1
    3a1a:	96 95       	lsr	r25
    3a1c:	87 95       	ror	r24
    3a1e:	97 f9       	bld	r25, 7
    3a20:	08 95       	ret

00003a22 <sin>:
    3a22:	9f 93       	push	r25
    3a24:	25 df       	rcall	.-438    	; 0x3870 <__fp_rempio2>
    3a26:	0f 90       	pop	r0
    3a28:	07 fc       	sbrc	r0, 7
    3a2a:	ee 5f       	subi	r30, 0xFE	; 254
    3a2c:	59 cf       	rjmp	.-334    	; 0x38e0 <__fp_sinus>

00003a2e <__fp_mpack>:
    3a2e:	9f 3f       	cpi	r25, 0xFF	; 255
    3a30:	31 f0       	breq	.+12     	; 0x3a3e <__fp_mpack_finite+0xc>

00003a32 <__fp_mpack_finite>:
    3a32:	91 50       	subi	r25, 0x01	; 1
    3a34:	20 f4       	brcc	.+8      	; 0x3a3e <__fp_mpack_finite+0xc>
    3a36:	87 95       	ror	r24
    3a38:	77 95       	ror	r23
    3a3a:	67 95       	ror	r22
    3a3c:	b7 95       	ror	r27
    3a3e:	88 0f       	add	r24, r24
    3a40:	91 1d       	adc	r25, r1
    3a42:	96 95       	lsr	r25
    3a44:	87 95       	ror	r24
    3a46:	97 f9       	bld	r25, 7
    3a48:	08 95       	ret

00003a4a <__fp_powsodd>:
    3a4a:	9f 93       	push	r25
    3a4c:	8f 93       	push	r24
    3a4e:	7f 93       	push	r23
    3a50:	6f 93       	push	r22
    3a52:	ff 93       	push	r31
    3a54:	ef 93       	push	r30
    3a56:	9b 01       	movw	r18, r22
    3a58:	ac 01       	movw	r20, r24
    3a5a:	80 df       	rcall	.-256    	; 0x395c <__mulsf3>
    3a5c:	ef 91       	pop	r30
    3a5e:	ff 91       	pop	r31
    3a60:	05 d0       	rcall	.+10     	; 0x3a6c <__fp_powser>
    3a62:	2f 91       	pop	r18
    3a64:	3f 91       	pop	r19
    3a66:	4f 91       	pop	r20
    3a68:	5f 91       	pop	r21
    3a6a:	78 cf       	rjmp	.-272    	; 0x395c <__mulsf3>

00003a6c <__fp_powser>:
    3a6c:	df 93       	push	r29
    3a6e:	cf 93       	push	r28
    3a70:	1f 93       	push	r17
    3a72:	0f 93       	push	r16
    3a74:	ff 92       	push	r15
    3a76:	ef 92       	push	r14
    3a78:	df 92       	push	r13
    3a7a:	7b 01       	movw	r14, r22
    3a7c:	8c 01       	movw	r16, r24
    3a7e:	68 94       	set
    3a80:	05 c0       	rjmp	.+10     	; 0x3a8c <__fp_powser+0x20>
    3a82:	da 2e       	mov	r13, r26
    3a84:	ef 01       	movw	r28, r30
    3a86:	76 df       	rcall	.-276    	; 0x3974 <__mulsf3x>
    3a88:	fe 01       	movw	r30, r28
    3a8a:	e8 94       	clt
    3a8c:	a5 91       	lpm	r26, Z+
    3a8e:	25 91       	lpm	r18, Z+
    3a90:	35 91       	lpm	r19, Z+
    3a92:	45 91       	lpm	r20, Z+
    3a94:	55 91       	lpm	r21, Z+
    3a96:	ae f3       	brts	.-22     	; 0x3a82 <__fp_powser+0x16>
    3a98:	ef 01       	movw	r28, r30
    3a9a:	7e dd       	rcall	.-1284   	; 0x3598 <__addsf3x>
    3a9c:	fe 01       	movw	r30, r28
    3a9e:	97 01       	movw	r18, r14
    3aa0:	a8 01       	movw	r20, r16
    3aa2:	da 94       	dec	r13
    3aa4:	79 f7       	brne	.-34     	; 0x3a84 <__fp_powser+0x18>
    3aa6:	df 90       	pop	r13
    3aa8:	ef 90       	pop	r14
    3aaa:	ff 90       	pop	r15
    3aac:	0f 91       	pop	r16
    3aae:	1f 91       	pop	r17
    3ab0:	cf 91       	pop	r28
    3ab2:	df 91       	pop	r29
    3ab4:	08 95       	ret

00003ab6 <__divmodhi4>:
    3ab6:	97 fb       	bst	r25, 7
    3ab8:	09 2e       	mov	r0, r25
    3aba:	07 26       	eor	r0, r23
    3abc:	0a d0       	rcall	.+20     	; 0x3ad2 <__divmodhi4_neg1>
    3abe:	77 fd       	sbrc	r23, 7
    3ac0:	04 d0       	rcall	.+8      	; 0x3aca <__divmodhi4_neg2>
    3ac2:	2e d0       	rcall	.+92     	; 0x3b20 <__udivmodhi4>
    3ac4:	06 d0       	rcall	.+12     	; 0x3ad2 <__divmodhi4_neg1>
    3ac6:	00 20       	and	r0, r0
    3ac8:	1a f4       	brpl	.+6      	; 0x3ad0 <__divmodhi4_exit>

00003aca <__divmodhi4_neg2>:
    3aca:	70 95       	com	r23
    3acc:	61 95       	neg	r22
    3ace:	7f 4f       	sbci	r23, 0xFF	; 255

00003ad0 <__divmodhi4_exit>:
    3ad0:	08 95       	ret

00003ad2 <__divmodhi4_neg1>:
    3ad2:	f6 f7       	brtc	.-4      	; 0x3ad0 <__divmodhi4_exit>
    3ad4:	90 95       	com	r25
    3ad6:	81 95       	neg	r24
    3ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    3ada:	08 95       	ret

00003adc <__udivmodsi4>:
    3adc:	a1 e2       	ldi	r26, 0x21	; 33
    3ade:	1a 2e       	mov	r1, r26
    3ae0:	aa 1b       	sub	r26, r26
    3ae2:	bb 1b       	sub	r27, r27
    3ae4:	fd 01       	movw	r30, r26
    3ae6:	0d c0       	rjmp	.+26     	; 0x3b02 <__udivmodsi4_ep>

00003ae8 <__udivmodsi4_loop>:
    3ae8:	aa 1f       	adc	r26, r26
    3aea:	bb 1f       	adc	r27, r27
    3aec:	ee 1f       	adc	r30, r30
    3aee:	ff 1f       	adc	r31, r31
    3af0:	a2 17       	cp	r26, r18
    3af2:	b3 07       	cpc	r27, r19
    3af4:	e4 07       	cpc	r30, r20
    3af6:	f5 07       	cpc	r31, r21
    3af8:	20 f0       	brcs	.+8      	; 0x3b02 <__udivmodsi4_ep>
    3afa:	a2 1b       	sub	r26, r18
    3afc:	b3 0b       	sbc	r27, r19
    3afe:	e4 0b       	sbc	r30, r20
    3b00:	f5 0b       	sbc	r31, r21

00003b02 <__udivmodsi4_ep>:
    3b02:	66 1f       	adc	r22, r22
    3b04:	77 1f       	adc	r23, r23
    3b06:	88 1f       	adc	r24, r24
    3b08:	99 1f       	adc	r25, r25
    3b0a:	1a 94       	dec	r1
    3b0c:	69 f7       	brne	.-38     	; 0x3ae8 <__udivmodsi4_loop>
    3b0e:	60 95       	com	r22
    3b10:	70 95       	com	r23
    3b12:	80 95       	com	r24
    3b14:	90 95       	com	r25
    3b16:	9b 01       	movw	r18, r22
    3b18:	ac 01       	movw	r20, r24
    3b1a:	bd 01       	movw	r22, r26
    3b1c:	cf 01       	movw	r24, r30
    3b1e:	08 95       	ret

00003b20 <__udivmodhi4>:
    3b20:	aa 1b       	sub	r26, r26
    3b22:	bb 1b       	sub	r27, r27
    3b24:	51 e1       	ldi	r21, 0x11	; 17
    3b26:	07 c0       	rjmp	.+14     	; 0x3b36 <__udivmodhi4_ep>

00003b28 <__udivmodhi4_loop>:
    3b28:	aa 1f       	adc	r26, r26
    3b2a:	bb 1f       	adc	r27, r27
    3b2c:	a6 17       	cp	r26, r22
    3b2e:	b7 07       	cpc	r27, r23
    3b30:	10 f0       	brcs	.+4      	; 0x3b36 <__udivmodhi4_ep>
    3b32:	a6 1b       	sub	r26, r22
    3b34:	b7 0b       	sbc	r27, r23

00003b36 <__udivmodhi4_ep>:
    3b36:	88 1f       	adc	r24, r24
    3b38:	99 1f       	adc	r25, r25
    3b3a:	5a 95       	dec	r21
    3b3c:	a9 f7       	brne	.-22     	; 0x3b28 <__udivmodhi4_loop>
    3b3e:	80 95       	com	r24
    3b40:	90 95       	com	r25
    3b42:	bc 01       	movw	r22, r24
    3b44:	cd 01       	movw	r24, r26
    3b46:	08 95       	ret

00003b48 <do_rand>:
    3b48:	8f 92       	push	r8
    3b4a:	9f 92       	push	r9
    3b4c:	af 92       	push	r10
    3b4e:	bf 92       	push	r11
    3b50:	cf 92       	push	r12
    3b52:	df 92       	push	r13
    3b54:	ef 92       	push	r14
    3b56:	ff 92       	push	r15
    3b58:	cf 93       	push	r28
    3b5a:	df 93       	push	r29
    3b5c:	ec 01       	movw	r28, r24
    3b5e:	88 81       	ld	r24, Y
    3b60:	99 81       	ldd	r25, Y+1	; 0x01
    3b62:	aa 81       	ldd	r26, Y+2	; 0x02
    3b64:	bb 81       	ldd	r27, Y+3	; 0x03
    3b66:	00 97       	sbiw	r24, 0x00	; 0
    3b68:	a1 05       	cpc	r26, r1
    3b6a:	b1 05       	cpc	r27, r1
    3b6c:	21 f4       	brne	.+8      	; 0x3b76 <do_rand+0x2e>
    3b6e:	84 e2       	ldi	r24, 0x24	; 36
    3b70:	99 ed       	ldi	r25, 0xD9	; 217
    3b72:	ab e5       	ldi	r26, 0x5B	; 91
    3b74:	b7 e0       	ldi	r27, 0x07	; 7
    3b76:	bc 01       	movw	r22, r24
    3b78:	cd 01       	movw	r24, r26
    3b7a:	2d e1       	ldi	r18, 0x1D	; 29
    3b7c:	33 ef       	ldi	r19, 0xF3	; 243
    3b7e:	41 e0       	ldi	r20, 0x01	; 1
    3b80:	50 e0       	ldi	r21, 0x00	; 0
    3b82:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <__divmodsi4>
    3b86:	49 01       	movw	r8, r18
    3b88:	5a 01       	movw	r10, r20
    3b8a:	27 ea       	ldi	r18, 0xA7	; 167
    3b8c:	31 e4       	ldi	r19, 0x41	; 65
    3b8e:	40 e0       	ldi	r20, 0x00	; 0
    3b90:	50 e0       	ldi	r21, 0x00	; 0
    3b92:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <__mulsi3>
    3b96:	6b 01       	movw	r12, r22
    3b98:	7c 01       	movw	r14, r24
    3b9a:	c5 01       	movw	r24, r10
    3b9c:	b4 01       	movw	r22, r8
    3b9e:	2c ee       	ldi	r18, 0xEC	; 236
    3ba0:	34 ef       	ldi	r19, 0xF4	; 244
    3ba2:	4f ef       	ldi	r20, 0xFF	; 255
    3ba4:	5f ef       	ldi	r21, 0xFF	; 255
    3ba6:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <__mulsi3>
    3baa:	dc 01       	movw	r26, r24
    3bac:	cb 01       	movw	r24, r22
    3bae:	c8 0e       	add	r12, r24
    3bb0:	d9 1e       	adc	r13, r25
    3bb2:	ea 1e       	adc	r14, r26
    3bb4:	fb 1e       	adc	r15, r27
    3bb6:	f7 fe       	sbrs	r15, 7
    3bb8:	08 c0       	rjmp	.+16     	; 0x3bca <do_rand+0x82>
    3bba:	8f ef       	ldi	r24, 0xFF	; 255
    3bbc:	9f ef       	ldi	r25, 0xFF	; 255
    3bbe:	af ef       	ldi	r26, 0xFF	; 255
    3bc0:	bf e7       	ldi	r27, 0x7F	; 127
    3bc2:	c8 0e       	add	r12, r24
    3bc4:	d9 1e       	adc	r13, r25
    3bc6:	ea 1e       	adc	r14, r26
    3bc8:	fb 1e       	adc	r15, r27
    3bca:	c8 82       	st	Y, r12
    3bcc:	d9 82       	std	Y+1, r13	; 0x01
    3bce:	ea 82       	std	Y+2, r14	; 0x02
    3bd0:	fb 82       	std	Y+3, r15	; 0x03
    3bd2:	c6 01       	movw	r24, r12
    3bd4:	9f 77       	andi	r25, 0x7F	; 127
    3bd6:	df 91       	pop	r29
    3bd8:	cf 91       	pop	r28
    3bda:	ff 90       	pop	r15
    3bdc:	ef 90       	pop	r14
    3bde:	df 90       	pop	r13
    3be0:	cf 90       	pop	r12
    3be2:	bf 90       	pop	r11
    3be4:	af 90       	pop	r10
    3be6:	9f 90       	pop	r9
    3be8:	8f 90       	pop	r8
    3bea:	08 95       	ret

00003bec <rand_r>:
    3bec:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <do_rand>
    3bf0:	08 95       	ret

00003bf2 <rand>:
    3bf2:	8b e5       	ldi	r24, 0x5B	; 91
    3bf4:	92 e0       	ldi	r25, 0x02	; 2
    3bf6:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <do_rand>
    3bfa:	08 95       	ret

00003bfc <srand>:
    3bfc:	a0 e0       	ldi	r26, 0x00	; 0
    3bfe:	b0 e0       	ldi	r27, 0x00	; 0
    3c00:	80 93 5b 02 	sts	0x025B, r24
    3c04:	90 93 5c 02 	sts	0x025C, r25
    3c08:	a0 93 5d 02 	sts	0x025D, r26
    3c0c:	b0 93 5e 02 	sts	0x025E, r27
    3c10:	08 95       	ret

00003c12 <memcpy>:
    3c12:	fb 01       	movw	r30, r22
    3c14:	dc 01       	movw	r26, r24
    3c16:	02 c0       	rjmp	.+4      	; 0x3c1c <memcpy+0xa>
    3c18:	01 90       	ld	r0, Z+
    3c1a:	0d 92       	st	X+, r0
    3c1c:	41 50       	subi	r20, 0x01	; 1
    3c1e:	50 40       	sbci	r21, 0x00	; 0
    3c20:	d8 f7       	brcc	.-10     	; 0x3c18 <memcpy+0x6>
    3c22:	08 95       	ret

00003c24 <memset>:
    3c24:	dc 01       	movw	r26, r24
    3c26:	01 c0       	rjmp	.+2      	; 0x3c2a <memset+0x6>
    3c28:	6d 93       	st	X+, r22
    3c2a:	41 50       	subi	r20, 0x01	; 1
    3c2c:	50 40       	sbci	r21, 0x00	; 0
    3c2e:	e0 f7       	brcc	.-8      	; 0x3c28 <memset+0x4>
    3c30:	08 95       	ret

00003c32 <strncpy>:
    3c32:	fb 01       	movw	r30, r22
    3c34:	dc 01       	movw	r26, r24
    3c36:	41 50       	subi	r20, 0x01	; 1
    3c38:	50 40       	sbci	r21, 0x00	; 0
    3c3a:	48 f0       	brcs	.+18     	; 0x3c4e <strncpy+0x1c>
    3c3c:	01 90       	ld	r0, Z+
    3c3e:	0d 92       	st	X+, r0
    3c40:	00 20       	and	r0, r0
    3c42:	c9 f7       	brne	.-14     	; 0x3c36 <strncpy+0x4>
    3c44:	01 c0       	rjmp	.+2      	; 0x3c48 <strncpy+0x16>
    3c46:	1d 92       	st	X+, r1
    3c48:	41 50       	subi	r20, 0x01	; 1
    3c4a:	50 40       	sbci	r21, 0x00	; 0
    3c4c:	e0 f7       	brcc	.-8      	; 0x3c46 <strncpy+0x14>
    3c4e:	08 95       	ret

00003c50 <__mulsi3>:
    3c50:	62 9f       	mul	r22, r18
    3c52:	d0 01       	movw	r26, r0
    3c54:	73 9f       	mul	r23, r19
    3c56:	f0 01       	movw	r30, r0
    3c58:	82 9f       	mul	r24, r18
    3c5a:	e0 0d       	add	r30, r0
    3c5c:	f1 1d       	adc	r31, r1
    3c5e:	64 9f       	mul	r22, r20
    3c60:	e0 0d       	add	r30, r0
    3c62:	f1 1d       	adc	r31, r1
    3c64:	92 9f       	mul	r25, r18
    3c66:	f0 0d       	add	r31, r0
    3c68:	83 9f       	mul	r24, r19
    3c6a:	f0 0d       	add	r31, r0
    3c6c:	74 9f       	mul	r23, r20
    3c6e:	f0 0d       	add	r31, r0
    3c70:	65 9f       	mul	r22, r21
    3c72:	f0 0d       	add	r31, r0
    3c74:	99 27       	eor	r25, r25
    3c76:	72 9f       	mul	r23, r18
    3c78:	b0 0d       	add	r27, r0
    3c7a:	e1 1d       	adc	r30, r1
    3c7c:	f9 1f       	adc	r31, r25
    3c7e:	63 9f       	mul	r22, r19
    3c80:	b0 0d       	add	r27, r0
    3c82:	e1 1d       	adc	r30, r1
    3c84:	f9 1f       	adc	r31, r25
    3c86:	bd 01       	movw	r22, r26
    3c88:	cf 01       	movw	r24, r30
    3c8a:	11 24       	eor	r1, r1
    3c8c:	08 95       	ret

00003c8e <__divmodsi4>:
    3c8e:	97 fb       	bst	r25, 7
    3c90:	09 2e       	mov	r0, r25
    3c92:	05 26       	eor	r0, r21
    3c94:	0e d0       	rcall	.+28     	; 0x3cb2 <__divmodsi4_neg1>
    3c96:	57 fd       	sbrc	r21, 7
    3c98:	04 d0       	rcall	.+8      	; 0x3ca2 <__divmodsi4_neg2>
    3c9a:	20 df       	rcall	.-448    	; 0x3adc <__udivmodsi4>
    3c9c:	0a d0       	rcall	.+20     	; 0x3cb2 <__divmodsi4_neg1>
    3c9e:	00 1c       	adc	r0, r0
    3ca0:	38 f4       	brcc	.+14     	; 0x3cb0 <__divmodsi4_exit>

00003ca2 <__divmodsi4_neg2>:
    3ca2:	50 95       	com	r21
    3ca4:	40 95       	com	r20
    3ca6:	30 95       	com	r19
    3ca8:	21 95       	neg	r18
    3caa:	3f 4f       	sbci	r19, 0xFF	; 255
    3cac:	4f 4f       	sbci	r20, 0xFF	; 255
    3cae:	5f 4f       	sbci	r21, 0xFF	; 255

00003cb0 <__divmodsi4_exit>:
    3cb0:	08 95       	ret

00003cb2 <__divmodsi4_neg1>:
    3cb2:	f6 f7       	brtc	.-4      	; 0x3cb0 <__divmodsi4_exit>
    3cb4:	90 95       	com	r25
    3cb6:	80 95       	com	r24
    3cb8:	70 95       	com	r23
    3cba:	61 95       	neg	r22
    3cbc:	7f 4f       	sbci	r23, 0xFF	; 255
    3cbe:	8f 4f       	sbci	r24, 0xFF	; 255
    3cc0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cc2:	08 95       	ret

00003cc4 <_exit>:
    3cc4:	f8 94       	cli

00003cc6 <__stop_program>:
    3cc6:	ff cf       	rjmp	.-2      	; 0x3cc6 <__stop_program>
