
Lab 5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000060  00800200  00003df2  00003e86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003df2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018c7  00800260  00800260  00003ee6  2**0
                  ALLOC
  3 .stab         00002dcc  00000000  00000000  00003ee8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ba1  00000000  00000000  00006cb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000258  00000000  00000000  00007858  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000035b5  00000000  00000000  00007ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e92  00000000  00000000  0000b065  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000167a  00000000  00000000  0000bef7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d04  00000000  00000000  0000d574  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000133a  00000000  00000000  0000e278  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003a1e  00000000  00000000  0000f5b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  00012fd0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 81 00 	jmp	0x102	; 0x102 <__ctors_end>
       4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      10:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      14:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      18:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      1c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      20:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      24:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      28:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      2c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      30:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      34:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      38:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      3c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      40:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      44:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      48:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      4c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      50:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      54:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      58:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      5c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      60:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      64:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      68:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      6c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      70:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      74:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      78:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      7c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      80:	0c 94 85 11 	jmp	0x230a	; 0x230a <__vector_32>
      84:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      88:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      8c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      90:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      94:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      98:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      9c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      ac:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      bc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      cc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      dc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      e0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      e4:	05 a8       	sts	0x85, r16
      e6:	4c cd       	rjmp	.-1384   	; 0xfffffb80 <__eeprom_end+0xff7efb80>
      e8:	b2 d4       	rcall	.+2404   	; 0xa4e <createAsteroid+0xa6>
      ea:	4e b9       	out	0x0e, r20	; 14
      ec:	38 36       	cpi	r19, 0x68	; 104
      ee:	a9 02       	muls	r26, r25
      f0:	0c 50       	subi	r16, 0x0C	; 12
      f2:	b9 91       	ld	r27, Y+
      f4:	86 88       	ldd	r8, Z+22	; 0x16
      f6:	08 3c       	cpi	r16, 0xC8	; 200
      f8:	a6 aa       	sts	0x96, r26
      fa:	aa 2a       	or	r10, r26
      fc:	be 00       	.word	0x00be	; ????
      fe:	00 00       	nop
     100:	80 3f       	cpi	r24, 0xF0	; 240

00000102 <__ctors_end>:
     102:	11 24       	eor	r1, r1
     104:	1f be       	out	0x3f, r1	; 63
     106:	cf ef       	ldi	r28, 0xFF	; 255
     108:	d1 e2       	ldi	r29, 0x21	; 33
     10a:	de bf       	out	0x3e, r29	; 62
     10c:	cd bf       	out	0x3d, r28	; 61
     10e:	00 e0       	ldi	r16, 0x00	; 0
     110:	0c bf       	out	0x3c, r16	; 60

00000112 <__do_copy_data>:
     112:	12 e0       	ldi	r17, 0x02	; 2
     114:	a0 e0       	ldi	r26, 0x00	; 0
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	e2 ef       	ldi	r30, 0xF2	; 242
     11a:	fd e3       	ldi	r31, 0x3D	; 61
     11c:	00 e0       	ldi	r16, 0x00	; 0
     11e:	0b bf       	out	0x3b, r16	; 59
     120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x14>
     122:	07 90       	elpm	r0, Z+
     124:	0d 92       	st	X+, r0
     126:	a0 36       	cpi	r26, 0x60	; 96
     128:	b1 07       	cpc	r27, r17
     12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0x10>
     12c:	1b be       	out	0x3b, r1	; 59

0000012e <__do_clear_bss>:
     12e:	1b e1       	ldi	r17, 0x1B	; 27
     130:	a0 e6       	ldi	r26, 0x60	; 96
     132:	b2 e0       	ldi	r27, 0x02	; 2
     134:	01 c0       	rjmp	.+2      	; 0x138 <.do_clear_bss_start>

00000136 <.do_clear_bss_loop>:
     136:	1d 92       	st	X+, r1

00000138 <.do_clear_bss_start>:
     138:	a7 32       	cpi	r26, 0x27	; 39
     13a:	b1 07       	cpc	r27, r17
     13c:	e1 f7       	brne	.-8      	; 0x136 <.do_clear_bss_loop>
     13e:	0e 94 0b 04 	call	0x816	; 0x816 <main>
     142:	0c 94 f7 1e 	jmp	0x3dee	; 0x3dee <_exit>

00000146 <__bad_interrupt>:
     146:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014a <inputTask>:
 *  if the player should turn, accelerate, or both. This task never blocks, so
 *  it should run at the lowest priority above the idle task priority.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void inputTask(void *vParam) {
     14a:	ff cf       	rjmp	.-2      	; 0x14a <inputTask>

0000014c <updateTask>:
 *  If a bullet has been in flight for too long, this task will delete it. This
 *  task runs every 10 milliseconds.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void updateTask(void *vParam) {
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	0f 92       	push	r0
     152:	0f 92       	push	r0
     154:	cd b7       	in	r28, 0x3d	; 61
     156:	de b7       	in	r29, 0x3e	; 62
		ship.vel.x += ship.accel * -sin(ship.angle * DEG_TO_RAD);
		ship.vel.y += ship.accel * -cos(ship.angle * DEG_TO_RAD);
		vel = ship.vel.x * ship.vel.x + ship.vel.y * ship.vel.y;
		if (vel > SHIP_MAX_VEL) {
			ship.vel.x *= SHIP_MAX_VEL / vel;
			ship.vel.y *= SHIP_MAX_VEL / vel;
     158:	89 e6       	ldi	r24, 0x69	; 105
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	04 96       	adiw	r24, 0x04	; 4
     15e:	9a 83       	std	Y+2, r25	; 0x02
     160:	89 83       	std	Y+1, r24	; 0x01
	float vel;
	object *objIter, *objPrev;
	for (;;) {
		
		// spin ship
		ship.angle += ship.a_vel;
     162:	e7 e7       	ldi	r30, 0x77	; 119
     164:	f2 e0       	ldi	r31, 0x02	; 2
     166:	80 81       	ld	r24, Z
     168:	99 27       	eor	r25, r25
     16a:	87 fd       	sbrc	r24, 7
     16c:	90 95       	com	r25
     16e:	32 97       	sbiw	r30, 0x02	; 2
     170:	20 81       	ld	r18, Z
     172:	31 81       	ldd	r19, Z+1	; 0x01
     174:	82 0f       	add	r24, r18
     176:	93 1f       	adc	r25, r19
     178:	91 83       	std	Z+1, r25	; 0x01
     17a:	80 83       	st	Z, r24
		if (ship.angle >= 360)
     17c:	f1 e0       	ldi	r31, 0x01	; 1
     17e:	88 36       	cpi	r24, 0x68	; 104
     180:	9f 07       	cpc	r25, r31
     182:	2c f0       	brlt	.+10     	; 0x18e <updateTask+0x42>
         ship.angle -= 360;
     184:	88 56       	subi	r24, 0x68	; 104
     186:	91 40       	sbci	r25, 0x01	; 1
     188:	91 83       	std	Z+1, r25	; 0x01
     18a:	80 83       	st	Z, r24
     18c:	08 c0       	rjmp	.+16     	; 0x19e <updateTask+0x52>
		else if (ship.angle < 0)
     18e:	99 23       	and	r25, r25
     190:	34 f4       	brge	.+12     	; 0x19e <updateTask+0x52>
		   ship.angle += 360;
     192:	88 59       	subi	r24, 0x98	; 152
     194:	9e 4f       	sbci	r25, 0xFE	; 254
     196:	e5 e7       	ldi	r30, 0x75	; 117
     198:	f2 e0       	ldi	r31, 0x02	; 2
     19a:	91 83       	std	Z+1, r25	; 0x01
     19c:	80 83       	st	Z, r24
		
		// move ship
		ship.vel.x += ship.accel * -sin(ship.angle * DEG_TO_RAD);
     19e:	e1 e7       	ldi	r30, 0x71	; 113
     1a0:	f2 e0       	ldi	r31, 0x02	; 2
     1a2:	c0 80       	ld	r12, Z
     1a4:	d1 80       	ldd	r13, Z+1	; 0x01
     1a6:	e2 80       	ldd	r14, Z+2	; 0x02
     1a8:	f3 80       	ldd	r15, Z+3	; 0x03
     1aa:	34 96       	adiw	r30, 0x04	; 4
     1ac:	60 81       	ld	r22, Z
     1ae:	71 81       	ldd	r23, Z+1	; 0x01
     1b0:	88 27       	eor	r24, r24
     1b2:	77 fd       	sbrc	r23, 7
     1b4:	80 95       	com	r24
     1b6:	98 2f       	mov	r25, r24
     1b8:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
     1bc:	2b ed       	ldi	r18, 0xDB	; 219
     1be:	3f e0       	ldi	r19, 0x0F	; 15
     1c0:	49 e4       	ldi	r20, 0x49	; 73
     1c2:	50 e4       	ldi	r21, 0x40	; 64
     1c4:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     1c8:	20 e0       	ldi	r18, 0x00	; 0
     1ca:	30 e0       	ldi	r19, 0x00	; 0
     1cc:	44 e3       	ldi	r20, 0x34	; 52
     1ce:	53 e4       	ldi	r21, 0x43	; 67
     1d0:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
     1d4:	b6 2e       	mov	r11, r22
     1d6:	87 2e       	mov	r8, r23
     1d8:	18 2f       	mov	r17, r24
     1da:	09 2f       	mov	r16, r25
     1dc:	86 2f       	mov	r24, r22
     1de:	98 2d       	mov	r25, r8
     1e0:	a1 2f       	mov	r26, r17
     1e2:	b0 2f       	mov	r27, r16
     1e4:	bc 01       	movw	r22, r24
     1e6:	cd 01       	movw	r24, r26
     1e8:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <sin>
     1ec:	dc 01       	movw	r26, r24
     1ee:	cb 01       	movw	r24, r22
     1f0:	9c 01       	movw	r18, r24
     1f2:	ad 01       	movw	r20, r26
     1f4:	50 58       	subi	r21, 0x80	; 128
     1f6:	c7 01       	movw	r24, r14
     1f8:	b6 01       	movw	r22, r12
     1fa:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     1fe:	e9 e6       	ldi	r30, 0x69	; 105
     200:	f2 e0       	ldi	r31, 0x02	; 2
     202:	20 81       	ld	r18, Z
     204:	31 81       	ldd	r19, Z+1	; 0x01
     206:	42 81       	ldd	r20, Z+2	; 0x02
     208:	53 81       	ldd	r21, Z+3	; 0x03
     20a:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     20e:	46 2e       	mov	r4, r22
     210:	37 2e       	mov	r3, r23
     212:	28 2e       	mov	r2, r24
     214:	79 2e       	mov	r7, r25
     216:	86 2f       	mov	r24, r22
     218:	93 2d       	mov	r25, r3
     21a:	a2 2d       	mov	r26, r2
     21c:	b7 2d       	mov	r27, r7
     21e:	e9 e6       	ldi	r30, 0x69	; 105
     220:	f2 e0       	ldi	r31, 0x02	; 2
     222:	80 83       	st	Z, r24
     224:	91 83       	std	Z+1, r25	; 0x01
     226:	a2 83       	std	Z+2, r26	; 0x02
     228:	b3 83       	std	Z+3, r27	; 0x03
		ship.vel.y += ship.accel * -cos(ship.angle * DEG_TO_RAD);
     22a:	8b 2d       	mov	r24, r11
     22c:	98 2d       	mov	r25, r8
     22e:	a1 2f       	mov	r26, r17
     230:	b0 2f       	mov	r27, r16
     232:	bc 01       	movw	r22, r24
     234:	cd 01       	movw	r24, r26
     236:	0e 94 b8 1b 	call	0x3770	; 0x3770 <cos>
     23a:	dc 01       	movw	r26, r24
     23c:	cb 01       	movw	r24, r22
     23e:	9c 01       	movw	r18, r24
     240:	ad 01       	movw	r20, r26
     242:	50 58       	subi	r21, 0x80	; 128
     244:	c7 01       	movw	r24, r14
     246:	b6 01       	movw	r22, r12
     248:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     24c:	ed e6       	ldi	r30, 0x6D	; 109
     24e:	f2 e0       	ldi	r31, 0x02	; 2
     250:	20 81       	ld	r18, Z
     252:	31 81       	ldd	r19, Z+1	; 0x01
     254:	42 81       	ldd	r20, Z+2	; 0x02
     256:	53 81       	ldd	r21, Z+3	; 0x03
     258:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     25c:	66 2e       	mov	r6, r22
     25e:	57 2e       	mov	r5, r23
     260:	f8 2e       	mov	r15, r24
     262:	e9 2e       	mov	r14, r25
     264:	86 2f       	mov	r24, r22
     266:	95 2d       	mov	r25, r5
     268:	af 2d       	mov	r26, r15
     26a:	be 2d       	mov	r27, r14
     26c:	ed e6       	ldi	r30, 0x6D	; 109
     26e:	f2 e0       	ldi	r31, 0x02	; 2
     270:	80 83       	st	Z, r24
     272:	91 83       	std	Z+1, r25	; 0x01
     274:	a2 83       	std	Z+2, r26	; 0x02
     276:	b3 83       	std	Z+3, r27	; 0x03
		vel = ship.vel.x * ship.vel.x + ship.vel.y * ship.vel.y;
     278:	32 2d       	mov	r19, r2
     27a:	84 2d       	mov	r24, r4
     27c:	93 2d       	mov	r25, r3
     27e:	a2 2d       	mov	r26, r2
     280:	b7 2d       	mov	r27, r7
     282:	bc 01       	movw	r22, r24
     284:	cd 01       	movw	r24, r26
     286:	04 2d       	mov	r16, r4
     288:	13 2d       	mov	r17, r3
     28a:	23 2f       	mov	r18, r19
     28c:	3b 2f       	mov	r19, r27
     28e:	a9 01       	movw	r20, r18
     290:	98 01       	movw	r18, r16
     292:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     296:	4b 01       	movw	r8, r22
     298:	5c 01       	movw	r10, r24
     29a:	3f 2d       	mov	r19, r15
     29c:	86 2d       	mov	r24, r6
     29e:	95 2d       	mov	r25, r5
     2a0:	af 2d       	mov	r26, r15
     2a2:	be 2d       	mov	r27, r14
     2a4:	bc 01       	movw	r22, r24
     2a6:	cd 01       	movw	r24, r26
     2a8:	06 2d       	mov	r16, r6
     2aa:	15 2d       	mov	r17, r5
     2ac:	23 2f       	mov	r18, r19
     2ae:	3b 2f       	mov	r19, r27
     2b0:	a9 01       	movw	r20, r18
     2b2:	98 01       	movw	r18, r16
     2b4:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     2b8:	9b 01       	movw	r18, r22
     2ba:	ac 01       	movw	r20, r24
     2bc:	c5 01       	movw	r24, r10
     2be:	b4 01       	movw	r22, r8
     2c0:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     2c4:	16 2f       	mov	r17, r22
     2c6:	07 2f       	mov	r16, r23
     2c8:	c8 2e       	mov	r12, r24
     2ca:	89 2e       	mov	r8, r25
		if (vel > SHIP_MAX_VEL) {
     2cc:	86 2f       	mov	r24, r22
     2ce:	90 2f       	mov	r25, r16
     2d0:	ac 2d       	mov	r26, r12
     2d2:	b8 2d       	mov	r27, r8
     2d4:	bc 01       	movw	r22, r24
     2d6:	cd 01       	movw	r24, r26
     2d8:	20 e0       	ldi	r18, 0x00	; 0
     2da:	30 e0       	ldi	r19, 0x00	; 0
     2dc:	40 e0       	ldi	r20, 0x00	; 0
     2de:	51 e4       	ldi	r21, 0x41	; 65
     2e0:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     2e4:	18 16       	cp	r1, r24
     2e6:	dc f5       	brge	.+118    	; 0x35e <updateTask+0x212>
			ship.vel.x *= SHIP_MAX_VEL / vel;
     2e8:	60 e0       	ldi	r22, 0x00	; 0
     2ea:	70 e0       	ldi	r23, 0x00	; 0
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	91 e4       	ldi	r25, 0x41	; 65
     2f0:	e0 2f       	mov	r30, r16
     2f2:	01 2f       	mov	r16, r17
     2f4:	1e 2f       	mov	r17, r30
     2f6:	2c 2d       	mov	r18, r12
     2f8:	38 2d       	mov	r19, r8
     2fa:	a9 01       	movw	r20, r18
     2fc:	98 01       	movw	r18, r16
     2fe:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
     302:	c6 2e       	mov	r12, r22
     304:	87 2e       	mov	r8, r23
     306:	d8 2e       	mov	r13, r24
     308:	b9 2e       	mov	r11, r25
     30a:	84 2d       	mov	r24, r4
     30c:	93 2d       	mov	r25, r3
     30e:	a2 2d       	mov	r26, r2
     310:	b7 2d       	mov	r27, r7
     312:	bc 01       	movw	r22, r24
     314:	cd 01       	movw	r24, r26
     316:	0c 2d       	mov	r16, r12
     318:	18 2d       	mov	r17, r8
     31a:	2d 2d       	mov	r18, r13
     31c:	3b 2d       	mov	r19, r11
     31e:	a9 01       	movw	r20, r18
     320:	98 01       	movw	r18, r16
     322:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     326:	dc 01       	movw	r26, r24
     328:	cb 01       	movw	r24, r22
     32a:	e9 e6       	ldi	r30, 0x69	; 105
     32c:	f2 e0       	ldi	r31, 0x02	; 2
     32e:	80 83       	st	Z, r24
     330:	91 83       	std	Z+1, r25	; 0x01
     332:	a2 83       	std	Z+2, r26	; 0x02
     334:	b3 83       	std	Z+3, r27	; 0x03
			ship.vel.y *= SHIP_MAX_VEL / vel;
     336:	86 2d       	mov	r24, r6
     338:	95 2d       	mov	r25, r5
     33a:	af 2d       	mov	r26, r15
     33c:	be 2d       	mov	r27, r14
     33e:	bc 01       	movw	r22, r24
     340:	cd 01       	movw	r24, r26
     342:	2d 2d       	mov	r18, r13
     344:	3b 2d       	mov	r19, r11
     346:	a9 01       	movw	r20, r18
     348:	98 01       	movw	r18, r16
     34a:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <__mulsf3>
     34e:	dc 01       	movw	r26, r24
     350:	cb 01       	movw	r24, r22
     352:	e9 81       	ldd	r30, Y+1	; 0x01
     354:	fa 81       	ldd	r31, Y+2	; 0x02
     356:	80 83       	st	Z, r24
     358:	91 83       	std	Z+1, r25	; 0x01
     35a:	a2 83       	std	Z+2, r26	; 0x02
     35c:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		ship.pos.x += ship.vel.x;
     35e:	e1 e6       	ldi	r30, 0x61	; 97
     360:	f2 e0       	ldi	r31, 0x02	; 2
     362:	60 81       	ld	r22, Z
     364:	71 81       	ldd	r23, Z+1	; 0x01
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	38 96       	adiw	r30, 0x08	; 8
     36c:	20 81       	ld	r18, Z
     36e:	31 81       	ldd	r19, Z+1	; 0x01
     370:	42 81       	ldd	r20, Z+2	; 0x02
     372:	53 81       	ldd	r21, Z+3	; 0x03
     374:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     378:	06 2f       	mov	r16, r22
     37a:	17 2f       	mov	r17, r23
     37c:	e8 2e       	mov	r14, r24
     37e:	f9 2e       	mov	r15, r25
     380:	86 2f       	mov	r24, r22
     382:	91 2f       	mov	r25, r17
     384:	ae 2d       	mov	r26, r14
     386:	bf 2d       	mov	r27, r15
     388:	e1 e6       	ldi	r30, 0x61	; 97
     38a:	f2 e0       	ldi	r31, 0x02	; 2
     38c:	80 83       	st	Z, r24
     38e:	91 83       	std	Z+1, r25	; 0x01
     390:	a2 83       	std	Z+2, r26	; 0x02
     392:	b3 83       	std	Z+3, r27	; 0x03
		ship.pos.y += ship.vel.y;
     394:	34 96       	adiw	r30, 0x04	; 4
     396:	60 81       	ld	r22, Z
     398:	71 81       	ldd	r23, Z+1	; 0x01
     39a:	82 81       	ldd	r24, Z+2	; 0x02
     39c:	93 81       	ldd	r25, Z+3	; 0x03
     39e:	38 96       	adiw	r30, 0x08	; 8
     3a0:	20 81       	ld	r18, Z
     3a2:	31 81       	ldd	r19, Z+1	; 0x01
     3a4:	42 81       	ldd	r20, Z+2	; 0x02
     3a6:	53 81       	ldd	r21, Z+3	; 0x03
     3a8:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     3ac:	dc 01       	movw	r26, r24
     3ae:	cb 01       	movw	r24, r22
     3b0:	e5 e6       	ldi	r30, 0x65	; 101
     3b2:	f2 e0       	ldi	r31, 0x02	; 2
     3b4:	80 83       	st	Z, r24
     3b6:	91 83       	std	Z+1, r25	; 0x01
     3b8:	a2 83       	std	Z+2, r26	; 0x02
     3ba:	b3 83       	std	Z+3, r27	; 0x03
		
		if (ship.pos.x < 0.0) {
     3bc:	80 2f       	mov	r24, r16
     3be:	91 2f       	mov	r25, r17
     3c0:	ae 2d       	mov	r26, r14
     3c2:	bf 2d       	mov	r27, r15
     3c4:	bc 01       	movw	r22, r24
     3c6:	cd 01       	movw	r24, r26
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	a9 01       	movw	r20, r18
     3ce:	0e 94 b4 1b 	call	0x3768	; 0x3768 <__cmpsf2>
     3d2:	88 23       	and	r24, r24
     3d4:	ac f4       	brge	.+42     	; 0x400 <updateTask+0x2b4>
			ship.pos.x += SCREEN_W;
     3d6:	80 2f       	mov	r24, r16
     3d8:	91 2f       	mov	r25, r17
     3da:	ae 2d       	mov	r26, r14
     3dc:	bf 2d       	mov	r27, r15
     3de:	bc 01       	movw	r22, r24
     3e0:	cd 01       	movw	r24, r26
     3e2:	20 e0       	ldi	r18, 0x00	; 0
     3e4:	30 e0       	ldi	r19, 0x00	; 0
     3e6:	48 e4       	ldi	r20, 0x48	; 72
     3e8:	54 e4       	ldi	r21, 0x44	; 68
     3ea:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     3ee:	dc 01       	movw	r26, r24
     3f0:	cb 01       	movw	r24, r22
     3f2:	e1 e6       	ldi	r30, 0x61	; 97
     3f4:	f2 e0       	ldi	r31, 0x02	; 2
     3f6:	80 83       	st	Z, r24
     3f8:	91 83       	std	Z+1, r25	; 0x01
     3fa:	a2 83       	std	Z+2, r26	; 0x02
     3fc:	b3 83       	std	Z+3, r27	; 0x03
     3fe:	22 c0       	rjmp	.+68     	; 0x444 <updateTask+0x2f8>
		} else if (ship.pos.x > SCREEN_W) {
     400:	80 2f       	mov	r24, r16
     402:	91 2f       	mov	r25, r17
     404:	ae 2d       	mov	r26, r14
     406:	bf 2d       	mov	r27, r15
     408:	bc 01       	movw	r22, r24
     40a:	cd 01       	movw	r24, r26
     40c:	20 e0       	ldi	r18, 0x00	; 0
     40e:	30 e0       	ldi	r19, 0x00	; 0
     410:	48 e4       	ldi	r20, 0x48	; 72
     412:	54 e4       	ldi	r21, 0x44	; 68
     414:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     418:	18 16       	cp	r1, r24
     41a:	a4 f4       	brge	.+40     	; 0x444 <updateTask+0x2f8>
			ship.pos.x -= SCREEN_W;
     41c:	80 2f       	mov	r24, r16
     41e:	91 2f       	mov	r25, r17
     420:	ae 2d       	mov	r26, r14
     422:	bf 2d       	mov	r27, r15
     424:	bc 01       	movw	r22, r24
     426:	cd 01       	movw	r24, r26
     428:	20 e0       	ldi	r18, 0x00	; 0
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	48 e4       	ldi	r20, 0x48	; 72
     42e:	54 e4       	ldi	r21, 0x44	; 68
     430:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     434:	dc 01       	movw	r26, r24
     436:	cb 01       	movw	r24, r22
     438:	e1 e6       	ldi	r30, 0x61	; 97
     43a:	f2 e0       	ldi	r31, 0x02	; 2
     43c:	80 83       	st	Z, r24
     43e:	91 83       	std	Z+1, r25	; 0x01
     440:	a2 83       	std	Z+2, r26	; 0x02
     442:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		if (ship.pos.y < 0.0) {
     444:	e5 e6       	ldi	r30, 0x65	; 101
     446:	f2 e0       	ldi	r31, 0x02	; 2
     448:	c0 80       	ld	r12, Z
     44a:	d1 80       	ldd	r13, Z+1	; 0x01
     44c:	e2 80       	ldd	r14, Z+2	; 0x02
     44e:	f3 80       	ldd	r15, Z+3	; 0x03
     450:	c7 01       	movw	r24, r14
     452:	b6 01       	movw	r22, r12
     454:	20 e0       	ldi	r18, 0x00	; 0
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	a9 01       	movw	r20, r18
     45a:	0e 94 b4 1b 	call	0x3768	; 0x3768 <__cmpsf2>
     45e:	88 23       	and	r24, r24
     460:	8c f4       	brge	.+34     	; 0x484 <updateTask+0x338>
			ship.pos.y += SCREEN_H;
     462:	c7 01       	movw	r24, r14
     464:	b6 01       	movw	r22, r12
     466:	20 e0       	ldi	r18, 0x00	; 0
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	46 e1       	ldi	r20, 0x16	; 22
     46c:	54 e4       	ldi	r21, 0x44	; 68
     46e:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     472:	dc 01       	movw	r26, r24
     474:	cb 01       	movw	r24, r22
     476:	e5 e6       	ldi	r30, 0x65	; 101
     478:	f2 e0       	ldi	r31, 0x02	; 2
     47a:	80 83       	st	Z, r24
     47c:	91 83       	std	Z+1, r25	; 0x01
     47e:	a2 83       	std	Z+2, r26	; 0x02
     480:	b3 83       	std	Z+3, r27	; 0x03
     482:	1a c0       	rjmp	.+52     	; 0x4b8 <updateTask+0x36c>
		} else if (ship.pos.y > SCREEN_H) {
     484:	c7 01       	movw	r24, r14
     486:	b6 01       	movw	r22, r12
     488:	20 e0       	ldi	r18, 0x00	; 0
     48a:	30 e0       	ldi	r19, 0x00	; 0
     48c:	46 e1       	ldi	r20, 0x16	; 22
     48e:	54 e4       	ldi	r21, 0x44	; 68
     490:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     494:	18 16       	cp	r1, r24
     496:	84 f4       	brge	.+32     	; 0x4b8 <updateTask+0x36c>
			ship.pos.y -= SCREEN_H;
     498:	c7 01       	movw	r24, r14
     49a:	b6 01       	movw	r22, r12
     49c:	20 e0       	ldi	r18, 0x00	; 0
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	46 e1       	ldi	r20, 0x16	; 22
     4a2:	54 e4       	ldi	r21, 0x44	; 68
     4a4:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     4a8:	dc 01       	movw	r26, r24
     4aa:	cb 01       	movw	r24, r22
     4ac:	e5 e6       	ldi	r30, 0x65	; 101
     4ae:	f2 e0       	ldi	r31, 0x02	; 2
     4b0:	80 83       	st	Z, r24
     4b2:	91 83       	std	Z+1, r25	; 0x01
     4b4:	a2 83       	std	Z+2, r26	; 0x02
     4b6:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		// move bullets
		objPrev = NULL;
		objIter = bullets;
     4b8:	80 90 7f 02 	lds	r8, 0x027F
     4bc:	90 90 80 02 	lds	r9, 0x0280
		while (objIter != NULL) {
     4c0:	81 14       	cp	r8, r1
     4c2:	91 04       	cpc	r9, r1
     4c4:	09 f4       	brne	.+2      	; 0x4c8 <updateTask+0x37c>
     4c6:	f1 c0       	rjmp	.+482    	; 0x6aa <updateTask+0x55e>
		} else if (ship.pos.y > SCREEN_H) {
			ship.pos.y -= SCREEN_H;
		}
		
		// move bullets
		objPrev = NULL;
     4c8:	00 e0       	ldi	r16, 0x00	; 0
     4ca:	10 e0       	ldi	r17, 0x00	; 0
		objIter = bullets;
		while (objIter != NULL) {
			// Kill bullet after a while
			objIter->life += FRAME_DELAY_MS;
     4cc:	f4 01       	movw	r30, r8
     4ce:	81 8d       	ldd	r24, Z+25	; 0x19
     4d0:	92 8d       	ldd	r25, Z+26	; 0x1a
     4d2:	0a 96       	adiw	r24, 0x0a	; 10
     4d4:	92 8f       	std	Z+26, r25	; 0x1a
     4d6:	81 8f       	std	Z+25, r24	; 0x19
			if (objIter->life >= BULLET_LIFE_MS) {
     4d8:	f3 e0       	ldi	r31, 0x03	; 3
     4da:	88 3e       	cpi	r24, 0xE8	; 232
     4dc:	9f 07       	cpc	r25, r31
     4de:	c8 f1       	brcs	.+114    	; 0x552 <updateTask+0x406>
				
				xSemaphoreTake(usartMutex, portMAX_DELAY);
     4e0:	80 91 7d 02 	lds	r24, 0x027D
     4e4:	90 91 7e 02 	lds	r25, 0x027E
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	4f ef       	ldi	r20, 0xFF	; 255
     4ee:	5f ef       	ldi	r21, 0xFF	; 255
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
				vSpriteDelete(objIter->handle);
     4f6:	f4 01       	movw	r30, r8
     4f8:	80 81       	ld	r24, Z
     4fa:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
				
				if (objPrev != NULL) {
     4fe:	01 15       	cp	r16, r1
     500:	11 05       	cpc	r17, r1
     502:	69 f0       	breq	.+26     	; 0x51e <updateTask+0x3d2>
					objPrev->next = objIter->next;
     504:	f4 01       	movw	r30, r8
     506:	83 8d       	ldd	r24, Z+27	; 0x1b
     508:	94 8d       	ldd	r25, Z+28	; 0x1c
     50a:	f8 01       	movw	r30, r16
     50c:	94 8f       	std	Z+28, r25	; 0x1c
     50e:	83 8f       	std	Z+27, r24	; 0x1b
					vPortFree(objIter);
     510:	c4 01       	movw	r24, r8
     512:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
					objIter = objPrev->next;
     516:	f8 01       	movw	r30, r16
     518:	83 8c       	ldd	r8, Z+27	; 0x1b
     51a:	94 8c       	ldd	r9, Z+28	; 0x1c
     51c:	0e c0       	rjmp	.+28     	; 0x53a <updateTask+0x3ee>
				} else {
					bullets = objIter->next;
     51e:	f4 01       	movw	r30, r8
     520:	83 8d       	ldd	r24, Z+27	; 0x1b
     522:	94 8d       	ldd	r25, Z+28	; 0x1c
     524:	90 93 80 02 	sts	0x0280, r25
     528:	80 93 7f 02 	sts	0x027F, r24
					vPortFree(objIter);
     52c:	c4 01       	movw	r24, r8
     52e:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
					objIter = bullets;
     532:	80 90 7f 02 	lds	r8, 0x027F
     536:	90 90 80 02 	lds	r9, 0x0280
				}
				xSemaphoreGive(usartMutex);
     53a:	80 91 7d 02 	lds	r24, 0x027D
     53e:	90 91 7e 02 	lds	r25, 0x027E
     542:	60 e0       	ldi	r22, 0x00	; 0
     544:	70 e0       	ldi	r23, 0x00	; 0
     546:	40 e0       	ldi	r20, 0x00	; 0
     548:	50 e0       	ldi	r21, 0x00	; 0
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	0e 94 c8 12 	call	0x2590	; 0x2590 <xQueueGenericSend>
     550:	a8 c0       	rjmp	.+336    	; 0x6a2 <updateTask+0x556>
			} else {
            objIter->pos.x += objIter->vel.x;
     552:	f4 01       	movw	r30, r8
     554:	61 81       	ldd	r22, Z+1	; 0x01
     556:	72 81       	ldd	r23, Z+2	; 0x02
     558:	83 81       	ldd	r24, Z+3	; 0x03
     55a:	94 81       	ldd	r25, Z+4	; 0x04
     55c:	21 85       	ldd	r18, Z+9	; 0x09
     55e:	32 85       	ldd	r19, Z+10	; 0x0a
     560:	43 85       	ldd	r20, Z+11	; 0x0b
     562:	54 85       	ldd	r21, Z+12	; 0x0c
     564:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     568:	16 2f       	mov	r17, r22
     56a:	07 2f       	mov	r16, r23
     56c:	f8 2e       	mov	r15, r24
     56e:	e9 2e       	mov	r14, r25
     570:	86 2f       	mov	r24, r22
     572:	90 2f       	mov	r25, r16
     574:	af 2d       	mov	r26, r15
     576:	be 2d       	mov	r27, r14
     578:	f4 01       	movw	r30, r8
     57a:	81 83       	std	Z+1, r24	; 0x01
     57c:	92 83       	std	Z+2, r25	; 0x02
     57e:	a3 83       	std	Z+3, r26	; 0x03
     580:	b4 83       	std	Z+4, r27	; 0x04
            objIter->pos.y += objIter->vel.y;
     582:	65 81       	ldd	r22, Z+5	; 0x05
     584:	76 81       	ldd	r23, Z+6	; 0x06
     586:	87 81       	ldd	r24, Z+7	; 0x07
     588:	90 85       	ldd	r25, Z+8	; 0x08
     58a:	25 85       	ldd	r18, Z+13	; 0x0d
     58c:	36 85       	ldd	r19, Z+14	; 0x0e
     58e:	47 85       	ldd	r20, Z+15	; 0x0f
     590:	50 89       	ldd	r21, Z+16	; 0x10
     592:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     596:	dc 01       	movw	r26, r24
     598:	cb 01       	movw	r24, r22
     59a:	f4 01       	movw	r30, r8
     59c:	85 83       	std	Z+5, r24	; 0x05
     59e:	96 83       	std	Z+6, r25	; 0x06
     5a0:	a7 83       	std	Z+7, r26	; 0x07
     5a2:	b0 87       	std	Z+8, r27	; 0x08

            if (objIter->pos.x < 0.0) {
     5a4:	81 2f       	mov	r24, r17
     5a6:	90 2f       	mov	r25, r16
     5a8:	af 2d       	mov	r26, r15
     5aa:	be 2d       	mov	r27, r14
     5ac:	bc 01       	movw	r22, r24
     5ae:	cd 01       	movw	r24, r26
     5b0:	20 e0       	ldi	r18, 0x00	; 0
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	a9 01       	movw	r20, r18
     5b6:	0e 94 b4 1b 	call	0x3768	; 0x3768 <__cmpsf2>
     5ba:	88 23       	and	r24, r24
     5bc:	a4 f4       	brge	.+40     	; 0x5e6 <updateTask+0x49a>
             objIter->pos.x += SCREEN_W;
     5be:	81 2f       	mov	r24, r17
     5c0:	90 2f       	mov	r25, r16
     5c2:	af 2d       	mov	r26, r15
     5c4:	be 2d       	mov	r27, r14
     5c6:	bc 01       	movw	r22, r24
     5c8:	cd 01       	movw	r24, r26
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	48 e4       	ldi	r20, 0x48	; 72
     5d0:	54 e4       	ldi	r21, 0x44	; 68
     5d2:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     5d6:	dc 01       	movw	r26, r24
     5d8:	cb 01       	movw	r24, r22
     5da:	f4 01       	movw	r30, r8
     5dc:	81 83       	std	Z+1, r24	; 0x01
     5de:	92 83       	std	Z+2, r25	; 0x02
     5e0:	a3 83       	std	Z+3, r26	; 0x03
     5e2:	b4 83       	std	Z+4, r27	; 0x04
     5e4:	21 c0       	rjmp	.+66     	; 0x628 <updateTask+0x4dc>
            } else if (objIter->pos.x > SCREEN_W) {
     5e6:	81 2f       	mov	r24, r17
     5e8:	90 2f       	mov	r25, r16
     5ea:	af 2d       	mov	r26, r15
     5ec:	be 2d       	mov	r27, r14
     5ee:	bc 01       	movw	r22, r24
     5f0:	cd 01       	movw	r24, r26
     5f2:	20 e0       	ldi	r18, 0x00	; 0
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	48 e4       	ldi	r20, 0x48	; 72
     5f8:	54 e4       	ldi	r21, 0x44	; 68
     5fa:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     5fe:	18 16       	cp	r1, r24
     600:	9c f4       	brge	.+38     	; 0x628 <updateTask+0x4dc>
             objIter->pos.x -= SCREEN_W;
     602:	81 2f       	mov	r24, r17
     604:	90 2f       	mov	r25, r16
     606:	af 2d       	mov	r26, r15
     608:	be 2d       	mov	r27, r14
     60a:	bc 01       	movw	r22, r24
     60c:	cd 01       	movw	r24, r26
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	48 e4       	ldi	r20, 0x48	; 72
     614:	54 e4       	ldi	r21, 0x44	; 68
     616:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     61a:	dc 01       	movw	r26, r24
     61c:	cb 01       	movw	r24, r22
     61e:	f4 01       	movw	r30, r8
     620:	81 83       	std	Z+1, r24	; 0x01
     622:	92 83       	std	Z+2, r25	; 0x02
     624:	a3 83       	std	Z+3, r26	; 0x03
     626:	b4 83       	std	Z+4, r27	; 0x04
            }

            if (objIter->pos.y < 0.0) {
     628:	f4 01       	movw	r30, r8
     62a:	c5 80       	ldd	r12, Z+5	; 0x05
     62c:	d6 80       	ldd	r13, Z+6	; 0x06
     62e:	e7 80       	ldd	r14, Z+7	; 0x07
     630:	f0 84       	ldd	r15, Z+8	; 0x08
     632:	c7 01       	movw	r24, r14
     634:	b6 01       	movw	r22, r12
     636:	20 e0       	ldi	r18, 0x00	; 0
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	a9 01       	movw	r20, r18
     63c:	0e 94 b4 1b 	call	0x3768	; 0x3768 <__cmpsf2>
     640:	88 23       	and	r24, r24
     642:	84 f4       	brge	.+32     	; 0x664 <updateTask+0x518>
             objIter->pos.y += SCREEN_H;
     644:	c7 01       	movw	r24, r14
     646:	b6 01       	movw	r22, r12
     648:	20 e0       	ldi	r18, 0x00	; 0
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	46 e1       	ldi	r20, 0x16	; 22
     64e:	54 e4       	ldi	r21, 0x44	; 68
     650:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     654:	dc 01       	movw	r26, r24
     656:	cb 01       	movw	r24, r22
     658:	f4 01       	movw	r30, r8
     65a:	85 83       	std	Z+5, r24	; 0x05
     65c:	96 83       	std	Z+6, r25	; 0x06
     65e:	a7 83       	std	Z+7, r26	; 0x07
     660:	b0 87       	std	Z+8, r27	; 0x08
     662:	19 c0       	rjmp	.+50     	; 0x696 <updateTask+0x54a>
            } else if (objIter->pos.y > SCREEN_H) {
     664:	c7 01       	movw	r24, r14
     666:	b6 01       	movw	r22, r12
     668:	20 e0       	ldi	r18, 0x00	; 0
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	46 e1       	ldi	r20, 0x16	; 22
     66e:	54 e4       	ldi	r21, 0x44	; 68
     670:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     674:	18 16       	cp	r1, r24
     676:	7c f4       	brge	.+30     	; 0x696 <updateTask+0x54a>
             objIter->pos.y -= SCREEN_H;
     678:	c7 01       	movw	r24, r14
     67a:	b6 01       	movw	r22, r12
     67c:	20 e0       	ldi	r18, 0x00	; 0
     67e:	30 e0       	ldi	r19, 0x00	; 0
     680:	46 e1       	ldi	r20, 0x16	; 22
     682:	54 e4       	ldi	r21, 0x44	; 68
     684:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     688:	dc 01       	movw	r26, r24
     68a:	cb 01       	movw	r24, r22
     68c:	f4 01       	movw	r30, r8
     68e:	85 83       	std	Z+5, r24	; 0x05
     690:	96 83       	std	Z+6, r25	; 0x06
     692:	a7 83       	std	Z+7, r26	; 0x07
     694:	b0 87       	std	Z+8, r27	; 0x08
            }

            objPrev = objIter;
            objIter = objIter->next;
     696:	f4 01       	movw	r30, r8
     698:	93 8d       	ldd	r25, Z+27	; 0x1b
     69a:	84 8d       	ldd	r24, Z+28	; 0x1c
     69c:	84 01       	movw	r16, r8
     69e:	89 2e       	mov	r8, r25
     6a0:	98 2e       	mov	r9, r24
		}
		
		// move bullets
		objPrev = NULL;
		objIter = bullets;
		while (objIter != NULL) {
     6a2:	81 14       	cp	r8, r1
     6a4:	91 04       	cpc	r9, r1
     6a6:	09 f0       	breq	.+2      	; 0x6aa <updateTask+0x55e>
     6a8:	11 cf       	rjmp	.-478    	; 0x4cc <updateTask+0x380>
		// move asteroids
        /* 
         * ToDo: Add code to move the asteroids
         */
		objPrev = NULL;
		objIter = asteroids;
     6aa:	80 90 81 02 	lds	r8, 0x0281
     6ae:	90 90 82 02 	lds	r9, 0x0282
		while (objIter != NULL) {
     6b2:	81 14       	cp	r8, r1
     6b4:	91 04       	cpc	r9, r1
     6b6:	09 f4       	brne	.+2      	; 0x6ba <updateTask+0x56e>
     6b8:	a9 c0       	rjmp	.+338    	; 0x80c <updateTask+0x6c0>
			objIter->pos.x += objIter->vel.x;
     6ba:	f4 01       	movw	r30, r8
     6bc:	61 81       	ldd	r22, Z+1	; 0x01
     6be:	72 81       	ldd	r23, Z+2	; 0x02
     6c0:	83 81       	ldd	r24, Z+3	; 0x03
     6c2:	94 81       	ldd	r25, Z+4	; 0x04
     6c4:	21 85       	ldd	r18, Z+9	; 0x09
     6c6:	32 85       	ldd	r19, Z+10	; 0x0a
     6c8:	43 85       	ldd	r20, Z+11	; 0x0b
     6ca:	54 85       	ldd	r21, Z+12	; 0x0c
     6cc:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     6d0:	16 2f       	mov	r17, r22
     6d2:	07 2f       	mov	r16, r23
     6d4:	f8 2e       	mov	r15, r24
     6d6:	e9 2e       	mov	r14, r25
     6d8:	86 2f       	mov	r24, r22
     6da:	90 2f       	mov	r25, r16
     6dc:	af 2d       	mov	r26, r15
     6de:	be 2d       	mov	r27, r14
     6e0:	f4 01       	movw	r30, r8
     6e2:	81 83       	std	Z+1, r24	; 0x01
     6e4:	92 83       	std	Z+2, r25	; 0x02
     6e6:	a3 83       	std	Z+3, r26	; 0x03
     6e8:	b4 83       	std	Z+4, r27	; 0x04
			objIter->pos.y += objIter->vel.y;
     6ea:	65 81       	ldd	r22, Z+5	; 0x05
     6ec:	76 81       	ldd	r23, Z+6	; 0x06
     6ee:	87 81       	ldd	r24, Z+7	; 0x07
     6f0:	90 85       	ldd	r25, Z+8	; 0x08
     6f2:	25 85       	ldd	r18, Z+13	; 0x0d
     6f4:	36 85       	ldd	r19, Z+14	; 0x0e
     6f6:	47 85       	ldd	r20, Z+15	; 0x0f
     6f8:	50 89       	ldd	r21, Z+16	; 0x10
     6fa:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     6fe:	dc 01       	movw	r26, r24
     700:	cb 01       	movw	r24, r22
     702:	f4 01       	movw	r30, r8
     704:	85 83       	std	Z+5, r24	; 0x05
     706:	96 83       	std	Z+6, r25	; 0x06
     708:	a7 83       	std	Z+7, r26	; 0x07
     70a:	b0 87       	std	Z+8, r27	; 0x08
      
			if (objIter->pos.x < 0.0) {
     70c:	81 2f       	mov	r24, r17
     70e:	90 2f       	mov	r25, r16
     710:	af 2d       	mov	r26, r15
     712:	be 2d       	mov	r27, r14
     714:	bc 01       	movw	r22, r24
     716:	cd 01       	movw	r24, r26
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	a9 01       	movw	r20, r18
     71e:	0e 94 b4 1b 	call	0x3768	; 0x3768 <__cmpsf2>
     722:	88 23       	and	r24, r24
     724:	a4 f4       	brge	.+40     	; 0x74e <updateTask+0x602>
				objIter->pos.x += SCREEN_W;
     726:	81 2f       	mov	r24, r17
     728:	90 2f       	mov	r25, r16
     72a:	af 2d       	mov	r26, r15
     72c:	be 2d       	mov	r27, r14
     72e:	bc 01       	movw	r22, r24
     730:	cd 01       	movw	r24, r26
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	48 e4       	ldi	r20, 0x48	; 72
     738:	54 e4       	ldi	r21, 0x44	; 68
     73a:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     73e:	dc 01       	movw	r26, r24
     740:	cb 01       	movw	r24, r22
     742:	f4 01       	movw	r30, r8
     744:	81 83       	std	Z+1, r24	; 0x01
     746:	92 83       	std	Z+2, r25	; 0x02
     748:	a3 83       	std	Z+3, r26	; 0x03
     74a:	b4 83       	std	Z+4, r27	; 0x04
     74c:	21 c0       	rjmp	.+66     	; 0x790 <updateTask+0x644>
			} else if (objIter->pos.x > SCREEN_W) {
     74e:	81 2f       	mov	r24, r17
     750:	90 2f       	mov	r25, r16
     752:	af 2d       	mov	r26, r15
     754:	be 2d       	mov	r27, r14
     756:	bc 01       	movw	r22, r24
     758:	cd 01       	movw	r24, r26
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	48 e4       	ldi	r20, 0x48	; 72
     760:	54 e4       	ldi	r21, 0x44	; 68
     762:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     766:	18 16       	cp	r1, r24
     768:	9c f4       	brge	.+38     	; 0x790 <updateTask+0x644>
				objIter->pos.x -= SCREEN_W;
     76a:	81 2f       	mov	r24, r17
     76c:	90 2f       	mov	r25, r16
     76e:	af 2d       	mov	r26, r15
     770:	be 2d       	mov	r27, r14
     772:	bc 01       	movw	r22, r24
     774:	cd 01       	movw	r24, r26
     776:	20 e0       	ldi	r18, 0x00	; 0
     778:	30 e0       	ldi	r19, 0x00	; 0
     77a:	48 e4       	ldi	r20, 0x48	; 72
     77c:	54 e4       	ldi	r21, 0x44	; 68
     77e:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     782:	dc 01       	movw	r26, r24
     784:	cb 01       	movw	r24, r22
     786:	f4 01       	movw	r30, r8
     788:	81 83       	std	Z+1, r24	; 0x01
     78a:	92 83       	std	Z+2, r25	; 0x02
     78c:	a3 83       	std	Z+3, r26	; 0x03
     78e:	b4 83       	std	Z+4, r27	; 0x04
			}
      
			if (objIter->pos.y < 0.0) {
     790:	f4 01       	movw	r30, r8
     792:	c5 80       	ldd	r12, Z+5	; 0x05
     794:	d6 80       	ldd	r13, Z+6	; 0x06
     796:	e7 80       	ldd	r14, Z+7	; 0x07
     798:	f0 84       	ldd	r15, Z+8	; 0x08
     79a:	c7 01       	movw	r24, r14
     79c:	b6 01       	movw	r22, r12
     79e:	20 e0       	ldi	r18, 0x00	; 0
     7a0:	30 e0       	ldi	r19, 0x00	; 0
     7a2:	a9 01       	movw	r20, r18
     7a4:	0e 94 b4 1b 	call	0x3768	; 0x3768 <__cmpsf2>
     7a8:	88 23       	and	r24, r24
     7aa:	84 f4       	brge	.+32     	; 0x7cc <updateTask+0x680>
				objIter->pos.y += SCREEN_H;
     7ac:	c7 01       	movw	r24, r14
     7ae:	b6 01       	movw	r22, r12
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	30 e0       	ldi	r19, 0x00	; 0
     7b4:	46 e1       	ldi	r20, 0x16	; 22
     7b6:	54 e4       	ldi	r21, 0x44	; 68
     7b8:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     7bc:	dc 01       	movw	r26, r24
     7be:	cb 01       	movw	r24, r22
     7c0:	f4 01       	movw	r30, r8
     7c2:	85 83       	std	Z+5, r24	; 0x05
     7c4:	96 83       	std	Z+6, r25	; 0x06
     7c6:	a7 83       	std	Z+7, r26	; 0x07
     7c8:	b0 87       	std	Z+8, r27	; 0x08
     7ca:	19 c0       	rjmp	.+50     	; 0x7fe <updateTask+0x6b2>
			} else if (objIter->pos.y > SCREEN_H) {
     7cc:	c7 01       	movw	r24, r14
     7ce:	b6 01       	movw	r22, r12
     7d0:	20 e0       	ldi	r18, 0x00	; 0
     7d2:	30 e0       	ldi	r19, 0x00	; 0
     7d4:	46 e1       	ldi	r20, 0x16	; 22
     7d6:	54 e4       	ldi	r21, 0x44	; 68
     7d8:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__gesf2>
     7dc:	18 16       	cp	r1, r24
     7de:	7c f4       	brge	.+30     	; 0x7fe <updateTask+0x6b2>
				objIter->pos.y -= SCREEN_H;
     7e0:	c7 01       	movw	r24, r14
     7e2:	b6 01       	movw	r22, r12
     7e4:	20 e0       	ldi	r18, 0x00	; 0
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	46 e1       	ldi	r20, 0x16	; 22
     7ea:	54 e4       	ldi	r21, 0x44	; 68
     7ec:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     7f0:	dc 01       	movw	r26, r24
     7f2:	cb 01       	movw	r24, r22
     7f4:	f4 01       	movw	r30, r8
     7f6:	85 83       	std	Z+5, r24	; 0x05
     7f8:	96 83       	std	Z+6, r25	; 0x06
     7fa:	a7 83       	std	Z+7, r26	; 0x07
     7fc:	b0 87       	std	Z+8, r27	; 0x08
			}
      
			objPrev = objIter;
			objIter = objIter->next;
     7fe:	f4 01       	movw	r30, r8
     800:	83 8c       	ldd	r8, Z+27	; 0x1b
     802:	94 8c       	ldd	r9, Z+28	; 0x1c
        /* 
         * ToDo: Add code to move the asteroids
         */
		objPrev = NULL;
		objIter = asteroids;
		while (objIter != NULL) {
     804:	81 14       	cp	r8, r1
     806:	91 04       	cpc	r9, r1
     808:	09 f0       	breq	.+2      	; 0x80c <updateTask+0x6c0>
     80a:	57 cf       	rjmp	.-338    	; 0x6ba <updateTask+0x56e>
			}
      
			objPrev = objIter;
			objIter = objIter->next;
		}
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
     80c:	8a e0       	ldi	r24, 0x0A	; 10
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	0e 94 80 18 	call	0x3100	; 0x3100 <vTaskDelay>
	}
     814:	a6 cc       	rjmp	.-1716   	; 0x162 <updateTask+0x16>

00000816 <main>:
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
	}
}

int main(void) {
	DDRB = 0x00;
     816:	14 b8       	out	0x04, r1	; 4
	TCCR2A = _BV(CS00); 
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	80 93 b0 00 	sts	0x00B0, r24
	
	usartMutex = xSemaphoreCreateMutex();
     81e:	0e 94 66 13 	call	0x26cc	; 0x26cc <xQueueCreateMutex>
     822:	90 93 7e 02 	sts	0x027E, r25
     826:	80 93 7d 02 	sts	0x027D, r24
	
	vWindowCreate(SCREEN_W, SCREEN_H);
     82a:	80 e2       	ldi	r24, 0x20	; 32
     82c:	93 e0       	ldi	r25, 0x03	; 3
     82e:	68 e5       	ldi	r22, 0x58	; 88
     830:	72 e0       	ldi	r23, 0x02	; 2
     832:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <vWindowCreate>
	
	sei();
     836:	78 94       	sei
	
	xTaskCreate(inputTask, (signed char *) "i", 80, NULL, 1, &inputTaskHandle);
     838:	85 ea       	ldi	r24, 0xA5	; 165
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	60 e0       	ldi	r22, 0x00	; 0
     83e:	72 e0       	ldi	r23, 0x02	; 2
     840:	40 e5       	ldi	r20, 0x50	; 80
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	20 e0       	ldi	r18, 0x00	; 0
     846:	30 e0       	ldi	r19, 0x00	; 0
     848:	01 e0       	ldi	r16, 0x01	; 1
     84a:	0f 2e       	mov	r0, r31
     84c:	f7 e8       	ldi	r31, 0x87	; 135
     84e:	ef 2e       	mov	r14, r31
     850:	f2 e0       	ldi	r31, 0x02	; 2
     852:	ff 2e       	mov	r15, r31
     854:	f0 2d       	mov	r31, r0
     856:	cc 24       	eor	r12, r12
     858:	dd 24       	eor	r13, r13
     85a:	aa 24       	eor	r10, r10
     85c:	bb 24       	eor	r11, r11
     85e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <xTaskGenericCreate>
	xTaskCreate(bulletTask, (signed char *) "b", 130, NULL, 2, &bulletTaskHandle);
     862:	80 e5       	ldi	r24, 0x50	; 80
     864:	97 e0       	ldi	r25, 0x07	; 7
     866:	62 e0       	ldi	r22, 0x02	; 2
     868:	72 e0       	ldi	r23, 0x02	; 2
     86a:	42 e8       	ldi	r20, 0x82	; 130
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	20 e0       	ldi	r18, 0x00	; 0
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	02 e0       	ldi	r16, 0x02	; 2
     874:	0f 2e       	mov	r0, r31
     876:	f5 e8       	ldi	r31, 0x85	; 133
     878:	ef 2e       	mov	r14, r31
     87a:	f2 e0       	ldi	r31, 0x02	; 2
     87c:	ff 2e       	mov	r15, r31
     87e:	f0 2d       	mov	r31, r0
     880:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <xTaskGenericCreate>
	xTaskCreate(updateTask, (signed char *) "u", 200, NULL, 4, &updateTaskHandle);
     884:	86 ea       	ldi	r24, 0xA6	; 166
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	64 e0       	ldi	r22, 0x04	; 4
     88a:	72 e0       	ldi	r23, 0x02	; 2
     88c:	48 ec       	ldi	r20, 0xC8	; 200
     88e:	50 e0       	ldi	r21, 0x00	; 0
     890:	20 e0       	ldi	r18, 0x00	; 0
     892:	30 e0       	ldi	r19, 0x00	; 0
     894:	04 e0       	ldi	r16, 0x04	; 4
     896:	0f 2e       	mov	r0, r31
     898:	f3 e8       	ldi	r31, 0x83	; 131
     89a:	ef 2e       	mov	r14, r31
     89c:	f2 e0       	ldi	r31, 0x02	; 2
     89e:	ff 2e       	mov	r15, r31
     8a0:	f0 2d       	mov	r31, r0
     8a2:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <xTaskGenericCreate>
	xTaskCreate(drawTask, (signed char *) "d", 230, NULL, 3, NULL);
     8a6:	88 e1       	ldi	r24, 0x18	; 24
     8a8:	99 e0       	ldi	r25, 0x09	; 9
     8aa:	66 e0       	ldi	r22, 0x06	; 6
     8ac:	72 e0       	ldi	r23, 0x02	; 2
     8ae:	46 ee       	ldi	r20, 0xE6	; 230
     8b0:	50 e0       	ldi	r21, 0x00	; 0
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	30 e0       	ldi	r19, 0x00	; 0
     8b6:	03 e0       	ldi	r16, 0x03	; 3
     8b8:	ee 24       	eor	r14, r14
     8ba:	ff 24       	eor	r15, r15
     8bc:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <xTaskGenericCreate>
	//xTaskCreate(USART_Write_Task, (signed char *) "w", 150, NULL, 5, NULL);
	
	vTaskStartScheduler();
     8c0:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <vTaskStartScheduler>
     8c4:	ff cf       	rjmp	.-2      	; 0x8c4 <main+0xae>

000008c6 <reset>:
 * Function: reset
 *
 * Description: This function destroys all game objects in the heap and clears
 *  their respective sprites from the window.
 *----------------------------------------------------------------------------*/
void reset(void) {
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
     *		thisObject = nextObject
     *	}
     */
	object *nextObject;
	// removes asteroids
	while (asteroids != NULL) {
     8ca:	c0 91 81 02 	lds	r28, 0x0281
     8ce:	d0 91 82 02 	lds	r29, 0x0282
     8d2:	20 97       	sbiw	r28, 0x00	; 0
     8d4:	91 f0       	breq	.+36     	; 0x8fa <reset+0x34>
		vSpriteDelete(asteroids->handle);
     8d6:	88 81       	ld	r24, Y
     8d8:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
		nextObject = asteroids->next;
     8dc:	80 91 81 02 	lds	r24, 0x0281
     8e0:	90 91 82 02 	lds	r25, 0x0282
     8e4:	fc 01       	movw	r30, r24
     8e6:	c3 8d       	ldd	r28, Z+27	; 0x1b
     8e8:	d4 8d       	ldd	r29, Z+28	; 0x1c
		vPortFree(asteroids);
     8ea:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
		asteroids = nextObject;
     8ee:	d0 93 82 02 	sts	0x0282, r29
     8f2:	c0 93 81 02 	sts	0x0281, r28
     *		thisObject = nextObject
     *	}
     */
	object *nextObject;
	// removes asteroids
	while (asteroids != NULL) {
     8f6:	20 97       	sbiw	r28, 0x00	; 0
     8f8:	71 f7       	brne	.-36     	; 0x8d6 <reset+0x10>
		vSpriteDelete(asteroids->handle);
		nextObject = asteroids->next;
		vPortFree(asteroids);
		asteroids = nextObject;
	}
	vGroupDelete(astGroup);
     8fa:	80 91 89 02 	lds	r24, 0x0289
     8fe:	0e 94 13 0c 	call	0x1826	; 0x1826 <vGroupDelete>
	
	// removes bullets
	while (bullets != NULL) {
     902:	c0 91 7f 02 	lds	r28, 0x027F
     906:	d0 91 80 02 	lds	r29, 0x0280
     90a:	20 97       	sbiw	r28, 0x00	; 0
     90c:	91 f0       	breq	.+36     	; 0x932 <reset+0x6c>
   	vSpriteDelete(bullets->handle);
     90e:	88 81       	ld	r24, Y
     910:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
   	nextObject = bullets->next;
     914:	80 91 7f 02 	lds	r24, 0x027F
     918:	90 91 80 02 	lds	r25, 0x0280
     91c:	fc 01       	movw	r30, r24
     91e:	c3 8d       	ldd	r28, Z+27	; 0x1b
     920:	d4 8d       	ldd	r29, Z+28	; 0x1c
   	vPortFree(bullets);
     922:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
   	bullets = nextObject;
     926:	d0 93 80 02 	sts	0x0280, r29
     92a:	c0 93 7f 02 	sts	0x027F, r28
		asteroids = nextObject;
	}
	vGroupDelete(astGroup);
	
	// removes bullets
	while (bullets != NULL) {
     92e:	20 97       	sbiw	r28, 0x00	; 0
     930:	71 f7       	brne	.-36     	; 0x90e <reset+0x48>
   	vSpriteDelete(bullets->handle);
   	nextObject = bullets->next;
   	vPortFree(bullets);
   	bullets = nextObject;
	}
}
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	08 95       	ret

00000938 <getRandStartPosVal>:
 *
 * param dimOver2: Half of the dimension of the window for which a random
 *  coordinate value is desired.
 * return: A safe, pseudorandom coordinate value.
 *----------------------------------------------------------------------------*/
int16_t getRandStartPosVal(int16_t dimOver2) {
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	ec 01       	movw	r28, r24
   return rand() % (dimOver2 - DEAD_ZONE_OVER_2) + (rand() % 2) * (dimOver2 + DEAD_ZONE_OVER_2);
     942:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     946:	be 01       	movw	r22, r28
     948:	68 57       	subi	r22, 0x78	; 120
     94a:	70 40       	sbci	r23, 0x00	; 0
     94c:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     950:	8c 01       	movw	r16, r24
     952:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     956:	62 e0       	ldi	r22, 0x02	; 2
     958:	70 e0       	ldi	r23, 0x00	; 0
     95a:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     95e:	ac 01       	movw	r20, r24
     960:	9e 01       	movw	r18, r28
     962:	28 58       	subi	r18, 0x88	; 136
     964:	3f 4f       	sbci	r19, 0xFF	; 255
     966:	42 9f       	mul	r20, r18
     968:	c0 01       	movw	r24, r0
     96a:	43 9f       	mul	r20, r19
     96c:	90 0d       	add	r25, r0
     96e:	52 9f       	mul	r21, r18
     970:	90 0d       	add	r25, r0
     972:	11 24       	eor	r1, r1
     974:	80 0f       	add	r24, r16
     976:	91 1f       	adc	r25, r17
}
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	1f 91       	pop	r17
     97e:	0f 91       	pop	r16
     980:	08 95       	ret

00000982 <sizeToPix>:
 * param size: A number in the range [1-3]
 * return: A pixel size which may be used to appropriately scale an asteroid
 *  sprite.
 *----------------------------------------------------------------------------*/
uint16_t sizeToPix(int8_t size) {
	switch (size) {
     982:	82 30       	cpi	r24, 0x02	; 2
     984:	71 f0       	breq	.+28     	; 0x9a2 <sizeToPix+0x20>
     986:	83 30       	cpi	r24, 0x03	; 3
     988:	19 f0       	breq	.+6      	; 0x990 <sizeToPix+0xe>
     98a:	81 30       	cpi	r24, 0x01	; 1
     98c:	39 f4       	brne	.+14     	; 0x99c <sizeToPix+0x1a>
     98e:	03 c0       	rjmp	.+6      	; 0x996 <sizeToPix+0x14>
		case 3:
		    return AST_SIZE_3;
     990:	84 e6       	ldi	r24, 0x64	; 100
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	08 95       	ret
		case 2:
		    return AST_SIZE_2;
		case 1:
		    return AST_SIZE_1;
     996:	8f e0       	ldi	r24, 0x0F	; 15
     998:	90 e0       	ldi	r25, 0x00	; 0
     99a:	08 95       	ret
		default:
		    return AST_SIZE_3 << 2;
     99c:	80 e9       	ldi	r24, 0x90	; 144
     99e:	91 e0       	ldi	r25, 0x01	; 1
     9a0:	08 95       	ret
uint16_t sizeToPix(int8_t size) {
	switch (size) {
		case 3:
		    return AST_SIZE_3;
		case 2:
		    return AST_SIZE_2;
     9a2:	88 e2       	ldi	r24, 0x28	; 40
     9a4:	90 e0       	ldi	r25, 0x00	; 0
		    return AST_SIZE_1;
		default:
		    return AST_SIZE_3 << 2;
	}
	return AST_SIZE_3 << 2;
}
     9a6:	08 95       	ret

000009a8 <createAsteroid>:
 * param size: The starting size of the asteroid. Must be in the range [1,3].
 * param nxt: A pointer to the next asteroid object in a linked list.
 * return: A pointer to a malloc'd asteroid object. Must be freed by the calling
 *  process.
 *----------------------------------------------------------------------------*/
object *createAsteroid(float x, float y, float velx, float vely, int16_t angle, int8_t avel, int8_t size, object *nxt) {
     9a8:	3f 92       	push	r3
     9aa:	4f 92       	push	r4
     9ac:	5f 92       	push	r5
     9ae:	6f 92       	push	r6
     9b0:	7f 92       	push	r7
     9b2:	8f 92       	push	r8
     9b4:	9f 92       	push	r9
     9b6:	af 92       	push	r10
     9b8:	bf 92       	push	r11
     9ba:	cf 92       	push	r12
     9bc:	df 92       	push	r13
     9be:	ef 92       	push	r14
     9c0:	ff 92       	push	r15
     9c2:	0f 93       	push	r16
     9c4:	1f 93       	push	r17
     9c6:	cf 93       	push	r28
     9c8:	df 93       	push	r29
     9ca:	cd b7       	in	r28, 0x3d	; 61
     9cc:	de b7       	in	r29, 0x3e	; 62
     9ce:	28 97       	sbiw	r28, 0x08	; 8
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	f8 94       	cli
     9d4:	de bf       	out	0x3e, r29	; 62
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	cd bf       	out	0x3d, r28	; 61
     9da:	2b 01       	movw	r4, r22
     9dc:	3c 01       	movw	r6, r24
     9de:	29 83       	std	Y+1, r18	; 0x01
     9e0:	3a 83       	std	Y+2, r19	; 0x02
     9e2:	4b 83       	std	Y+3, r20	; 0x03
     9e4:	5c 83       	std	Y+4, r21	; 0x04
     9e6:	3e 8c       	ldd	r3, Y+30	; 0x1e
     * asteroid->next = nxt;
     * Create a new sprite using xSpriteCreate()
     * Add new asteroid to the group "astGroup" using:
     *	vGroupAddSprite() 
     */
      object *newAsteroid = pvPortMalloc(sizeof(object));
     9e8:	8d e1       	ldi	r24, 0x1D	; 29
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
     9f0:	5c 01       	movw	r10, r24
      
      newAsteroid->handle = xSpriteCreate(
         astImages[rand() % 3],  //reference to png filename
     9f2:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     9f6:	8c 01       	movw	r16, r24
     * Add new asteroid to the group "astGroup" using:
     *	vGroupAddSprite() 
     */
      object *newAsteroid = pvPortMalloc(sizeof(object));
      
      newAsteroid->handle = xSpriteCreate(
     9f8:	83 2d       	mov	r24, r3
     9fa:	0e 94 c1 04 	call	0x982	; 0x982 <sizeToPix>
     9fe:	7c 01       	movw	r14, r24
         astImages[rand() % 3],  //reference to png filename
     a00:	c8 01       	movw	r24, r16
     a02:	63 e0       	ldi	r22, 0x03	; 3
     a04:	70 e0       	ldi	r23, 0x00	; 0
     a06:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     * Add new asteroid to the group "astGroup" using:
     *	vGroupAddSprite() 
     */
      object *newAsteroid = pvPortMalloc(sizeof(object));
      
      newAsteroid->handle = xSpriteCreate(
     a0a:	fc 01       	movw	r30, r24
     a0c:	ee 0f       	add	r30, r30
     a0e:	ff 1f       	adc	r31, r31
     a10:	e4 5b       	subi	r30, 0xB4	; 180
     a12:	fd 4f       	sbci	r31, 0xFD	; 253
     a14:	c0 80       	ld	r12, Z
     a16:	d1 80       	ldd	r13, Z+1	; 0x01
     a18:	c3 01       	movw	r24, r6
     a1a:	b2 01       	movw	r22, r4
     a1c:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
     a20:	6d 83       	std	Y+5, r22	; 0x05
     a22:	7e 83       	std	Y+6, r23	; 0x06
     a24:	8f 83       	std	Y+7, r24	; 0x07
     a26:	98 87       	std	Y+8, r25	; 0x08
     a28:	69 81       	ldd	r22, Y+1	; 0x01
     a2a:	7a 81       	ldd	r23, Y+2	; 0x02
     a2c:	8b 81       	ldd	r24, Y+3	; 0x03
     a2e:	9c 81       	ldd	r25, Y+4	; 0x04
     a30:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
     a34:	8b 01       	movw	r16, r22
     a36:	9c 01       	movw	r18, r24
     a38:	c6 01       	movw	r24, r12
     a3a:	6d 81       	ldd	r22, Y+5	; 0x05
     a3c:	7e 81       	ldd	r23, Y+6	; 0x06
     a3e:	a8 01       	movw	r20, r16
     a40:	94 01       	movw	r18, r8
     a42:	87 01       	movw	r16, r14
     a44:	cc 24       	eor	r12, r12
     a46:	c3 94       	inc	r12
     a48:	0e 94 21 0b 	call	0x1642	; 0x1642 <xSpriteCreate>
     a4c:	68 2f       	mov	r22, r24
     a4e:	d5 01       	movw	r26, r10
     a50:	8c 93       	st	X, r24
         angle,                      //rAngle
         sizeToPix(size),        //width
         sizeToPix(size),        //height
         1);                     //depth
      
      newAsteroid->pos.x = x;
     a52:	f5 01       	movw	r30, r10
     a54:	41 82       	std	Z+1, r4	; 0x01
     a56:	52 82       	std	Z+2, r5	; 0x02
     a58:	63 82       	std	Z+3, r6	; 0x03
     a5a:	74 82       	std	Z+4, r7	; 0x04
      newAsteroid->pos.y = y;
     a5c:	89 81       	ldd	r24, Y+1	; 0x01
     a5e:	9a 81       	ldd	r25, Y+2	; 0x02
     a60:	ab 81       	ldd	r26, Y+3	; 0x03
     a62:	bc 81       	ldd	r27, Y+4	; 0x04
     a64:	85 83       	std	Z+5, r24	; 0x05
     a66:	96 83       	std	Z+6, r25	; 0x06
     a68:	a7 83       	std	Z+7, r26	; 0x07
     a6a:	b0 87       	std	Z+8, r27	; 0x08

      newAsteroid->vel.x = x;
     a6c:	41 86       	std	Z+9, r4	; 0x09
     a6e:	52 86       	std	Z+10, r5	; 0x0a
     a70:	63 86       	std	Z+11, r6	; 0x0b
     a72:	74 86       	std	Z+12, r7	; 0x0c
      newAsteroid->vel.y = y;
     a74:	89 81       	ldd	r24, Y+1	; 0x01
     a76:	9a 81       	ldd	r25, Y+2	; 0x02
     a78:	ab 81       	ldd	r26, Y+3	; 0x03
     a7a:	bc 81       	ldd	r27, Y+4	; 0x04
     a7c:	85 87       	std	Z+13, r24	; 0x0d
     a7e:	96 87       	std	Z+14, r25	; 0x0e
     a80:	a7 87       	std	Z+15, r26	; 0x0f
     a82:	b0 8b       	std	Z+16, r27	; 0x10

      newAsteroid->angle = angle;
     a84:	96 8a       	std	Z+22, r9	; 0x16
     a86:	85 8a       	std	Z+21, r8	; 0x15

      newAsteroid->a_vel = avel;
     a88:	8d 8d       	ldd	r24, Y+29	; 0x1d
     a8a:	87 8b       	std	Z+23, r24	; 0x17

      newAsteroid->size = size;
     a8c:	30 8e       	std	Z+24, r3	; 0x18

      newAsteroid->next = asteroids;
     a8e:	20 91 81 02 	lds	r18, 0x0281
     a92:	30 91 82 02 	lds	r19, 0x0282
     a96:	34 8f       	std	Z+28, r19	; 0x1c
     a98:	23 8f       	std	Z+27, r18	; 0x1b
	  
      vGroupAddSprite(astGroup, newAsteroid->handle);
     a9a:	80 91 89 02 	lds	r24, 0x0289
     a9e:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <vGroupAddSprite>
      
      return newAsteroid;
}
     aa2:	8a 2d       	mov	r24, r10
     aa4:	9b 2d       	mov	r25, r11
     aa6:	28 96       	adiw	r28, 0x08	; 8
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	f8 94       	cli
     aac:	de bf       	out	0x3e, r29	; 62
     aae:	0f be       	out	0x3f, r0	; 63
     ab0:	cd bf       	out	0x3d, r28	; 61
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	1f 91       	pop	r17
     ab8:	0f 91       	pop	r16
     aba:	ff 90       	pop	r15
     abc:	ef 90       	pop	r14
     abe:	df 90       	pop	r13
     ac0:	cf 90       	pop	r12
     ac2:	bf 90       	pop	r11
     ac4:	af 90       	pop	r10
     ac6:	9f 90       	pop	r9
     ac8:	8f 90       	pop	r8
     aca:	7f 90       	pop	r7
     acc:	6f 90       	pop	r6
     ace:	5f 90       	pop	r5
     ad0:	4f 90       	pop	r4
     ad2:	3f 90       	pop	r3
     ad4:	08 95       	ret

00000ad6 <init>:
 * Function: init
 *
 * Description: This function initializes a new game of asteroids. A window
 *  must be created before this function may be called.
 *----------------------------------------------------------------------------*/
void init(void) {
     ad6:	2f 92       	push	r2
     ad8:	3f 92       	push	r3
     ada:	4f 92       	push	r4
     adc:	5f 92       	push	r5
     ade:	6f 92       	push	r6
     ae0:	7f 92       	push	r7
     ae2:	8f 92       	push	r8
     ae4:	9f 92       	push	r9
     ae6:	af 92       	push	r10
     ae8:	bf 92       	push	r11
     aea:	cf 92       	push	r12
     aec:	df 92       	push	r13
     aee:	ef 92       	push	r14
     af0:	ff 92       	push	r15
     af2:	0f 93       	push	r16
     af4:	1f 93       	push	r17
     af6:	cf 93       	push	r28
     af8:	df 93       	push	r29
     afa:	cd b7       	in	r28, 0x3d	; 61
     afc:	de b7       	in	r29, 0x3e	; 62
     afe:	28 97       	sbiw	r28, 0x08	; 8
     b00:	0f b6       	in	r0, 0x3f	; 63
     b02:	f8 94       	cli
     b04:	de bf       	out	0x3e, r29	; 62
     b06:	0f be       	out	0x3f, r0	; 63
     b08:	cd bf       	out	0x3d, r28	; 61
	int i;
	
	bullets = NULL;
     b0a:	10 92 80 02 	sts	0x0280, r1
     b0e:	10 92 7f 02 	sts	0x027F, r1
	asteroids = NULL;
     b12:	10 92 82 02 	sts	0x0282, r1
     b16:	10 92 81 02 	sts	0x0281, r1
	astGroup = ERROR_HANDLE;
     b1a:	8f ef       	ldi	r24, 0xFF	; 255
     b1c:	80 93 89 02 	sts	0x0289, r24
	
	background = xSpriteCreate("stars.png", SCREEN_W>>1, SCREEN_H>>1, 0, SCREEN_W, SCREEN_H, 0);
     b20:	88 e0       	ldi	r24, 0x08	; 8
     b22:	92 e0       	ldi	r25, 0x02	; 2
     b24:	60 e9       	ldi	r22, 0x90	; 144
     b26:	71 e0       	ldi	r23, 0x01	; 1
     b28:	4c e2       	ldi	r20, 0x2C	; 44
     b2a:	51 e0       	ldi	r21, 0x01	; 1
     b2c:	20 e0       	ldi	r18, 0x00	; 0
     b2e:	30 e0       	ldi	r19, 0x00	; 0
     b30:	00 e2       	ldi	r16, 0x20	; 32
     b32:	13 e0       	ldi	r17, 0x03	; 3
     b34:	0f 2e       	mov	r0, r31
     b36:	f8 e5       	ldi	r31, 0x58	; 88
     b38:	ef 2e       	mov	r14, r31
     b3a:	f2 e0       	ldi	r31, 0x02	; 2
     b3c:	ff 2e       	mov	r15, r31
     b3e:	f0 2d       	mov	r31, r0
     b40:	cc 24       	eor	r12, r12
     b42:	0e 94 21 0b 	call	0x1642	; 0x1642 <xSpriteCreate>
     b46:	80 93 8a 02 	sts	0x028A, r24
	
	srand(TCNT0);
     b4a:	86 b5       	in	r24, 0x26	; 38
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <srand>
	
	astGroup = xGroupCreate();
     b52:	0e 94 ed 0b 	call	0x17da	; 0x17da <xGroupCreate>
     b56:	80 93 89 02 	sts	0x0289, r24
     b5a:	0f 2e       	mov	r0, r31
     b5c:	f5 e0       	ldi	r31, 0x05	; 5
     b5e:	2f 2e       	mov	r2, r31
     b60:	33 24       	eor	r3, r3
     b62:	f0 2d       	mov	r31, r0
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
         getRandStartPosVal(SCREEN_W >> 1),
     b64:	80 e9       	ldi	r24, 0x90	; 144
     b66:	91 e0       	ldi	r25, 0x01	; 1
     b68:	0e 94 9c 04 	call	0x938	; 0x938 <getRandStartPosVal>
     b6c:	2c 01       	movw	r4, r24
         getRandStartPosVal(SCREEN_H >> 1),
     b6e:	8c e2       	ldi	r24, 0x2C	; 44
     b70:	91 e0       	ldi	r25, 0x01	; 1
     b72:	0e 94 9c 04 	call	0x938	; 0x938 <getRandStartPosVal>
     b76:	7c 01       	movw	r14, r24
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     b78:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     b7c:	6c 01       	movw	r12, r24
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     b7e:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     b82:	5c 01       	movw	r10, r24
         rand() % 360,
     b84:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     b88:	4c 01       	movw	r8, r24
         (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
     b8a:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
     b8e:	9c 83       	std	Y+4, r25	; 0x04
     b90:	8b 83       	std	Y+3, r24	; 0x03
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
     b92:	00 d0       	rcall	.+0      	; 0xb94 <init+0xbe>
     b94:	0f 92       	push	r0
     b96:	2d b7       	in	r18, 0x3d	; 61
     b98:	3e b7       	in	r19, 0x3e	; 62
     b9a:	2f 5f       	subi	r18, 0xFF	; 255
     b9c:	3f 4f       	sbci	r19, 0xFF	; 255
     b9e:	3a 83       	std	Y+2, r19	; 0x02
     ba0:	29 83       	std	Y+1, r18	; 0x01
     ba2:	b2 01       	movw	r22, r4
     ba4:	88 27       	eor	r24, r24
     ba6:	77 fd       	sbrc	r23, 7
     ba8:	80 95       	com	r24
     baa:	98 2f       	mov	r25, r24
     bac:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
     bb0:	6d 83       	std	Y+5, r22	; 0x05
     bb2:	7e 83       	std	Y+6, r23	; 0x06
     bb4:	8f 83       	std	Y+7, r24	; 0x07
     bb6:	98 87       	std	Y+8, r25	; 0x08
     bb8:	b7 01       	movw	r22, r14
     bba:	88 27       	eor	r24, r24
     bbc:	77 fd       	sbrc	r23, 7
     bbe:	80 95       	com	r24
     bc0:	98 2f       	mov	r25, r24
     bc2:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
     bc6:	2b 01       	movw	r4, r22
     bc8:	3c 01       	movw	r6, r24
         getRandStartPosVal(SCREEN_W >> 1),
         getRandStartPosVal(SCREEN_H >> 1),
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     bca:	c6 01       	movw	r24, r12
     bcc:	64 e1       	ldi	r22, 0x14	; 20
     bce:	70 e0       	ldi	r23, 0x00	; 0
     bd0:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     bd4:	fc 01       	movw	r30, r24
     bd6:	bf 01       	movw	r22, r30
     bd8:	88 27       	eor	r24, r24
     bda:	77 fd       	sbrc	r23, 7
     bdc:	80 95       	com	r24
     bde:	98 2f       	mov	r25, r24
     be0:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
     be4:	20 e0       	ldi	r18, 0x00	; 0
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	40 ea       	ldi	r20, 0xA0	; 160
     bea:	50 e4       	ldi	r21, 0x40	; 64
     bec:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
     bf0:	20 e0       	ldi	r18, 0x00	; 0
     bf2:	30 e0       	ldi	r19, 0x00	; 0
     bf4:	40 e0       	ldi	r20, 0x00	; 0
     bf6:	50 e4       	ldi	r21, 0x40	; 64
     bf8:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     bfc:	7b 01       	movw	r14, r22
     bfe:	8c 01       	movw	r16, r24
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     c00:	c5 01       	movw	r24, r10
     c02:	64 e1       	ldi	r22, 0x14	; 20
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     c0a:	9c 01       	movw	r18, r24
     c0c:	b9 01       	movw	r22, r18
     c0e:	88 27       	eor	r24, r24
     c10:	77 fd       	sbrc	r23, 7
     c12:	80 95       	com	r24
     c14:	98 2f       	mov	r25, r24
     c16:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
     c1a:	20 e0       	ldi	r18, 0x00	; 0
     c1c:	30 e0       	ldi	r19, 0x00	; 0
     c1e:	40 ea       	ldi	r20, 0xA0	; 160
     c20:	50 e4       	ldi	r21, 0x40	; 64
     c22:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
     c26:	20 e0       	ldi	r18, 0x00	; 0
     c28:	30 e0       	ldi	r19, 0x00	; 0
     c2a:	40 e0       	ldi	r20, 0x00	; 0
     c2c:	50 e4       	ldi	r21, 0x40	; 64
     c2e:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
     c32:	5b 01       	movw	r10, r22
     c34:	6c 01       	movw	r12, r24
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
     c36:	c4 01       	movw	r24, r8
     c38:	68 e6       	ldi	r22, 0x68	; 104
     c3a:	71 e0       	ldi	r23, 0x01	; 1
     c3c:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     c40:	4c 01       	movw	r8, r24
         getRandStartPosVal(SCREEN_W >> 1),
         getRandStartPosVal(SCREEN_H >> 1),
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
         rand() % 360,
         (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
     c42:	8b 81       	ldd	r24, Y+3	; 0x03
     c44:	9c 81       	ldd	r25, Y+4	; 0x04
     c46:	6e e1       	ldi	r22, 0x1E	; 30
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
     c4e:	fc 01       	movw	r30, r24
     c50:	bf 01       	movw	r22, r30
     c52:	88 27       	eor	r24, r24
     c54:	77 fd       	sbrc	r23, 7
     c56:	80 95       	com	r24
     c58:	98 2f       	mov	r25, r24
     c5a:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
     c5e:	20 e0       	ldi	r18, 0x00	; 0
     c60:	30 e0       	ldi	r19, 0x00	; 0
     c62:	40 ea       	ldi	r20, 0xA0	; 160
     c64:	50 e4       	ldi	r21, 0x40	; 64
     c66:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
     c6a:	20 e0       	ldi	r18, 0x00	; 0
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	40 e4       	ldi	r20, 0x40	; 64
     c70:	50 e4       	ldi	r21, 0x40	; 64
     c72:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
     c76:	0e 94 23 1c 	call	0x3846	; 0x3846 <__fixsfsi>
     c7a:	e9 81       	ldd	r30, Y+1	; 0x01
     c7c:	fa 81       	ldd	r31, Y+2	; 0x02
     c7e:	60 83       	st	Z, r22
     c80:	23 e0       	ldi	r18, 0x03	; 3
     c82:	21 83       	std	Z+1, r18	; 0x01
     c84:	80 91 81 02 	lds	r24, 0x0281
     c88:	90 91 82 02 	lds	r25, 0x0282
     c8c:	93 83       	std	Z+3, r25	; 0x03
     c8e:	82 83       	std	Z+2, r24	; 0x02
     c90:	6d 81       	ldd	r22, Y+5	; 0x05
     c92:	7e 81       	ldd	r23, Y+6	; 0x06
     c94:	8f 81       	ldd	r24, Y+7	; 0x07
     c96:	98 85       	ldd	r25, Y+8	; 0x08
     c98:	a3 01       	movw	r20, r6
     c9a:	92 01       	movw	r18, r4
     c9c:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <createAsteroid>
     ca0:	90 93 82 02 	sts	0x0282, r25
     ca4:	80 93 81 02 	sts	0x0281, r24
     ca8:	08 94       	sec
     caa:	21 08       	sbc	r2, r1
     cac:	31 08       	sbc	r3, r1
	
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
     cae:	0f 90       	pop	r0
     cb0:	0f 90       	pop	r0
     cb2:	0f 90       	pop	r0
     cb4:	0f 90       	pop	r0
     cb6:	21 14       	cp	r2, r1
     cb8:	31 04       	cpc	r3, r1
     cba:	09 f0       	breq	.+2      	; 0xcbe <init+0x1e8>
     cbc:	53 cf       	rjmp	.-346    	; 0xb64 <init+0x8e>
         (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
         3,
         asteroids);
	}
	
	ship.handle = xSpriteCreate(
     cbe:	82 e1       	ldi	r24, 0x12	; 18
     cc0:	92 e0       	ldi	r25, 0x02	; 2
     cc2:	60 e9       	ldi	r22, 0x90	; 144
     cc4:	71 e0       	ldi	r23, 0x01	; 1
     cc6:	4c e2       	ldi	r20, 0x2C	; 44
     cc8:	51 e0       	ldi	r21, 0x01	; 1
     cca:	20 e0       	ldi	r18, 0x00	; 0
     ccc:	30 e0       	ldi	r19, 0x00	; 0
     cce:	08 e1       	ldi	r16, 0x18	; 24
     cd0:	10 e0       	ldi	r17, 0x00	; 0
     cd2:	0f 2e       	mov	r0, r31
     cd4:	f8 e1       	ldi	r31, 0x18	; 24
     cd6:	ef 2e       	mov	r14, r31
     cd8:	ff 24       	eor	r15, r15
     cda:	f0 2d       	mov	r31, r0
     cdc:	cc 24       	eor	r12, r12
     cde:	c3 94       	inc	r12
     ce0:	0e 94 21 0b 	call	0x1642	; 0x1642 <xSpriteCreate>
     ce4:	80 93 60 02 	sts	0x0260, r24
      0, 
      SHIP_SIZE, 
      SHIP_SIZE, 
      1);
   
	ship.pos.x = SCREEN_W >> 1;
     ce8:	80 e0       	ldi	r24, 0x00	; 0
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	a8 ec       	ldi	r26, 0xC8	; 200
     cee:	b3 e4       	ldi	r27, 0x43	; 67
     cf0:	80 93 61 02 	sts	0x0261, r24
     cf4:	90 93 62 02 	sts	0x0262, r25
     cf8:	a0 93 63 02 	sts	0x0263, r26
     cfc:	b0 93 64 02 	sts	0x0264, r27
	ship.pos.y = SCREEN_H >> 1;
     d00:	80 e0       	ldi	r24, 0x00	; 0
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	a6 e9       	ldi	r26, 0x96	; 150
     d06:	b3 e4       	ldi	r27, 0x43	; 67
     d08:	80 93 65 02 	sts	0x0265, r24
     d0c:	90 93 66 02 	sts	0x0266, r25
     d10:	a0 93 67 02 	sts	0x0267, r26
     d14:	b0 93 68 02 	sts	0x0268, r27
	ship.vel.x = 0;
     d18:	80 e0       	ldi	r24, 0x00	; 0
     d1a:	90 e0       	ldi	r25, 0x00	; 0
     d1c:	dc 01       	movw	r26, r24
     d1e:	80 93 69 02 	sts	0x0269, r24
     d22:	90 93 6a 02 	sts	0x026A, r25
     d26:	a0 93 6b 02 	sts	0x026B, r26
     d2a:	b0 93 6c 02 	sts	0x026C, r27
	ship.vel.y = 0;
     d2e:	80 93 6d 02 	sts	0x026D, r24
     d32:	90 93 6e 02 	sts	0x026E, r25
     d36:	a0 93 6f 02 	sts	0x026F, r26
     d3a:	b0 93 70 02 	sts	0x0270, r27
	ship.accel = 0;
     d3e:	80 93 71 02 	sts	0x0271, r24
     d42:	90 93 72 02 	sts	0x0272, r25
     d46:	a0 93 73 02 	sts	0x0273, r26
     d4a:	b0 93 74 02 	sts	0x0274, r27
	ship.angle = 0;
     d4e:	10 92 76 02 	sts	0x0276, r1
     d52:	10 92 75 02 	sts	0x0275, r1
	ship.a_vel = 0;
     d56:	10 92 77 02 	sts	0x0277, r1
}
     d5a:	28 96       	adiw	r28, 0x08	; 8
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	f8 94       	cli
     d60:	de bf       	out	0x3e, r29	; 62
     d62:	0f be       	out	0x3f, r0	; 63
     d64:	cd bf       	out	0x3d, r28	; 61
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	1f 91       	pop	r17
     d6c:	0f 91       	pop	r16
     d6e:	ff 90       	pop	r15
     d70:	ef 90       	pop	r14
     d72:	df 90       	pop	r13
     d74:	cf 90       	pop	r12
     d76:	bf 90       	pop	r11
     d78:	af 90       	pop	r10
     d7a:	9f 90       	pop	r9
     d7c:	8f 90       	pop	r8
     d7e:	7f 90       	pop	r7
     d80:	6f 90       	pop	r6
     d82:	5f 90       	pop	r5
     d84:	4f 90       	pop	r4
     d86:	3f 90       	pop	r3
     d88:	2f 90       	pop	r2
     d8a:	08 95       	ret

00000d8c <createBullet>:
 * param vely: The new bullet's y velocity.
 * param nxt: A pointer to the next bullet object in a linked list of bullets.
 * return: A pointer to a malloc'd bullet object. This pointer must be freed by
 *  the caller.
 *----------------------------------------------------------------------------*/
object *createBullet(float x, float y, float velx, float vely, object *nxt) {
     d8c:	4f 92       	push	r4
     d8e:	5f 92       	push	r5
     d90:	6f 92       	push	r6
     d92:	7f 92       	push	r7
     d94:	8f 92       	push	r8
     d96:	9f 92       	push	r9
     d98:	af 92       	push	r10
     d9a:	bf 92       	push	r11
     d9c:	cf 92       	push	r12
     d9e:	df 92       	push	r13
     da0:	ef 92       	push	r14
     da2:	ff 92       	push	r15
     da4:	0f 93       	push	r16
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	cd b7       	in	r28, 0x3d	; 61
     dae:	de b7       	in	r29, 0x3e	; 62
     db0:	2c 97       	sbiw	r28, 0x0c	; 12
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	de bf       	out	0x3e, r29	; 62
     db8:	0f be       	out	0x3f, r0	; 63
     dba:	cd bf       	out	0x3d, r28	; 61
     dbc:	2b 01       	movw	r4, r22
     dbe:	3c 01       	movw	r6, r24
     dc0:	29 83       	std	Y+1, r18	; 0x01
     dc2:	3a 83       	std	Y+2, r19	; 0x02
     dc4:	4b 83       	std	Y+3, r20	; 0x03
     dc6:	5c 83       	std	Y+4, r21	; 0x04
     dc8:	ed 82       	std	Y+5, r14	; 0x05
     dca:	fe 82       	std	Y+6, r15	; 0x06
     dcc:	0f 83       	std	Y+7, r16	; 0x07
     dce:	18 87       	std	Y+8, r17	; 0x08
     dd0:	a9 86       	std	Y+9, r10	; 0x09
     dd2:	ba 86       	std	Y+10, r11	; 0x0a
     dd4:	cb 86       	std	Y+11, r12	; 0x0b
     dd6:	dc 86       	std	Y+12, r13	; 0x0c
     * Setup the pointers in the linked list using:
     * bullet->next = nxt;
     * Create a new sprite using xSpriteCreate()
     */
	 
   object *newBullet = pvPortMalloc(sizeof(object));
     dd8:	8d e1       	ldi	r24, 0x1D	; 29
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
     de0:	5c 01       	movw	r10, r24
	
	newBullet->handle = xSpriteCreate(
     de2:	c3 01       	movw	r24, r6
     de4:	b2 01       	movw	r22, r4
     de6:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
     dea:	6b 01       	movw	r12, r22
     dec:	7c 01       	movw	r14, r24
     dee:	69 81       	ldd	r22, Y+1	; 0x01
     df0:	7a 81       	ldd	r23, Y+2	; 0x02
     df2:	8b 81       	ldd	r24, Y+3	; 0x03
     df4:	9c 81       	ldd	r25, Y+4	; 0x04
     df6:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
     dfa:	8b 01       	movw	r16, r22
     dfc:	9c 01       	movw	r18, r24
     dfe:	8b e1       	ldi	r24, 0x1B	; 27
     e00:	92 e0       	ldi	r25, 0x02	; 2
     e02:	b6 01       	movw	r22, r12
     e04:	a8 01       	movw	r20, r16
     e06:	20 e0       	ldi	r18, 0x00	; 0
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	06 e0       	ldi	r16, 0x06	; 6
     e0c:	10 e0       	ldi	r17, 0x00	; 0
     e0e:	0f 2e       	mov	r0, r31
     e10:	f6 e0       	ldi	r31, 0x06	; 6
     e12:	ef 2e       	mov	r14, r31
     e14:	ff 24       	eor	r15, r15
     e16:	f0 2d       	mov	r31, r0
     e18:	cc 24       	eor	r12, r12
     e1a:	c3 94       	inc	r12
     e1c:	0e 94 21 0b 	call	0x1642	; 0x1642 <xSpriteCreate>
     e20:	d5 01       	movw	r26, r10
     e22:	8c 93       	st	X, r24
	0,                      //rAngle
	BULLET_SIZE,			   //width
	BULLET_SIZE,			   //height
	1);                     //depth

   newBullet->pos.x = x;
     e24:	f5 01       	movw	r30, r10
     e26:	41 82       	std	Z+1, r4	; 0x01
     e28:	52 82       	std	Z+2, r5	; 0x02
     e2a:	63 82       	std	Z+3, r6	; 0x03
     e2c:	74 82       	std	Z+4, r7	; 0x04
   newBullet->pos.y = y;
     e2e:	89 81       	ldd	r24, Y+1	; 0x01
     e30:	9a 81       	ldd	r25, Y+2	; 0x02
     e32:	ab 81       	ldd	r26, Y+3	; 0x03
     e34:	bc 81       	ldd	r27, Y+4	; 0x04
     e36:	85 83       	std	Z+5, r24	; 0x05
     e38:	96 83       	std	Z+6, r25	; 0x06
     e3a:	a7 83       	std	Z+7, r26	; 0x07
     e3c:	b0 87       	std	Z+8, r27	; 0x08
   newBullet->vel.x = velx;
     e3e:	8d 81       	ldd	r24, Y+5	; 0x05
     e40:	9e 81       	ldd	r25, Y+6	; 0x06
     e42:	af 81       	ldd	r26, Y+7	; 0x07
     e44:	b8 85       	ldd	r27, Y+8	; 0x08
     e46:	81 87       	std	Z+9, r24	; 0x09
     e48:	92 87       	std	Z+10, r25	; 0x0a
     e4a:	a3 87       	std	Z+11, r26	; 0x0b
     e4c:	b4 87       	std	Z+12, r27	; 0x0c
   newBullet->vel.y = vely;
     e4e:	89 85       	ldd	r24, Y+9	; 0x09
     e50:	9a 85       	ldd	r25, Y+10	; 0x0a
     e52:	ab 85       	ldd	r26, Y+11	; 0x0b
     e54:	bc 85       	ldd	r27, Y+12	; 0x0c
     e56:	85 87       	std	Z+13, r24	; 0x0d
     e58:	96 87       	std	Z+14, r25	; 0x0e
     e5a:	a7 87       	std	Z+15, r26	; 0x0f
     e5c:	b0 8b       	std	Z+16, r27	; 0x10
   newBullet->size = BULLET_SIZE;
     e5e:	86 e0       	ldi	r24, 0x06	; 6
     e60:	80 8f       	std	Z+24, r24	; 0x18
   newBullet->life = BULLET_LIFE_MS;
     e62:	88 ee       	ldi	r24, 0xE8	; 232
     e64:	93 e0       	ldi	r25, 0x03	; 3
     e66:	92 8f       	std	Z+26, r25	; 0x1a
     e68:	81 8f       	std	Z+25, r24	; 0x19
   newBullet->next = nxt;
     e6a:	94 8e       	std	Z+28, r9	; 0x1c
     e6c:	83 8e       	std	Z+27, r8	; 0x1b

   return (newBullet); 
}
     e6e:	8a 2d       	mov	r24, r10
     e70:	9b 2d       	mov	r25, r11
     e72:	2c 96       	adiw	r28, 0x0c	; 12
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	de bf       	out	0x3e, r29	; 62
     e7a:	0f be       	out	0x3f, r0	; 63
     e7c:	cd bf       	out	0x3d, r28	; 61
     e7e:	df 91       	pop	r29
     e80:	cf 91       	pop	r28
     e82:	1f 91       	pop	r17
     e84:	0f 91       	pop	r16
     e86:	ff 90       	pop	r15
     e88:	ef 90       	pop	r14
     e8a:	df 90       	pop	r13
     e8c:	cf 90       	pop	r12
     e8e:	bf 90       	pop	r11
     e90:	af 90       	pop	r10
     e92:	9f 90       	pop	r9
     e94:	8f 90       	pop	r8
     e96:	7f 90       	pop	r7
     e98:	6f 90       	pop	r6
     e9a:	5f 90       	pop	r5
     e9c:	4f 90       	pop	r4
     e9e:	08 95       	ret

00000ea0 <bulletTask>:
 *  second to regulate the fire rate.  If a bullet is not fired, the task
 *  blocks for a frame delay (FRAME_DELAY_MS)
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void bulletTask(void *vParam) {
     ea0:	cf 93       	push	r28
     ea2:	df 93       	push	r29
     ea4:	cd b7       	in	r28, 0x3d	; 61
     ea6:	de b7       	in	r29, 0x3e	; 62
     ea8:	2a 97       	sbiw	r28, 0x0a	; 10
     eaa:	0f b6       	in	r0, 0x3f	; 63
     eac:	f8 94       	cli
     eae:	de bf       	out	0x3e, r29	; 62
     eb0:	0f be       	out	0x3f, r0	; 63
     eb2:	cd bf       	out	0x3d, r28	; 61
     */
	// variable to hold ticks value of last task run
	portTickType xLastWakeTime;

	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
     eb4:	0e 94 18 17 	call	0x2e30	; 0x2e30 <xTaskGetTickCount>
     eb8:	9a 83       	std	Y+2, r25	; 0x02
     eba:	89 83       	std	Y+1, r24	; 0x01
    while (1) {
		if(SHOOT_BUTTON) {
         
         xSemaphoreTake(usartMutex, portMAX_DELAY);
			bullets = createBullet(ship.pos.x, ship.pos.y, ship.vel.x + BULLET_VEL, ship.vel.y + BULLET_VEL, bullets);
     ebc:	0f 2e       	mov	r0, r31
     ebe:	f1 e6       	ldi	r31, 0x61	; 97
     ec0:	6f 2e       	mov	r6, r31
     ec2:	f2 e0       	ldi	r31, 0x02	; 2
     ec4:	7f 2e       	mov	r7, r31
     ec6:	f0 2d       	mov	r31, r0
     ec8:	44 24       	eor	r4, r4
     eca:	55 24       	eor	r5, r5
     ecc:	68 94       	set
     ece:	42 f8       	bld	r4, 2
     ed0:	46 0c       	add	r4, r6
     ed2:	57 1c       	adc	r5, r7
     ed4:	22 24       	eor	r2, r2
     ed6:	33 24       	eor	r3, r3
     ed8:	68 94       	set
     eda:	23 f8       	bld	r2, 3
     edc:	26 0c       	add	r2, r6
     ede:	37 1c       	adc	r3, r7
	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
    while (1) {
		if(SHOOT_BUTTON) {
         
         xSemaphoreTake(usartMutex, portMAX_DELAY);
     ee0:	80 91 7d 02 	lds	r24, 0x027D
     ee4:	90 91 7e 02 	lds	r25, 0x027E
     ee8:	60 e0       	ldi	r22, 0x00	; 0
     eea:	70 e0       	ldi	r23, 0x00	; 0
     eec:	4f ef       	ldi	r20, 0xFF	; 255
     eee:	5f ef       	ldi	r21, 0xFF	; 255
     ef0:	20 e0       	ldi	r18, 0x00	; 0
     ef2:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
			bullets = createBullet(ship.pos.x, ship.pos.y, ship.vel.x + BULLET_VEL, ship.vel.y + BULLET_VEL, bullets);
     ef6:	d3 01       	movw	r26, r6
     ef8:	8d 91       	ld	r24, X+
     efa:	9d 91       	ld	r25, X+
     efc:	0d 90       	ld	r0, X+
     efe:	bc 91       	ld	r27, X
     f00:	a0 2d       	mov	r26, r0
     f02:	8b 83       	std	Y+3, r24	; 0x03
     f04:	9c 83       	std	Y+4, r25	; 0x04
     f06:	ad 83       	std	Y+5, r26	; 0x05
     f08:	be 83       	std	Y+6, r27	; 0x06
     f0a:	d2 01       	movw	r26, r4
     f0c:	8d 91       	ld	r24, X+
     f0e:	9d 91       	ld	r25, X+
     f10:	0d 90       	ld	r0, X+
     f12:	bc 91       	ld	r27, X
     f14:	a0 2d       	mov	r26, r0
     f16:	8f 83       	std	Y+7, r24	; 0x07
     f18:	98 87       	std	Y+8, r25	; 0x08
     f1a:	a9 87       	std	Y+9, r26	; 0x09
     f1c:	ba 87       	std	Y+10, r27	; 0x0a
     f1e:	f1 01       	movw	r30, r2
     f20:	60 81       	ld	r22, Z
     f22:	71 81       	ldd	r23, Z+1	; 0x01
     f24:	82 81       	ldd	r24, Z+2	; 0x02
     f26:	93 81       	ldd	r25, Z+3	; 0x03
     f28:	20 e0       	ldi	r18, 0x00	; 0
     f2a:	30 e0       	ldi	r19, 0x00	; 0
     f2c:	40 ec       	ldi	r20, 0xC0	; 192
     f2e:	50 e4       	ldi	r21, 0x40	; 64
     f30:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     f34:	7b 01       	movw	r14, r22
     f36:	8c 01       	movw	r16, r24
     f38:	ad e6       	ldi	r26, 0x6D	; 109
     f3a:	b2 e0       	ldi	r27, 0x02	; 2
     f3c:	6d 91       	ld	r22, X+
     f3e:	7d 91       	ld	r23, X+
     f40:	8d 91       	ld	r24, X+
     f42:	9c 91       	ld	r25, X
     f44:	20 e0       	ldi	r18, 0x00	; 0
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	40 ec       	ldi	r20, 0xC0	; 192
     f4a:	50 e4       	ldi	r21, 0x40	; 64
     f4c:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <__addsf3>
     f50:	5b 01       	movw	r10, r22
     f52:	6c 01       	movw	r12, r24
     f54:	80 90 7f 02 	lds	r8, 0x027F
     f58:	90 90 80 02 	lds	r9, 0x0280
     f5c:	6b 81       	ldd	r22, Y+3	; 0x03
     f5e:	7c 81       	ldd	r23, Y+4	; 0x04
     f60:	8d 81       	ldd	r24, Y+5	; 0x05
     f62:	9e 81       	ldd	r25, Y+6	; 0x06
     f64:	2f 81       	ldd	r18, Y+7	; 0x07
     f66:	38 85       	ldd	r19, Y+8	; 0x08
     f68:	49 85       	ldd	r20, Y+9	; 0x09
     f6a:	5a 85       	ldd	r21, Y+10	; 0x0a
     f6c:	0e 94 c6 06 	call	0xd8c	; 0xd8c <createBullet>
     f70:	90 93 80 02 	sts	0x0280, r25
     f74:	80 93 7f 02 	sts	0x027F, r24
			xSemaphoreGive(usartMutex);
     f78:	80 91 7d 02 	lds	r24, 0x027D
     f7c:	90 91 7e 02 	lds	r25, 0x027E
     f80:	60 e0       	ldi	r22, 0x00	; 0
     f82:	70 e0       	ldi	r23, 0x00	; 0
     f84:	40 e0       	ldi	r20, 0x00	; 0
     f86:	50 e0       	ldi	r21, 0x00	; 0
     f88:	20 e0       	ldi	r18, 0x00	; 0
     f8a:	0e 94 c8 12 	call	0x2590	; 0x2590 <xQueueGenericSend>
						
			vTaskDelay((BULLET_LIFE_MS/2)/portTICK_RATE_MS);
     f8e:	84 ef       	ldi	r24, 0xF4	; 244
     f90:	91 e0       	ldi	r25, 0x01	; 1
     f92:	0e 94 80 18 	call	0x3100	; 0x3100 <vTaskDelay>
		}
			
		vTaskDelayUntil(&xLastWakeTime, FRAME_DELAY_MS / portTICK_RATE_MS);
     f96:	ce 01       	movw	r24, r28
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	6a e0       	ldi	r22, 0x0A	; 10
     f9c:	70 e0       	ldi	r23, 0x00	; 0
     f9e:	0e 94 a0 18 	call	0x3140	; 0x3140 <vTaskDelayUntil>
     fa2:	9e cf       	rjmp	.-196    	; 0xee0 <bulletTask+0x40>

00000fa4 <spawnAsteroid>:
 *
 * param pos: A pointer to the position at which the new asteroids will be
 *  created.
 * param size: The size of the asteroid being destroyed.
 *----------------------------------------------------------------------------*/
void spawnAsteroid(point *pos, uint8_t size) {
     fa4:	2f 92       	push	r2
     fa6:	3f 92       	push	r3
     fa8:	4f 92       	push	r4
     faa:	5f 92       	push	r5
     fac:	6f 92       	push	r6
     fae:	7f 92       	push	r7
     fb0:	8f 92       	push	r8
     fb2:	9f 92       	push	r9
     fb4:	af 92       	push	r10
     fb6:	bf 92       	push	r11
     fb8:	cf 92       	push	r12
     fba:	df 92       	push	r13
     fbc:	ef 92       	push	r14
     fbe:	ff 92       	push	r15
     fc0:	0f 93       	push	r16
     fc2:	1f 93       	push	r17
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	cd b7       	in	r28, 0x3d	; 61
     fca:	de b7       	in	r29, 0x3e	; 62
     fcc:	6a 97       	sbiw	r28, 0x1a	; 26
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	f8 94       	cli
     fd2:	de bf       	out	0x3e, r29	; 62
     fd4:	0f be       	out	0x3f, r0	; 63
     fd6:	cd bf       	out	0x3d, r28	; 61
     fd8:	9c 83       	std	Y+4, r25	; 0x04
     fda:	8b 83       	std	Y+3, r24	; 0x03
	/* ToDo:
     * Spawn 3 smaller asteroids, or no asteroids depending on the size of this asteroid
     * Use createAsteroid()
     */
   int vel, accel;
   if (size > 1) {
     fdc:	62 30       	cpi	r22, 0x02	; 2
     fde:	08 f4       	brcc	.+2      	; 0xfe2 <spawnAsteroid+0x3e>
     fe0:	0e c1       	rjmp	.+540    	; 0x11fe <spawnAsteroid+0x25a>
      switch (size - 1) {
     fe2:	86 2f       	mov	r24, r22
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	01 97       	sbiw	r24, 0x01	; 1
     fe8:	81 30       	cpi	r24, 0x01	; 1
     fea:	91 05       	cpc	r25, r1
     fec:	69 f0       	breq	.+26     	; 0x1008 <spawnAsteroid+0x64>
     fee:	82 30       	cpi	r24, 0x02	; 2
     ff0:	91 05       	cpc	r25, r1
     ff2:	29 f4       	brne	.+10     	; 0xffe <spawnAsteroid+0x5a>
         case 2:
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
     ff4:	26 e0       	ldi	r18, 0x06	; 6
     ff6:	30 e0       	ldi	r19, 0x00	; 0
     */
   int vel, accel;
   if (size > 1) {
      switch (size - 1) {
         case 2:
            vel = AST_MAX_VEL_2;
     ff8:	83 e0       	ldi	r24, 0x03	; 3
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	09 c0       	rjmp	.+18     	; 0x1010 <spawnAsteroid+0x6c>
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
            break;
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
     ffe:	23 e0       	ldi	r18, 0x03	; 3
    1000:	30 e0       	ldi	r19, 0x00	; 0
         case 1:
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
            break;
         default:
            vel = AST_MAX_VEL_3;
    1002:	82 e0       	ldi	r24, 0x02	; 2
    1004:	90 e0       	ldi	r25, 0x00	; 0
            accel = AST_MAX_AVEL_3;
            break;
    1006:	04 c0       	rjmp	.+8      	; 0x1010 <spawnAsteroid+0x6c>
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
            break;
         case 1:
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
    1008:	29 e0       	ldi	r18, 0x09	; 9
    100a:	30 e0       	ldi	r19, 0x00	; 0
         case 2:
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
            break;
         case 1:
            vel = AST_MAX_VEL_1;
    100c:	84 e0       	ldi	r24, 0x04	; 4
    100e:	90 e0       	ldi	r25, 0x00	; 0
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
    1010:	48 2f       	mov	r20, r24
    1012:	44 0f       	add	r20, r20
    1014:	54 2f       	mov	r21, r20
    1016:	55 0f       	add	r21, r21
    1018:	55 0f       	add	r21, r21
    101a:	45 0f       	add	r20, r21
    101c:	e4 2e       	mov	r14, r20
    101e:	ff 24       	eor	r15, r15
    1020:	e7 fc       	sbrc	r14, 7
    1022:	f0 94       	com	r15
    1024:	fe 82       	std	Y+6, r15	; 0x06
    1026:	ed 82       	std	Y+5, r14	; 0x05
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
            rand() % 360,                                   //angle
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    1028:	42 2f       	mov	r20, r18
    102a:	44 0f       	add	r20, r20
    102c:	54 2f       	mov	r21, r20
    102e:	55 0f       	add	r21, r21
    1030:	55 0f       	add	r21, r21
    1032:	45 0f       	add	r20, r21
    1034:	04 2f       	mov	r16, r20
    1036:	11 27       	eor	r17, r17
    1038:	07 fd       	sbrc	r16, 7
    103a:	10 95       	com	r17
    103c:	18 8b       	std	Y+16, r17	; 0x10
    103e:	0f 87       	std	Y+15, r16	; 0x0f
    1040:	0f 2e       	mov	r0, r31
    1042:	f3 e0       	ldi	r31, 0x03	; 3
    1044:	2f 2e       	mov	r2, r31
    1046:	33 24       	eor	r3, r3
    1048:	f0 2d       	mov	r31, r0
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    104a:	7c 01       	movw	r14, r24
    104c:	00 27       	eor	r16, r16
    104e:	f7 fc       	sbrc	r15, 7
    1050:	00 95       	com	r16
    1052:	10 2f       	mov	r17, r16
    1054:	e9 8a       	std	Y+17, r14	; 0x11
    1056:	fa 8a       	std	Y+18, r15	; 0x12
    1058:	0b 8b       	std	Y+19, r16	; 0x13
    105a:	1c 8b       	std	Y+20, r17	; 0x14
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
            rand() % 360,                                   //angle
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    105c:	c9 01       	movw	r24, r18
    105e:	aa 27       	eor	r26, r26
    1060:	97 fd       	sbrc	r25, 7
    1062:	a0 95       	com	r26
    1064:	ba 2f       	mov	r27, r26
    1066:	8d 8b       	std	Y+21, r24	; 0x15
    1068:	9e 8b       	std	Y+22, r25	; 0x16
    106a:	af 8b       	std	Y+23, r26	; 0x17
    106c:	b8 8f       	std	Y+24, r27	; 0x18
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    106e:	76 2e       	mov	r7, r22
    1070:	7a 94       	dec	r7
    1072:	3a 82       	std	Y+2, r3	; 0x02
    1074:	29 82       	std	Y+1, r2	; 0x01
    1076:	ab 81       	ldd	r26, Y+3	; 0x03
    1078:	bc 81       	ldd	r27, Y+4	; 0x04
    107a:	ed 90       	ld	r14, X+
    107c:	fd 90       	ld	r15, X+
    107e:	0d 91       	ld	r16, X+
    1080:	1c 91       	ld	r17, X
    1082:	13 97       	sbiw	r26, 0x03	; 3
    1084:	ef 82       	std	Y+7, r14	; 0x07
    1086:	f8 86       	std	Y+8, r15	; 0x08
    1088:	09 87       	std	Y+9, r16	; 0x09
    108a:	1a 87       	std	Y+10, r17	; 0x0a
    108c:	14 96       	adiw	r26, 0x04	; 4
    108e:	ed 90       	ld	r14, X+
    1090:	fd 90       	ld	r15, X+
    1092:	0d 91       	ld	r16, X+
    1094:	1c 91       	ld	r17, X
    1096:	17 97       	sbiw	r26, 0x07	; 7
    1098:	eb 86       	std	Y+11, r14	; 0x0b
    109a:	fc 86       	std	Y+12, r15	; 0x0c
    109c:	0d 87       	std	Y+13, r16	; 0x0d
    109e:	1e 87       	std	Y+14, r17	; 0x0e
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
    10a0:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
    10a4:	8c 01       	movw	r16, r24
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    10a6:	69 89       	ldd	r22, Y+17	; 0x11
    10a8:	7a 89       	ldd	r23, Y+18	; 0x12
    10aa:	8b 89       	ldd	r24, Y+19	; 0x13
    10ac:	9c 89       	ldd	r25, Y+20	; 0x14
    10ae:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
    10b2:	6b 01       	movw	r12, r22
    10b4:	7c 01       	movw	r14, r24
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
    10b6:	c8 01       	movw	r24, r16
    10b8:	6d 81       	ldd	r22, Y+5	; 0x05
    10ba:	7e 81       	ldd	r23, Y+6	; 0x06
    10bc:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
    10c0:	fc 01       	movw	r30, r24
    10c2:	bf 01       	movw	r22, r30
    10c4:	88 27       	eor	r24, r24
    10c6:	77 fd       	sbrc	r23, 7
    10c8:	80 95       	com	r24
    10ca:	98 2f       	mov	r25, r24
    10cc:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
    10d0:	20 e0       	ldi	r18, 0x00	; 0
    10d2:	30 e0       	ldi	r19, 0x00	; 0
    10d4:	40 ea       	ldi	r20, 0xA0	; 160
    10d6:	50 e4       	ldi	r21, 0x40	; 64
    10d8:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
    10dc:	a7 01       	movw	r20, r14
    10de:	96 01       	movw	r18, r12
    10e0:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
    10e4:	66 2e       	mov	r6, r22
    10e6:	57 2e       	mov	r5, r23
    10e8:	48 2e       	mov	r4, r24
    10ea:	29 2e       	mov	r2, r25
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
    10ec:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
    10f0:	6d 81       	ldd	r22, Y+5	; 0x05
    10f2:	7e 81       	ldd	r23, Y+6	; 0x06
    10f4:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
    10f8:	8c 01       	movw	r16, r24
    10fa:	b8 01       	movw	r22, r16
    10fc:	88 27       	eor	r24, r24
    10fe:	77 fd       	sbrc	r23, 7
    1100:	80 95       	com	r24
    1102:	98 2f       	mov	r25, r24
    1104:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
    1108:	20 e0       	ldi	r18, 0x00	; 0
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	40 ea       	ldi	r20, 0xA0	; 160
    110e:	50 e4       	ldi	r21, 0x40	; 64
    1110:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
    1114:	a7 01       	movw	r20, r14
    1116:	96 01       	movw	r18, r12
    1118:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
    111c:	b6 2e       	mov	r11, r22
    111e:	a7 2e       	mov	r10, r23
    1120:	98 2e       	mov	r9, r24
    1122:	89 2e       	mov	r8, r25
            rand() % 360,                                   //angle
    1124:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
    1128:	6c 01       	movw	r12, r24
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    112a:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <rand>
    112e:	9c 01       	movw	r18, r24
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    1130:	00 d0       	rcall	.+0      	; 0x1132 <spawnAsteroid+0x18e>
    1132:	0f 92       	push	r0
    1134:	0d b7       	in	r16, 0x3d	; 61
    1136:	1e b7       	in	r17, 0x3e	; 62
    1138:	0f 5f       	subi	r16, 0xFF	; 255
    113a:	1f 4f       	sbci	r17, 0xFF	; 255
    113c:	c6 01       	movw	r24, r12
    113e:	68 e6       	ldi	r22, 0x68	; 104
    1140:	71 e0       	ldi	r23, 0x01	; 1
    1142:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
    1146:	9a 8f       	std	Y+26, r25	; 0x1a
    1148:	89 8f       	std	Y+25, r24	; 0x19
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
            rand() % 360,                                   //angle
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    114a:	c9 01       	movw	r24, r18
    114c:	6f 85       	ldd	r22, Y+15	; 0x0f
    114e:	78 89       	ldd	r23, Y+16	; 0x10
    1150:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <__divmodhi4>
    1154:	9c 01       	movw	r18, r24
    1156:	b9 01       	movw	r22, r18
    1158:	88 27       	eor	r24, r24
    115a:	77 fd       	sbrc	r23, 7
    115c:	80 95       	com	r24
    115e:	98 2f       	mov	r25, r24
    1160:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
    1164:	20 e0       	ldi	r18, 0x00	; 0
    1166:	30 e0       	ldi	r19, 0x00	; 0
    1168:	40 ea       	ldi	r20, 0xA0	; 160
    116a:	50 e4       	ldi	r21, 0x40	; 64
    116c:	0e 94 bb 1b 	call	0x3776	; 0x3776 <__divsf3>
    1170:	6b 01       	movw	r12, r22
    1172:	7c 01       	movw	r14, r24
    1174:	6d 89       	ldd	r22, Y+21	; 0x15
    1176:	7e 89       	ldd	r23, Y+22	; 0x16
    1178:	8f 89       	ldd	r24, Y+23	; 0x17
    117a:	98 8d       	ldd	r25, Y+24	; 0x18
    117c:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__floatsisf>
    1180:	9b 01       	movw	r18, r22
    1182:	ac 01       	movw	r20, r24
    1184:	c7 01       	movw	r24, r14
    1186:	b6 01       	movw	r22, r12
    1188:	0e 94 4f 1b 	call	0x369e	; 0x369e <__subsf3>
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    118c:	0e 94 23 1c 	call	0x3846	; 0x3846 <__fixsfsi>
    1190:	d8 01       	movw	r26, r16
    1192:	6c 93       	st	X, r22
    1194:	11 96       	adiw	r26, 0x01	; 1
    1196:	7c 92       	st	X, r7
    1198:	11 97       	sbiw	r26, 0x01	; 1
    119a:	80 91 81 02 	lds	r24, 0x0281
    119e:	90 91 82 02 	lds	r25, 0x0282
    11a2:	13 96       	adiw	r26, 0x03	; 3
    11a4:	9c 93       	st	X, r25
    11a6:	8e 93       	st	-X, r24
    11a8:	12 97       	sbiw	r26, 0x02	; 2
    11aa:	6f 81       	ldd	r22, Y+7	; 0x07
    11ac:	78 85       	ldd	r23, Y+8	; 0x08
    11ae:	89 85       	ldd	r24, Y+9	; 0x09
    11b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    11b2:	2b 85       	ldd	r18, Y+11	; 0x0b
    11b4:	3c 85       	ldd	r19, Y+12	; 0x0c
    11b6:	4d 85       	ldd	r20, Y+13	; 0x0d
    11b8:	5e 85       	ldd	r21, Y+14	; 0x0e
    11ba:	c6 2c       	mov	r12, r6
    11bc:	d5 2c       	mov	r13, r5
    11be:	e4 2c       	mov	r14, r4
    11c0:	f2 2c       	mov	r15, r2
    11c2:	87 01       	movw	r16, r14
    11c4:	76 01       	movw	r14, r12
    11c6:	a9 2d       	mov	r26, r9
    11c8:	b8 2d       	mov	r27, r8
    11ca:	8b 2c       	mov	r8, r11
    11cc:	9a 2c       	mov	r9, r10
    11ce:	aa 2e       	mov	r10, r26
    11d0:	bb 2e       	mov	r11, r27
    11d2:	65 01       	movw	r12, r10
    11d4:	54 01       	movw	r10, r8
    11d6:	89 8c       	ldd	r8, Y+25	; 0x19
    11d8:	9a 8c       	ldd	r9, Y+26	; 0x1a
    11da:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <createAsteroid>
    11de:	90 93 82 02 	sts	0x0282, r25
    11e2:	80 93 81 02 	sts	0x0281, r24
    11e6:	e9 81       	ldd	r30, Y+1	; 0x01
    11e8:	fa 81       	ldd	r31, Y+2	; 0x02
    11ea:	31 97       	sbiw	r30, 0x01	; 1
    11ec:	fa 83       	std	Y+2, r31	; 0x02
    11ee:	e9 83       	std	Y+1, r30	; 0x01
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
    11f0:	0f 90       	pop	r0
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	30 97       	sbiw	r30, 0x00	; 0
    11fa:	09 f0       	breq	.+2      	; 0x11fe <spawnAsteroid+0x25a>
    11fc:	3c cf       	rjmp	.-392    	; 0x1076 <spawnAsteroid+0xd2>
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
            size - 1,                                       //size
            asteroids);                                     //next asteroid
      }
   }
    11fe:	6a 96       	adiw	r28, 0x1a	; 26
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	de bf       	out	0x3e, r29	; 62
    1206:	0f be       	out	0x3f, r0	; 63
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	1f 91       	pop	r17
    1210:	0f 91       	pop	r16
    1212:	ff 90       	pop	r15
    1214:	ef 90       	pop	r14
    1216:	df 90       	pop	r13
    1218:	cf 90       	pop	r12
    121a:	bf 90       	pop	r11
    121c:	af 90       	pop	r10
    121e:	9f 90       	pop	r9
    1220:	8f 90       	pop	r8
    1222:	7f 90       	pop	r7
    1224:	6f 90       	pop	r6
    1226:	5f 90       	pop	r5
    1228:	4f 90       	pop	r4
    122a:	3f 90       	pop	r3
    122c:	2f 90       	pop	r2
    122e:	08 95       	ret

00001230 <drawTask>:
 *  checks collisions and performs the proper action based on the types of the
 *  colliding objects.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void drawTask(void *vParam) {
    1230:	cf 93       	push	r28
    1232:	df 93       	push	r29
    1234:	cd b7       	in	r28, 0x3d	; 61
    1236:	de b7       	in	r29, 0x3e	; 62
    1238:	29 97       	sbiw	r28, 0x09	; 9
    123a:	0f b6       	in	r0, 0x3f	; 63
    123c:	f8 94       	cli
    123e:	de bf       	out	0x3e, r29	; 62
    1240:	0f be       	out	0x3f, r0	; 63
    1242:	cd bf       	out	0x3d, r28	; 61
	object *objIter, *objPrev, *astIter, *astPrev, *objTemp;
	xSpriteHandle hit, handle;
	point pos;
	uint8_t size;
	
	vTaskSuspend(updateTaskHandle);
    1244:	80 91 83 02 	lds	r24, 0x0283
    1248:	90 91 84 02 	lds	r25, 0x0284
    124c:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskSuspend>
	vTaskSuspend(bulletTaskHandle);
    1250:	80 91 85 02 	lds	r24, 0x0285
    1254:	90 91 86 02 	lds	r25, 0x0286
    1258:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskSuspend>
	vTaskSuspend(inputTaskHandle);
    125c:	80 91 87 02 	lds	r24, 0x0287
    1260:	90 91 88 02 	lds	r25, 0x0288
    1264:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskSuspend>
	init();
    1268:	0e 94 6b 05 	call	0xad6	; 0xad6 <init>
	vTaskResume(updateTaskHandle);
    126c:	80 91 83 02 	lds	r24, 0x0283
    1270:	90 91 84 02 	lds	r25, 0x0284
    1274:	0e 94 55 16 	call	0x2caa	; 0x2caa <vTaskResume>
	vTaskResume(bulletTaskHandle);
    1278:	80 91 85 02 	lds	r24, 0x0285
    127c:	90 91 86 02 	lds	r25, 0x0286
    1280:	0e 94 55 16 	call	0x2caa	; 0x2caa <vTaskResume>
	vTaskResume(inputTaskHandle);
    1284:	80 91 87 02 	lds	r24, 0x0287
    1288:	90 91 88 02 	lds	r25, 0x0288
    128c:	0e 94 55 16 	call	0x2caa	; 0x2caa <vTaskResume>
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
    1290:	0f 2e       	mov	r0, r31
    1292:	f0 e6       	ldi	r31, 0x60	; 96
    1294:	4f 2e       	mov	r4, r31
    1296:	f2 e0       	ldi	r31, 0x02	; 2
    1298:	5f 2e       	mov	r5, r31
    129a:	f0 2d       	mov	r31, r0
    129c:	0f 2e       	mov	r0, r31
    129e:	f5 e1       	ldi	r31, 0x15	; 21
    12a0:	2f 2e       	mov	r2, r31
    12a2:	33 24       	eor	r3, r3
    12a4:	f0 2d       	mov	r31, r0
    12a6:	24 0c       	add	r2, r4
    12a8:	35 1c       	adc	r3, r5
	vTaskResume(updateTaskHandle);
	vTaskResume(bulletTaskHandle);
	vTaskResume(inputTaskHandle);
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
    12aa:	80 91 7d 02 	lds	r24, 0x027D
    12ae:	90 91 7e 02 	lds	r25, 0x027E
    12b2:	60 e0       	ldi	r22, 0x00	; 0
    12b4:	70 e0       	ldi	r23, 0x00	; 0
    12b6:	4f ef       	ldi	r20, 0xFF	; 255
    12b8:	5f ef       	ldi	r21, 0xFF	; 255
    12ba:	20 e0       	ldi	r18, 0x00	; 0
    12bc:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
		
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
    12c0:	f1 01       	movw	r30, r2
    12c2:	60 81       	ld	r22, Z
    12c4:	71 81       	ldd	r23, Z+1	; 0x01
    12c6:	f2 01       	movw	r30, r4
    12c8:	80 81       	ld	r24, Z
    12ca:	0e 94 9b 0b 	call	0x1736	; 0x1736 <vSpriteSetRotation>
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);
    12ce:	e1 e6       	ldi	r30, 0x61	; 97
    12d0:	f2 e0       	ldi	r31, 0x02	; 2
    12d2:	60 81       	ld	r22, Z
    12d4:	71 81       	ldd	r23, Z+1	; 0x01
    12d6:	82 81       	ldd	r24, Z+2	; 0x02
    12d8:	93 81       	ldd	r25, Z+3	; 0x03
    12da:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
    12de:	6b 01       	movw	r12, r22
    12e0:	7c 01       	movw	r14, r24
    12e2:	e5 e6       	ldi	r30, 0x65	; 101
    12e4:	f2 e0       	ldi	r31, 0x02	; 2
    12e6:	60 81       	ld	r22, Z
    12e8:	71 81       	ldd	r23, Z+1	; 0x01
    12ea:	82 81       	ldd	r24, Z+2	; 0x02
    12ec:	93 81       	ldd	r25, Z+3	; 0x03
    12ee:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
    12f2:	8b 01       	movw	r16, r22
    12f4:	9c 01       	movw	r18, r24
    12f6:	f2 01       	movw	r30, r4
    12f8:	80 81       	ld	r24, Z
    12fa:	b6 01       	movw	r22, r12
    12fc:	a8 01       	movw	r20, r16
    12fe:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vSpriteSetPosition>

		objPrev = NULL;
		objIter = bullets;
    1302:	e0 90 7f 02 	lds	r14, 0x027F
    1306:	f0 90 80 02 	lds	r15, 0x0280
		while (objIter != NULL) {
    130a:	e1 14       	cp	r14, r1
    130c:	f1 04       	cpc	r15, r1
    130e:	09 f4       	brne	.+2      	; 0x1312 <drawTask+0xe2>
    1310:	98 c0       	rjmp	.+304    	; 0x1442 <drawTask+0x212>
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);

		objPrev = NULL;
    1312:	66 24       	eor	r6, r6
    1314:	77 24       	eor	r7, r7
		objIter = bullets;
		while (objIter != NULL) {
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
    1316:	f7 01       	movw	r30, r14
    1318:	61 81       	ldd	r22, Z+1	; 0x01
    131a:	72 81       	ldd	r23, Z+2	; 0x02
    131c:	83 81       	ldd	r24, Z+3	; 0x03
    131e:	94 81       	ldd	r25, Z+4	; 0x04
    1320:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
    1324:	4b 01       	movw	r8, r22
    1326:	5c 01       	movw	r10, r24
    1328:	f7 01       	movw	r30, r14
    132a:	65 81       	ldd	r22, Z+5	; 0x05
    132c:	76 81       	ldd	r23, Z+6	; 0x06
    132e:	87 81       	ldd	r24, Z+7	; 0x07
    1330:	90 85       	ldd	r25, Z+8	; 0x08
    1332:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
    1336:	8b 01       	movw	r16, r22
    1338:	9c 01       	movw	r18, r24
    133a:	f7 01       	movw	r30, r14
    133c:	80 81       	ld	r24, Z
    133e:	b4 01       	movw	r22, r8
    1340:	a8 01       	movw	r20, r16
    1342:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vSpriteSetPosition>
			if (uCollide(objIter->handle, astGroup, &hit, 1) > 0) {
    1346:	f7 01       	movw	r30, r14
    1348:	80 81       	ld	r24, Z
    134a:	60 91 89 02 	lds	r22, 0x0289
    134e:	ae 01       	movw	r20, r28
    1350:	4f 5f       	subi	r20, 0xFF	; 255
    1352:	5f 4f       	sbci	r21, 0xFF	; 255
    1354:	21 e0       	ldi	r18, 0x01	; 1
    1356:	0e 94 1d 0c 	call	0x183a	; 0x183a <uCollide>
    135a:	88 23       	and	r24, r24
    135c:	09 f4       	brne	.+2      	; 0x1360 <drawTask+0x130>
    135e:	67 c0       	rjmp	.+206    	; 0x142e <drawTask+0x1fe>
				vSpriteDelete(objIter->handle);
    1360:	f7 01       	movw	r30, r14
    1362:	80 81       	ld	r24, Z
    1364:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
				
				if (objPrev != NULL) {
    1368:	61 14       	cp	r6, r1
    136a:	71 04       	cpc	r7, r1
    136c:	69 f0       	breq	.+26     	; 0x1388 <drawTask+0x158>
					objPrev->next = objIter->next;
    136e:	f7 01       	movw	r30, r14
    1370:	83 8d       	ldd	r24, Z+27	; 0x1b
    1372:	94 8d       	ldd	r25, Z+28	; 0x1c
    1374:	f3 01       	movw	r30, r6
    1376:	94 8f       	std	Z+28, r25	; 0x1c
    1378:	83 8f       	std	Z+27, r24	; 0x1b
					vPortFree(objIter);
    137a:	c7 01       	movw	r24, r14
    137c:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
					objIter = objPrev->next;
    1380:	f3 01       	movw	r30, r6
    1382:	e3 8c       	ldd	r14, Z+27	; 0x1b
    1384:	f4 8c       	ldd	r15, Z+28	; 0x1c
    1386:	0e c0       	rjmp	.+28     	; 0x13a4 <drawTask+0x174>
				} else {
					bullets = objIter->next;
    1388:	f7 01       	movw	r30, r14
    138a:	83 8d       	ldd	r24, Z+27	; 0x1b
    138c:	94 8d       	ldd	r25, Z+28	; 0x1c
    138e:	90 93 80 02 	sts	0x0280, r25
    1392:	80 93 7f 02 	sts	0x027F, r24
					vPortFree(objIter);
    1396:	c7 01       	movw	r24, r14
    1398:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
					objIter = bullets;
    139c:	e0 90 7f 02 	lds	r14, 0x027F
    13a0:	f0 90 80 02 	lds	r15, 0x0280
				}
				astPrev = NULL;
				astIter = asteroids;
    13a4:	c0 90 81 02 	lds	r12, 0x0281
    13a8:	d0 90 82 02 	lds	r13, 0x0282
				while (astIter != NULL) {
    13ac:	c1 14       	cp	r12, r1
    13ae:	d1 04       	cpc	r13, r1
    13b0:	09 f4       	brne	.+2      	; 0x13b4 <drawTask+0x184>
    13b2:	43 c0       	rjmp	.+134    	; 0x143a <drawTask+0x20a>
					if (astIter->handle == hit) {
    13b4:	99 81       	ldd	r25, Y+1	; 0x01
    13b6:	f6 01       	movw	r30, r12
    13b8:	80 81       	ld	r24, Z
    13ba:	89 17       	cp	r24, r25
    13bc:	89 f5       	brne	.+98     	; 0x1420 <drawTask+0x1f0>
    13be:	f3 c0       	rjmp	.+486    	; 0x15a6 <drawTask+0x376>
    13c0:	f8 01       	movw	r30, r16
    13c2:	80 81       	ld	r24, Z
    13c4:	89 17       	cp	r24, r25
    13c6:	59 f5       	brne	.+86     	; 0x141e <drawTask+0x1ee>
						spawnAsteroid(&pos, size);
						break;					
						
					} else {
						astPrev = astIter;
						astIter = astIter->next;
    13c8:	48 01       	movw	r8, r16
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
					if (astIter->handle == hit) {
						pos = astIter->pos;
    13ca:	de 01       	movw	r26, r28
    13cc:	12 96       	adiw	r26, 0x02	; 2
    13ce:	31 96       	adiw	r30, 0x01	; 1
    13d0:	88 e0       	ldi	r24, 0x08	; 8
    13d2:	01 90       	ld	r0, Z+
    13d4:	0d 92       	st	X+, r0
    13d6:	81 50       	subi	r24, 0x01	; 1
    13d8:	e1 f7       	brne	.-8      	; 0x13d2 <drawTask+0x1a2>
						size = astIter->size;
    13da:	f4 01       	movw	r30, r8
    13dc:	b0 8c       	ldd	r11, Z+24	; 0x18
						vSpriteDelete(astIter->handle);
    13de:	80 81       	ld	r24, Z
    13e0:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
						if (astPrev != NULL) {
    13e4:	c1 14       	cp	r12, r1
    13e6:	d1 04       	cpc	r13, r1
    13e8:	51 f0       	breq	.+20     	; 0x13fe <drawTask+0x1ce>
					        astPrev->next = astIter->next;
    13ea:	f4 01       	movw	r30, r8
    13ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    13ee:	94 8d       	ldd	r25, Z+28	; 0x1c
    13f0:	f6 01       	movw	r30, r12
    13f2:	94 8f       	std	Z+28, r25	; 0x1c
    13f4:	83 8f       	std	Z+27, r24	; 0x1b
					        vPortFree(astIter);
    13f6:	c4 01       	movw	r24, r8
    13f8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
    13fc:	0a c0       	rjmp	.+20     	; 0x1412 <drawTask+0x1e2>
					        astIter = astPrev->next;
				        } else {
					        asteroids = astIter->next;
    13fe:	f8 01       	movw	r30, r16
    1400:	83 8d       	ldd	r24, Z+27	; 0x1b
    1402:	94 8d       	ldd	r25, Z+28	; 0x1c
    1404:	90 93 82 02 	sts	0x0282, r25
    1408:	80 93 81 02 	sts	0x0281, r24
					        vPortFree(astIter);
    140c:	c8 01       	movw	r24, r16
    140e:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
				        }
						spawnAsteroid(&pos, size);
    1412:	ce 01       	movw	r24, r28
    1414:	02 96       	adiw	r24, 0x02	; 2
    1416:	6b 2d       	mov	r22, r11
    1418:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <spawnAsteroid>
						break;					
    141c:	0e c0       	rjmp	.+28     	; 0x143a <drawTask+0x20a>
						
					} else {
						astPrev = astIter;
						astIter = astIter->next;
    141e:	68 01       	movw	r12, r16
    1420:	f6 01       	movw	r30, r12
    1422:	03 8d       	ldd	r16, Z+27	; 0x1b
    1424:	14 8d       	ldd	r17, Z+28	; 0x1c
					vPortFree(objIter);
					objIter = bullets;
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
    1426:	01 15       	cp	r16, r1
    1428:	11 05       	cpc	r17, r1
    142a:	51 f6       	brne	.-108    	; 0x13c0 <drawTask+0x190>
    142c:	06 c0       	rjmp	.+12     	; 0x143a <drawTask+0x20a>
						astIter = astIter->next;
					}
				}
			} else {
				objPrev = objIter;
			   objIter = objIter->next;
    142e:	f7 01       	movw	r30, r14
    1430:	93 8d       	ldd	r25, Z+27	; 0x1b
    1432:	84 8d       	ldd	r24, Z+28	; 0x1c
    1434:	37 01       	movw	r6, r14
    1436:	e9 2e       	mov	r14, r25
    1438:	f8 2e       	mov	r15, r24
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);

		objPrev = NULL;
		objIter = bullets;
		while (objIter != NULL) {
    143a:	e1 14       	cp	r14, r1
    143c:	f1 04       	cpc	r15, r1
    143e:	09 f0       	breq	.+2      	; 0x1442 <drawTask+0x212>
    1440:	6a cf       	rjmp	.-300    	; 0x1316 <drawTask+0xe6>
				objPrev = objIter;
			   objIter = objIter->next;
			}			
		}
		
		objIter = asteroids;
    1442:	00 91 81 02 	lds	r16, 0x0281
    1446:	10 91 82 02 	lds	r17, 0x0282
		while (objIter != NULL) {
    144a:	01 15       	cp	r16, r1
    144c:	11 05       	cpc	r17, r1
    144e:	21 f1       	breq	.+72     	; 0x1498 <drawTask+0x268>
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
    1450:	f8 01       	movw	r30, r16
    1452:	61 81       	ldd	r22, Z+1	; 0x01
    1454:	72 81       	ldd	r23, Z+2	; 0x02
    1456:	83 81       	ldd	r24, Z+3	; 0x03
    1458:	94 81       	ldd	r25, Z+4	; 0x04
    145a:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
    145e:	4b 01       	movw	r8, r22
    1460:	5c 01       	movw	r10, r24
    1462:	f8 01       	movw	r30, r16
    1464:	65 81       	ldd	r22, Z+5	; 0x05
    1466:	76 81       	ldd	r23, Z+6	; 0x06
    1468:	87 81       	ldd	r24, Z+7	; 0x07
    146a:	90 85       	ldd	r25, Z+8	; 0x08
    146c:	0e 94 28 1c 	call	0x3850	; 0x3850 <__fixunssfsi>
    1470:	6b 01       	movw	r12, r22
    1472:	7c 01       	movw	r14, r24
    1474:	f8 01       	movw	r30, r16
    1476:	80 81       	ld	r24, Z
    1478:	b4 01       	movw	r22, r8
    147a:	a6 01       	movw	r20, r12
    147c:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vSpriteSetPosition>
			vSpriteSetRotation(objIter->handle, objIter->angle);
    1480:	f8 01       	movw	r30, r16
    1482:	65 89       	ldd	r22, Z+21	; 0x15
    1484:	76 89       	ldd	r23, Z+22	; 0x16
    1486:	80 81       	ld	r24, Z
    1488:	0e 94 9b 0b 	call	0x1736	; 0x1736 <vSpriteSetRotation>
			objIter = objIter->next;
    148c:	f8 01       	movw	r30, r16
    148e:	03 8d       	ldd	r16, Z+27	; 0x1b
    1490:	14 8d       	ldd	r17, Z+28	; 0x1c
			   objIter = objIter->next;
			}			
		}
		
		objIter = asteroids;
		while (objIter != NULL) {
    1492:	01 15       	cp	r16, r1
    1494:	11 05       	cpc	r17, r1
    1496:	e1 f6       	brne	.-72     	; 0x1450 <drawTask+0x220>
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
			vSpriteSetRotation(objIter->handle, objIter->angle);
			objIter = objIter->next;
		}			
				
		if (uCollide(ship.handle, astGroup, &hit, 1) > 0 || asteroids == NULL) {
    1498:	f2 01       	movw	r30, r4
    149a:	80 81       	ld	r24, Z
    149c:	60 91 89 02 	lds	r22, 0x0289
    14a0:	ae 01       	movw	r20, r28
    14a2:	4f 5f       	subi	r20, 0xFF	; 255
    14a4:	5f 4f       	sbci	r21, 0xFF	; 255
    14a6:	21 e0       	ldi	r18, 0x01	; 1
    14a8:	0e 94 1d 0c 	call	0x183a	; 0x183a <uCollide>
    14ac:	88 23       	and	r24, r24
    14ae:	39 f4       	brne	.+14     	; 0x14be <drawTask+0x28e>
    14b0:	80 91 81 02 	lds	r24, 0x0281
    14b4:	90 91 82 02 	lds	r25, 0x0282
    14b8:	00 97       	sbiw	r24, 0x00	; 0
    14ba:	09 f0       	breq	.+2      	; 0x14be <drawTask+0x28e>
    14bc:	64 c0       	rjmp	.+200    	; 0x1586 <drawTask+0x356>
			vTaskSuspend(updateTaskHandle);
    14be:	80 91 83 02 	lds	r24, 0x0283
    14c2:	90 91 84 02 	lds	r25, 0x0284
    14c6:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskSuspend>
			vTaskSuspend(bulletTaskHandle);
    14ca:	80 91 85 02 	lds	r24, 0x0285
    14ce:	90 91 86 02 	lds	r25, 0x0286
    14d2:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskSuspend>
			vTaskSuspend(inputTaskHandle);
    14d6:	80 91 87 02 	lds	r24, 0x0287
    14da:	90 91 88 02 	lds	r25, 0x0288
    14de:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskSuspend>
			
			if (asteroids == NULL)
    14e2:	80 91 81 02 	lds	r24, 0x0281
    14e6:	90 91 82 02 	lds	r25, 0x0282
    14ea:	00 97       	sbiw	r24, 0x00	; 0
    14ec:	c1 f4       	brne	.+48     	; 0x151e <drawTask+0x2ee>
			   handle = xSpriteCreate("win.png", SCREEN_W>>1, SCREEN_H>>1, 20, SCREEN_W>>1, SCREEN_H>>1, 100);
    14ee:	86 e2       	ldi	r24, 0x26	; 38
    14f0:	92 e0       	ldi	r25, 0x02	; 2
    14f2:	60 e9       	ldi	r22, 0x90	; 144
    14f4:	71 e0       	ldi	r23, 0x01	; 1
    14f6:	4c e2       	ldi	r20, 0x2C	; 44
    14f8:	51 e0       	ldi	r21, 0x01	; 1
    14fa:	24 e1       	ldi	r18, 0x14	; 20
    14fc:	30 e0       	ldi	r19, 0x00	; 0
    14fe:	00 e9       	ldi	r16, 0x90	; 144
    1500:	11 e0       	ldi	r17, 0x01	; 1
    1502:	0f 2e       	mov	r0, r31
    1504:	fc e2       	ldi	r31, 0x2C	; 44
    1506:	ef 2e       	mov	r14, r31
    1508:	f1 e0       	ldi	r31, 0x01	; 1
    150a:	ff 2e       	mov	r15, r31
    150c:	f0 2d       	mov	r31, r0
    150e:	0f 2e       	mov	r0, r31
    1510:	f4 e6       	ldi	r31, 0x64	; 100
    1512:	cf 2e       	mov	r12, r31
    1514:	f0 2d       	mov	r31, r0
    1516:	0e 94 21 0b 	call	0x1642	; 0x1642 <xSpriteCreate>
    151a:	08 2f       	mov	r16, r24
    151c:	17 c0       	rjmp	.+46     	; 0x154c <drawTask+0x31c>
			else
			   handle = xSpriteCreate("lose.png", SCREEN_W>>1, SCREEN_H>>1, 0, SCREEN_W>>1, SCREEN_H>>1, 100);
    151e:	8e e2       	ldi	r24, 0x2E	; 46
    1520:	92 e0       	ldi	r25, 0x02	; 2
    1522:	60 e9       	ldi	r22, 0x90	; 144
    1524:	71 e0       	ldi	r23, 0x01	; 1
    1526:	4c e2       	ldi	r20, 0x2C	; 44
    1528:	51 e0       	ldi	r21, 0x01	; 1
    152a:	20 e0       	ldi	r18, 0x00	; 0
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	00 e9       	ldi	r16, 0x90	; 144
    1530:	11 e0       	ldi	r17, 0x01	; 1
    1532:	0f 2e       	mov	r0, r31
    1534:	fc e2       	ldi	r31, 0x2C	; 44
    1536:	ef 2e       	mov	r14, r31
    1538:	f1 e0       	ldi	r31, 0x01	; 1
    153a:	ff 2e       	mov	r15, r31
    153c:	f0 2d       	mov	r31, r0
    153e:	0f 2e       	mov	r0, r31
    1540:	f4 e6       	ldi	r31, 0x64	; 100
    1542:	cf 2e       	mov	r12, r31
    1544:	f0 2d       	mov	r31, r0
    1546:	0e 94 21 0b 	call	0x1642	; 0x1642 <xSpriteCreate>
    154a:	08 2f       	mov	r16, r24
				
			vTaskDelay(3000 / portTICK_RATE_MS);
    154c:	88 eb       	ldi	r24, 0xB8	; 184
    154e:	9b e0       	ldi	r25, 0x0B	; 11
    1550:	0e 94 80 18 	call	0x3100	; 0x3100 <vTaskDelay>
			vSpriteDelete(handle);
    1554:	80 2f       	mov	r24, r16
    1556:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
			
			reset();
    155a:	0e 94 63 04 	call	0x8c6	; 0x8c6 <reset>
			init();
    155e:	0e 94 6b 05 	call	0xad6	; 0xad6 <init>
			
			vTaskResume(updateTaskHandle);
    1562:	80 91 83 02 	lds	r24, 0x0283
    1566:	90 91 84 02 	lds	r25, 0x0284
    156a:	0e 94 55 16 	call	0x2caa	; 0x2caa <vTaskResume>
			vTaskResume(bulletTaskHandle);
    156e:	80 91 85 02 	lds	r24, 0x0285
    1572:	90 91 86 02 	lds	r25, 0x0286
    1576:	0e 94 55 16 	call	0x2caa	; 0x2caa <vTaskResume>
			vTaskResume(inputTaskHandle);
    157a:	80 91 87 02 	lds	r24, 0x0287
    157e:	90 91 88 02 	lds	r25, 0x0288
    1582:	0e 94 55 16 	call	0x2caa	; 0x2caa <vTaskResume>
		}
		
		xSemaphoreGive(usartMutex);
    1586:	80 91 7d 02 	lds	r24, 0x027D
    158a:	90 91 7e 02 	lds	r25, 0x027E
    158e:	60 e0       	ldi	r22, 0x00	; 0
    1590:	70 e0       	ldi	r23, 0x00	; 0
    1592:	40 e0       	ldi	r20, 0x00	; 0
    1594:	50 e0       	ldi	r21, 0x00	; 0
    1596:	20 e0       	ldi	r18, 0x00	; 0
    1598:	0e 94 c8 12 	call	0x2590	; 0x2590 <xQueueGenericSend>
		
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
    159c:	8a e0       	ldi	r24, 0x0A	; 10
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	0e 94 80 18 	call	0x3100	; 0x3100 <vTaskDelay>
	}
    15a4:	82 ce       	rjmp	.-764    	; 0x12aa <drawTask+0x7a>
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
					if (astIter->handle == hit) {
						pos = astIter->pos;
    15a6:	de 01       	movw	r26, r28
    15a8:	12 96       	adiw	r26, 0x02	; 2
    15aa:	f6 01       	movw	r30, r12
    15ac:	31 96       	adiw	r30, 0x01	; 1
    15ae:	88 e0       	ldi	r24, 0x08	; 8
    15b0:	01 90       	ld	r0, Z+
    15b2:	0d 92       	st	X+, r0
    15b4:	81 50       	subi	r24, 0x01	; 1
    15b6:	e1 f7       	brne	.-8      	; 0x15b0 <drawTask+0x380>
						size = astIter->size;
    15b8:	f6 01       	movw	r30, r12
    15ba:	b0 8c       	ldd	r11, Z+24	; 0x18
						vSpriteDelete(astIter->handle);
    15bc:	80 81       	ld	r24, Z
    15be:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vSpriteDelete>
					bullets = objIter->next;
					vPortFree(objIter);
					objIter = bullets;
				}
				astPrev = NULL;
				astIter = asteroids;
    15c2:	86 01       	movw	r16, r12
    15c4:	1c cf       	rjmp	.-456    	; 0x13fe <drawTask+0x1ce>

000015c6 <vPrint>:
* Description: Prints the supplied string to the python terminal.  Useful for 
*  debugging.
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	ec 01       	movw	r28, r24
	USART_Write(PYTHON_PRINT);
    15cc:	8b e0       	ldi	r24, 0x0B	; 11
    15ce:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	while (*s != '\0') {
    15d2:	88 81       	ld	r24, Y
    15d4:	88 23       	and	r24, r24
    15d6:	31 f0       	breq	.+12     	; 0x15e4 <vPrint+0x1e>
* Description: Prints the supplied string to the python terminal.  Useful for 
*  debugging.
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
    15d8:	21 96       	adiw	r28, 0x01	; 1
	USART_Write(PYTHON_PRINT);
	while (*s != '\0') {
		USART_Write((uint8_t)*s++);
    15da:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
	USART_Write(PYTHON_PRINT);
	while (*s != '\0') {
    15de:	89 91       	ld	r24, Y+
    15e0:	88 23       	and	r24, r24
    15e2:	d9 f7       	brne	.-10     	; 0x15da <vPrint+0x14>
		USART_Write((uint8_t)*s++);
	}
	USART_Write(0x00);  /* string is null-terminated */
    15e4:	80 e0       	ldi	r24, 0x00	; 0
    15e6:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    15ea:	df 91       	pop	r29
    15ec:	cf 91       	pop	r28
    15ee:	08 95       	ret

000015f0 <vWindowCreate>:
*  context and opens a window for drawing with the specified dimensions.
*
* param width: Desired width of the window in pixels
* param height: Desired height of the window in pixels
*******************************************************************************/
void vWindowCreate(uint16_t width, uint16_t height) {
    15f0:	0f 93       	push	r16
    15f2:	1f 93       	push	r17
    15f4:	cf 93       	push	r28
    15f6:	df 93       	push	r29
    15f8:	18 2f       	mov	r17, r24
    15fa:	09 2f       	mov	r16, r25
    15fc:	c6 2f       	mov	r28, r22
    15fe:	d7 2f       	mov	r29, r23
	USART_Init(BAUD_RATE, configCPU_CLOCK_HZ);
    1600:	80 e0       	ldi	r24, 0x00	; 0
    1602:	96 e9       	ldi	r25, 0x96	; 150
    1604:	40 e0       	ldi	r20, 0x00	; 0
    1606:	54 e2       	ldi	r21, 0x24	; 36
    1608:	64 ef       	ldi	r22, 0xF4	; 244
    160a:	70 e0       	ldi	r23, 0x00	; 0
    160c:	0e 94 05 1b 	call	0x360a	; 0x360a <USART_Init>

	USART_Read();
    1610:	0e 94 47 1b 	call	0x368e	; 0x368e <USART_Read>
	USART_Write_Unprotected(0xFF);
    1614:	8f ef       	ldi	r24, 0xFF	; 255
    1616:	0e 94 3f 1b 	call	0x367e	; 0x367e <USART_Write_Unprotected>
	
	USART_Write_Unprotected(CREATE_WINDOW);
    161a:	8a e0       	ldi	r24, 0x0A	; 10
    161c:	0e 94 3f 1b 	call	0x367e	; 0x367e <USART_Write_Unprotected>
	USART_Write_Unprotected(width >> 8);
    1620:	80 2f       	mov	r24, r16
    1622:	0e 94 3f 1b 	call	0x367e	; 0x367e <USART_Write_Unprotected>
	USART_Write_Unprotected(width & 0x00FF);
    1626:	81 2f       	mov	r24, r17
    1628:	0e 94 3f 1b 	call	0x367e	; 0x367e <USART_Write_Unprotected>
	USART_Write_Unprotected(height >> 8);
    162c:	8d 2f       	mov	r24, r29
    162e:	0e 94 3f 1b 	call	0x367e	; 0x367e <USART_Write_Unprotected>
	USART_Write_Unprotected(height & 0x00FF);
    1632:	8c 2f       	mov	r24, r28
    1634:	0e 94 3f 1b 	call	0x367e	; 0x367e <USART_Write_Unprotected>
}
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	1f 91       	pop	r17
    163e:	0f 91       	pop	r16
    1640:	08 95       	ret

00001642 <xSpriteCreate>:
* param height: Initial, unrotated height of the sprite in pixels
* param depth: Initial draw depth of the sprite (larger numbers are in front)
* return: A valid handle to the new sprite on success; ERROR_HANDLE otherwise
*******************************************************************************/
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
    1642:	7f 92       	push	r7
    1644:	8f 92       	push	r8
    1646:	9f 92       	push	r9
    1648:	af 92       	push	r10
    164a:	bf 92       	push	r11
    164c:	cf 92       	push	r12
    164e:	df 92       	push	r13
    1650:	ef 92       	push	r14
    1652:	ff 92       	push	r15
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	ec 01       	movw	r28, r24
    165e:	b6 2e       	mov	r11, r22
    1660:	d7 2e       	mov	r13, r23
    1662:	94 2e       	mov	r9, r20
    1664:	a5 2e       	mov	r10, r21
    1666:	72 2e       	mov	r7, r18
    1668:	83 2e       	mov	r8, r19
	
	USART_Write(CREATE_SPRITE);
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>

	while (*filename != '\0') {
    1670:	88 81       	ld	r24, Y
    1672:	88 23       	and	r24, r24
    1674:	31 f0       	breq	.+12     	; 0x1682 <xSpriteCreate+0x40>
* param width: Initial, unrotated width of the sprite in pixels
* param height: Initial, unrotated height of the sprite in pixels
* param depth: Initial draw depth of the sprite (larger numbers are in front)
* return: A valid handle to the new sprite on success; ERROR_HANDLE otherwise
*******************************************************************************/
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
    1676:	21 96       	adiw	r28, 0x01	; 1
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
	
	USART_Write(CREATE_SPRITE);

	while (*filename != '\0') {
		USART_Write((uint8_t)*filename++);
    1678:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
	
	USART_Write(CREATE_SPRITE);

	while (*filename != '\0') {
    167c:	89 91       	ld	r24, Y+
    167e:	88 23       	and	r24, r24
    1680:	d9 f7       	brne	.-10     	; 0x1678 <xSpriteCreate+0x36>
		USART_Write((uint8_t)*filename++);
	}
	USART_Write(0x00);  /* Filename is null-terminated */
    1682:	80 e0       	ldi	r24, 0x00	; 0
    1684:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>

	USART_Write(xPos >> 8);
    1688:	8d 2d       	mov	r24, r13
    168a:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(xPos & 0x00FF);
    168e:	8b 2d       	mov	r24, r11
    1690:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(yPos >> 8);
    1694:	8a 2d       	mov	r24, r10
    1696:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(yPos & 0x00FF);
    169a:	89 2d       	mov	r24, r9
    169c:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(rAngle >> 8);
    16a0:	88 2d       	mov	r24, r8
    16a2:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(rAngle & 0x00FF);
    16a6:	87 2d       	mov	r24, r7
    16a8:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(width >> 8);
    16ac:	81 2f       	mov	r24, r17
    16ae:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(width & 0x00FF);
    16b2:	80 2f       	mov	r24, r16
    16b4:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(height >> 8);
    16b8:	8f 2d       	mov	r24, r15
    16ba:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(height & 0x00FF);
    16be:	8e 2d       	mov	r24, r14
    16c0:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(depth);
    16c4:	8c 2d       	mov	r24, r12
    16c6:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	
	PORTA = 0xAA;
    16ca:	8a ea       	ldi	r24, 0xAA	; 170
    16cc:	82 b9       	out	0x02, r24	; 2
	xSpriteHandle result = (xSpriteHandle)USART_Read();
    16ce:	0e 94 47 1b 	call	0x368e	; 0x368e <USART_Read>
	PORTA = 0xFF;
    16d2:	9f ef       	ldi	r25, 0xFF	; 255
    16d4:	92 b9       	out	0x02, r25	; 2
	
	return result;
}
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	ff 90       	pop	r15
    16e0:	ef 90       	pop	r14
    16e2:	df 90       	pop	r13
    16e4:	cf 90       	pop	r12
    16e6:	bf 90       	pop	r11
    16e8:	af 90       	pop	r10
    16ea:	9f 90       	pop	r9
    16ec:	8f 90       	pop	r8
    16ee:	7f 90       	pop	r7
    16f0:	08 95       	ret

000016f2 <vSpriteSetPosition>:
*
* param sprite: The handle to the sprite
* param x: New x-position of the sprite's center in window coordinates
* param y: New y-position of the sprite's center in window coordinates
*******************************************************************************/
void vSpriteSetPosition(xSpriteHandle sprite, uint16_t x, uint16_t y) {
    16f2:	ff 92       	push	r15
    16f4:	0f 93       	push	r16
    16f6:	1f 93       	push	r17
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	f8 2e       	mov	r15, r24
    16fe:	16 2f       	mov	r17, r22
    1700:	07 2f       	mov	r16, r23
    1702:	c4 2f       	mov	r28, r20
    1704:	d5 2f       	mov	r29, r21
	USART_Write(SET_POS);
    1706:	82 e0       	ldi	r24, 0x02	; 2
    1708:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    170c:	8f 2d       	mov	r24, r15
    170e:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(x >> 8);
    1712:	80 2f       	mov	r24, r16
    1714:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(x & 0x00FF);
    1718:	81 2f       	mov	r24, r17
    171a:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(y >> 8);
    171e:	8d 2f       	mov	r24, r29
    1720:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(y & 0x00FF);
    1724:	8c 2f       	mov	r24, r28
    1726:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    172a:	df 91       	pop	r29
    172c:	cf 91       	pop	r28
    172e:	1f 91       	pop	r17
    1730:	0f 91       	pop	r16
    1732:	ff 90       	pop	r15
    1734:	08 95       	ret

00001736 <vSpriteSetRotation>:
* Description: Sets the given sprite's rotation.
*
* param sprite: The handle to the sprite
* param angle: Angle in degrees to rotate the sprite CCW about its center
*******************************************************************************/
void vSpriteSetRotation(xSpriteHandle sprite, uint16_t angle) {
    1736:	1f 93       	push	r17
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
    173c:	18 2f       	mov	r17, r24
    173e:	c6 2f       	mov	r28, r22
    1740:	d7 2f       	mov	r29, r23
	USART_Write(SET_ROT);
    1742:	83 e0       	ldi	r24, 0x03	; 3
    1744:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    1748:	81 2f       	mov	r24, r17
    174a:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(angle >> 8);
    174e:	8d 2f       	mov	r24, r29
    1750:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(angle & 0x00FF);
    1754:	8c 2f       	mov	r24, r28
    1756:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	1f 91       	pop	r17
    1760:	08 95       	ret

00001762 <vSpriteSetSize>:
*
* param sprite: The handle to the sprite
* param width: New width of the sprite in pixels before applying rotation
* param height: New height of the sprite in pixels before applying rotation
*******************************************************************************/
void vSpriteSetSize(xSpriteHandle sprite, uint16_t width, uint16_t height) {
    1762:	ff 92       	push	r15
    1764:	0f 93       	push	r16
    1766:	1f 93       	push	r17
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	f8 2e       	mov	r15, r24
    176e:	16 2f       	mov	r17, r22
    1770:	07 2f       	mov	r16, r23
    1772:	c4 2f       	mov	r28, r20
    1774:	d5 2f       	mov	r29, r21
	USART_Write(SET_SIZE);
    1776:	8d e0       	ldi	r24, 0x0D	; 13
    1778:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    177c:	8f 2d       	mov	r24, r15
    177e:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(width >> 8);
    1782:	80 2f       	mov	r24, r16
    1784:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(width & 0x00FF);
    1788:	81 2f       	mov	r24, r17
    178a:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(height >> 8);
    178e:	8d 2f       	mov	r24, r29
    1790:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(height & 0x00FF);
    1794:	8c 2f       	mov	r24, r28
    1796:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    179a:	df 91       	pop	r29
    179c:	cf 91       	pop	r28
    179e:	1f 91       	pop	r17
    17a0:	0f 91       	pop	r16
    17a2:	ff 90       	pop	r15
    17a4:	08 95       	ret

000017a6 <vSpriteSetDepth>:
* Description: Sets the draw depth of the given sprite.
*
* param sprite: The handle to the sprite
* param depth: New draw depth (larger depths are in front of smaller depths)
*******************************************************************************/
void vSpriteSetDepth(xSpriteHandle sprite, uint8_t depth) {
    17a6:	cf 93       	push	r28
    17a8:	df 93       	push	r29
    17aa:	d8 2f       	mov	r29, r24
    17ac:	c6 2f       	mov	r28, r22
	USART_Write(SET_ORDER);
    17ae:	8c e0       	ldi	r24, 0x0C	; 12
    17b0:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    17b4:	8d 2f       	mov	r24, r29
    17b6:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(depth);
    17ba:	8c 2f       	mov	r24, r28
    17bc:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    17c0:	df 91       	pop	r29
    17c2:	cf 91       	pop	r28
    17c4:	08 95       	ret

000017c6 <vSpriteDelete>:
* Description: Removes the sprite from the window and invalidates the given
*  handle.
*
* param sprite: The handle to the sprite to be deleted
*******************************************************************************/
void vSpriteDelete(xSpriteHandle sprite) {
    17c6:	cf 93       	push	r28
    17c8:	c8 2f       	mov	r28, r24
	USART_Write(DELETE_SPRITE);
    17ca:	84 e0       	ldi	r24, 0x04	; 4
    17cc:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    17d0:	8c 2f       	mov	r24, r28
    17d2:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    17d6:	cf 91       	pop	r28
    17d8:	08 95       	ret

000017da <xGroupCreate>:
*  collision tests (see bCollide).
*
* return: A valid handle to the new group on success; ERROR_HANDLE otherwise
*******************************************************************************/
xGroupHandle xGroupCreate(void) {
	USART_Write(CREATE_GROUP);
    17da:	85 e0       	ldi	r24, 0x05	; 5
    17dc:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	xGroupHandle result = (xGroupHandle)USART_Read();
    17e0:	0e 94 47 1b 	call	0x368e	; 0x368e <USART_Read>
	
	return result;
}
    17e4:	08 95       	ret

000017e6 <vGroupAddSprite>:
* Description: Adds the given sprite to the given group.
*
* param group: The handle to the group to add the sprite to
* param sprite: The handle to the sprite to add to the group
*******************************************************************************/
void vGroupAddSprite(xGroupHandle group, xSpriteHandle sprite) {
    17e6:	cf 93       	push	r28
    17e8:	df 93       	push	r29
    17ea:	d8 2f       	mov	r29, r24
    17ec:	c6 2f       	mov	r28, r22
	USART_Write(ADD_TO_GROUP);
    17ee:	86 e0       	ldi	r24, 0x06	; 6
    17f0:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(group);
    17f4:	8d 2f       	mov	r24, r29
    17f6:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    17fa:	8c 2f       	mov	r24, r28
    17fc:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    1800:	df 91       	pop	r29
    1802:	cf 91       	pop	r28
    1804:	08 95       	ret

00001806 <vGroupRemoveSprite>:
* Description: Removes the given sprite from the given group.
*
* param group: The handle to the group to remove the sprite from
* param sprite: The handle to the sprite to remove from the group
*******************************************************************************/
void vGroupRemoveSprite(xGroupHandle group, xSpriteHandle sprite) {
    1806:	cf 93       	push	r28
    1808:	df 93       	push	r29
    180a:	d8 2f       	mov	r29, r24
    180c:	c6 2f       	mov	r28, r22
	USART_Write(REMOVE_FROM_GROUP);
    180e:	87 e0       	ldi	r24, 0x07	; 7
    1810:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(group);
    1814:	8d 2f       	mov	r24, r29
    1816:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    181a:	8c 2f       	mov	r24, r28
    181c:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	08 95       	ret

00001826 <vGroupDelete>:
* Description: Invalidates the given group handle and removes all the sprites
*  it contains from it.
*
* param group: The handle to the group to be deleted
*******************************************************************************/
void vGroupDelete(xGroupHandle group) {
    1826:	cf 93       	push	r28
    1828:	c8 2f       	mov	r28, r24
	USART_Write(DELETE_GROUP);
    182a:	88 e0       	ldi	r24, 0x08	; 8
    182c:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(group);
    1830:	8c 2f       	mov	r24, r28
    1832:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
}
    1836:	cf 91       	pop	r28
    1838:	08 95       	ret

0000183a <uCollide>:
*  sprite collided with
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
    183a:	ff 92       	push	r15
    183c:	0f 93       	push	r16
    183e:	1f 93       	push	r17
    1840:	cf 93       	push	r28
    1842:	df 93       	push	r29
    1844:	d8 2f       	mov	r29, r24
    1846:	c6 2f       	mov	r28, r22
    1848:	04 2f       	mov	r16, r20
    184a:	f5 2e       	mov	r15, r21
    184c:	12 2f       	mov	r17, r18
	uint8_t hitCount = 0;
	
	USART_Write(COLLIDE);
    184e:	89 e0       	ldi	r24, 0x09	; 9
    1850:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(sprite);
    1854:	8d 2f       	mov	r24, r29
    1856:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	USART_Write(group);
    185a:	8c 2f       	mov	r24, r28
    185c:	0e 94 37 1b 	call	0x366e	; 0x366e <USART_Write>
	
	while (hitCount < hitsSize) {
    1860:	11 23       	and	r17, r17
    1862:	61 f0       	breq	.+24     	; 0x187c <uCollide+0x42>
    1864:	c0 2f       	mov	r28, r16
    1866:	df 2d       	mov	r29, r15
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
	uint8_t hitCount = 0;
    1868:	00 e0       	ldi	r16, 0x00	; 0
	USART_Write(COLLIDE);
	USART_Write(sprite);
	USART_Write(group);
	
	while (hitCount < hitsSize) {
		hits[hitCount] = USART_Read();
    186a:	0e 94 47 1b 	call	0x368e	; 0x368e <USART_Read>
    186e:	89 93       	st	Y+, r24
		if (hits[hitCount] == ERROR_HANDLE) {
    1870:	8f 3f       	cpi	r24, 0xFF	; 255
    1872:	59 f0       	breq	.+22     	; 0x188a <uCollide+0x50>
			return hitCount;
		}
		hitCount++;
    1874:	0f 5f       	subi	r16, 0xFF	; 255
	
	USART_Write(COLLIDE);
	USART_Write(sprite);
	USART_Write(group);
	
	while (hitCount < hitsSize) {
    1876:	01 17       	cp	r16, r17
    1878:	c1 f7       	brne	.-16     	; 0x186a <uCollide+0x30>
    187a:	03 c0       	rjmp	.+6      	; 0x1882 <uCollide+0x48>
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
	uint8_t hitCount = 0;
    187c:	00 e0       	ldi	r16, 0x00	; 0
    187e:	01 c0       	rjmp	.+2      	; 0x1882 <uCollide+0x48>
		}
		hitCount++;
	}
	
	while (USART_Read() != ERROR_HANDLE)
	    hitCount++;
    1880:	0f 5f       	subi	r16, 0xFF	; 255
			return hitCount;
		}
		hitCount++;
	}
	
	while (USART_Read() != ERROR_HANDLE)
    1882:	0e 94 47 1b 	call	0x368e	; 0x368e <USART_Read>
    1886:	8f 3f       	cpi	r24, 0xFF	; 255
    1888:	d9 f7       	brne	.-10     	; 0x1880 <uCollide+0x46>
	    hitCount++;
		
	return hitCount;
    188a:	80 2f       	mov	r24, r16
    188c:	df 91       	pop	r29
    188e:	cf 91       	pop	r28
    1890:	1f 91       	pop	r17
    1892:	0f 91       	pop	r16
    1894:	ff 90       	pop	r15
    1896:	08 95       	ret

00001898 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    18a2:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    18a6:	80 91 8b 02 	lds	r24, 0x028B
    18aa:	88 23       	and	r24, r24
    18ac:	f9 f4       	brne	.+62     	; 0x18ec <pvPortMalloc+0x54>
		{
			prvHeapInit();
    18ae:	80 e9       	ldi	r24, 0x90	; 144
    18b0:	92 e0       	ldi	r25, 0x02	; 2
    18b2:	90 93 8d 02 	sts	0x028D, r25
    18b6:	80 93 8c 02 	sts	0x028C, r24
    18ba:	10 92 8f 02 	sts	0x028F, r1
    18be:	10 92 8e 02 	sts	0x028E, r1
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	98 e1       	ldi	r25, 0x18	; 24
    18c6:	90 93 93 1a 	sts	0x1A93, r25
    18ca:	80 93 92 1a 	sts	0x1A92, r24
    18ce:	e2 e9       	ldi	r30, 0x92	; 146
    18d0:	fa e1       	ldi	r31, 0x1A	; 26
    18d2:	12 92       	st	-Z, r1
    18d4:	12 92       	st	-Z, r1
    18d6:	90 93 93 02 	sts	0x0293, r25
    18da:	80 93 92 02 	sts	0x0292, r24
    18de:	f0 93 91 02 	sts	0x0291, r31
    18e2:	e0 93 90 02 	sts	0x0290, r30
			xHeapHasBeenInitialised = pdTRUE;
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	80 93 8b 02 	sts	0x028B, r24
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    18ec:	20 97       	sbiw	r28, 0x00	; 0
    18ee:	09 f4       	brne	.+2      	; 0x18f2 <pvPortMalloc+0x5a>
    18f0:	62 c0       	rjmp	.+196    	; 0x19b6 <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    18f2:	9e 01       	movw	r18, r28
    18f4:	2b 5f       	subi	r18, 0xFB	; 251
    18f6:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    18f8:	24 96       	adiw	r28, 0x04	; 4
    18fa:	87 e1       	ldi	r24, 0x17	; 23
    18fc:	cf 3f       	cpi	r28, 0xFF	; 255
    18fe:	d8 07       	cpc	r29, r24
    1900:	08 f0       	brcs	.+2      	; 0x1904 <pvPortMalloc+0x6c>
    1902:	5c c0       	rjmp	.+184    	; 0x19bc <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1904:	e0 91 8c 02 	lds	r30, 0x028C
    1908:	f0 91 8d 02 	lds	r31, 0x028D

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    190c:	ac e8       	ldi	r26, 0x8C	; 140
    190e:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1910:	02 c0       	rjmp	.+4      	; 0x1916 <pvPortMalloc+0x7e>
    1912:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1914:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1916:	82 81       	ldd	r24, Z+2	; 0x02
    1918:	93 81       	ldd	r25, Z+3	; 0x03
    191a:	82 17       	cp	r24, r18
    191c:	93 07       	cpc	r25, r19
    191e:	20 f4       	brcc	.+8      	; 0x1928 <pvPortMalloc+0x90>
    1920:	80 81       	ld	r24, Z
    1922:	91 81       	ldd	r25, Z+1	; 0x01
    1924:	00 97       	sbiw	r24, 0x00	; 0
    1926:	a9 f7       	brne	.-22     	; 0x1912 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1928:	ca e1       	ldi	r28, 0x1A	; 26
    192a:	e0 39       	cpi	r30, 0x90	; 144
    192c:	fc 07       	cpc	r31, r28
    192e:	09 f4       	brne	.+2      	; 0x1932 <pvPortMalloc+0x9a>
    1930:	48 c0       	rjmp	.+144    	; 0x19c2 <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1932:	8d 91       	ld	r24, X+
    1934:	9c 91       	ld	r25, X
    1936:	11 97       	sbiw	r26, 0x01	; 1
    1938:	8c 01       	movw	r16, r24
    193a:	0b 5f       	subi	r16, 0xFB	; 251
    193c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    193e:	80 81       	ld	r24, Z
    1940:	91 81       	ldd	r25, Z+1	; 0x01
    1942:	11 96       	adiw	r26, 0x01	; 1
    1944:	9c 93       	st	X, r25
    1946:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1948:	82 81       	ldd	r24, Z+2	; 0x02
    194a:	93 81       	ldd	r25, Z+3	; 0x03
    194c:	82 1b       	sub	r24, r18
    194e:	93 0b       	sbc	r25, r19
    1950:	8b 30       	cpi	r24, 0x0B	; 11
    1952:	91 05       	cpc	r25, r1
    1954:	18 f1       	brcs	.+70     	; 0x199c <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1956:	af 01       	movw	r20, r30
    1958:	42 0f       	add	r20, r18
    195a:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    195c:	da 01       	movw	r26, r20
    195e:	13 96       	adiw	r26, 0x03	; 3
    1960:	9c 93       	st	X, r25
    1962:	8e 93       	st	-X, r24
    1964:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
    1966:	33 83       	std	Z+3, r19	; 0x03
    1968:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    196a:	12 96       	adiw	r26, 0x02	; 2
    196c:	2d 91       	ld	r18, X+
    196e:	3c 91       	ld	r19, X
    1970:	13 97       	sbiw	r26, 0x03	; 3
    1972:	6c e8       	ldi	r22, 0x8C	; 140
    1974:	72 e0       	ldi	r23, 0x02	; 2
    1976:	01 c0       	rjmp	.+2      	; 0x197a <pvPortMalloc+0xe2>
    1978:	bd 01       	movw	r22, r26
    197a:	eb 01       	movw	r28, r22
    197c:	a8 81       	ld	r26, Y
    197e:	b9 81       	ldd	r27, Y+1	; 0x01
    1980:	12 96       	adiw	r26, 0x02	; 2
    1982:	8d 91       	ld	r24, X+
    1984:	9c 91       	ld	r25, X
    1986:	13 97       	sbiw	r26, 0x03	; 3
    1988:	82 17       	cp	r24, r18
    198a:	93 07       	cpc	r25, r19
    198c:	a8 f3       	brcs	.-22     	; 0x1978 <pvPortMalloc+0xe0>
    198e:	ea 01       	movw	r28, r20
    1990:	b9 83       	std	Y+1, r27	; 0x01
    1992:	a8 83       	st	Y, r26
    1994:	db 01       	movw	r26, r22
    1996:	11 96       	adiw	r26, 0x01	; 1
    1998:	5c 93       	st	X, r21
    199a:	4e 93       	st	-X, r20
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    199c:	80 91 52 02 	lds	r24, 0x0252
    19a0:	90 91 53 02 	lds	r25, 0x0253
    19a4:	22 81       	ldd	r18, Z+2	; 0x02
    19a6:	33 81       	ldd	r19, Z+3	; 0x03
    19a8:	82 1b       	sub	r24, r18
    19aa:	93 0b       	sbc	r25, r19
    19ac:	90 93 53 02 	sts	0x0253, r25
    19b0:	80 93 52 02 	sts	0x0252, r24
    19b4:	08 c0       	rjmp	.+16     	; 0x19c6 <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    19b6:	00 e0       	ldi	r16, 0x00	; 0
    19b8:	10 e0       	ldi	r17, 0x00	; 0
    19ba:	05 c0       	rjmp	.+10     	; 0x19c6 <pvPortMalloc+0x12e>
    19bc:	00 e0       	ldi	r16, 0x00	; 0
    19be:	10 e0       	ldi	r17, 0x00	; 0
    19c0:	02 c0       	rjmp	.+4      	; 0x19c6 <pvPortMalloc+0x12e>
    19c2:	00 e0       	ldi	r16, 0x00	; 0
    19c4:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    19c6:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    19ca:	80 2f       	mov	r24, r16
    19cc:	91 2f       	mov	r25, r17
    19ce:	df 91       	pop	r29
    19d0:	cf 91       	pop	r28
    19d2:	1f 91       	pop	r17
    19d4:	0f 91       	pop	r16
    19d6:	08 95       	ret

000019d8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    19d8:	0f 93       	push	r16
    19da:	1f 93       	push	r17
    19dc:	cf 93       	push	r28
    19de:	df 93       	push	r29
    19e0:	ec 01       	movw	r28, r24
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    19e2:	00 97       	sbiw	r24, 0x00	; 0
    19e4:	39 f1       	breq	.+78     	; 0x1a34 <vPortFree+0x5c>
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
    19e6:	8c 01       	movw	r16, r24
    19e8:	05 50       	subi	r16, 0x05	; 5
    19ea:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
    19ec:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    19f0:	f8 01       	movw	r30, r16
    19f2:	22 81       	ldd	r18, Z+2	; 0x02
    19f4:	33 81       	ldd	r19, Z+3	; 0x03
    19f6:	ac e8       	ldi	r26, 0x8C	; 140
    19f8:	b2 e0       	ldi	r27, 0x02	; 2
    19fa:	01 c0       	rjmp	.+2      	; 0x19fe <vPortFree+0x26>
    19fc:	df 01       	movw	r26, r30
    19fe:	ed 91       	ld	r30, X+
    1a00:	fc 91       	ld	r31, X
    1a02:	11 97       	sbiw	r26, 0x01	; 1
    1a04:	82 81       	ldd	r24, Z+2	; 0x02
    1a06:	93 81       	ldd	r25, Z+3	; 0x03
    1a08:	82 17       	cp	r24, r18
    1a0a:	93 07       	cpc	r25, r19
    1a0c:	b8 f3       	brcs	.-18     	; 0x19fc <vPortFree+0x24>
    1a0e:	25 97       	sbiw	r28, 0x05	; 5
    1a10:	f9 83       	std	Y+1, r31	; 0x01
    1a12:	e8 83       	st	Y, r30
    1a14:	0d 93       	st	X+, r16
    1a16:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1a18:	80 91 52 02 	lds	r24, 0x0252
    1a1c:	90 91 53 02 	lds	r25, 0x0253
    1a20:	2a 81       	ldd	r18, Y+2	; 0x02
    1a22:	3b 81       	ldd	r19, Y+3	; 0x03
    1a24:	82 0f       	add	r24, r18
    1a26:	93 1f       	adc	r25, r19
    1a28:	90 93 53 02 	sts	0x0253, r25
    1a2c:	80 93 52 02 	sts	0x0252, r24
		}
		xTaskResumeAll();
    1a30:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
	}
}
    1a34:	df 91       	pop	r29
    1a36:	cf 91       	pop	r28
    1a38:	1f 91       	pop	r17
    1a3a:	0f 91       	pop	r16
    1a3c:	08 95       	ret

00001a3e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1a3e:	80 91 52 02 	lds	r24, 0x0252
    1a42:	90 91 53 02 	lds	r25, 0x0253
    1a46:	08 95       	ret

00001a48 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
    1a48:	08 95       	ret

00001a4a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1a4a:	af 92       	push	r10
    1a4c:	bf 92       	push	r11
    1a4e:	cf 92       	push	r12
    1a50:	df 92       	push	r13
    1a52:	ef 92       	push	r14
    1a54:	ff 92       	push	r15
    1a56:	0f 93       	push	r16
    1a58:	1f 93       	push	r17
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
    1a5e:	6c 01       	movw	r12, r24
    1a60:	e6 2e       	mov	r14, r22
    1a62:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1a64:	8a e1       	ldi	r24, 0x1A	; 26
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
    1a6c:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
    1a6e:	00 97       	sbiw	r24, 0x00	; 0
    1a70:	09 f4       	brne	.+2      	; 0x1a74 <xCoRoutineCreate+0x2a>
    1a72:	62 c0       	rjmp	.+196    	; 0x1b38 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1a74:	80 91 94 1a 	lds	r24, 0x1A94
    1a78:	90 91 95 1a 	lds	r25, 0x1A95
    1a7c:	00 97       	sbiw	r24, 0x00	; 0
    1a7e:	39 f5       	brne	.+78     	; 0x1ace <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1a80:	10 93 95 1a 	sts	0x1A95, r17
    1a84:	00 93 94 1a 	sts	0x1A94, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1a88:	c7 e9       	ldi	r28, 0x97	; 151
    1a8a:	da e1       	ldi	r29, 0x1A	; 26
    1a8c:	ce 01       	movw	r24, r28
    1a8e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
    1a92:	ce 01       	movw	r24, r28
    1a94:	09 96       	adiw	r24, 0x09	; 9
    1a96:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1a9a:	c9 ea       	ldi	r28, 0xA9	; 169
    1a9c:	da e1       	ldi	r29, 0x1A	; 26
    1a9e:	ce 01       	movw	r24, r28
    1aa0:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1aa4:	0f 2e       	mov	r0, r31
    1aa6:	f2 eb       	ldi	r31, 0xB2	; 178
    1aa8:	af 2e       	mov	r10, r31
    1aaa:	fa e1       	ldi	r31, 0x1A	; 26
    1aac:	bf 2e       	mov	r11, r31
    1aae:	f0 2d       	mov	r31, r0
    1ab0:	c5 01       	movw	r24, r10
    1ab2:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1ab6:	8b eb       	ldi	r24, 0xBB	; 187
    1ab8:	9a e1       	ldi	r25, 0x1A	; 26
    1aba:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1abe:	d0 93 c5 1a 	sts	0x1AC5, r29
    1ac2:	c0 93 c4 1a 	sts	0x1AC4, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1ac6:	b0 92 c7 1a 	sts	0x1AC7, r11
    1aca:	a0 92 c6 1a 	sts	0x1AC6, r10
    1ace:	ce 2d       	mov	r28, r14
    1ad0:	e1 10       	cpse	r14, r1
    1ad2:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1ad4:	f8 01       	movw	r30, r16
    1ad6:	11 8e       	std	Z+25, r1	; 0x19
    1ad8:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1ada:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1adc:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1ade:	c1 92       	st	Z+, r12
    1ae0:	d1 92       	st	Z+, r13
    1ae2:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1ae4:	cf 01       	movw	r24, r30
    1ae6:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1aea:	c8 01       	movw	r24, r16
    1aec:	0c 96       	adiw	r24, 0x0c	; 12
    1aee:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1af2:	f8 01       	movw	r30, r16
    1af4:	11 87       	std	Z+9, r17	; 0x09
    1af6:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1af8:	13 8b       	std	Z+19, r17	; 0x13
    1afa:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1afc:	84 e0       	ldi	r24, 0x04	; 4
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	8c 1b       	sub	r24, r28
    1b02:	91 09       	sbc	r25, r1
    1b04:	95 87       	std	Z+13, r25	; 0x0d
    1b06:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1b08:	86 89       	ldd	r24, Z+22	; 0x16
    1b0a:	90 91 96 1a 	lds	r25, 0x1A96
    1b0e:	98 17       	cp	r25, r24
    1b10:	10 f4       	brcc	.+4      	; 0x1b16 <xCoRoutineCreate+0xcc>
    1b12:	80 93 96 1a 	sts	0x1A96, r24
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	9c 01       	movw	r18, r24
    1b1a:	22 0f       	add	r18, r18
    1b1c:	33 1f       	adc	r19, r19
    1b1e:	22 0f       	add	r18, r18
    1b20:	33 1f       	adc	r19, r19
    1b22:	22 0f       	add	r18, r18
    1b24:	33 1f       	adc	r19, r19
    1b26:	82 0f       	add	r24, r18
    1b28:	93 1f       	adc	r25, r19
    1b2a:	89 56       	subi	r24, 0x69	; 105
    1b2c:	95 4e       	sbci	r25, 0xE5	; 229
    1b2e:	b7 01       	movw	r22, r14
    1b30:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>

		xReturn = pdPASS;
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	01 c0       	rjmp	.+2      	; 0x1b3a <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b38:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    1b3a:	df 91       	pop	r29
    1b3c:	cf 91       	pop	r28
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	ff 90       	pop	r15
    1b44:	ef 90       	pop	r14
    1b46:	df 90       	pop	r13
    1b48:	cf 90       	pop	r12
    1b4a:	bf 90       	pop	r11
    1b4c:	af 90       	pop	r10
    1b4e:	08 95       	ret

00001b50 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1b50:	0f 93       	push	r16
    1b52:	1f 93       	push	r17
    1b54:	cf 93       	push	r28
    1b56:	df 93       	push	r29
    1b58:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1b5a:	c0 91 c8 1a 	lds	r28, 0x1AC8
    1b5e:	d0 91 c9 1a 	lds	r29, 0x1AC9
    1b62:	c8 0f       	add	r28, r24
    1b64:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1b66:	80 91 94 1a 	lds	r24, 0x1A94
    1b6a:	90 91 95 1a 	lds	r25, 0x1A95
    1b6e:	02 96       	adiw	r24, 0x02	; 2
    1b70:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1b74:	e0 91 94 1a 	lds	r30, 0x1A94
    1b78:	f0 91 95 1a 	lds	r31, 0x1A95
    1b7c:	d3 83       	std	Z+3, r29	; 0x03
    1b7e:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1b80:	80 91 c8 1a 	lds	r24, 0x1AC8
    1b84:	90 91 c9 1a 	lds	r25, 0x1AC9
    1b88:	c8 17       	cp	r28, r24
    1b8a:	d9 07       	cpc	r29, r25
    1b8c:	50 f4       	brcc	.+20     	; 0x1ba2 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1b8e:	bf 01       	movw	r22, r30
    1b90:	6e 5f       	subi	r22, 0xFE	; 254
    1b92:	7f 4f       	sbci	r23, 0xFF	; 255
    1b94:	80 91 c6 1a 	lds	r24, 0x1AC6
    1b98:	90 91 c7 1a 	lds	r25, 0x1AC7
    1b9c:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsert>
    1ba0:	09 c0       	rjmp	.+18     	; 0x1bb4 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ba2:	bf 01       	movw	r22, r30
    1ba4:	6e 5f       	subi	r22, 0xFE	; 254
    1ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba8:	80 91 c4 1a 	lds	r24, 0x1AC4
    1bac:	90 91 c5 1a 	lds	r25, 0x1AC5
    1bb0:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsert>
	}

	if( pxEventList )
    1bb4:	01 15       	cp	r16, r1
    1bb6:	11 05       	cpc	r17, r1
    1bb8:	49 f0       	breq	.+18     	; 0x1bcc <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1bba:	60 91 94 1a 	lds	r22, 0x1A94
    1bbe:	70 91 95 1a 	lds	r23, 0x1A95
    1bc2:	64 5f       	subi	r22, 0xF4	; 244
    1bc4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bc6:	c8 01       	movw	r24, r16
    1bc8:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsert>
	}
}
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
    1bd0:	1f 91       	pop	r17
    1bd2:	0f 91       	pop	r16
    1bd4:	08 95       	ret

00001bd6 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1bd6:	cf 92       	push	r12
    1bd8:	df 92       	push	r13
    1bda:	ef 92       	push	r14
    1bdc:	ff 92       	push	r15
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1be6:	80 91 bb 1a 	lds	r24, 0x1ABB
    1bea:	88 23       	and	r24, r24
    1bec:	b9 f1       	breq	.+110    	; 0x1c5c <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1bee:	0f 2e       	mov	r0, r31
    1bf0:	f0 ec       	ldi	r31, 0xC0	; 192
    1bf2:	ef 2e       	mov	r14, r31
    1bf4:	fa e1       	ldi	r31, 0x1A	; 26
    1bf6:	ff 2e       	mov	r15, r31
    1bf8:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1bfa:	0f 2e       	mov	r0, r31
    1bfc:	fb eb       	ldi	r31, 0xBB	; 187
    1bfe:	cf 2e       	mov	r12, r31
    1c00:	fa e1       	ldi	r31, 0x1A	; 26
    1c02:	df 2e       	mov	r13, r31
    1c04:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1c06:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1c08:	d7 01       	movw	r26, r14
    1c0a:	ed 91       	ld	r30, X+
    1c0c:	fc 91       	ld	r31, X
    1c0e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c10:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1c12:	ce 01       	movw	r24, r28
    1c14:	0c 96       	adiw	r24, 0x0c	; 12
    1c16:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1c1a:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1c1c:	8e 01       	movw	r16, r28
    1c1e:	0e 5f       	subi	r16, 0xFE	; 254
    1c20:	1f 4f       	sbci	r17, 0xFF	; 255
    1c22:	c8 01       	movw	r24, r16
    1c24:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1c28:	8e 89       	ldd	r24, Y+22	; 0x16
    1c2a:	90 91 96 1a 	lds	r25, 0x1A96
    1c2e:	98 17       	cp	r25, r24
    1c30:	10 f4       	brcc	.+4      	; 0x1c36 <vCoRoutineSchedule+0x60>
    1c32:	80 93 96 1a 	sts	0x1A96, r24
    1c36:	90 e0       	ldi	r25, 0x00	; 0
    1c38:	9c 01       	movw	r18, r24
    1c3a:	22 0f       	add	r18, r18
    1c3c:	33 1f       	adc	r19, r19
    1c3e:	22 0f       	add	r18, r18
    1c40:	33 1f       	adc	r19, r19
    1c42:	22 0f       	add	r18, r18
    1c44:	33 1f       	adc	r19, r19
    1c46:	82 0f       	add	r24, r18
    1c48:	93 1f       	adc	r25, r19
    1c4a:	89 56       	subi	r24, 0x69	; 105
    1c4c:	95 4e       	sbci	r25, 0xE5	; 229
    1c4e:	b8 01       	movw	r22, r16
    1c50:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1c54:	f6 01       	movw	r30, r12
    1c56:	80 81       	ld	r24, Z
    1c58:	88 23       	and	r24, r24
    1c5a:	a9 f6       	brne	.-86     	; 0x1c06 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1c5c:	0e 94 18 17 	call	0x2e30	; 0x2e30 <xTaskGetTickCount>
    1c60:	20 91 ca 1a 	lds	r18, 0x1ACA
    1c64:	30 91 cb 1a 	lds	r19, 0x1ACB
    1c68:	82 1b       	sub	r24, r18
    1c6a:	93 0b       	sbc	r25, r19
    1c6c:	90 93 cd 1a 	sts	0x1ACD, r25
    1c70:	80 93 cc 1a 	sts	0x1ACC, r24
    1c74:	74 c0       	rjmp	.+232    	; 0x1d5e <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1c76:	20 91 c8 1a 	lds	r18, 0x1AC8
    1c7a:	30 91 c9 1a 	lds	r19, 0x1AC9
    1c7e:	2f 5f       	subi	r18, 0xFF	; 255
    1c80:	3f 4f       	sbci	r19, 0xFF	; 255
    1c82:	30 93 c9 1a 	sts	0x1AC9, r19
    1c86:	20 93 c8 1a 	sts	0x1AC8, r18
		xPassedTicks--;
    1c8a:	01 97       	sbiw	r24, 0x01	; 1
    1c8c:	90 93 cd 1a 	sts	0x1ACD, r25
    1c90:	80 93 cc 1a 	sts	0x1ACC, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1c94:	21 15       	cp	r18, r1
    1c96:	31 05       	cpc	r19, r1
    1c98:	81 f4       	brne	.+32     	; 0x1cba <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1c9a:	80 91 c4 1a 	lds	r24, 0x1AC4
    1c9e:	90 91 c5 1a 	lds	r25, 0x1AC5
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1ca2:	20 91 c6 1a 	lds	r18, 0x1AC6
    1ca6:	30 91 c7 1a 	lds	r19, 0x1AC7
    1caa:	30 93 c5 1a 	sts	0x1AC5, r19
    1cae:	20 93 c4 1a 	sts	0x1AC4, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    1cb2:	90 93 c7 1a 	sts	0x1AC7, r25
    1cb6:	80 93 c6 1a 	sts	0x1AC6, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1cba:	e0 91 c4 1a 	lds	r30, 0x1AC4
    1cbe:	f0 91 c5 1a 	lds	r31, 0x1AC5
    1cc2:	80 81       	ld	r24, Z
    1cc4:	88 23       	and	r24, r24
    1cc6:	09 f4       	brne	.+2      	; 0x1cca <vCoRoutineSchedule+0xf4>
    1cc8:	4a c0       	rjmp	.+148    	; 0x1d5e <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1cca:	05 80       	ldd	r0, Z+5	; 0x05
    1ccc:	f6 81       	ldd	r31, Z+6	; 0x06
    1cce:	e0 2d       	mov	r30, r0
    1cd0:	c6 81       	ldd	r28, Z+6	; 0x06
    1cd2:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1cd4:	2a 81       	ldd	r18, Y+2	; 0x02
    1cd6:	3b 81       	ldd	r19, Y+3	; 0x03
    1cd8:	80 91 c8 1a 	lds	r24, 0x1AC8
    1cdc:	90 91 c9 1a 	lds	r25, 0x1AC9
    1ce0:	82 17       	cp	r24, r18
    1ce2:	93 07       	cpc	r25, r19
    1ce4:	78 f4       	brcc	.+30     	; 0x1d04 <vCoRoutineSchedule+0x12e>
    1ce6:	3b c0       	rjmp	.+118    	; 0x1d5e <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1ce8:	05 80       	ldd	r0, Z+5	; 0x05
    1cea:	f6 81       	ldd	r31, Z+6	; 0x06
    1cec:	e0 2d       	mov	r30, r0
    1cee:	c6 81       	ldd	r28, Z+6	; 0x06
    1cf0:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1cf2:	2a 81       	ldd	r18, Y+2	; 0x02
    1cf4:	3b 81       	ldd	r19, Y+3	; 0x03
    1cf6:	80 91 c8 1a 	lds	r24, 0x1AC8
    1cfa:	90 91 c9 1a 	lds	r25, 0x1AC9
    1cfe:	82 17       	cp	r24, r18
    1d00:	93 07       	cpc	r25, r19
    1d02:	68 f1       	brcs	.+90     	; 0x1d5e <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1d04:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    1d06:	8e 01       	movw	r16, r28
    1d08:	0e 5f       	subi	r16, 0xFE	; 254
    1d0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0c:	c8 01       	movw	r24, r16
    1d0e:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1d12:	8c 89       	ldd	r24, Y+20	; 0x14
    1d14:	9d 89       	ldd	r25, Y+21	; 0x15
    1d16:	00 97       	sbiw	r24, 0x00	; 0
    1d18:	21 f0       	breq	.+8      	; 0x1d22 <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	0c 96       	adiw	r24, 0x0c	; 12
    1d1e:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1d22:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1d24:	8e 89       	ldd	r24, Y+22	; 0x16
    1d26:	90 91 96 1a 	lds	r25, 0x1A96
    1d2a:	98 17       	cp	r25, r24
    1d2c:	10 f4       	brcc	.+4      	; 0x1d32 <vCoRoutineSchedule+0x15c>
    1d2e:	80 93 96 1a 	sts	0x1A96, r24
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	9c 01       	movw	r18, r24
    1d36:	22 0f       	add	r18, r18
    1d38:	33 1f       	adc	r19, r19
    1d3a:	22 0f       	add	r18, r18
    1d3c:	33 1f       	adc	r19, r19
    1d3e:	22 0f       	add	r18, r18
    1d40:	33 1f       	adc	r19, r19
    1d42:	82 0f       	add	r24, r18
    1d44:	93 1f       	adc	r25, r19
    1d46:	89 56       	subi	r24, 0x69	; 105
    1d48:	95 4e       	sbci	r25, 0xE5	; 229
    1d4a:	b8 01       	movw	r22, r16
    1d4c:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1d50:	e0 91 c4 1a 	lds	r30, 0x1AC4
    1d54:	f0 91 c5 1a 	lds	r31, 0x1AC5
    1d58:	80 81       	ld	r24, Z
    1d5a:	88 23       	and	r24, r24
    1d5c:	29 f6       	brne	.-118    	; 0x1ce8 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1d5e:	80 91 cc 1a 	lds	r24, 0x1ACC
    1d62:	90 91 cd 1a 	lds	r25, 0x1ACD
    1d66:	00 97       	sbiw	r24, 0x00	; 0
    1d68:	09 f0       	breq	.+2      	; 0x1d6c <vCoRoutineSchedule+0x196>
    1d6a:	85 cf       	rjmp	.-246    	; 0x1c76 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1d6c:	80 91 c8 1a 	lds	r24, 0x1AC8
    1d70:	90 91 c9 1a 	lds	r25, 0x1AC9
    1d74:	90 93 cb 1a 	sts	0x1ACB, r25
    1d78:	80 93 ca 1a 	sts	0x1ACA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1d7c:	20 91 96 1a 	lds	r18, 0x1A96
    1d80:	82 2f       	mov	r24, r18
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	fc 01       	movw	r30, r24
    1d86:	ee 0f       	add	r30, r30
    1d88:	ff 1f       	adc	r31, r31
    1d8a:	ee 0f       	add	r30, r30
    1d8c:	ff 1f       	adc	r31, r31
    1d8e:	ee 0f       	add	r30, r30
    1d90:	ff 1f       	adc	r31, r31
    1d92:	e8 0f       	add	r30, r24
    1d94:	f9 1f       	adc	r31, r25
    1d96:	e9 56       	subi	r30, 0x69	; 105
    1d98:	f5 4e       	sbci	r31, 0xE5	; 229
    1d9a:	30 81       	ld	r19, Z
    1d9c:	33 23       	and	r19, r19
    1d9e:	d9 f4       	brne	.+54     	; 0x1dd6 <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1da0:	22 23       	and	r18, r18
    1da2:	31 f4       	brne	.+12     	; 0x1db0 <vCoRoutineSchedule+0x1da>
    1da4:	47 c0       	rjmp	.+142    	; 0x1e34 <vCoRoutineSchedule+0x25e>
    1da6:	22 23       	and	r18, r18
    1da8:	19 f4       	brne	.+6      	; 0x1db0 <vCoRoutineSchedule+0x1da>
    1daa:	20 93 96 1a 	sts	0x1A96, r18
    1dae:	42 c0       	rjmp	.+132    	; 0x1e34 <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1db0:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1db2:	82 2f       	mov	r24, r18
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	fc 01       	movw	r30, r24
    1db8:	ee 0f       	add	r30, r30
    1dba:	ff 1f       	adc	r31, r31
    1dbc:	ee 0f       	add	r30, r30
    1dbe:	ff 1f       	adc	r31, r31
    1dc0:	ee 0f       	add	r30, r30
    1dc2:	ff 1f       	adc	r31, r31
    1dc4:	e8 0f       	add	r30, r24
    1dc6:	f9 1f       	adc	r31, r25
    1dc8:	e9 56       	subi	r30, 0x69	; 105
    1dca:	f5 4e       	sbci	r31, 0xE5	; 229
    1dcc:	30 81       	ld	r19, Z
    1dce:	33 23       	and	r19, r19
    1dd0:	51 f3       	breq	.-44     	; 0x1da6 <vCoRoutineSchedule+0x1d0>
    1dd2:	20 93 96 1a 	sts	0x1A96, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	ee 0f       	add	r30, r30
    1dda:	ff 1f       	adc	r31, r31
    1ddc:	ee 0f       	add	r30, r30
    1dde:	ff 1f       	adc	r31, r31
    1de0:	ee 0f       	add	r30, r30
    1de2:	ff 1f       	adc	r31, r31
    1de4:	8e 0f       	add	r24, r30
    1de6:	9f 1f       	adc	r25, r31
    1de8:	fc 01       	movw	r30, r24
    1dea:	e9 56       	subi	r30, 0x69	; 105
    1dec:	f5 4e       	sbci	r31, 0xE5	; 229
    1dee:	a1 81       	ldd	r26, Z+1	; 0x01
    1df0:	b2 81       	ldd	r27, Z+2	; 0x02
    1df2:	12 96       	adiw	r26, 0x02	; 2
    1df4:	0d 90       	ld	r0, X+
    1df6:	bc 91       	ld	r27, X
    1df8:	a0 2d       	mov	r26, r0
    1dfa:	b2 83       	std	Z+2, r27	; 0x02
    1dfc:	a1 83       	std	Z+1, r26	; 0x01
    1dfe:	cf 01       	movw	r24, r30
    1e00:	03 96       	adiw	r24, 0x03	; 3
    1e02:	a8 17       	cp	r26, r24
    1e04:	b9 07       	cpc	r27, r25
    1e06:	31 f4       	brne	.+12     	; 0x1e14 <vCoRoutineSchedule+0x23e>
    1e08:	12 96       	adiw	r26, 0x02	; 2
    1e0a:	8d 91       	ld	r24, X+
    1e0c:	9c 91       	ld	r25, X
    1e0e:	13 97       	sbiw	r26, 0x03	; 3
    1e10:	92 83       	std	Z+2, r25	; 0x02
    1e12:	81 83       	std	Z+1, r24	; 0x01
    1e14:	01 80       	ldd	r0, Z+1	; 0x01
    1e16:	f2 81       	ldd	r31, Z+2	; 0x02
    1e18:	e0 2d       	mov	r30, r0
    1e1a:	a6 81       	ldd	r26, Z+6	; 0x06
    1e1c:	b7 81       	ldd	r27, Z+7	; 0x07
    1e1e:	b0 93 95 1a 	sts	0x1A95, r27
    1e22:	a0 93 94 1a 	sts	0x1A94, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1e26:	ed 91       	ld	r30, X+
    1e28:	fc 91       	ld	r31, X
    1e2a:	11 97       	sbiw	r26, 0x01	; 1
    1e2c:	cd 01       	movw	r24, r26
    1e2e:	57 96       	adiw	r26, 0x17	; 23
    1e30:	6c 91       	ld	r22, X
    1e32:	19 95       	eicall

	return;
}
    1e34:	df 91       	pop	r29
    1e36:	cf 91       	pop	r28
    1e38:	1f 91       	pop	r17
    1e3a:	0f 91       	pop	r16
    1e3c:	ff 90       	pop	r15
    1e3e:	ef 90       	pop	r14
    1e40:	df 90       	pop	r13
    1e42:	cf 90       	pop	r12
    1e44:	08 95       	ret

00001e46 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1e46:	0f 93       	push	r16
    1e48:	1f 93       	push	r17
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1e4e:	dc 01       	movw	r26, r24
    1e50:	15 96       	adiw	r26, 0x05	; 5
    1e52:	ed 91       	ld	r30, X+
    1e54:	fc 91       	ld	r31, X
    1e56:	16 97       	sbiw	r26, 0x06	; 6
    1e58:	06 81       	ldd	r16, Z+6	; 0x06
    1e5a:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e5c:	e8 01       	movw	r28, r16
    1e5e:	2c 96       	adiw	r28, 0x0c	; 12
    1e60:	ce 01       	movw	r24, r28
    1e62:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1e66:	8b eb       	ldi	r24, 0xBB	; 187
    1e68:	9a e1       	ldi	r25, 0x1A	; 26
    1e6a:	be 01       	movw	r22, r28
    1e6c:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1e70:	e0 91 94 1a 	lds	r30, 0x1A94
    1e74:	f0 91 95 1a 	lds	r31, 0x1A95
	{
		xReturn = pdTRUE;
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	d8 01       	movw	r26, r16
    1e7c:	56 96       	adiw	r26, 0x16	; 22
    1e7e:	2c 91       	ld	r18, X
    1e80:	56 97       	sbiw	r26, 0x16	; 22
    1e82:	96 89       	ldd	r25, Z+22	; 0x16
    1e84:	29 17       	cp	r18, r25
    1e86:	08 f4       	brcc	.+2      	; 0x1e8a <xCoRoutineRemoveFromEventList+0x44>
    1e88:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1e8a:	df 91       	pop	r29
    1e8c:	cf 91       	pop	r28
    1e8e:	1f 91       	pop	r17
    1e90:	0f 91       	pop	r16
    1e92:	08 95       	ret

00001e94 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1e94:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1e96:	03 96       	adiw	r24, 0x03	; 3
    1e98:	92 83       	std	Z+2, r25	; 0x02
    1e9a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1e9c:	2f ef       	ldi	r18, 0xFF	; 255
    1e9e:	3f ef       	ldi	r19, 0xFF	; 255
    1ea0:	34 83       	std	Z+4, r19	; 0x04
    1ea2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1ea4:	96 83       	std	Z+6, r25	; 0x06
    1ea6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1ea8:	90 87       	std	Z+8, r25	; 0x08
    1eaa:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1eac:	10 82       	st	Z, r1
}
    1eae:	08 95       	ret

00001eb0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1eb0:	fc 01       	movw	r30, r24
    1eb2:	11 86       	std	Z+9, r1	; 0x09
    1eb4:	10 86       	std	Z+8, r1	; 0x08
}
    1eb6:	08 95       	ret

00001eb8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1eb8:	cf 93       	push	r28
    1eba:	df 93       	push	r29
    1ebc:	ec 01       	movw	r28, r24
    1ebe:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1ec0:	89 81       	ldd	r24, Y+1	; 0x01
    1ec2:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1ec4:	dc 01       	movw	r26, r24
    1ec6:	12 96       	adiw	r26, 0x02	; 2
    1ec8:	2d 91       	ld	r18, X+
    1eca:	3c 91       	ld	r19, X
    1ecc:	13 97       	sbiw	r26, 0x03	; 3
    1ece:	33 83       	std	Z+3, r19	; 0x03
    1ed0:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1ed2:	29 81       	ldd	r18, Y+1	; 0x01
    1ed4:	3a 81       	ldd	r19, Y+2	; 0x02
    1ed6:	35 83       	std	Z+5, r19	; 0x05
    1ed8:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1eda:	12 96       	adiw	r26, 0x02	; 2
    1edc:	2d 91       	ld	r18, X+
    1ede:	3c 91       	ld	r19, X
    1ee0:	13 97       	sbiw	r26, 0x03	; 3
    1ee2:	d9 01       	movw	r26, r18
    1ee4:	15 96       	adiw	r26, 0x05	; 5
    1ee6:	7c 93       	st	X, r23
    1ee8:	6e 93       	st	-X, r22
    1eea:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1eec:	dc 01       	movw	r26, r24
    1eee:	13 96       	adiw	r26, 0x03	; 3
    1ef0:	7c 93       	st	X, r23
    1ef2:	6e 93       	st	-X, r22
    1ef4:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1ef6:	7a 83       	std	Y+2, r23	; 0x02
    1ef8:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1efa:	d1 87       	std	Z+9, r29	; 0x09
    1efc:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
    1efe:	88 81       	ld	r24, Y
    1f00:	8f 5f       	subi	r24, 0xFF	; 255
    1f02:	88 83       	st	Y, r24
}
    1f04:	df 91       	pop	r29
    1f06:	cf 91       	pop	r28
    1f08:	08 95       	ret

00001f0a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1f0a:	cf 93       	push	r28
    1f0c:	df 93       	push	r29
    1f0e:	ac 01       	movw	r20, r24
    1f10:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1f12:	28 81       	ld	r18, Y
    1f14:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1f16:	8f ef       	ldi	r24, 0xFF	; 255
    1f18:	2f 3f       	cpi	r18, 0xFF	; 255
    1f1a:	38 07       	cpc	r19, r24
    1f1c:	21 f4       	brne	.+8      	; 0x1f26 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f1e:	fa 01       	movw	r30, r20
    1f20:	a7 81       	ldd	r26, Z+7	; 0x07
    1f22:	b0 85       	ldd	r27, Z+8	; 0x08
    1f24:	18 c0       	rjmp	.+48     	; 0x1f56 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1f26:	da 01       	movw	r26, r20
    1f28:	13 96       	adiw	r26, 0x03	; 3
    1f2a:	fa 01       	movw	r30, r20
    1f2c:	85 81       	ldd	r24, Z+5	; 0x05
    1f2e:	96 81       	ldd	r25, Z+6	; 0x06
    1f30:	fc 01       	movw	r30, r24
    1f32:	80 81       	ld	r24, Z
    1f34:	91 81       	ldd	r25, Z+1	; 0x01
    1f36:	28 17       	cp	r18, r24
    1f38:	39 07       	cpc	r19, r25
    1f3a:	68 f0       	brcs	.+26     	; 0x1f56 <vListInsert+0x4c>
    1f3c:	12 96       	adiw	r26, 0x02	; 2
    1f3e:	0d 90       	ld	r0, X+
    1f40:	bc 91       	ld	r27, X
    1f42:	a0 2d       	mov	r26, r0
    1f44:	12 96       	adiw	r26, 0x02	; 2
    1f46:	ed 91       	ld	r30, X+
    1f48:	fc 91       	ld	r31, X
    1f4a:	13 97       	sbiw	r26, 0x03	; 3
    1f4c:	80 81       	ld	r24, Z
    1f4e:	91 81       	ldd	r25, Z+1	; 0x01
    1f50:	28 17       	cp	r18, r24
    1f52:	39 07       	cpc	r19, r25
    1f54:	98 f7       	brcc	.-26     	; 0x1f3c <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1f56:	12 96       	adiw	r26, 0x02	; 2
    1f58:	ed 91       	ld	r30, X+
    1f5a:	fc 91       	ld	r31, X
    1f5c:	13 97       	sbiw	r26, 0x03	; 3
    1f5e:	fb 83       	std	Y+3, r31	; 0x03
    1f60:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1f62:	d5 83       	std	Z+5, r29	; 0x05
    1f64:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1f66:	bd 83       	std	Y+5, r27	; 0x05
    1f68:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1f6a:	13 96       	adiw	r26, 0x03	; 3
    1f6c:	dc 93       	st	X, r29
    1f6e:	ce 93       	st	-X, r28
    1f70:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1f72:	59 87       	std	Y+9, r21	; 0x09
    1f74:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    1f76:	fa 01       	movw	r30, r20
    1f78:	80 81       	ld	r24, Z
    1f7a:	8f 5f       	subi	r24, 0xFF	; 255
    1f7c:	80 83       	st	Z, r24
}
    1f7e:	df 91       	pop	r29
    1f80:	cf 91       	pop	r28
    1f82:	08 95       	ret

00001f84 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    1f84:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1f86:	a2 81       	ldd	r26, Z+2	; 0x02
    1f88:	b3 81       	ldd	r27, Z+3	; 0x03
    1f8a:	84 81       	ldd	r24, Z+4	; 0x04
    1f8c:	95 81       	ldd	r25, Z+5	; 0x05
    1f8e:	15 96       	adiw	r26, 0x05	; 5
    1f90:	9c 93       	st	X, r25
    1f92:	8e 93       	st	-X, r24
    1f94:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f96:	a4 81       	ldd	r26, Z+4	; 0x04
    1f98:	b5 81       	ldd	r27, Z+5	; 0x05
    1f9a:	82 81       	ldd	r24, Z+2	; 0x02
    1f9c:	93 81       	ldd	r25, Z+3	; 0x03
    1f9e:	13 96       	adiw	r26, 0x03	; 3
    1fa0:	9c 93       	st	X, r25
    1fa2:	8e 93       	st	-X, r24
    1fa4:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1fa6:	a0 85       	ldd	r26, Z+8	; 0x08
    1fa8:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1faa:	11 96       	adiw	r26, 0x01	; 1
    1fac:	8d 91       	ld	r24, X+
    1fae:	9c 91       	ld	r25, X
    1fb0:	12 97       	sbiw	r26, 0x02	; 2
    1fb2:	8e 17       	cp	r24, r30
    1fb4:	9f 07       	cpc	r25, r31
    1fb6:	31 f4       	brne	.+12     	; 0x1fc4 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1fb8:	84 81       	ldd	r24, Z+4	; 0x04
    1fba:	95 81       	ldd	r25, Z+5	; 0x05
    1fbc:	12 96       	adiw	r26, 0x02	; 2
    1fbe:	9c 93       	st	X, r25
    1fc0:	8e 93       	st	-X, r24
    1fc2:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1fc4:	11 86       	std	Z+9, r1	; 0x09
    1fc6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1fc8:	8c 91       	ld	r24, X
    1fca:	81 50       	subi	r24, 0x01	; 1
    1fcc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1fce:	8c 91       	ld	r24, X
}
    1fd0:	08 95       	ret

00001fd2 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1fd2:	21 e1       	ldi	r18, 0x11	; 17
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1fd8:	31 97       	sbiw	r30, 0x01	; 1
    1fda:	32 e2       	ldi	r19, 0x22	; 34
    1fdc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1fde:	fc 01       	movw	r30, r24
    1fe0:	32 97       	sbiw	r30, 0x02	; 2
    1fe2:	a3 e3       	ldi	r26, 0x33	; 51
    1fe4:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    1fe6:	fc 01       	movw	r30, r24
    1fe8:	33 97       	sbiw	r30, 0x03	; 3
    1fea:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    1fec:	fc 01       	movw	r30, r24
    1fee:	34 97       	sbiw	r30, 0x04	; 4
    1ff0:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    1ff2:	fc 01       	movw	r30, r24
    1ff4:	35 97       	sbiw	r30, 0x05	; 5
    1ff6:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1ff8:	fc 01       	movw	r30, r24
    1ffa:	36 97       	sbiw	r30, 0x06	; 6
    1ffc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1ffe:	fc 01       	movw	r30, r24
    2000:	37 97       	sbiw	r30, 0x07	; 7
    2002:	60 e8       	ldi	r22, 0x80	; 128
    2004:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    2006:	fc 01       	movw	r30, r24
    2008:	38 97       	sbiw	r30, 0x08	; 8
    200a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    200c:	fc 01       	movw	r30, r24
    200e:	39 97       	sbiw	r30, 0x09	; 9
    2010:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2012:	fc 01       	movw	r30, r24
    2014:	3a 97       	sbiw	r30, 0x0a	; 10
    2016:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2018:	fc 01       	movw	r30, r24
    201a:	3b 97       	sbiw	r30, 0x0b	; 11
    201c:	62 e0       	ldi	r22, 0x02	; 2
    201e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2020:	fc 01       	movw	r30, r24
    2022:	3c 97       	sbiw	r30, 0x0c	; 12
    2024:	63 e0       	ldi	r22, 0x03	; 3
    2026:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2028:	fc 01       	movw	r30, r24
    202a:	3d 97       	sbiw	r30, 0x0d	; 13
    202c:	64 e0       	ldi	r22, 0x04	; 4
    202e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2030:	fc 01       	movw	r30, r24
    2032:	3e 97       	sbiw	r30, 0x0e	; 14
    2034:	65 e0       	ldi	r22, 0x05	; 5
    2036:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2038:	fc 01       	movw	r30, r24
    203a:	3f 97       	sbiw	r30, 0x0f	; 15
    203c:	66 e0       	ldi	r22, 0x06	; 6
    203e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2040:	fc 01       	movw	r30, r24
    2042:	70 97       	sbiw	r30, 0x10	; 16
    2044:	67 e0       	ldi	r22, 0x07	; 7
    2046:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2048:	fc 01       	movw	r30, r24
    204a:	71 97       	sbiw	r30, 0x11	; 17
    204c:	68 e0       	ldi	r22, 0x08	; 8
    204e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2050:	fc 01       	movw	r30, r24
    2052:	72 97       	sbiw	r30, 0x12	; 18
    2054:	69 e0       	ldi	r22, 0x09	; 9
    2056:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2058:	fc 01       	movw	r30, r24
    205a:	73 97       	sbiw	r30, 0x13	; 19
    205c:	60 e1       	ldi	r22, 0x10	; 16
    205e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2060:	fc 01       	movw	r30, r24
    2062:	74 97       	sbiw	r30, 0x14	; 20
    2064:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2066:	fc 01       	movw	r30, r24
    2068:	75 97       	sbiw	r30, 0x15	; 21
    206a:	22 e1       	ldi	r18, 0x12	; 18
    206c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    206e:	fc 01       	movw	r30, r24
    2070:	76 97       	sbiw	r30, 0x16	; 22
    2072:	23 e1       	ldi	r18, 0x13	; 19
    2074:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2076:	fc 01       	movw	r30, r24
    2078:	77 97       	sbiw	r30, 0x17	; 23
    207a:	24 e1       	ldi	r18, 0x14	; 20
    207c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    207e:	fc 01       	movw	r30, r24
    2080:	78 97       	sbiw	r30, 0x18	; 24
    2082:	25 e1       	ldi	r18, 0x15	; 21
    2084:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2086:	fc 01       	movw	r30, r24
    2088:	79 97       	sbiw	r30, 0x19	; 25
    208a:	26 e1       	ldi	r18, 0x16	; 22
    208c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    208e:	fc 01       	movw	r30, r24
    2090:	7a 97       	sbiw	r30, 0x1a	; 26
    2092:	27 e1       	ldi	r18, 0x17	; 23
    2094:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2096:	fc 01       	movw	r30, r24
    2098:	7b 97       	sbiw	r30, 0x1b	; 27
    209a:	28 e1       	ldi	r18, 0x18	; 24
    209c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    209e:	fc 01       	movw	r30, r24
    20a0:	7c 97       	sbiw	r30, 0x1c	; 28
    20a2:	29 e1       	ldi	r18, 0x19	; 25
    20a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    20a6:	fc 01       	movw	r30, r24
    20a8:	7d 97       	sbiw	r30, 0x1d	; 29
    20aa:	20 e2       	ldi	r18, 0x20	; 32
    20ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    20ae:	fc 01       	movw	r30, r24
    20b0:	7e 97       	sbiw	r30, 0x1e	; 30
    20b2:	21 e2       	ldi	r18, 0x21	; 33
    20b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    20b6:	fc 01       	movw	r30, r24
    20b8:	7f 97       	sbiw	r30, 0x1f	; 31
    20ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    20bc:	fc 01       	movw	r30, r24
    20be:	b0 97       	sbiw	r30, 0x20	; 32
    20c0:	23 e2       	ldi	r18, 0x23	; 35
    20c2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    20c4:	fc 01       	movw	r30, r24
    20c6:	b1 97       	sbiw	r30, 0x21	; 33
    20c8:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    20ca:	fc 01       	movw	r30, r24
    20cc:	b2 97       	sbiw	r30, 0x22	; 34
    20ce:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    20d0:	fc 01       	movw	r30, r24
    20d2:	b3 97       	sbiw	r30, 0x23	; 35
    20d4:	26 e2       	ldi	r18, 0x26	; 38
    20d6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    20d8:	fc 01       	movw	r30, r24
    20da:	b4 97       	sbiw	r30, 0x24	; 36
    20dc:	27 e2       	ldi	r18, 0x27	; 39
    20de:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    20e0:	fc 01       	movw	r30, r24
    20e2:	b5 97       	sbiw	r30, 0x25	; 37
    20e4:	28 e2       	ldi	r18, 0x28	; 40
    20e6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    20e8:	fc 01       	movw	r30, r24
    20ea:	b6 97       	sbiw	r30, 0x26	; 38
    20ec:	29 e2       	ldi	r18, 0x29	; 41
    20ee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    20f0:	fc 01       	movw	r30, r24
    20f2:	b7 97       	sbiw	r30, 0x27	; 39
    20f4:	20 e3       	ldi	r18, 0x30	; 48
    20f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    20f8:	fc 01       	movw	r30, r24
    20fa:	b8 97       	sbiw	r30, 0x28	; 40
    20fc:	21 e3       	ldi	r18, 0x31	; 49
    20fe:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2100:	89 97       	sbiw	r24, 0x29	; 41
}
    2102:	08 95       	ret

00002104 <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
    2104:	10 92 99 00 	sts	0x0099, r1

#endif

    portOCRL = ucLowByte;
    2108:	89 ef       	ldi	r24, 0xF9	; 249
    210a:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
    210e:	8b e0       	ldi	r24, 0x0B	; 11
    2110:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    2114:	e1 e7       	ldi	r30, 0x71	; 113
    2116:	f0 e0       	ldi	r31, 0x00	; 0
    2118:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    211a:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
    211c:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    211e:	a0 91 ce 1a 	lds	r26, 0x1ACE
    2122:	b0 91 cf 1a 	lds	r27, 0x1ACF
    2126:	cd 91       	ld	r28, X+
    2128:	cd bf       	out	0x3d, r28	; 61
    212a:	dd 91       	ld	r29, X+
    212c:	de bf       	out	0x3e, r29	; 62
    212e:	ff 91       	pop	r31
    2130:	ef 91       	pop	r30
    2132:	df 91       	pop	r29
    2134:	cf 91       	pop	r28
    2136:	bf 91       	pop	r27
    2138:	af 91       	pop	r26
    213a:	9f 91       	pop	r25
    213c:	8f 91       	pop	r24
    213e:	7f 91       	pop	r23
    2140:	6f 91       	pop	r22
    2142:	5f 91       	pop	r21
    2144:	4f 91       	pop	r20
    2146:	3f 91       	pop	r19
    2148:	2f 91       	pop	r18
    214a:	1f 91       	pop	r17
    214c:	0f 91       	pop	r16
    214e:	ff 90       	pop	r15
    2150:	ef 90       	pop	r14
    2152:	df 90       	pop	r13
    2154:	cf 90       	pop	r12
    2156:	bf 90       	pop	r11
    2158:	af 90       	pop	r10
    215a:	9f 90       	pop	r9
    215c:	8f 90       	pop	r8
    215e:	7f 90       	pop	r7
    2160:	6f 90       	pop	r6
    2162:	5f 90       	pop	r5
    2164:	4f 90       	pop	r4
    2166:	3f 90       	pop	r3
    2168:	2f 90       	pop	r2
    216a:	1f 90       	pop	r1
    216c:	0f 90       	pop	r0
    216e:	0c be       	out	0x3c, r0	; 60
    2170:	0f 90       	pop	r0
    2172:	0b be       	out	0x3b, r0	; 59
    2174:	0f 90       	pop	r0
    2176:	0f be       	out	0x3f, r0	; 63
    2178:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    217a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    217c:	81 e0       	ldi	r24, 0x01	; 1
    217e:	08 95       	ret

00002180 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2180:	08 95       	ret

00002182 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2182:	0f 92       	push	r0
    2184:	0f b6       	in	r0, 0x3f	; 63
    2186:	f8 94       	cli
    2188:	0f 92       	push	r0
    218a:	0b b6       	in	r0, 0x3b	; 59
    218c:	0f 92       	push	r0
    218e:	0c b6       	in	r0, 0x3c	; 60
    2190:	0f 92       	push	r0
    2192:	1f 92       	push	r1
    2194:	11 24       	eor	r1, r1
    2196:	2f 92       	push	r2
    2198:	3f 92       	push	r3
    219a:	4f 92       	push	r4
    219c:	5f 92       	push	r5
    219e:	6f 92       	push	r6
    21a0:	7f 92       	push	r7
    21a2:	8f 92       	push	r8
    21a4:	9f 92       	push	r9
    21a6:	af 92       	push	r10
    21a8:	bf 92       	push	r11
    21aa:	cf 92       	push	r12
    21ac:	df 92       	push	r13
    21ae:	ef 92       	push	r14
    21b0:	ff 92       	push	r15
    21b2:	0f 93       	push	r16
    21b4:	1f 93       	push	r17
    21b6:	2f 93       	push	r18
    21b8:	3f 93       	push	r19
    21ba:	4f 93       	push	r20
    21bc:	5f 93       	push	r21
    21be:	6f 93       	push	r22
    21c0:	7f 93       	push	r23
    21c2:	8f 93       	push	r24
    21c4:	9f 93       	push	r25
    21c6:	af 93       	push	r26
    21c8:	bf 93       	push	r27
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
    21ce:	ef 93       	push	r30
    21d0:	ff 93       	push	r31
    21d2:	a0 91 ce 1a 	lds	r26, 0x1ACE
    21d6:	b0 91 cf 1a 	lds	r27, 0x1ACF
    21da:	0d b6       	in	r0, 0x3d	; 61
    21dc:	0d 92       	st	X+, r0
    21de:	0e b6       	in	r0, 0x3e	; 62
    21e0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    21e2:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    21e6:	a0 91 ce 1a 	lds	r26, 0x1ACE
    21ea:	b0 91 cf 1a 	lds	r27, 0x1ACF
    21ee:	cd 91       	ld	r28, X+
    21f0:	cd bf       	out	0x3d, r28	; 61
    21f2:	dd 91       	ld	r29, X+
    21f4:	de bf       	out	0x3e, r29	; 62
    21f6:	ff 91       	pop	r31
    21f8:	ef 91       	pop	r30
    21fa:	df 91       	pop	r29
    21fc:	cf 91       	pop	r28
    21fe:	bf 91       	pop	r27
    2200:	af 91       	pop	r26
    2202:	9f 91       	pop	r25
    2204:	8f 91       	pop	r24
    2206:	7f 91       	pop	r23
    2208:	6f 91       	pop	r22
    220a:	5f 91       	pop	r21
    220c:	4f 91       	pop	r20
    220e:	3f 91       	pop	r19
    2210:	2f 91       	pop	r18
    2212:	1f 91       	pop	r17
    2214:	0f 91       	pop	r16
    2216:	ff 90       	pop	r15
    2218:	ef 90       	pop	r14
    221a:	df 90       	pop	r13
    221c:	cf 90       	pop	r12
    221e:	bf 90       	pop	r11
    2220:	af 90       	pop	r10
    2222:	9f 90       	pop	r9
    2224:	8f 90       	pop	r8
    2226:	7f 90       	pop	r7
    2228:	6f 90       	pop	r6
    222a:	5f 90       	pop	r5
    222c:	4f 90       	pop	r4
    222e:	3f 90       	pop	r3
    2230:	2f 90       	pop	r2
    2232:	1f 90       	pop	r1
    2234:	0f 90       	pop	r0
    2236:	0c be       	out	0x3c, r0	; 60
    2238:	0f 90       	pop	r0
    223a:	0b be       	out	0x3b, r0	; 59
    223c:	0f 90       	pop	r0
    223e:	0f be       	out	0x3f, r0	; 63
    2240:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2242:	08 95       	ret

00002244 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2244:	0f 92       	push	r0
    2246:	0f b6       	in	r0, 0x3f	; 63
    2248:	f8 94       	cli
    224a:	0f 92       	push	r0
    224c:	0b b6       	in	r0, 0x3b	; 59
    224e:	0f 92       	push	r0
    2250:	0c b6       	in	r0, 0x3c	; 60
    2252:	0f 92       	push	r0
    2254:	1f 92       	push	r1
    2256:	11 24       	eor	r1, r1
    2258:	2f 92       	push	r2
    225a:	3f 92       	push	r3
    225c:	4f 92       	push	r4
    225e:	5f 92       	push	r5
    2260:	6f 92       	push	r6
    2262:	7f 92       	push	r7
    2264:	8f 92       	push	r8
    2266:	9f 92       	push	r9
    2268:	af 92       	push	r10
    226a:	bf 92       	push	r11
    226c:	cf 92       	push	r12
    226e:	df 92       	push	r13
    2270:	ef 92       	push	r14
    2272:	ff 92       	push	r15
    2274:	0f 93       	push	r16
    2276:	1f 93       	push	r17
    2278:	2f 93       	push	r18
    227a:	3f 93       	push	r19
    227c:	4f 93       	push	r20
    227e:	5f 93       	push	r21
    2280:	6f 93       	push	r22
    2282:	7f 93       	push	r23
    2284:	8f 93       	push	r24
    2286:	9f 93       	push	r25
    2288:	af 93       	push	r26
    228a:	bf 93       	push	r27
    228c:	cf 93       	push	r28
    228e:	df 93       	push	r29
    2290:	ef 93       	push	r30
    2292:	ff 93       	push	r31
    2294:	a0 91 ce 1a 	lds	r26, 0x1ACE
    2298:	b0 91 cf 1a 	lds	r27, 0x1ACF
    229c:	0d b6       	in	r0, 0x3d	; 61
    229e:	0d 92       	st	X+, r0
    22a0:	0e b6       	in	r0, 0x3e	; 62
    22a2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    22a4:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <vTaskIncrementTick>
	vTaskSwitchContext();
    22a8:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22ac:	a0 91 ce 1a 	lds	r26, 0x1ACE
    22b0:	b0 91 cf 1a 	lds	r27, 0x1ACF
    22b4:	cd 91       	ld	r28, X+
    22b6:	cd bf       	out	0x3d, r28	; 61
    22b8:	dd 91       	ld	r29, X+
    22ba:	de bf       	out	0x3e, r29	; 62
    22bc:	ff 91       	pop	r31
    22be:	ef 91       	pop	r30
    22c0:	df 91       	pop	r29
    22c2:	cf 91       	pop	r28
    22c4:	bf 91       	pop	r27
    22c6:	af 91       	pop	r26
    22c8:	9f 91       	pop	r25
    22ca:	8f 91       	pop	r24
    22cc:	7f 91       	pop	r23
    22ce:	6f 91       	pop	r22
    22d0:	5f 91       	pop	r21
    22d2:	4f 91       	pop	r20
    22d4:	3f 91       	pop	r19
    22d6:	2f 91       	pop	r18
    22d8:	1f 91       	pop	r17
    22da:	0f 91       	pop	r16
    22dc:	ff 90       	pop	r15
    22de:	ef 90       	pop	r14
    22e0:	df 90       	pop	r13
    22e2:	cf 90       	pop	r12
    22e4:	bf 90       	pop	r11
    22e6:	af 90       	pop	r10
    22e8:	9f 90       	pop	r9
    22ea:	8f 90       	pop	r8
    22ec:	7f 90       	pop	r7
    22ee:	6f 90       	pop	r6
    22f0:	5f 90       	pop	r5
    22f2:	4f 90       	pop	r4
    22f4:	3f 90       	pop	r3
    22f6:	2f 90       	pop	r2
    22f8:	1f 90       	pop	r1
    22fa:	0f 90       	pop	r0
    22fc:	0c be       	out	0x3c, r0	; 60
    22fe:	0f 90       	pop	r0
    2300:	0b be       	out	0x3b, r0	; 59
    2302:	0f 90       	pop	r0
    2304:	0f be       	out	0x3f, r0	; 63
    2306:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2308:	08 95       	ret

0000230a <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    230a:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYieldFromTick>
			asm volatile ( "reti" );
    230e:	18 95       	reti

00002310 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2310:	cf 93       	push	r28
    2312:	df 93       	push	r29
    2314:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2316:	cd 91       	ld	r28, X+
    2318:	dc 91       	ld	r29, X
    231a:	11 97       	sbiw	r26, 0x01	; 1
    231c:	20 97       	sbiw	r28, 0x00	; 0
    231e:	21 f1       	breq	.+72     	; 0x2368 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2320:	5c 96       	adiw	r26, 0x1c	; 28
    2322:	4c 91       	ld	r20, X
    2324:	5c 97       	sbiw	r26, 0x1c	; 28
    2326:	16 96       	adiw	r26, 0x06	; 6
    2328:	2d 91       	ld	r18, X+
    232a:	3c 91       	ld	r19, X
    232c:	17 97       	sbiw	r26, 0x07	; 7
    232e:	24 0f       	add	r18, r20
    2330:	31 1d       	adc	r19, r1
    2332:	17 96       	adiw	r26, 0x07	; 7
    2334:	3c 93       	st	X, r19
    2336:	2e 93       	st	-X, r18
    2338:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    233a:	12 96       	adiw	r26, 0x02	; 2
    233c:	ed 91       	ld	r30, X+
    233e:	fc 91       	ld	r31, X
    2340:	13 97       	sbiw	r26, 0x03	; 3
    2342:	2e 17       	cp	r18, r30
    2344:	3f 07       	cpc	r19, r31
    2346:	20 f0       	brcs	.+8      	; 0x2350 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2348:	17 96       	adiw	r26, 0x07	; 7
    234a:	dc 93       	st	X, r29
    234c:	ce 93       	st	-X, r28
    234e:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2350:	16 96       	adiw	r26, 0x06	; 6
    2352:	3c 91       	ld	r19, X
    2354:	16 97       	sbiw	r26, 0x06	; 6
    2356:	17 96       	adiw	r26, 0x07	; 7
    2358:	2c 91       	ld	r18, X
    235a:	86 2f       	mov	r24, r22
    235c:	97 2f       	mov	r25, r23
    235e:	63 2f       	mov	r22, r19
    2360:	72 2f       	mov	r23, r18
    2362:	50 e0       	ldi	r21, 0x00	; 0
    2364:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <memcpy>
	}
}
    2368:	df 91       	pop	r29
    236a:	cf 91       	pop	r28
    236c:	08 95       	ret

0000236e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    236e:	0f 93       	push	r16
    2370:	1f 93       	push	r17
    2372:	cf 93       	push	r28
    2374:	df 93       	push	r29
    2376:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2378:	0f b6       	in	r0, 0x3f	; 63
    237a:	f8 94       	cli
    237c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    237e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2380:	18 16       	cp	r1, r24
    2382:	c4 f4       	brge	.+48     	; 0x23b4 <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2384:	89 89       	ldd	r24, Y+17	; 0x11
    2386:	88 23       	and	r24, r24
    2388:	29 f4       	brne	.+10     	; 0x2394 <prvUnlockQueue+0x26>
    238a:	14 c0       	rjmp	.+40     	; 0x23b4 <prvUnlockQueue+0x46>
    238c:	89 89       	ldd	r24, Y+17	; 0x11
    238e:	88 23       	and	r24, r24
    2390:	21 f4       	brne	.+8      	; 0x239a <prvUnlockQueue+0x2c>
    2392:	10 c0       	rjmp	.+32     	; 0x23b4 <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2394:	8e 01       	movw	r16, r28
    2396:	0f 5e       	subi	r16, 0xEF	; 239
    2398:	1f 4f       	sbci	r17, 0xFF	; 255
    239a:	c8 01       	movw	r24, r16
    239c:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    23a0:	88 23       	and	r24, r24
    23a2:	11 f0       	breq	.+4      	; 0x23a8 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    23a4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    23a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23aa:	81 50       	subi	r24, 0x01	; 1
    23ac:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    23ae:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23b0:	18 16       	cp	r1, r24
    23b2:	64 f3       	brlt	.-40     	; 0x238c <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    23b4:	8f ef       	ldi	r24, 0xFF	; 255
    23b6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    23b8:	0f 90       	pop	r0
    23ba:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    23bc:	0f b6       	in	r0, 0x3f	; 63
    23be:	f8 94       	cli
    23c0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    23c2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    23c4:	18 16       	cp	r1, r24
    23c6:	c4 f4       	brge	.+48     	; 0x23f8 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23c8:	88 85       	ldd	r24, Y+8	; 0x08
    23ca:	88 23       	and	r24, r24
    23cc:	29 f4       	brne	.+10     	; 0x23d8 <prvUnlockQueue+0x6a>
    23ce:	14 c0       	rjmp	.+40     	; 0x23f8 <prvUnlockQueue+0x8a>
    23d0:	88 85       	ldd	r24, Y+8	; 0x08
    23d2:	88 23       	and	r24, r24
    23d4:	21 f4       	brne	.+8      	; 0x23de <prvUnlockQueue+0x70>
    23d6:	10 c0       	rjmp	.+32     	; 0x23f8 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23d8:	8e 01       	movw	r16, r28
    23da:	08 5f       	subi	r16, 0xF8	; 248
    23dc:	1f 4f       	sbci	r17, 0xFF	; 255
    23de:	c8 01       	movw	r24, r16
    23e0:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    23e4:	88 23       	and	r24, r24
    23e6:	11 f0       	breq	.+4      	; 0x23ec <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    23e8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    23ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
    23ee:	81 50       	subi	r24, 0x01	; 1
    23f0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    23f2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    23f4:	18 16       	cp	r1, r24
    23f6:	64 f3       	brlt	.-40     	; 0x23d0 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    23f8:	8f ef       	ldi	r24, 0xFF	; 255
    23fa:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    23fc:	0f 90       	pop	r0
    23fe:	0f be       	out	0x3f, r0	; 63
}
    2400:	df 91       	pop	r29
    2402:	cf 91       	pop	r28
    2404:	1f 91       	pop	r17
    2406:	0f 91       	pop	r16
    2408:	08 95       	ret

0000240a <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    240a:	cf 93       	push	r28
    240c:	df 93       	push	r29
    240e:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2410:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2412:	22 23       	and	r18, r18
    2414:	59 f4       	brne	.+22     	; 0x242c <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2416:	88 81       	ld	r24, Y
    2418:	99 81       	ldd	r25, Y+1	; 0x01
    241a:	00 97       	sbiw	r24, 0x00	; 0
    241c:	e1 f5       	brne	.+120    	; 0x2496 <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    241e:	8a 81       	ldd	r24, Y+2	; 0x02
    2420:	9b 81       	ldd	r25, Y+3	; 0x03
    2422:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    2426:	1b 82       	std	Y+3, r1	; 0x03
    2428:	1a 82       	std	Y+2, r1	; 0x02
    242a:	35 c0       	rjmp	.+106    	; 0x2496 <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    242c:	44 23       	and	r20, r20
    242e:	b9 f4       	brne	.+46     	; 0x245e <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2430:	8c 81       	ldd	r24, Y+4	; 0x04
    2432:	9d 81       	ldd	r25, Y+5	; 0x05
    2434:	42 2f       	mov	r20, r18
    2436:	50 e0       	ldi	r21, 0x00	; 0
    2438:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    243c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    243e:	8c 81       	ldd	r24, Y+4	; 0x04
    2440:	9d 81       	ldd	r25, Y+5	; 0x05
    2442:	82 0f       	add	r24, r18
    2444:	91 1d       	adc	r25, r1
    2446:	9d 83       	std	Y+5, r25	; 0x05
    2448:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    244a:	2a 81       	ldd	r18, Y+2	; 0x02
    244c:	3b 81       	ldd	r19, Y+3	; 0x03
    244e:	82 17       	cp	r24, r18
    2450:	93 07       	cpc	r25, r19
    2452:	08 f1       	brcs	.+66     	; 0x2496 <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2454:	88 81       	ld	r24, Y
    2456:	99 81       	ldd	r25, Y+1	; 0x01
    2458:	9d 83       	std	Y+5, r25	; 0x05
    245a:	8c 83       	std	Y+4, r24	; 0x04
    245c:	1c c0       	rjmp	.+56     	; 0x2496 <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    245e:	8e 81       	ldd	r24, Y+6	; 0x06
    2460:	9f 81       	ldd	r25, Y+7	; 0x07
    2462:	42 2f       	mov	r20, r18
    2464:	50 e0       	ldi	r21, 0x00	; 0
    2466:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    246a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    246c:	50 e0       	ldi	r21, 0x00	; 0
    246e:	50 95       	com	r21
    2470:	41 95       	neg	r20
    2472:	5f 4f       	sbci	r21, 0xFF	; 255
    2474:	8e 81       	ldd	r24, Y+6	; 0x06
    2476:	9f 81       	ldd	r25, Y+7	; 0x07
    2478:	84 0f       	add	r24, r20
    247a:	95 1f       	adc	r25, r21
    247c:	9f 83       	std	Y+7, r25	; 0x07
    247e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2480:	28 81       	ld	r18, Y
    2482:	39 81       	ldd	r19, Y+1	; 0x01
    2484:	82 17       	cp	r24, r18
    2486:	93 07       	cpc	r25, r19
    2488:	30 f4       	brcc	.+12     	; 0x2496 <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    248a:	8a 81       	ldd	r24, Y+2	; 0x02
    248c:	9b 81       	ldd	r25, Y+3	; 0x03
    248e:	48 0f       	add	r20, r24
    2490:	59 1f       	adc	r21, r25
    2492:	5f 83       	std	Y+7, r21	; 0x07
    2494:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2496:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2498:	8f 5f       	subi	r24, 0xFF	; 255
    249a:	8a 8f       	std	Y+26, r24	; 0x1a
}
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	08 95       	ret

000024a2 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    24a2:	cf 93       	push	r28
    24a4:	df 93       	push	r29
    24a6:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    24a8:	0f b6       	in	r0, 0x3f	; 63
    24aa:	f8 94       	cli
    24ac:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    24ae:	48 81       	ld	r20, Y
    24b0:	59 81       	ldd	r21, Y+1	; 0x01
    24b2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    24b4:	30 e0       	ldi	r19, 0x00	; 0
    24b6:	ec 8d       	ldd	r30, Y+28	; 0x1c
    24b8:	f0 e0       	ldi	r31, 0x00	; 0
    24ba:	2e 9f       	mul	r18, r30
    24bc:	c0 01       	movw	r24, r0
    24be:	2f 9f       	mul	r18, r31
    24c0:	90 0d       	add	r25, r0
    24c2:	3e 9f       	mul	r19, r30
    24c4:	90 0d       	add	r25, r0
    24c6:	11 24       	eor	r1, r1
    24c8:	84 0f       	add	r24, r20
    24ca:	95 1f       	adc	r25, r21
    24cc:	9b 83       	std	Y+3, r25	; 0x03
    24ce:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    24d0:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    24d2:	5d 83       	std	Y+5, r21	; 0x05
    24d4:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    24d6:	c9 01       	movw	r24, r18
    24d8:	01 97       	sbiw	r24, 0x01	; 1
    24da:	e8 9f       	mul	r30, r24
    24dc:	90 01       	movw	r18, r0
    24de:	e9 9f       	mul	r30, r25
    24e0:	30 0d       	add	r19, r0
    24e2:	f8 9f       	mul	r31, r24
    24e4:	30 0d       	add	r19, r0
    24e6:	11 24       	eor	r1, r1
    24e8:	24 0f       	add	r18, r20
    24ea:	35 1f       	adc	r19, r21
    24ec:	3f 83       	std	Y+7, r19	; 0x07
    24ee:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    24f0:	8f ef       	ldi	r24, 0xFF	; 255
    24f2:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    24f4:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    24f6:	66 23       	and	r22, r22
    24f8:	61 f4       	brne	.+24     	; 0x2512 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24fa:	88 85       	ldd	r24, Y+8	; 0x08
    24fc:	88 23       	and	r24, r24
    24fe:	89 f0       	breq	.+34     	; 0x2522 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2500:	ce 01       	movw	r24, r28
    2502:	08 96       	adiw	r24, 0x08	; 8
    2504:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    2508:	81 30       	cpi	r24, 0x01	; 1
    250a:	59 f4       	brne	.+22     	; 0x2522 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    250c:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    2510:	08 c0       	rjmp	.+16     	; 0x2522 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2512:	ce 01       	movw	r24, r28
    2514:	08 96       	adiw	r24, 0x08	; 8
    2516:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    251a:	ce 01       	movw	r24, r28
    251c:	41 96       	adiw	r24, 0x11	; 17
    251e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	df 91       	pop	r29
    252a:	cf 91       	pop	r28
    252c:	08 95       	ret

0000252e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    252e:	0f 93       	push	r16
    2530:	1f 93       	push	r17
    2532:	cf 93       	push	r28
    2534:	df 93       	push	r29
    2536:	18 2f       	mov	r17, r24
    2538:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    253a:	88 23       	and	r24, r24
    253c:	f9 f0       	breq	.+62     	; 0x257c <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    253e:	8f e1       	ldi	r24, 0x1F	; 31
    2540:	90 e0       	ldi	r25, 0x00	; 0
    2542:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
    2546:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    2548:	00 97       	sbiw	r24, 0x00	; 0
    254a:	d9 f0       	breq	.+54     	; 0x2582 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    254c:	01 9f       	mul	r16, r17
    254e:	c0 01       	movw	r24, r0
    2550:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2552:	01 96       	adiw	r24, 0x01	; 1
    2554:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
    2558:	99 83       	std	Y+1, r25	; 0x01
    255a:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    255c:	00 97       	sbiw	r24, 0x00	; 0
    255e:	41 f0       	breq	.+16     	; 0x2570 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2560:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2562:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    2564:	ce 01       	movw	r24, r28
    2566:	61 e0       	ldi	r22, 0x01	; 1
    2568:	0e 94 51 12 	call	0x24a2	; 0x24a2 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    256c:	ce 01       	movw	r24, r28
    256e:	0b c0       	rjmp	.+22     	; 0x2586 <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2570:	ce 01       	movw	r24, r28
    2572:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2576:	80 e0       	ldi	r24, 0x00	; 0
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	05 c0       	rjmp	.+10     	; 0x2586 <xQueueGenericCreate+0x58>
    257c:	80 e0       	ldi	r24, 0x00	; 0
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	02 c0       	rjmp	.+4      	; 0x2586 <xQueueGenericCreate+0x58>
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	1f 91       	pop	r17
    258c:	0f 91       	pop	r16
    258e:	08 95       	ret

00002590 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2590:	8f 92       	push	r8
    2592:	9f 92       	push	r9
    2594:	bf 92       	push	r11
    2596:	cf 92       	push	r12
    2598:	df 92       	push	r13
    259a:	ef 92       	push	r14
    259c:	ff 92       	push	r15
    259e:	0f 93       	push	r16
    25a0:	1f 93       	push	r17
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
    25a6:	00 d0       	rcall	.+0      	; 0x25a8 <xQueueGenericSend+0x18>
    25a8:	0f 92       	push	r0
    25aa:	0f 92       	push	r0
    25ac:	cd b7       	in	r28, 0x3d	; 61
    25ae:	de b7       	in	r29, 0x3e	; 62
    25b0:	8c 01       	movw	r16, r24
    25b2:	4b 01       	movw	r8, r22
    25b4:	5d 83       	std	Y+5, r21	; 0x05
    25b6:	4c 83       	std	Y+4, r20	; 0x04
    25b8:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    25ba:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    25bc:	ee 24       	eor	r14, r14
    25be:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    25c0:	cc 24       	eor	r12, r12
    25c2:	dd 24       	eor	r13, r13
    25c4:	68 94       	set
    25c6:	c3 f8       	bld	r12, 3
    25c8:	c8 0e       	add	r12, r24
    25ca:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    25cc:	0f b6       	in	r0, 0x3f	; 63
    25ce:	f8 94       	cli
    25d0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    25d2:	f8 01       	movw	r30, r16
    25d4:	92 8d       	ldd	r25, Z+26	; 0x1a
    25d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    25d8:	98 17       	cp	r25, r24
    25da:	a8 f4       	brcc	.+42     	; 0x2606 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    25dc:	c8 01       	movw	r24, r16
    25de:	b4 01       	movw	r22, r8
    25e0:	4b 2d       	mov	r20, r11
    25e2:	0e 94 05 12 	call	0x240a	; 0x240a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25e6:	f8 01       	movw	r30, r16
    25e8:	81 89       	ldd	r24, Z+17	; 0x11
    25ea:	88 23       	and	r24, r24
    25ec:	41 f0       	breq	.+16     	; 0x25fe <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    25ee:	c8 01       	movw	r24, r16
    25f0:	41 96       	adiw	r24, 0x11	; 17
    25f2:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    25f6:	81 30       	cpi	r24, 0x01	; 1
    25f8:	11 f4       	brne	.+4      	; 0x25fe <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    25fa:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    25fe:	0f 90       	pop	r0
    2600:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2602:	81 e0       	ldi	r24, 0x01	; 1
    2604:	52 c0       	rjmp	.+164    	; 0x26aa <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2606:	8c 81       	ldd	r24, Y+4	; 0x04
    2608:	9d 81       	ldd	r25, Y+5	; 0x05
    260a:	00 97       	sbiw	r24, 0x00	; 0
    260c:	21 f4       	brne	.+8      	; 0x2616 <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    260e:	0f 90       	pop	r0
    2610:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2612:	80 e0       	ldi	r24, 0x00	; 0
    2614:	4a c0       	rjmp	.+148    	; 0x26aa <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    2616:	ff 20       	and	r15, r15
    2618:	29 f4       	brne	.+10     	; 0x2624 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    261a:	ce 01       	movw	r24, r28
    261c:	01 96       	adiw	r24, 0x01	; 1
    261e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2622:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    2624:	0f 90       	pop	r0
    2626:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2628:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    262c:	0f b6       	in	r0, 0x3f	; 63
    262e:	f8 94       	cli
    2630:	0f 92       	push	r0
    2632:	f8 01       	movw	r30, r16
    2634:	85 8d       	ldd	r24, Z+29	; 0x1d
    2636:	8f 3f       	cpi	r24, 0xFF	; 255
    2638:	09 f4       	brne	.+2      	; 0x263c <xQueueGenericSend+0xac>
    263a:	15 8e       	std	Z+29, r1	; 0x1d
    263c:	f8 01       	movw	r30, r16
    263e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2640:	8f 3f       	cpi	r24, 0xFF	; 255
    2642:	09 f4       	brne	.+2      	; 0x2646 <xQueueGenericSend+0xb6>
    2644:	16 8e       	std	Z+30, r1	; 0x1e
    2646:	0f 90       	pop	r0
    2648:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    264a:	ce 01       	movw	r24, r28
    264c:	01 96       	adiw	r24, 0x01	; 1
    264e:	be 01       	movw	r22, r28
    2650:	6c 5f       	subi	r22, 0xFC	; 252
    2652:	7f 4f       	sbci	r23, 0xFF	; 255
    2654:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskCheckForTimeOut>
    2658:	88 23       	and	r24, r24
    265a:	09 f5       	brne	.+66     	; 0x269e <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    265c:	0f b6       	in	r0, 0x3f	; 63
    265e:	f8 94       	cli
    2660:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2662:	f8 01       	movw	r30, r16
    2664:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2666:	0f 90       	pop	r0
    2668:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    266a:	f8 01       	movw	r30, r16
    266c:	83 8d       	ldd	r24, Z+27	; 0x1b
    266e:	98 17       	cp	r25, r24
    2670:	81 f4       	brne	.+32     	; 0x2692 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2672:	6c 81       	ldd	r22, Y+4	; 0x04
    2674:	7d 81       	ldd	r23, Y+5	; 0x05
    2676:	c6 01       	movw	r24, r12
    2678:	0e 94 97 19 	call	0x332e	; 0x332e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    267c:	c8 01       	movw	r24, r16
    267e:	0e 94 b7 11 	call	0x236e	; 0x236e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2682:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
    2686:	88 23       	and	r24, r24
    2688:	09 f0       	breq	.+2      	; 0x268c <xQueueGenericSend+0xfc>
    268a:	a0 cf       	rjmp	.-192    	; 0x25cc <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    268c:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    2690:	9d cf       	rjmp	.-198    	; 0x25cc <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2692:	c8 01       	movw	r24, r16
    2694:	0e 94 b7 11 	call	0x236e	; 0x236e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2698:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
    269c:	97 cf       	rjmp	.-210    	; 0x25cc <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    269e:	c8 01       	movw	r24, r16
    26a0:	0e 94 b7 11 	call	0x236e	; 0x236e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    26a4:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    26a8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    26aa:	0f 90       	pop	r0
    26ac:	0f 90       	pop	r0
    26ae:	0f 90       	pop	r0
    26b0:	0f 90       	pop	r0
    26b2:	0f 90       	pop	r0
    26b4:	df 91       	pop	r29
    26b6:	cf 91       	pop	r28
    26b8:	1f 91       	pop	r17
    26ba:	0f 91       	pop	r16
    26bc:	ff 90       	pop	r15
    26be:	ef 90       	pop	r14
    26c0:	df 90       	pop	r13
    26c2:	cf 90       	pop	r12
    26c4:	bf 90       	pop	r11
    26c6:	9f 90       	pop	r9
    26c8:	8f 90       	pop	r8
    26ca:	08 95       	ret

000026cc <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    26cc:	cf 93       	push	r28
    26ce:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    26d0:	8f e1       	ldi	r24, 0x1F	; 31
    26d2:	90 e0       	ldi	r25, 0x00	; 0
    26d4:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
    26d8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    26da:	00 97       	sbiw	r24, 0x00	; 0
    26dc:	f9 f0       	breq	.+62     	; 0x271c <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    26de:	1b 82       	std	Y+3, r1	; 0x03
    26e0:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    26e2:	19 82       	std	Y+1, r1	; 0x01
    26e4:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    26e6:	1d 82       	std	Y+5, r1	; 0x05
    26e8:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    26ea:	1f 82       	std	Y+7, r1	; 0x07
    26ec:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    26ee:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    26f0:	81 e0       	ldi	r24, 0x01	; 1
    26f2:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    26f4:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    26f6:	8f ef       	ldi	r24, 0xFF	; 255
    26f8:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    26fa:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    26fc:	ce 01       	movw	r24, r28
    26fe:	08 96       	adiw	r24, 0x08	; 8
    2700:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2704:	ce 01       	movw	r24, r28
    2706:	41 96       	adiw	r24, 0x11	; 17
    2708:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    270c:	ce 01       	movw	r24, r28
    270e:	60 e0       	ldi	r22, 0x00	; 0
    2710:	70 e0       	ldi	r23, 0x00	; 0
    2712:	40 e0       	ldi	r20, 0x00	; 0
    2714:	50 e0       	ldi	r21, 0x00	; 0
    2716:	20 e0       	ldi	r18, 0x00	; 0
    2718:	0e 94 c8 12 	call	0x2590	; 0x2590 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    271c:	8c 2f       	mov	r24, r28
    271e:	9d 2f       	mov	r25, r29
    2720:	df 91       	pop	r29
    2722:	cf 91       	pop	r28
    2724:	08 95       	ret

00002726 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2726:	0f 93       	push	r16
    2728:	1f 93       	push	r17
    272a:	cf 93       	push	r28
    272c:	df 93       	push	r29
    272e:	ec 01       	movw	r28, r24
    2730:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2732:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2734:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2736:	98 17       	cp	r25, r24
    2738:	e0 f4       	brcc	.+56     	; 0x2772 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    273a:	ce 01       	movw	r24, r28
    273c:	42 2f       	mov	r20, r18
    273e:	0e 94 05 12 	call	0x240a	; 0x240a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2742:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2744:	8f 3f       	cpi	r24, 0xFF	; 255
    2746:	81 f4       	brne	.+32     	; 0x2768 <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2748:	89 89       	ldd	r24, Y+17	; 0x11
    274a:	88 23       	and	r24, r24
    274c:	a1 f0       	breq	.+40     	; 0x2776 <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    274e:	ce 01       	movw	r24, r28
    2750:	41 96       	adiw	r24, 0x11	; 17
    2752:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    2756:	88 23       	and	r24, r24
    2758:	81 f0       	breq	.+32     	; 0x277a <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    275a:	01 15       	cp	r16, r1
    275c:	11 05       	cpc	r17, r1
    275e:	79 f0       	breq	.+30     	; 0x277e <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	f8 01       	movw	r30, r16
    2764:	80 83       	st	Z, r24
    2766:	0c c0       	rjmp	.+24     	; 0x2780 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2768:	8e 8d       	ldd	r24, Y+30	; 0x1e
    276a:	8f 5f       	subi	r24, 0xFF	; 255
    276c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	07 c0       	rjmp	.+14     	; 0x2780 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2772:	80 e0       	ldi	r24, 0x00	; 0
    2774:	05 c0       	rjmp	.+10     	; 0x2780 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2776:	81 e0       	ldi	r24, 0x01	; 1
    2778:	03 c0       	rjmp	.+6      	; 0x2780 <xQueueGenericSendFromISR+0x5a>
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	01 c0       	rjmp	.+2      	; 0x2780 <xQueueGenericSendFromISR+0x5a>
    277e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2780:	df 91       	pop	r29
    2782:	cf 91       	pop	r28
    2784:	1f 91       	pop	r17
    2786:	0f 91       	pop	r16
    2788:	08 95       	ret

0000278a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    278a:	8f 92       	push	r8
    278c:	9f 92       	push	r9
    278e:	bf 92       	push	r11
    2790:	cf 92       	push	r12
    2792:	df 92       	push	r13
    2794:	ef 92       	push	r14
    2796:	ff 92       	push	r15
    2798:	0f 93       	push	r16
    279a:	1f 93       	push	r17
    279c:	cf 93       	push	r28
    279e:	df 93       	push	r29
    27a0:	00 d0       	rcall	.+0      	; 0x27a2 <xQueueGenericReceive+0x18>
    27a2:	0f 92       	push	r0
    27a4:	0f 92       	push	r0
    27a6:	cd b7       	in	r28, 0x3d	; 61
    27a8:	de b7       	in	r29, 0x3e	; 62
    27aa:	8c 01       	movw	r16, r24
    27ac:	4b 01       	movw	r8, r22
    27ae:	5d 83       	std	Y+5, r21	; 0x05
    27b0:	4c 83       	std	Y+4, r20	; 0x04
    27b2:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    27b4:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    27b6:	ee 24       	eor	r14, r14
    27b8:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    27ba:	0f 2e       	mov	r0, r31
    27bc:	f1 e1       	ldi	r31, 0x11	; 17
    27be:	cf 2e       	mov	r12, r31
    27c0:	dd 24       	eor	r13, r13
    27c2:	f0 2d       	mov	r31, r0
    27c4:	c8 0e       	add	r12, r24
    27c6:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    27c8:	0f b6       	in	r0, 0x3f	; 63
    27ca:	f8 94       	cli
    27cc:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    27ce:	f8 01       	movw	r30, r16
    27d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    27d2:	88 23       	and	r24, r24
    27d4:	a1 f1       	breq	.+104    	; 0x283e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    27d6:	e6 80       	ldd	r14, Z+6	; 0x06
    27d8:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    27da:	c8 01       	movw	r24, r16
    27dc:	b4 01       	movw	r22, r8
    27de:	0e 94 88 11 	call	0x2310	; 0x2310 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    27e2:	bb 20       	and	r11, r11
    27e4:	d1 f4       	brne	.+52     	; 0x281a <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    27e6:	f8 01       	movw	r30, r16
    27e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    27ea:	81 50       	subi	r24, 0x01	; 1
    27ec:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    27ee:	80 81       	ld	r24, Z
    27f0:	91 81       	ldd	r25, Z+1	; 0x01
    27f2:	00 97       	sbiw	r24, 0x00	; 0
    27f4:	29 f4       	brne	.+10     	; 0x2800 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    27f6:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <xTaskGetCurrentTaskHandle>
    27fa:	f8 01       	movw	r30, r16
    27fc:	93 83       	std	Z+3, r25	; 0x03
    27fe:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2800:	f8 01       	movw	r30, r16
    2802:	80 85       	ldd	r24, Z+8	; 0x08
    2804:	88 23       	and	r24, r24
    2806:	b9 f0       	breq	.+46     	; 0x2836 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2808:	c8 01       	movw	r24, r16
    280a:	08 96       	adiw	r24, 0x08	; 8
    280c:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    2810:	81 30       	cpi	r24, 0x01	; 1
    2812:	89 f4       	brne	.+34     	; 0x2836 <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    2814:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    2818:	0e c0       	rjmp	.+28     	; 0x2836 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    281a:	f8 01       	movw	r30, r16
    281c:	f7 82       	std	Z+7, r15	; 0x07
    281e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2820:	81 89       	ldd	r24, Z+17	; 0x11
    2822:	88 23       	and	r24, r24
    2824:	41 f0       	breq	.+16     	; 0x2836 <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2826:	c8 01       	movw	r24, r16
    2828:	41 96       	adiw	r24, 0x11	; 17
    282a:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    282e:	88 23       	and	r24, r24
    2830:	11 f0       	breq	.+4      	; 0x2836 <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2832:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    2836:	0f 90       	pop	r0
    2838:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    283a:	81 e0       	ldi	r24, 0x01	; 1
    283c:	5f c0       	rjmp	.+190    	; 0x28fc <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    283e:	8c 81       	ldd	r24, Y+4	; 0x04
    2840:	9d 81       	ldd	r25, Y+5	; 0x05
    2842:	00 97       	sbiw	r24, 0x00	; 0
    2844:	21 f4       	brne	.+8      	; 0x284e <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2846:	0f 90       	pop	r0
    2848:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	57 c0       	rjmp	.+174    	; 0x28fc <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    284e:	ff 20       	and	r15, r15
    2850:	29 f4       	brne	.+10     	; 0x285c <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2852:	ce 01       	movw	r24, r28
    2854:	01 96       	adiw	r24, 0x01	; 1
    2856:	0e 94 0b 1a 	call	0x3416	; 0x3416 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    285a:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    285c:	0f 90       	pop	r0
    285e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2860:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	f8 94       	cli
    2868:	0f 92       	push	r0
    286a:	f8 01       	movw	r30, r16
    286c:	85 8d       	ldd	r24, Z+29	; 0x1d
    286e:	8f 3f       	cpi	r24, 0xFF	; 255
    2870:	09 f4       	brne	.+2      	; 0x2874 <xQueueGenericReceive+0xea>
    2872:	15 8e       	std	Z+29, r1	; 0x1d
    2874:	f8 01       	movw	r30, r16
    2876:	86 8d       	ldd	r24, Z+30	; 0x1e
    2878:	8f 3f       	cpi	r24, 0xFF	; 255
    287a:	09 f4       	brne	.+2      	; 0x287e <xQueueGenericReceive+0xf4>
    287c:	16 8e       	std	Z+30, r1	; 0x1e
    287e:	0f 90       	pop	r0
    2880:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2882:	ce 01       	movw	r24, r28
    2884:	01 96       	adiw	r24, 0x01	; 1
    2886:	be 01       	movw	r22, r28
    2888:	6c 5f       	subi	r22, 0xFC	; 252
    288a:	7f 4f       	sbci	r23, 0xFF	; 255
    288c:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskCheckForTimeOut>
    2890:	88 23       	and	r24, r24
    2892:	71 f5       	brne	.+92     	; 0x28f0 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2894:	0f b6       	in	r0, 0x3f	; 63
    2896:	f8 94       	cli
    2898:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    289a:	f8 01       	movw	r30, r16
    289c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    289e:	0f 90       	pop	r0
    28a0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    28a2:	88 23       	and	r24, r24
    28a4:	f9 f4       	brne	.+62     	; 0x28e4 <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28a6:	f8 01       	movw	r30, r16
    28a8:	80 81       	ld	r24, Z
    28aa:	91 81       	ldd	r25, Z+1	; 0x01
    28ac:	00 97       	sbiw	r24, 0x00	; 0
    28ae:	51 f4       	brne	.+20     	; 0x28c4 <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	f8 94       	cli
    28b4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    28b6:	f8 01       	movw	r30, r16
    28b8:	82 81       	ldd	r24, Z+2	; 0x02
    28ba:	93 81       	ldd	r25, Z+3	; 0x03
    28bc:	0e 94 76 1a 	call	0x34ec	; 0x34ec <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    28c0:	0f 90       	pop	r0
    28c2:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28c4:	6c 81       	ldd	r22, Y+4	; 0x04
    28c6:	7d 81       	ldd	r23, Y+5	; 0x05
    28c8:	c6 01       	movw	r24, r12
    28ca:	0e 94 97 19 	call	0x332e	; 0x332e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    28ce:	c8 01       	movw	r24, r16
    28d0:	0e 94 b7 11 	call	0x236e	; 0x236e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    28d4:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
    28d8:	88 23       	and	r24, r24
    28da:	09 f0       	breq	.+2      	; 0x28de <xQueueGenericReceive+0x154>
    28dc:	75 cf       	rjmp	.-278    	; 0x27c8 <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    28de:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    28e2:	72 cf       	rjmp	.-284    	; 0x27c8 <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    28e4:	c8 01       	movw	r24, r16
    28e6:	0e 94 b7 11 	call	0x236e	; 0x236e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    28ea:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
    28ee:	6c cf       	rjmp	.-296    	; 0x27c8 <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    28f0:	c8 01       	movw	r24, r16
    28f2:	0e 94 b7 11 	call	0x236e	; 0x236e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    28f6:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    28fa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    28fc:	0f 90       	pop	r0
    28fe:	0f 90       	pop	r0
    2900:	0f 90       	pop	r0
    2902:	0f 90       	pop	r0
    2904:	0f 90       	pop	r0
    2906:	df 91       	pop	r29
    2908:	cf 91       	pop	r28
    290a:	1f 91       	pop	r17
    290c:	0f 91       	pop	r16
    290e:	ff 90       	pop	r15
    2910:	ef 90       	pop	r14
    2912:	df 90       	pop	r13
    2914:	cf 90       	pop	r12
    2916:	bf 90       	pop	r11
    2918:	9f 90       	pop	r9
    291a:	8f 90       	pop	r8
    291c:	08 95       	ret

0000291e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    291e:	0f 93       	push	r16
    2920:	1f 93       	push	r17
    2922:	cf 93       	push	r28
    2924:	df 93       	push	r29
    2926:	ec 01       	movw	r28, r24
    2928:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    292a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    292c:	88 23       	and	r24, r24
    292e:	f1 f0       	breq	.+60     	; 0x296c <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2930:	ce 01       	movw	r24, r28
    2932:	0e 94 88 11 	call	0x2310	; 0x2310 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2936:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2938:	81 50       	subi	r24, 0x01	; 1
    293a:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    293c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    293e:	8f 3f       	cpi	r24, 0xFF	; 255
    2940:	81 f4       	brne	.+32     	; 0x2962 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2942:	88 85       	ldd	r24, Y+8	; 0x08
    2944:	88 23       	and	r24, r24
    2946:	a1 f0       	breq	.+40     	; 0x2970 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2948:	ce 01       	movw	r24, r28
    294a:	08 96       	adiw	r24, 0x08	; 8
    294c:	0e 94 c3 19 	call	0x3386	; 0x3386 <xTaskRemoveFromEventList>
    2950:	88 23       	and	r24, r24
    2952:	81 f0       	breq	.+32     	; 0x2974 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2954:	01 15       	cp	r16, r1
    2956:	11 05       	cpc	r17, r1
    2958:	79 f0       	breq	.+30     	; 0x2978 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	f8 01       	movw	r30, r16
    295e:	80 83       	st	Z, r24
    2960:	0c c0       	rjmp	.+24     	; 0x297a <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2962:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2964:	8f 5f       	subi	r24, 0xFF	; 255
    2966:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	07 c0       	rjmp	.+14     	; 0x297a <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    296c:	80 e0       	ldi	r24, 0x00	; 0
    296e:	05 c0       	rjmp	.+10     	; 0x297a <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	03 c0       	rjmp	.+6      	; 0x297a <xQueueReceiveFromISR+0x5c>
    2974:	81 e0       	ldi	r24, 0x01	; 1
    2976:	01 c0       	rjmp	.+2      	; 0x297a <xQueueReceiveFromISR+0x5c>
    2978:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    297a:	df 91       	pop	r29
    297c:	cf 91       	pop	r28
    297e:	1f 91       	pop	r17
    2980:	0f 91       	pop	r16
    2982:	08 95       	ret

00002984 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2984:	0f b6       	in	r0, 0x3f	; 63
    2986:	f8 94       	cli
    2988:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    298a:	fc 01       	movw	r30, r24
    298c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    298e:	0f 90       	pop	r0
    2990:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2992:	08 95       	ret

00002994 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2994:	fc 01       	movw	r30, r24
    2996:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    2998:	08 95       	ret

0000299a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    299a:	cf 93       	push	r28
    299c:	df 93       	push	r29
    299e:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    29a0:	88 81       	ld	r24, Y
    29a2:	99 81       	ldd	r25, Y+1	; 0x01
    29a4:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
	vPortFree( pxQueue );
    29a8:	ce 01       	movw	r24, r28
    29aa:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
}
    29ae:	df 91       	pop	r29
    29b0:	cf 91       	pop	r28
    29b2:	08 95       	ret

000029b4 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    29b4:	fc 01       	movw	r30, r24
    29b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    29b8:	81 e0       	ldi	r24, 0x01	; 1
    29ba:	91 11       	cpse	r25, r1
    29bc:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    29be:	08 95       	ret

000029c0 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    29c0:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    29c2:	22 8d       	ldd	r18, Z+26	; 0x1a
    29c4:	81 e0       	ldi	r24, 0x01	; 1
    29c6:	93 8d       	ldd	r25, Z+27	; 0x1b
    29c8:	29 13       	cpse	r18, r25
    29ca:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    29cc:	08 95       	ret

000029ce <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    29ce:	cf 93       	push	r28
    29d0:	df 93       	push	r29
    29d2:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    29d4:	e0 91 ce 1a 	lds	r30, 0x1ACE
    29d8:	f0 91 cf 1a 	lds	r31, 0x1ACF
    29dc:	93 83       	std	Z+3, r25	; 0x03
    29de:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    29e0:	80 91 d6 1a 	lds	r24, 0x1AD6
    29e4:	90 91 d7 1a 	lds	r25, 0x1AD7
    29e8:	c8 17       	cp	r28, r24
    29ea:	d9 07       	cpc	r29, r25
    29ec:	68 f4       	brcc	.+26     	; 0x2a08 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    29ee:	80 91 d9 1a 	lds	r24, 0x1AD9
    29f2:	90 91 da 1a 	lds	r25, 0x1ADA
    29f6:	60 91 ce 1a 	lds	r22, 0x1ACE
    29fa:	70 91 cf 1a 	lds	r23, 0x1ACF
    29fe:	6e 5f       	subi	r22, 0xFE	; 254
    2a00:	7f 4f       	sbci	r23, 0xFF	; 255
    2a02:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsert>
    2a06:	17 c0       	rjmp	.+46     	; 0x2a36 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a08:	80 91 db 1a 	lds	r24, 0x1ADB
    2a0c:	90 91 dc 1a 	lds	r25, 0x1ADC
    2a10:	60 91 ce 1a 	lds	r22, 0x1ACE
    2a14:	70 91 cf 1a 	lds	r23, 0x1ACF
    2a18:	6e 5f       	subi	r22, 0xFE	; 254
    2a1a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a1c:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2a20:	80 91 59 02 	lds	r24, 0x0259
    2a24:	90 91 5a 02 	lds	r25, 0x025A
    2a28:	c8 17       	cp	r28, r24
    2a2a:	d9 07       	cpc	r29, r25
    2a2c:	20 f4       	brcc	.+8      	; 0x2a36 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2a2e:	d0 93 5a 02 	sts	0x025A, r29
    2a32:	c0 93 59 02 	sts	0x0259, r28
		}
	}
}
    2a36:	df 91       	pop	r29
    2a38:	cf 91       	pop	r28
    2a3a:	08 95       	ret

00002a3c <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2a3c:	cf ed       	ldi	r28, 0xDF	; 223
    2a3e:	da e1       	ldi	r29, 0x1A	; 26
    2a40:	88 81       	ld	r24, Y
    2a42:	82 30       	cpi	r24, 0x02	; 2
    2a44:	e8 f3       	brcs	.-6      	; 0x2a40 <prvIdleTask+0x4>
			{
				taskYIELD();
    2a46:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    2a4a:	fa cf       	rjmp	.-12     	; 0x2a40 <prvIdleTask+0x4>

00002a4c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2a4c:	4f 92       	push	r4
    2a4e:	5f 92       	push	r5
    2a50:	6f 92       	push	r6
    2a52:	7f 92       	push	r7
    2a54:	8f 92       	push	r8
    2a56:	9f 92       	push	r9
    2a58:	bf 92       	push	r11
    2a5a:	cf 92       	push	r12
    2a5c:	df 92       	push	r13
    2a5e:	ef 92       	push	r14
    2a60:	ff 92       	push	r15
    2a62:	0f 93       	push	r16
    2a64:	1f 93       	push	r17
    2a66:	cf 93       	push	r28
    2a68:	df 93       	push	r29
    2a6a:	2c 01       	movw	r4, r24
    2a6c:	4b 01       	movw	r8, r22
    2a6e:	ea 01       	movw	r28, r20
    2a70:	39 01       	movw	r6, r18
    2a72:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2a74:	8a e2       	ldi	r24, 0x2A	; 42
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
    2a7c:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    2a7e:	00 97       	sbiw	r24, 0x00	; 0
    2a80:	09 f4       	brne	.+2      	; 0x2a84 <xTaskGenericCreate+0x38>
    2a82:	e3 c0       	rjmp	.+454    	; 0x2c4a <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2a84:	c1 14       	cp	r12, r1
    2a86:	d1 04       	cpc	r13, r1
    2a88:	09 f0       	breq	.+2      	; 0x2a8c <xTaskGenericCreate+0x40>
    2a8a:	f4 c0       	rjmp	.+488    	; 0x2c74 <xTaskGenericCreate+0x228>
    2a8c:	ce 01       	movw	r24, r28
    2a8e:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
    2a92:	6c 01       	movw	r12, r24
    2a94:	f8 01       	movw	r30, r16
    2a96:	90 8f       	std	Z+24, r25	; 0x18
    2a98:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2a9a:	00 97       	sbiw	r24, 0x00	; 0
    2a9c:	29 f4       	brne	.+10     	; 0x2aa8 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2a9e:	c8 01       	movw	r24, r16
    2aa0:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2aa4:	8f ef       	ldi	r24, 0xFF	; 255
    2aa6:	d6 c0       	rjmp	.+428    	; 0x2c54 <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2aa8:	c6 01       	movw	r24, r12
    2aaa:	65 ea       	ldi	r22, 0xA5	; 165
    2aac:	70 e0       	ldi	r23, 0x00	; 0
    2aae:	ae 01       	movw	r20, r28
    2ab0:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2ab4:	9e 01       	movw	r18, r28
    2ab6:	21 50       	subi	r18, 0x01	; 1
    2ab8:	30 40       	sbci	r19, 0x00	; 0
    2aba:	f8 01       	movw	r30, r16
    2abc:	87 89       	ldd	r24, Z+23	; 0x17
    2abe:	90 8d       	ldd	r25, Z+24	; 0x18
    2ac0:	6c 01       	movw	r12, r24
    2ac2:	c2 0e       	add	r12, r18
    2ac4:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2ac6:	c8 01       	movw	r24, r16
    2ac8:	49 96       	adiw	r24, 0x19	; 25
    2aca:	b4 01       	movw	r22, r8
    2acc:	40 e1       	ldi	r20, 0x10	; 16
    2ace:	50 e0       	ldi	r21, 0x00	; 0
    2ad0:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2ad4:	f8 01       	movw	r30, r16
    2ad6:	10 a6       	lds	r17, 0xb0
    2ad8:	cb 2d       	mov	r28, r11
    2ada:	f3 e0       	ldi	r31, 0x03	; 3
    2adc:	fb 15       	cp	r31, r11
    2ade:	08 f4       	brcc	.+2      	; 0x2ae2 <xTaskGenericCreate+0x96>
    2ae0:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    2ae2:	f8 01       	movw	r30, r16
    2ae4:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    2ae6:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2ae8:	88 24       	eor	r8, r8
    2aea:	99 24       	eor	r9, r9
    2aec:	68 94       	set
    2aee:	81 f8       	bld	r8, 1
    2af0:	80 0e       	add	r8, r16
    2af2:	91 1e       	adc	r9, r17
    2af4:	c4 01       	movw	r24, r8
    2af6:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2afa:	c8 01       	movw	r24, r16
    2afc:	0c 96       	adiw	r24, 0x0c	; 12
    2afe:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2b02:	f8 01       	movw	r30, r16
    2b04:	11 87       	std	Z+9, r17	; 0x09
    2b06:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2b08:	84 e0       	ldi	r24, 0x04	; 4
    2b0a:	90 e0       	ldi	r25, 0x00	; 0
    2b0c:	8c 1b       	sub	r24, r28
    2b0e:	91 09       	sbc	r25, r1
    2b10:	95 87       	std	Z+13, r25	; 0x0d
    2b12:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2b14:	13 8b       	std	Z+19, r17	; 0x13
    2b16:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2b18:	c6 01       	movw	r24, r12
    2b1a:	b2 01       	movw	r22, r4
    2b1c:	a3 01       	movw	r20, r6
    2b1e:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <pxPortInitialiseStack>
    2b22:	f8 01       	movw	r30, r16
    2b24:	91 83       	std	Z+1, r25	; 0x01
    2b26:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2b28:	e1 14       	cp	r14, r1
    2b2a:	f1 04       	cpc	r15, r1
    2b2c:	19 f0       	breq	.+6      	; 0x2b34 <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2b2e:	f7 01       	movw	r30, r14
    2b30:	11 83       	std	Z+1, r17	; 0x01
    2b32:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2b3a:	80 91 d8 1a 	lds	r24, 0x1AD8
    2b3e:	8f 5f       	subi	r24, 0xFF	; 255
    2b40:	80 93 d8 1a 	sts	0x1AD8, r24
			if( pxCurrentTCB == NULL )
    2b44:	80 91 ce 1a 	lds	r24, 0x1ACE
    2b48:	90 91 cf 1a 	lds	r25, 0x1ACF
    2b4c:	00 97       	sbiw	r24, 0x00	; 0
    2b4e:	d9 f5       	brne	.+118    	; 0x2bc6 <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2b50:	10 93 cf 1a 	sts	0x1ACF, r17
    2b54:	00 93 ce 1a 	sts	0x1ACE, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2b58:	80 91 d8 1a 	lds	r24, 0x1AD8
    2b5c:	81 30       	cpi	r24, 0x01	; 1
    2b5e:	09 f0       	breq	.+2      	; 0x2b62 <xTaskGenericCreate+0x116>
    2b60:	41 c0       	rjmp	.+130    	; 0x2be4 <xTaskGenericCreate+0x198>
    2b62:	c0 e0       	ldi	r28, 0x00	; 0
    2b64:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2b66:	ce 01       	movw	r24, r28
    2b68:	88 0f       	add	r24, r24
    2b6a:	99 1f       	adc	r25, r25
    2b6c:	88 0f       	add	r24, r24
    2b6e:	99 1f       	adc	r25, r25
    2b70:	88 0f       	add	r24, r24
    2b72:	99 1f       	adc	r25, r25
    2b74:	8c 0f       	add	r24, r28
    2b76:	9d 1f       	adc	r25, r29
    2b78:	81 52       	subi	r24, 0x21	; 33
    2b7a:	95 4e       	sbci	r25, 0xE5	; 229
    2b7c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
    2b80:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2b82:	c4 30       	cpi	r28, 0x04	; 4
    2b84:	d1 05       	cpc	r29, r1
    2b86:	79 f7       	brne	.-34     	; 0x2b66 <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2b88:	c3 e0       	ldi	r28, 0x03	; 3
    2b8a:	db e1       	ldi	r29, 0x1B	; 27
    2b8c:	ce 01       	movw	r24, r28
    2b8e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2b92:	0f 2e       	mov	r0, r31
    2b94:	fc e0       	ldi	r31, 0x0C	; 12
    2b96:	ef 2e       	mov	r14, r31
    2b98:	fb e1       	ldi	r31, 0x1B	; 27
    2b9a:	ff 2e       	mov	r15, r31
    2b9c:	f0 2d       	mov	r31, r0
    2b9e:	c7 01       	movw	r24, r14
    2ba0:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2ba4:	85 e1       	ldi	r24, 0x15	; 21
    2ba6:	9b e1       	ldi	r25, 0x1B	; 27
    2ba8:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    2bac:	8e e1       	ldi	r24, 0x1E	; 30
    2bae:	9b e1       	ldi	r25, 0x1B	; 27
    2bb0:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2bb4:	d0 93 dc 1a 	sts	0x1ADC, r29
    2bb8:	c0 93 db 1a 	sts	0x1ADB, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2bbc:	f0 92 da 1a 	sts	0x1ADA, r15
    2bc0:	e0 92 d9 1a 	sts	0x1AD9, r14
    2bc4:	0f c0       	rjmp	.+30     	; 0x2be4 <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2bc6:	80 91 d4 1a 	lds	r24, 0x1AD4
    2bca:	88 23       	and	r24, r24
    2bcc:	59 f4       	brne	.+22     	; 0x2be4 <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2bce:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2bd2:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2bd6:	86 89       	ldd	r24, Z+22	; 0x16
    2bd8:	b8 16       	cp	r11, r24
    2bda:	20 f0       	brcs	.+8      	; 0x2be4 <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    2bdc:	10 93 cf 1a 	sts	0x1ACF, r17
    2be0:	00 93 ce 1a 	sts	0x1ACE, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2be4:	f8 01       	movw	r30, r16
    2be6:	86 89       	ldd	r24, Z+22	; 0x16
    2be8:	90 91 dd 1a 	lds	r25, 0x1ADD
    2bec:	98 17       	cp	r25, r24
    2bee:	10 f4       	brcc	.+4      	; 0x2bf4 <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2bf0:	80 93 dd 1a 	sts	0x1ADD, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2bf4:	90 91 de 1a 	lds	r25, 0x1ADE
    2bf8:	9f 5f       	subi	r25, 0xFF	; 255
    2bfa:	90 93 de 1a 	sts	0x1ADE, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    2bfe:	90 91 d5 1a 	lds	r25, 0x1AD5
    2c02:	98 17       	cp	r25, r24
    2c04:	10 f4       	brcc	.+4      	; 0x2c0a <xTaskGenericCreate+0x1be>
    2c06:	80 93 d5 1a 	sts	0x1AD5, r24
    2c0a:	90 e0       	ldi	r25, 0x00	; 0
    2c0c:	9c 01       	movw	r18, r24
    2c0e:	22 0f       	add	r18, r18
    2c10:	33 1f       	adc	r19, r19
    2c12:	22 0f       	add	r18, r18
    2c14:	33 1f       	adc	r19, r19
    2c16:	22 0f       	add	r18, r18
    2c18:	33 1f       	adc	r19, r19
    2c1a:	82 0f       	add	r24, r18
    2c1c:	93 1f       	adc	r25, r19
    2c1e:	81 52       	subi	r24, 0x21	; 33
    2c20:	95 4e       	sbci	r25, 0xE5	; 229
    2c22:	b4 01       	movw	r22, r8
    2c24:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2c28:	0f 90       	pop	r0
    2c2a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2c2c:	80 91 d4 1a 	lds	r24, 0x1AD4
    2c30:	88 23       	and	r24, r24
    2c32:	69 f0       	breq	.+26     	; 0x2c4e <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2c34:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2c38:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2c3c:	86 89       	ldd	r24, Z+22	; 0x16
    2c3e:	8b 15       	cp	r24, r11
    2c40:	40 f4       	brcc	.+16     	; 0x2c52 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    2c42:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	05 c0       	rjmp	.+10     	; 0x2c54 <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2c4a:	8f ef       	ldi	r24, 0xFF	; 255
    2c4c:	03 c0       	rjmp	.+6      	; 0x2c54 <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2c4e:	81 e0       	ldi	r24, 0x01	; 1
    2c50:	01 c0       	rjmp	.+2      	; 0x2c54 <xTaskGenericCreate+0x208>
    2c52:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2c54:	df 91       	pop	r29
    2c56:	cf 91       	pop	r28
    2c58:	1f 91       	pop	r17
    2c5a:	0f 91       	pop	r16
    2c5c:	ff 90       	pop	r15
    2c5e:	ef 90       	pop	r14
    2c60:	df 90       	pop	r13
    2c62:	cf 90       	pop	r12
    2c64:	bf 90       	pop	r11
    2c66:	9f 90       	pop	r9
    2c68:	8f 90       	pop	r8
    2c6a:	7f 90       	pop	r7
    2c6c:	6f 90       	pop	r6
    2c6e:	5f 90       	pop	r5
    2c70:	4f 90       	pop	r4
    2c72:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2c74:	fc 01       	movw	r30, r24
    2c76:	d0 8e       	std	Z+24, r13	; 0x18
    2c78:	c7 8a       	std	Z+23, r12	; 0x17
    2c7a:	16 cf       	rjmp	.-468    	; 0x2aa8 <xTaskGenericCreate+0x5c>

00002c7c <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2c7c:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2c7e:	82 85       	ldd	r24, Z+10	; 0x0a
    2c80:	93 85       	ldd	r25, Z+11	; 0x0b
    2c82:	2b e1       	ldi	r18, 0x1B	; 27
    2c84:	8e 31       	cpi	r24, 0x1E	; 30
    2c86:	92 07       	cpc	r25, r18
    2c88:	61 f4       	brne	.+24     	; 0x2ca2 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    2c8a:	24 89       	ldd	r18, Z+20	; 0x14
    2c8c:	35 89       	ldd	r19, Z+21	; 0x15
    2c8e:	8b e1       	ldi	r24, 0x1B	; 27
    2c90:	25 31       	cpi	r18, 0x15	; 21
    2c92:	38 07       	cpc	r19, r24
    2c94:	41 f0       	breq	.+16     	; 0x2ca6 <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    2c96:	81 e0       	ldi	r24, 0x01	; 1
    2c98:	21 15       	cp	r18, r1
    2c9a:	31 05       	cpc	r19, r1
    2c9c:	29 f0       	breq	.+10     	; 0x2ca8 <xTaskIsTaskSuspended+0x2c>
    2c9e:	80 e0       	ldi	r24, 0x00	; 0
    2ca0:	08 95       	ret
    2ca2:	80 e0       	ldi	r24, 0x00	; 0
    2ca4:	08 95       	ret
    2ca6:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    2ca8:	08 95       	ret

00002caa <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    2caa:	0f 93       	push	r16
    2cac:	1f 93       	push	r17
    2cae:	cf 93       	push	r28
    2cb0:	df 93       	push	r29
    2cb2:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    2cb4:	00 97       	sbiw	r24, 0x00	; 0
    2cb6:	b9 f1       	breq	.+110    	; 0x2d26 <vTaskResume+0x7c>
    2cb8:	80 91 ce 1a 	lds	r24, 0x1ACE
    2cbc:	90 91 cf 1a 	lds	r25, 0x1ACF
    2cc0:	c8 17       	cp	r28, r24
    2cc2:	d9 07       	cpc	r29, r25
    2cc4:	81 f1       	breq	.+96     	; 0x2d26 <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    2cc6:	0f b6       	in	r0, 0x3f	; 63
    2cc8:	f8 94       	cli
    2cca:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2ccc:	ce 01       	movw	r24, r28
    2cce:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xTaskIsTaskSuspended>
    2cd2:	81 30       	cpi	r24, 0x01	; 1
    2cd4:	31 f5       	brne	.+76     	; 0x2d22 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    2cd6:	8e 01       	movw	r16, r28
    2cd8:	0e 5f       	subi	r16, 0xFE	; 254
    2cda:	1f 4f       	sbci	r17, 0xFF	; 255
    2cdc:	c8 01       	movw	r24, r16
    2cde:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2ce2:	8e 89       	ldd	r24, Y+22	; 0x16
    2ce4:	90 91 d5 1a 	lds	r25, 0x1AD5
    2ce8:	98 17       	cp	r25, r24
    2cea:	10 f4       	brcc	.+4      	; 0x2cf0 <vTaskResume+0x46>
    2cec:	80 93 d5 1a 	sts	0x1AD5, r24
    2cf0:	90 e0       	ldi	r25, 0x00	; 0
    2cf2:	9c 01       	movw	r18, r24
    2cf4:	22 0f       	add	r18, r18
    2cf6:	33 1f       	adc	r19, r19
    2cf8:	22 0f       	add	r18, r18
    2cfa:	33 1f       	adc	r19, r19
    2cfc:	22 0f       	add	r18, r18
    2cfe:	33 1f       	adc	r19, r19
    2d00:	82 0f       	add	r24, r18
    2d02:	93 1f       	adc	r25, r19
    2d04:	81 52       	subi	r24, 0x21	; 33
    2d06:	95 4e       	sbci	r25, 0xE5	; 229
    2d08:	b8 01       	movw	r22, r16
    2d0a:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2d0e:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2d12:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2d16:	9e 89       	ldd	r25, Y+22	; 0x16
    2d18:	86 89       	ldd	r24, Z+22	; 0x16
    2d1a:	98 17       	cp	r25, r24
    2d1c:	10 f0       	brcs	.+4      	; 0x2d22 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    2d1e:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    2d22:	0f 90       	pop	r0
    2d24:	0f be       	out	0x3f, r0	; 63
		}
	}
    2d26:	df 91       	pop	r29
    2d28:	cf 91       	pop	r28
    2d2a:	1f 91       	pop	r17
    2d2c:	0f 91       	pop	r16
    2d2e:	08 95       	ret

00002d30 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    2d30:	ef 92       	push	r14
    2d32:	ff 92       	push	r15
    2d34:	1f 93       	push	r17
    2d36:	cf 93       	push	r28
    2d38:	df 93       	push	r29
    2d3a:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2d3c:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xTaskIsTaskSuspended>
    2d40:	81 30       	cpi	r24, 0x01	; 1
    2d42:	b9 f5       	brne	.+110    	; 0x2db2 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d44:	80 91 d3 1a 	lds	r24, 0x1AD3
    2d48:	88 23       	and	r24, r24
    2d4a:	51 f5       	brne	.+84     	; 0x2da0 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    2d4c:	e0 91 ce 1a 	lds	r30, 0x1ACE
    2d50:	f0 91 cf 1a 	lds	r31, 0x1ACF
    2d54:	11 e0       	ldi	r17, 0x01	; 1
    2d56:	9e 89       	ldd	r25, Y+22	; 0x16
    2d58:	86 89       	ldd	r24, Z+22	; 0x16
    2d5a:	98 17       	cp	r25, r24
    2d5c:	08 f4       	brcc	.+2      	; 0x2d60 <xTaskResumeFromISR+0x30>
    2d5e:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    2d60:	ee 24       	eor	r14, r14
    2d62:	ff 24       	eor	r15, r15
    2d64:	68 94       	set
    2d66:	e1 f8       	bld	r14, 1
    2d68:	ec 0e       	add	r14, r28
    2d6a:	fd 1e       	adc	r15, r29
    2d6c:	c7 01       	movw	r24, r14
    2d6e:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2d72:	8e 89       	ldd	r24, Y+22	; 0x16
    2d74:	90 91 d5 1a 	lds	r25, 0x1AD5
    2d78:	98 17       	cp	r25, r24
    2d7a:	10 f4       	brcc	.+4      	; 0x2d80 <xTaskResumeFromISR+0x50>
    2d7c:	80 93 d5 1a 	sts	0x1AD5, r24
    2d80:	90 e0       	ldi	r25, 0x00	; 0
    2d82:	9c 01       	movw	r18, r24
    2d84:	22 0f       	add	r18, r18
    2d86:	33 1f       	adc	r19, r19
    2d88:	22 0f       	add	r18, r18
    2d8a:	33 1f       	adc	r19, r19
    2d8c:	22 0f       	add	r18, r18
    2d8e:	33 1f       	adc	r19, r19
    2d90:	82 0f       	add	r24, r18
    2d92:	93 1f       	adc	r25, r19
    2d94:	81 52       	subi	r24, 0x21	; 33
    2d96:	95 4e       	sbci	r25, 0xE5	; 229
    2d98:	b7 01       	movw	r22, r14
    2d9a:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
    2d9e:	0a c0       	rjmp	.+20     	; 0x2db4 <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2da0:	be 01       	movw	r22, r28
    2da2:	64 5f       	subi	r22, 0xF4	; 244
    2da4:	7f 4f       	sbci	r23, 0xFF	; 255
    2da6:	85 e1       	ldi	r24, 0x15	; 21
    2da8:	9b e1       	ldi	r25, 0x1B	; 27
    2daa:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    2dae:	10 e0       	ldi	r17, 0x00	; 0
    2db0:	01 c0       	rjmp	.+2      	; 0x2db4 <xTaskResumeFromISR+0x84>
    2db2:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    2db4:	81 2f       	mov	r24, r17
    2db6:	df 91       	pop	r29
    2db8:	cf 91       	pop	r28
    2dba:	1f 91       	pop	r17
    2dbc:	ff 90       	pop	r15
    2dbe:	ef 90       	pop	r14
    2dc0:	08 95       	ret

00002dc2 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2dc2:	af 92       	push	r10
    2dc4:	bf 92       	push	r11
    2dc6:	cf 92       	push	r12
    2dc8:	df 92       	push	r13
    2dca:	ef 92       	push	r14
    2dcc:	ff 92       	push	r15
    2dce:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2dd0:	8e e1       	ldi	r24, 0x1E	; 30
    2dd2:	95 e1       	ldi	r25, 0x15	; 21
    2dd4:	64 e5       	ldi	r22, 0x54	; 84
    2dd6:	72 e0       	ldi	r23, 0x02	; 2
    2dd8:	45 e5       	ldi	r20, 0x55	; 85
    2dda:	50 e0       	ldi	r21, 0x00	; 0
    2ddc:	20 e0       	ldi	r18, 0x00	; 0
    2dde:	30 e0       	ldi	r19, 0x00	; 0
    2de0:	00 e0       	ldi	r16, 0x00	; 0
    2de2:	ee 24       	eor	r14, r14
    2de4:	ff 24       	eor	r15, r15
    2de6:	cc 24       	eor	r12, r12
    2de8:	dd 24       	eor	r13, r13
    2dea:	aa 24       	eor	r10, r10
    2dec:	bb 24       	eor	r11, r11
    2dee:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2df2:	81 30       	cpi	r24, 0x01	; 1
    2df4:	49 f4       	brne	.+18     	; 0x2e08 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2df6:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2df8:	80 93 d4 1a 	sts	0x1AD4, r24
		xTickCount = ( portTickType ) 0U;
    2dfc:	10 92 d7 1a 	sts	0x1AD7, r1
    2e00:	10 92 d6 1a 	sts	0x1AD6, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2e04:	0e 94 82 10 	call	0x2104	; 0x2104 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2e08:	0f 91       	pop	r16
    2e0a:	ff 90       	pop	r15
    2e0c:	ef 90       	pop	r14
    2e0e:	df 90       	pop	r13
    2e10:	cf 90       	pop	r12
    2e12:	bf 90       	pop	r11
    2e14:	af 90       	pop	r10
    2e16:	08 95       	ret

00002e18 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2e18:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2e1a:	10 92 d4 1a 	sts	0x1AD4, r1
	vPortEndScheduler();
    2e1e:	0e 94 c0 10 	call	0x2180	; 0x2180 <vPortEndScheduler>
}
    2e22:	08 95       	ret

00002e24 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2e24:	80 91 d3 1a 	lds	r24, 0x1AD3
    2e28:	8f 5f       	subi	r24, 0xFF	; 255
    2e2a:	80 93 d3 1a 	sts	0x1AD3, r24
}
    2e2e:	08 95       	ret

00002e30 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2e30:	0f b6       	in	r0, 0x3f	; 63
    2e32:	f8 94       	cli
    2e34:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2e36:	80 91 d6 1a 	lds	r24, 0x1AD6
    2e3a:	90 91 d7 1a 	lds	r25, 0x1AD7
	}
	taskEXIT_CRITICAL();
    2e3e:	0f 90       	pop	r0
    2e40:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2e42:	08 95       	ret

00002e44 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    2e44:	80 91 d6 1a 	lds	r24, 0x1AD6
    2e48:	90 91 d7 1a 	lds	r25, 0x1AD7
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2e4c:	08 95       	ret

00002e4e <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2e4e:	80 91 d8 1a 	lds	r24, 0x1AD8
}
    2e52:	08 95       	ret

00002e54 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2e54:	0f 93       	push	r16
    2e56:	1f 93       	push	r17
    2e58:	cf 93       	push	r28
    2e5a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2e5c:	80 91 d3 1a 	lds	r24, 0x1AD3
    2e60:	88 23       	and	r24, r24
    2e62:	09 f0       	breq	.+2      	; 0x2e66 <vTaskIncrementTick+0x12>
    2e64:	b3 c0       	rjmp	.+358    	; 0x2fcc <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    2e66:	80 91 d6 1a 	lds	r24, 0x1AD6
    2e6a:	90 91 d7 1a 	lds	r25, 0x1AD7
    2e6e:	01 96       	adiw	r24, 0x01	; 1
    2e70:	90 93 d7 1a 	sts	0x1AD7, r25
    2e74:	80 93 d6 1a 	sts	0x1AD6, r24
		if( xTickCount == ( portTickType ) 0U )
    2e78:	80 91 d6 1a 	lds	r24, 0x1AD6
    2e7c:	90 91 d7 1a 	lds	r25, 0x1AD7
    2e80:	00 97       	sbiw	r24, 0x00	; 0
    2e82:	99 f5       	brne	.+102    	; 0x2eea <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    2e84:	80 91 db 1a 	lds	r24, 0x1ADB
    2e88:	90 91 dc 1a 	lds	r25, 0x1ADC
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2e8c:	20 91 d9 1a 	lds	r18, 0x1AD9
    2e90:	30 91 da 1a 	lds	r19, 0x1ADA
    2e94:	30 93 dc 1a 	sts	0x1ADC, r19
    2e98:	20 93 db 1a 	sts	0x1ADB, r18
			pxOverflowDelayedTaskList = pxTemp;
    2e9c:	90 93 da 1a 	sts	0x1ADA, r25
    2ea0:	80 93 d9 1a 	sts	0x1AD9, r24
			xNumOfOverflows++;
    2ea4:	80 91 d0 1a 	lds	r24, 0x1AD0
    2ea8:	8f 5f       	subi	r24, 0xFF	; 255
    2eaa:	80 93 d0 1a 	sts	0x1AD0, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2eae:	e0 91 db 1a 	lds	r30, 0x1ADB
    2eb2:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2eb6:	80 81       	ld	r24, Z
    2eb8:	88 23       	and	r24, r24
    2eba:	39 f4       	brne	.+14     	; 0x2eca <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2ebc:	8f ef       	ldi	r24, 0xFF	; 255
    2ebe:	9f ef       	ldi	r25, 0xFF	; 255
    2ec0:	90 93 5a 02 	sts	0x025A, r25
    2ec4:	80 93 59 02 	sts	0x0259, r24
    2ec8:	10 c0       	rjmp	.+32     	; 0x2eea <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2eca:	e0 91 db 1a 	lds	r30, 0x1ADB
    2ece:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2ed2:	05 80       	ldd	r0, Z+5	; 0x05
    2ed4:	f6 81       	ldd	r31, Z+6	; 0x06
    2ed6:	e0 2d       	mov	r30, r0
    2ed8:	06 80       	ldd	r0, Z+6	; 0x06
    2eda:	f7 81       	ldd	r31, Z+7	; 0x07
    2edc:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2ede:	82 81       	ldd	r24, Z+2	; 0x02
    2ee0:	93 81       	ldd	r25, Z+3	; 0x03
    2ee2:	90 93 5a 02 	sts	0x025A, r25
    2ee6:	80 93 59 02 	sts	0x0259, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2eea:	20 91 d6 1a 	lds	r18, 0x1AD6
    2eee:	30 91 d7 1a 	lds	r19, 0x1AD7
    2ef2:	80 91 59 02 	lds	r24, 0x0259
    2ef6:	90 91 5a 02 	lds	r25, 0x025A
    2efa:	28 17       	cp	r18, r24
    2efc:	39 07       	cpc	r19, r25
    2efe:	08 f4       	brcc	.+2      	; 0x2f02 <vTaskIncrementTick+0xae>
    2f00:	6a c0       	rjmp	.+212    	; 0x2fd6 <vTaskIncrementTick+0x182>
    2f02:	e0 91 db 1a 	lds	r30, 0x1ADB
    2f06:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2f0a:	80 81       	ld	r24, Z
    2f0c:	88 23       	and	r24, r24
    2f0e:	99 f0       	breq	.+38     	; 0x2f36 <vTaskIncrementTick+0xe2>
    2f10:	e0 91 db 1a 	lds	r30, 0x1ADB
    2f14:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2f18:	05 80       	ldd	r0, Z+5	; 0x05
    2f1a:	f6 81       	ldd	r31, Z+6	; 0x06
    2f1c:	e0 2d       	mov	r30, r0
    2f1e:	c6 81       	ldd	r28, Z+6	; 0x06
    2f20:	d7 81       	ldd	r29, Z+7	; 0x07
    2f22:	8a 81       	ldd	r24, Y+2	; 0x02
    2f24:	9b 81       	ldd	r25, Y+3	; 0x03
    2f26:	20 91 d6 1a 	lds	r18, 0x1AD6
    2f2a:	30 91 d7 1a 	lds	r19, 0x1AD7
    2f2e:	28 17       	cp	r18, r24
    2f30:	39 07       	cpc	r19, r25
    2f32:	f8 f4       	brcc	.+62     	; 0x2f72 <vTaskIncrementTick+0x11e>
    2f34:	19 c0       	rjmp	.+50     	; 0x2f68 <vTaskIncrementTick+0x114>
    2f36:	8f ef       	ldi	r24, 0xFF	; 255
    2f38:	9f ef       	ldi	r25, 0xFF	; 255
    2f3a:	90 93 5a 02 	sts	0x025A, r25
    2f3e:	80 93 59 02 	sts	0x0259, r24
    2f42:	49 c0       	rjmp	.+146    	; 0x2fd6 <vTaskIncrementTick+0x182>
    2f44:	e0 91 db 1a 	lds	r30, 0x1ADB
    2f48:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2f4c:	05 80       	ldd	r0, Z+5	; 0x05
    2f4e:	f6 81       	ldd	r31, Z+6	; 0x06
    2f50:	e0 2d       	mov	r30, r0
    2f52:	c6 81       	ldd	r28, Z+6	; 0x06
    2f54:	d7 81       	ldd	r29, Z+7	; 0x07
    2f56:	8a 81       	ldd	r24, Y+2	; 0x02
    2f58:	9b 81       	ldd	r25, Y+3	; 0x03
    2f5a:	20 91 d6 1a 	lds	r18, 0x1AD6
    2f5e:	30 91 d7 1a 	lds	r19, 0x1AD7
    2f62:	28 17       	cp	r18, r24
    2f64:	39 07       	cpc	r19, r25
    2f66:	28 f4       	brcc	.+10     	; 0x2f72 <vTaskIncrementTick+0x11e>
    2f68:	90 93 5a 02 	sts	0x025A, r25
    2f6c:	80 93 59 02 	sts	0x0259, r24
    2f70:	32 c0       	rjmp	.+100    	; 0x2fd6 <vTaskIncrementTick+0x182>
    2f72:	8e 01       	movw	r16, r28
    2f74:	0e 5f       	subi	r16, 0xFE	; 254
    2f76:	1f 4f       	sbci	r17, 0xFF	; 255
    2f78:	c8 01       	movw	r24, r16
    2f7a:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
    2f7e:	8c 89       	ldd	r24, Y+20	; 0x14
    2f80:	9d 89       	ldd	r25, Y+21	; 0x15
    2f82:	00 97       	sbiw	r24, 0x00	; 0
    2f84:	21 f0       	breq	.+8      	; 0x2f8e <vTaskIncrementTick+0x13a>
    2f86:	ce 01       	movw	r24, r28
    2f88:	0c 96       	adiw	r24, 0x0c	; 12
    2f8a:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
    2f8e:	8e 89       	ldd	r24, Y+22	; 0x16
    2f90:	90 91 d5 1a 	lds	r25, 0x1AD5
    2f94:	98 17       	cp	r25, r24
    2f96:	10 f4       	brcc	.+4      	; 0x2f9c <vTaskIncrementTick+0x148>
    2f98:	80 93 d5 1a 	sts	0x1AD5, r24
    2f9c:	90 e0       	ldi	r25, 0x00	; 0
    2f9e:	9c 01       	movw	r18, r24
    2fa0:	22 0f       	add	r18, r18
    2fa2:	33 1f       	adc	r19, r19
    2fa4:	22 0f       	add	r18, r18
    2fa6:	33 1f       	adc	r19, r19
    2fa8:	22 0f       	add	r18, r18
    2faa:	33 1f       	adc	r19, r19
    2fac:	82 0f       	add	r24, r18
    2fae:	93 1f       	adc	r25, r19
    2fb0:	81 52       	subi	r24, 0x21	; 33
    2fb2:	95 4e       	sbci	r25, 0xE5	; 229
    2fb4:	b8 01       	movw	r22, r16
    2fb6:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
    2fba:	e0 91 db 1a 	lds	r30, 0x1ADB
    2fbe:	f0 91 dc 1a 	lds	r31, 0x1ADC
    2fc2:	80 81       	ld	r24, Z
    2fc4:	88 23       	and	r24, r24
    2fc6:	09 f0       	breq	.+2      	; 0x2fca <vTaskIncrementTick+0x176>
    2fc8:	bd cf       	rjmp	.-134    	; 0x2f44 <vTaskIncrementTick+0xf0>
    2fca:	b5 cf       	rjmp	.-150    	; 0x2f36 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    2fcc:	80 91 d2 1a 	lds	r24, 0x1AD2
    2fd0:	8f 5f       	subi	r24, 0xFF	; 255
    2fd2:	80 93 d2 1a 	sts	0x1AD2, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    2fd6:	df 91       	pop	r29
    2fd8:	cf 91       	pop	r28
    2fda:	1f 91       	pop	r17
    2fdc:	0f 91       	pop	r16
    2fde:	08 95       	ret

00002fe0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2fe0:	af 92       	push	r10
    2fe2:	bf 92       	push	r11
    2fe4:	cf 92       	push	r12
    2fe6:	df 92       	push	r13
    2fe8:	ef 92       	push	r14
    2fea:	ff 92       	push	r15
    2fec:	0f 93       	push	r16
    2fee:	1f 93       	push	r17
    2ff0:	cf 93       	push	r28
    2ff2:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2ff4:	0f b6       	in	r0, 0x3f	; 63
    2ff6:	f8 94       	cli
    2ff8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2ffa:	80 91 d3 1a 	lds	r24, 0x1AD3
    2ffe:	81 50       	subi	r24, 0x01	; 1
    3000:	80 93 d3 1a 	sts	0x1AD3, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3004:	80 91 d3 1a 	lds	r24, 0x1AD3
    3008:	88 23       	and	r24, r24
    300a:	09 f0       	breq	.+2      	; 0x300e <xTaskResumeAll+0x2e>
    300c:	69 c0       	rjmp	.+210    	; 0x30e0 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    300e:	80 91 d8 1a 	lds	r24, 0x1AD8
    3012:	88 23       	and	r24, r24
    3014:	81 f5       	brne	.+96     	; 0x3076 <xTaskResumeAll+0x96>
    3016:	67 c0       	rjmp	.+206    	; 0x30e6 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3018:	d6 01       	movw	r26, r12
    301a:	ed 91       	ld	r30, X+
    301c:	fc 91       	ld	r31, X
    301e:	c6 81       	ldd	r28, Z+6	; 0x06
    3020:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    3022:	ce 01       	movw	r24, r28
    3024:	0c 96       	adiw	r24, 0x0c	; 12
    3026:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    302a:	8e 01       	movw	r16, r28
    302c:	0e 5f       	subi	r16, 0xFE	; 254
    302e:	1f 4f       	sbci	r17, 0xFF	; 255
    3030:	c8 01       	movw	r24, r16
    3032:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3036:	8e 89       	ldd	r24, Y+22	; 0x16
    3038:	90 91 d5 1a 	lds	r25, 0x1AD5
    303c:	98 17       	cp	r25, r24
    303e:	10 f4       	brcc	.+4      	; 0x3044 <xTaskResumeAll+0x64>
    3040:	80 93 d5 1a 	sts	0x1AD5, r24
    3044:	90 e0       	ldi	r25, 0x00	; 0
    3046:	9c 01       	movw	r18, r24
    3048:	22 0f       	add	r18, r18
    304a:	33 1f       	adc	r19, r19
    304c:	22 0f       	add	r18, r18
    304e:	33 1f       	adc	r19, r19
    3050:	22 0f       	add	r18, r18
    3052:	33 1f       	adc	r19, r19
    3054:	82 0f       	add	r24, r18
    3056:	93 1f       	adc	r25, r19
    3058:	81 52       	subi	r24, 0x21	; 33
    305a:	95 4e       	sbci	r25, 0xE5	; 229
    305c:	b8 01       	movw	r22, r16
    305e:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3062:	e0 91 ce 1a 	lds	r30, 0x1ACE
    3066:	f0 91 cf 1a 	lds	r31, 0x1ACF
    306a:	9e 89       	ldd	r25, Y+22	; 0x16
    306c:	86 89       	ldd	r24, Z+22	; 0x16
    306e:	98 17       	cp	r25, r24
    3070:	88 f0       	brcs	.+34     	; 0x3094 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    3072:	ba 2c       	mov	r11, r10
    3074:	0f c0       	rjmp	.+30     	; 0x3094 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    3076:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3078:	0f 2e       	mov	r0, r31
    307a:	f5 e1       	ldi	r31, 0x15	; 21
    307c:	ef 2e       	mov	r14, r31
    307e:	fb e1       	ldi	r31, 0x1B	; 27
    3080:	ff 2e       	mov	r15, r31
    3082:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3084:	0f 2e       	mov	r0, r31
    3086:	fa e1       	ldi	r31, 0x1A	; 26
    3088:	cf 2e       	mov	r12, r31
    308a:	fb e1       	ldi	r31, 0x1B	; 27
    308c:	df 2e       	mov	r13, r31
    308e:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    3090:	aa 24       	eor	r10, r10
    3092:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3094:	f7 01       	movw	r30, r14
    3096:	80 81       	ld	r24, Z
    3098:	88 23       	and	r24, r24
    309a:	09 f0       	breq	.+2      	; 0x309e <xTaskResumeAll+0xbe>
    309c:	bd cf       	rjmp	.-134    	; 0x3018 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    309e:	80 91 d2 1a 	lds	r24, 0x1AD2
    30a2:	88 23       	and	r24, r24
    30a4:	81 f0       	breq	.+32     	; 0x30c6 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    30a6:	80 91 d2 1a 	lds	r24, 0x1AD2
    30aa:	88 23       	and	r24, r24
    30ac:	99 f0       	breq	.+38     	; 0x30d4 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    30ae:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <vTaskIncrementTick>
						--uxMissedTicks;
    30b2:	80 91 d2 1a 	lds	r24, 0x1AD2
    30b6:	81 50       	subi	r24, 0x01	; 1
    30b8:	80 93 d2 1a 	sts	0x1AD2, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    30bc:	80 91 d2 1a 	lds	r24, 0x1AD2
    30c0:	88 23       	and	r24, r24
    30c2:	a9 f7       	brne	.-22     	; 0x30ae <xTaskResumeAll+0xce>
    30c4:	07 c0       	rjmp	.+14     	; 0x30d4 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    30c6:	f1 e0       	ldi	r31, 0x01	; 1
    30c8:	bf 16       	cp	r11, r31
    30ca:	21 f0       	breq	.+8      	; 0x30d4 <xTaskResumeAll+0xf4>
    30cc:	80 91 d1 1a 	lds	r24, 0x1AD1
    30d0:	81 30       	cpi	r24, 0x01	; 1
    30d2:	41 f4       	brne	.+16     	; 0x30e4 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    30d4:	10 92 d1 1a 	sts	0x1AD1, r1
					portYIELD_WITHIN_API();
    30d8:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    30dc:	81 e0       	ldi	r24, 0x01	; 1
    30de:	03 c0       	rjmp	.+6      	; 0x30e6 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    30e0:	80 e0       	ldi	r24, 0x00	; 0
    30e2:	01 c0       	rjmp	.+2      	; 0x30e6 <xTaskResumeAll+0x106>
    30e4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    30e6:	0f 90       	pop	r0
    30e8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    30ea:	df 91       	pop	r29
    30ec:	cf 91       	pop	r28
    30ee:	1f 91       	pop	r17
    30f0:	0f 91       	pop	r16
    30f2:	ff 90       	pop	r15
    30f4:	ef 90       	pop	r14
    30f6:	df 90       	pop	r13
    30f8:	cf 90       	pop	r12
    30fa:	bf 90       	pop	r11
    30fc:	af 90       	pop	r10
    30fe:	08 95       	ret

00003100 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3106:	00 97       	sbiw	r24, 0x00	; 0
    3108:	b1 f0       	breq	.+44     	; 0x3136 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    310a:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    310e:	80 91 d6 1a 	lds	r24, 0x1AD6
    3112:	90 91 d7 1a 	lds	r25, 0x1AD7
    3116:	c8 0f       	add	r28, r24
    3118:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    311a:	80 91 ce 1a 	lds	r24, 0x1ACE
    311e:	90 91 cf 1a 	lds	r25, 0x1ACF
    3122:	02 96       	adiw	r24, 0x02	; 2
    3124:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3128:	ce 01       	movw	r24, r28
    312a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    312e:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3132:	88 23       	and	r24, r24
    3134:	11 f4       	brne	.+4      	; 0x313a <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    3136:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
		}
	}
    313a:	df 91       	pop	r29
    313c:	cf 91       	pop	r28
    313e:	08 95       	ret

00003140 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3140:	0f 93       	push	r16
    3142:	1f 93       	push	r17
    3144:	cf 93       	push	r28
    3146:	df 93       	push	r29
    3148:	8c 01       	movw	r16, r24
    314a:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    314c:	0e 94 12 17 	call	0x2e24	; 0x2e24 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3150:	f8 01       	movw	r30, r16
    3152:	80 81       	ld	r24, Z
    3154:	91 81       	ldd	r25, Z+1	; 0x01
    3156:	c8 0f       	add	r28, r24
    3158:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    315a:	20 91 d6 1a 	lds	r18, 0x1AD6
    315e:	30 91 d7 1a 	lds	r19, 0x1AD7
    3162:	28 17       	cp	r18, r24
    3164:	39 07       	cpc	r19, r25
    3166:	68 f4       	brcc	.+26     	; 0x3182 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    3168:	c8 17       	cp	r28, r24
    316a:	d9 07       	cpc	r29, r25
    316c:	50 f5       	brcc	.+84     	; 0x31c2 <vTaskDelayUntil+0x82>
    316e:	80 91 d6 1a 	lds	r24, 0x1AD6
    3172:	90 91 d7 1a 	lds	r25, 0x1AD7
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3176:	d1 83       	std	Z+1, r29	; 0x01
    3178:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    317a:	8c 17       	cp	r24, r28
    317c:	9d 07       	cpc	r25, r29
    317e:	b0 f4       	brcc	.+44     	; 0x31ac <vTaskDelayUntil+0x6c>
    3180:	0b c0       	rjmp	.+22     	; 0x3198 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3182:	c8 17       	cp	r28, r24
    3184:	d9 07       	cpc	r29, r25
    3186:	c8 f0       	brcs	.+50     	; 0x31ba <vTaskDelayUntil+0x7a>
    3188:	80 91 d6 1a 	lds	r24, 0x1AD6
    318c:	90 91 d7 1a 	lds	r25, 0x1AD7
    3190:	8c 17       	cp	r24, r28
    3192:	9d 07       	cpc	r25, r29
    3194:	90 f0       	brcs	.+36     	; 0x31ba <vTaskDelayUntil+0x7a>
    3196:	15 c0       	rjmp	.+42     	; 0x31c2 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    3198:	80 91 ce 1a 	lds	r24, 0x1ACE
    319c:	90 91 cf 1a 	lds	r25, 0x1ACF
    31a0:	02 96       	adiw	r24, 0x02	; 2
    31a2:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    31a6:	ce 01       	movw	r24, r28
    31a8:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    31ac:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    31b0:	88 23       	and	r24, r24
    31b2:	59 f4       	brne	.+22     	; 0x31ca <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    31b4:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    31b8:	08 c0       	rjmp	.+16     	; 0x31ca <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    31ba:	f8 01       	movw	r30, r16
    31bc:	d1 83       	std	Z+1, r29	; 0x01
    31be:	c0 83       	st	Z, r28
    31c0:	eb cf       	rjmp	.-42     	; 0x3198 <vTaskDelayUntil+0x58>
    31c2:	f8 01       	movw	r30, r16
    31c4:	d1 83       	std	Z+1, r29	; 0x01
    31c6:	c0 83       	st	Z, r28
    31c8:	f1 cf       	rjmp	.-30     	; 0x31ac <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    31ca:	df 91       	pop	r29
    31cc:	cf 91       	pop	r28
    31ce:	1f 91       	pop	r17
    31d0:	0f 91       	pop	r16
    31d2:	08 95       	ret

000031d4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    31d4:	80 91 d3 1a 	lds	r24, 0x1AD3
    31d8:	88 23       	and	r24, r24
    31da:	99 f4       	brne	.+38     	; 0x3202 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    31dc:	80 91 d5 1a 	lds	r24, 0x1AD5
    31e0:	90 e0       	ldi	r25, 0x00	; 0
    31e2:	fc 01       	movw	r30, r24
    31e4:	ee 0f       	add	r30, r30
    31e6:	ff 1f       	adc	r31, r31
    31e8:	ee 0f       	add	r30, r30
    31ea:	ff 1f       	adc	r31, r31
    31ec:	ee 0f       	add	r30, r30
    31ee:	ff 1f       	adc	r31, r31
    31f0:	8e 0f       	add	r24, r30
    31f2:	9f 1f       	adc	r25, r31
    31f4:	fc 01       	movw	r30, r24
    31f6:	e1 52       	subi	r30, 0x21	; 33
    31f8:	f5 4e       	sbci	r31, 0xE5	; 229
    31fa:	80 81       	ld	r24, Z
    31fc:	88 23       	and	r24, r24
    31fe:	29 f0       	breq	.+10     	; 0x320a <vTaskSwitchContext+0x36>
    3200:	1b c0       	rjmp	.+54     	; 0x3238 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3202:	81 e0       	ldi	r24, 0x01	; 1
    3204:	80 93 d1 1a 	sts	0x1AD1, r24
    3208:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    320a:	80 91 d5 1a 	lds	r24, 0x1AD5
    320e:	81 50       	subi	r24, 0x01	; 1
    3210:	80 93 d5 1a 	sts	0x1AD5, r24
    3214:	80 91 d5 1a 	lds	r24, 0x1AD5
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	fc 01       	movw	r30, r24
    321c:	ee 0f       	add	r30, r30
    321e:	ff 1f       	adc	r31, r31
    3220:	ee 0f       	add	r30, r30
    3222:	ff 1f       	adc	r31, r31
    3224:	ee 0f       	add	r30, r30
    3226:	ff 1f       	adc	r31, r31
    3228:	8e 0f       	add	r24, r30
    322a:	9f 1f       	adc	r25, r31
    322c:	fc 01       	movw	r30, r24
    322e:	e1 52       	subi	r30, 0x21	; 33
    3230:	f5 4e       	sbci	r31, 0xE5	; 229
    3232:	80 81       	ld	r24, Z
    3234:	88 23       	and	r24, r24
    3236:	49 f3       	breq	.-46     	; 0x320a <vTaskSwitchContext+0x36>
    3238:	80 91 d5 1a 	lds	r24, 0x1AD5
    323c:	90 e0       	ldi	r25, 0x00	; 0
    323e:	fc 01       	movw	r30, r24
    3240:	ee 0f       	add	r30, r30
    3242:	ff 1f       	adc	r31, r31
    3244:	ee 0f       	add	r30, r30
    3246:	ff 1f       	adc	r31, r31
    3248:	ee 0f       	add	r30, r30
    324a:	ff 1f       	adc	r31, r31
    324c:	e8 0f       	add	r30, r24
    324e:	f9 1f       	adc	r31, r25
    3250:	e1 52       	subi	r30, 0x21	; 33
    3252:	f5 4e       	sbci	r31, 0xE5	; 229
    3254:	a1 81       	ldd	r26, Z+1	; 0x01
    3256:	b2 81       	ldd	r27, Z+2	; 0x02
    3258:	12 96       	adiw	r26, 0x02	; 2
    325a:	0d 90       	ld	r0, X+
    325c:	bc 91       	ld	r27, X
    325e:	a0 2d       	mov	r26, r0
    3260:	b2 83       	std	Z+2, r27	; 0x02
    3262:	a1 83       	std	Z+1, r26	; 0x01
    3264:	cf 01       	movw	r24, r30
    3266:	03 96       	adiw	r24, 0x03	; 3
    3268:	a8 17       	cp	r26, r24
    326a:	b9 07       	cpc	r27, r25
    326c:	31 f4       	brne	.+12     	; 0x327a <vTaskSwitchContext+0xa6>
    326e:	12 96       	adiw	r26, 0x02	; 2
    3270:	8d 91       	ld	r24, X+
    3272:	9c 91       	ld	r25, X
    3274:	13 97       	sbiw	r26, 0x03	; 3
    3276:	92 83       	std	Z+2, r25	; 0x02
    3278:	81 83       	std	Z+1, r24	; 0x01
    327a:	01 80       	ldd	r0, Z+1	; 0x01
    327c:	f2 81       	ldd	r31, Z+2	; 0x02
    327e:	e0 2d       	mov	r30, r0
    3280:	86 81       	ldd	r24, Z+6	; 0x06
    3282:	97 81       	ldd	r25, Z+7	; 0x07
    3284:	90 93 cf 1a 	sts	0x1ACF, r25
    3288:	80 93 ce 1a 	sts	0x1ACE, r24
    328c:	08 95       	ret

0000328e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    328e:	ef 92       	push	r14
    3290:	ff 92       	push	r15
    3292:	0f 93       	push	r16
    3294:	1f 93       	push	r17
    3296:	cf 93       	push	r28
    3298:	df 93       	push	r29
    329a:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    329c:	0f b6       	in	r0, 0x3f	; 63
    329e:	f8 94       	cli
    32a0:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    32a2:	80 91 ce 1a 	lds	r24, 0x1ACE
    32a6:	90 91 cf 1a 	lds	r25, 0x1ACF
    32aa:	e8 16       	cp	r14, r24
    32ac:	f9 06       	cpc	r15, r25
    32ae:	21 f0       	breq	.+8      	; 0x32b8 <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    32b0:	e1 14       	cp	r14, r1
    32b2:	f1 04       	cpc	r15, r1
    32b4:	41 f4       	brne	.+16     	; 0x32c6 <vTaskSuspend+0x38>
    32b6:	02 c0       	rjmp	.+4      	; 0x32bc <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    32b8:	ee 24       	eor	r14, r14
    32ba:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    32bc:	c0 91 ce 1a 	lds	r28, 0x1ACE
    32c0:	d0 91 cf 1a 	lds	r29, 0x1ACF
    32c4:	01 c0       	rjmp	.+2      	; 0x32c8 <vTaskSuspend+0x3a>
    32c6:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    32c8:	8e 01       	movw	r16, r28
    32ca:	0e 5f       	subi	r16, 0xFE	; 254
    32cc:	1f 4f       	sbci	r17, 0xFF	; 255
    32ce:	c8 01       	movw	r24, r16
    32d0:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    32d4:	8c 89       	ldd	r24, Y+20	; 0x14
    32d6:	9d 89       	ldd	r25, Y+21	; 0x15
    32d8:	00 97       	sbiw	r24, 0x00	; 0
    32da:	21 f0       	breq	.+8      	; 0x32e4 <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    32dc:	ce 01       	movw	r24, r28
    32de:	0c 96       	adiw	r24, 0x0c	; 12
    32e0:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    32e4:	8e e1       	ldi	r24, 0x1E	; 30
    32e6:	9b e1       	ldi	r25, 0x1B	; 27
    32e8:	b8 01       	movw	r22, r16
    32ea:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    32ee:	0f 90       	pop	r0
    32f0:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    32f2:	e1 14       	cp	r14, r1
    32f4:	f1 04       	cpc	r15, r1
    32f6:	a1 f4       	brne	.+40     	; 0x3320 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    32f8:	80 91 d4 1a 	lds	r24, 0x1AD4
    32fc:	88 23       	and	r24, r24
    32fe:	19 f0       	breq	.+6      	; 0x3306 <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    3300:	0e 94 c1 10 	call	0x2182	; 0x2182 <vPortYield>
    3304:	0d c0       	rjmp	.+26     	; 0x3320 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    3306:	90 91 1e 1b 	lds	r25, 0x1B1E
    330a:	80 91 d8 1a 	lds	r24, 0x1AD8
    330e:	98 17       	cp	r25, r24
    3310:	29 f4       	brne	.+10     	; 0x331c <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3312:	10 92 cf 1a 	sts	0x1ACF, r1
    3316:	10 92 ce 1a 	sts	0x1ACE, r1
    331a:	02 c0       	rjmp	.+4      	; 0x3320 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    331c:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <vTaskSwitchContext>
				}
			}
		}
	}
    3320:	df 91       	pop	r29
    3322:	cf 91       	pop	r28
    3324:	1f 91       	pop	r17
    3326:	0f 91       	pop	r16
    3328:	ff 90       	pop	r15
    332a:	ef 90       	pop	r14
    332c:	08 95       	ret

0000332e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    332e:	cf 93       	push	r28
    3330:	df 93       	push	r29
    3332:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3334:	60 91 ce 1a 	lds	r22, 0x1ACE
    3338:	70 91 cf 1a 	lds	r23, 0x1ACF
    333c:	64 5f       	subi	r22, 0xF4	; 244
    333e:	7f 4f       	sbci	r23, 0xFF	; 255
    3340:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    3344:	80 91 ce 1a 	lds	r24, 0x1ACE
    3348:	90 91 cf 1a 	lds	r25, 0x1ACF
    334c:	02 96       	adiw	r24, 0x02	; 2
    334e:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3352:	8f ef       	ldi	r24, 0xFF	; 255
    3354:	cf 3f       	cpi	r28, 0xFF	; 255
    3356:	d8 07       	cpc	r29, r24
    3358:	59 f4       	brne	.+22     	; 0x3370 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    335a:	60 91 ce 1a 	lds	r22, 0x1ACE
    335e:	70 91 cf 1a 	lds	r23, 0x1ACF
    3362:	6e 5f       	subi	r22, 0xFE	; 254
    3364:	7f 4f       	sbci	r23, 0xFF	; 255
    3366:	8e e1       	ldi	r24, 0x1E	; 30
    3368:	9b e1       	ldi	r25, 0x1B	; 27
    336a:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
    336e:	08 c0       	rjmp	.+16     	; 0x3380 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3370:	80 91 d6 1a 	lds	r24, 0x1AD6
    3374:	90 91 d7 1a 	lds	r25, 0x1AD7
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3378:	8c 0f       	add	r24, r28
    337a:	9d 1f       	adc	r25, r29
    337c:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    3380:	df 91       	pop	r29
    3382:	cf 91       	pop	r28
    3384:	08 95       	ret

00003386 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3386:	0f 93       	push	r16
    3388:	1f 93       	push	r17
    338a:	cf 93       	push	r28
    338c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    338e:	dc 01       	movw	r26, r24
    3390:	15 96       	adiw	r26, 0x05	; 5
    3392:	ed 91       	ld	r30, X+
    3394:	fc 91       	ld	r31, X
    3396:	16 97       	sbiw	r26, 0x06	; 6
    3398:	06 81       	ldd	r16, Z+6	; 0x06
    339a:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    339c:	e8 01       	movw	r28, r16
    339e:	2c 96       	adiw	r28, 0x0c	; 12
    33a0:	ce 01       	movw	r24, r28
    33a2:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    33a6:	80 91 d3 1a 	lds	r24, 0x1AD3
    33aa:	88 23       	and	r24, r24
    33ac:	e9 f4       	brne	.+58     	; 0x33e8 <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    33ae:	e8 01       	movw	r28, r16
    33b0:	22 96       	adiw	r28, 0x02	; 2
    33b2:	ce 01       	movw	r24, r28
    33b4:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    33b8:	f8 01       	movw	r30, r16
    33ba:	86 89       	ldd	r24, Z+22	; 0x16
    33bc:	90 91 d5 1a 	lds	r25, 0x1AD5
    33c0:	98 17       	cp	r25, r24
    33c2:	10 f4       	brcc	.+4      	; 0x33c8 <xTaskRemoveFromEventList+0x42>
    33c4:	80 93 d5 1a 	sts	0x1AD5, r24
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	9c 01       	movw	r18, r24
    33cc:	22 0f       	add	r18, r18
    33ce:	33 1f       	adc	r19, r19
    33d0:	22 0f       	add	r18, r18
    33d2:	33 1f       	adc	r19, r19
    33d4:	22 0f       	add	r18, r18
    33d6:	33 1f       	adc	r19, r19
    33d8:	82 0f       	add	r24, r18
    33da:	93 1f       	adc	r25, r19
    33dc:	81 52       	subi	r24, 0x21	; 33
    33de:	95 4e       	sbci	r25, 0xE5	; 229
    33e0:	be 01       	movw	r22, r28
    33e2:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
    33e6:	05 c0       	rjmp	.+10     	; 0x33f2 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    33e8:	85 e1       	ldi	r24, 0x15	; 21
    33ea:	9b e1       	ldi	r25, 0x1B	; 27
    33ec:	be 01       	movw	r22, r28
    33ee:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    33f2:	e0 91 ce 1a 	lds	r30, 0x1ACE
    33f6:	f0 91 cf 1a 	lds	r31, 0x1ACF
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    33fa:	81 e0       	ldi	r24, 0x01	; 1
    33fc:	d8 01       	movw	r26, r16
    33fe:	56 96       	adiw	r26, 0x16	; 22
    3400:	2c 91       	ld	r18, X
    3402:	56 97       	sbiw	r26, 0x16	; 22
    3404:	96 89       	ldd	r25, Z+22	; 0x16
    3406:	29 17       	cp	r18, r25
    3408:	08 f4       	brcc	.+2      	; 0x340c <xTaskRemoveFromEventList+0x86>
    340a:	80 e0       	ldi	r24, 0x00	; 0
}
    340c:	df 91       	pop	r29
    340e:	cf 91       	pop	r28
    3410:	1f 91       	pop	r17
    3412:	0f 91       	pop	r16
    3414:	08 95       	ret

00003416 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    3416:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3418:	80 91 d0 1a 	lds	r24, 0x1AD0
    341c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    341e:	80 91 d6 1a 	lds	r24, 0x1AD6
    3422:	90 91 d7 1a 	lds	r25, 0x1AD7
    3426:	92 83       	std	Z+2, r25	; 0x02
    3428:	81 83       	std	Z+1, r24	; 0x01
}
    342a:	08 95       	ret

0000342c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    342c:	fc 01       	movw	r30, r24
    342e:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3430:	0f b6       	in	r0, 0x3f	; 63
    3432:	f8 94       	cli
    3434:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    3436:	4d 91       	ld	r20, X+
    3438:	5c 91       	ld	r21, X
    343a:	11 97       	sbiw	r26, 0x01	; 1
    343c:	6f ef       	ldi	r22, 0xFF	; 255
    343e:	4f 3f       	cpi	r20, 0xFF	; 255
    3440:	56 07       	cpc	r21, r22
    3442:	51 f1       	breq	.+84     	; 0x3498 <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3444:	80 91 d0 1a 	lds	r24, 0x1AD0
    3448:	90 81       	ld	r25, Z
    344a:	98 17       	cp	r25, r24
    344c:	49 f0       	breq	.+18     	; 0x3460 <xTaskCheckForTimeOut+0x34>
    344e:	20 91 d6 1a 	lds	r18, 0x1AD6
    3452:	30 91 d7 1a 	lds	r19, 0x1AD7
    3456:	81 81       	ldd	r24, Z+1	; 0x01
    3458:	92 81       	ldd	r25, Z+2	; 0x02
    345a:	28 17       	cp	r18, r24
    345c:	39 07       	cpc	r19, r25
    345e:	f0 f4       	brcc	.+60     	; 0x349c <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3460:	80 91 d6 1a 	lds	r24, 0x1AD6
    3464:	90 91 d7 1a 	lds	r25, 0x1AD7
    3468:	21 81       	ldd	r18, Z+1	; 0x01
    346a:	32 81       	ldd	r19, Z+2	; 0x02
    346c:	82 1b       	sub	r24, r18
    346e:	93 0b       	sbc	r25, r19
    3470:	84 17       	cp	r24, r20
    3472:	95 07       	cpc	r25, r21
    3474:	a8 f4       	brcc	.+42     	; 0x34a0 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3476:	80 91 d6 1a 	lds	r24, 0x1AD6
    347a:	90 91 d7 1a 	lds	r25, 0x1AD7
    347e:	b9 01       	movw	r22, r18
    3480:	68 1b       	sub	r22, r24
    3482:	79 0b       	sbc	r23, r25
    3484:	cb 01       	movw	r24, r22
    3486:	84 0f       	add	r24, r20
    3488:	95 1f       	adc	r25, r21
    348a:	8d 93       	st	X+, r24
    348c:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    348e:	cf 01       	movw	r24, r30
    3490:	0e 94 0b 1a 	call	0x3416	; 0x3416 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3494:	80 e0       	ldi	r24, 0x00	; 0
    3496:	05 c0       	rjmp	.+10     	; 0x34a2 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    3498:	80 e0       	ldi	r24, 0x00	; 0
    349a:	03 c0       	rjmp	.+6      	; 0x34a2 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    349c:	81 e0       	ldi	r24, 0x01	; 1
    349e:	01 c0       	rjmp	.+2      	; 0x34a2 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    34a0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    34a2:	0f 90       	pop	r0
    34a4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    34a6:	08 95       	ret

000034a8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    34a8:	81 e0       	ldi	r24, 0x01	; 1
    34aa:	80 93 d1 1a 	sts	0x1AD1, r24
}
    34ae:	08 95       	ret

000034b0 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    34b0:	00 97       	sbiw	r24, 0x00	; 0
    34b2:	29 f4       	brne	.+10     	; 0x34be <uxTaskGetStackHighWaterMark+0xe>
    34b4:	e0 91 ce 1a 	lds	r30, 0x1ACE
    34b8:	f0 91 cf 1a 	lds	r31, 0x1ACF
    34bc:	01 c0       	rjmp	.+2      	; 0x34c0 <uxTaskGetStackHighWaterMark+0x10>
    34be:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    34c0:	07 88       	ldd	r0, Z+23	; 0x17
    34c2:	f0 8d       	ldd	r31, Z+24	; 0x18
    34c4:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    34c6:	80 81       	ld	r24, Z
    34c8:	85 3a       	cpi	r24, 0xA5	; 165
    34ca:	41 f4       	brne	.+16     	; 0x34dc <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    34cc:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    34ce:	80 e0       	ldi	r24, 0x00	; 0
    34d0:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    34d2:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    34d4:	21 91       	ld	r18, Z+
    34d6:	25 3a       	cpi	r18, 0xA5	; 165
    34d8:	e1 f3       	breq	.-8      	; 0x34d2 <uxTaskGetStackHighWaterMark+0x22>
    34da:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    34dc:	80 e0       	ldi	r24, 0x00	; 0
    34de:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    34e0:	08 95       	ret

000034e2 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    34e2:	80 91 ce 1a 	lds	r24, 0x1ACE
    34e6:	90 91 cf 1a 	lds	r25, 0x1ACF

		return xReturn;
	}
    34ea:	08 95       	ret

000034ec <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    34ec:	0f 93       	push	r16
    34ee:	1f 93       	push	r17
    34f0:	cf 93       	push	r28
    34f2:	df 93       	push	r29
    34f4:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    34f6:	00 97       	sbiw	r24, 0x00	; 0
    34f8:	09 f4       	brne	.+2      	; 0x34fc <vTaskPriorityInherit+0x10>
    34fa:	4d c0       	rjmp	.+154    	; 0x3596 <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    34fc:	8e 89       	ldd	r24, Y+22	; 0x16
    34fe:	e0 91 ce 1a 	lds	r30, 0x1ACE
    3502:	f0 91 cf 1a 	lds	r31, 0x1ACF
    3506:	96 89       	ldd	r25, Z+22	; 0x16
    3508:	89 17       	cp	r24, r25
    350a:	08 f0       	brcs	.+2      	; 0x350e <vTaskPriorityInherit+0x22>
    350c:	44 c0       	rjmp	.+136    	; 0x3596 <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    350e:	e0 91 ce 1a 	lds	r30, 0x1ACE
    3512:	f0 91 cf 1a 	lds	r31, 0x1ACF
    3516:	96 89       	ldd	r25, Z+22	; 0x16
    3518:	24 e0       	ldi	r18, 0x04	; 4
    351a:	30 e0       	ldi	r19, 0x00	; 0
    351c:	29 1b       	sub	r18, r25
    351e:	31 09       	sbc	r19, r1
    3520:	3d 87       	std	Y+13, r19	; 0x0d
    3522:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3524:	90 e0       	ldi	r25, 0x00	; 0
    3526:	9c 01       	movw	r18, r24
    3528:	22 0f       	add	r18, r18
    352a:	33 1f       	adc	r19, r19
    352c:	22 0f       	add	r18, r18
    352e:	33 1f       	adc	r19, r19
    3530:	22 0f       	add	r18, r18
    3532:	33 1f       	adc	r19, r19
    3534:	82 0f       	add	r24, r18
    3536:	93 1f       	adc	r25, r19
    3538:	81 52       	subi	r24, 0x21	; 33
    353a:	95 4e       	sbci	r25, 0xE5	; 229
    353c:	2a 85       	ldd	r18, Y+10	; 0x0a
    353e:	3b 85       	ldd	r19, Y+11	; 0x0b
    3540:	28 17       	cp	r18, r24
    3542:	39 07       	cpc	r19, r25
    3544:	11 f5       	brne	.+68     	; 0x358a <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    3546:	8e 01       	movw	r16, r28
    3548:	0e 5f       	subi	r16, 0xFE	; 254
    354a:	1f 4f       	sbci	r17, 0xFF	; 255
    354c:	c8 01       	movw	r24, r16
    354e:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3552:	e0 91 ce 1a 	lds	r30, 0x1ACE
    3556:	f0 91 cf 1a 	lds	r31, 0x1ACF
    355a:	86 89       	ldd	r24, Z+22	; 0x16
    355c:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    355e:	90 91 d5 1a 	lds	r25, 0x1AD5
    3562:	98 17       	cp	r25, r24
    3564:	10 f4       	brcc	.+4      	; 0x356a <vTaskPriorityInherit+0x7e>
    3566:	80 93 d5 1a 	sts	0x1AD5, r24
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	9c 01       	movw	r18, r24
    356e:	22 0f       	add	r18, r18
    3570:	33 1f       	adc	r19, r19
    3572:	22 0f       	add	r18, r18
    3574:	33 1f       	adc	r19, r19
    3576:	22 0f       	add	r18, r18
    3578:	33 1f       	adc	r19, r19
    357a:	82 0f       	add	r24, r18
    357c:	93 1f       	adc	r25, r19
    357e:	81 52       	subi	r24, 0x21	; 33
    3580:	95 4e       	sbci	r25, 0xE5	; 229
    3582:	b8 01       	movw	r22, r16
    3584:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
    3588:	06 c0       	rjmp	.+12     	; 0x3596 <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    358a:	e0 91 ce 1a 	lds	r30, 0x1ACE
    358e:	f0 91 cf 1a 	lds	r31, 0x1ACF
    3592:	86 89       	ldd	r24, Z+22	; 0x16
    3594:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    3596:	df 91       	pop	r29
    3598:	cf 91       	pop	r28
    359a:	1f 91       	pop	r17
    359c:	0f 91       	pop	r16
    359e:	08 95       	ret

000035a0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    35a0:	0f 93       	push	r16
    35a2:	1f 93       	push	r17
    35a4:	cf 93       	push	r28
    35a6:	df 93       	push	r29
    35a8:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    35aa:	00 97       	sbiw	r24, 0x00	; 0
    35ac:	49 f1       	breq	.+82     	; 0x3600 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    35ae:	9e 89       	ldd	r25, Y+22	; 0x16
    35b0:	89 a5       	lds	r24, 0x69
    35b2:	98 17       	cp	r25, r24
    35b4:	29 f1       	breq	.+74     	; 0x3600 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    35b6:	8e 01       	movw	r16, r28
    35b8:	0e 5f       	subi	r16, 0xFE	; 254
    35ba:	1f 4f       	sbci	r17, 0xFF	; 255
    35bc:	c8 01       	movw	r24, r16
    35be:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    35c2:	49 a5       	lds	r20, 0x69
    35c4:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    35c6:	24 2f       	mov	r18, r20
    35c8:	30 e0       	ldi	r19, 0x00	; 0
    35ca:	84 e0       	ldi	r24, 0x04	; 4
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	82 1b       	sub	r24, r18
    35d0:	93 0b       	sbc	r25, r19
    35d2:	9d 87       	std	Y+13, r25	; 0x0d
    35d4:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    35d6:	80 91 d5 1a 	lds	r24, 0x1AD5
    35da:	84 17       	cp	r24, r20
    35dc:	10 f4       	brcc	.+4      	; 0x35e2 <vTaskPriorityDisinherit+0x42>
    35de:	40 93 d5 1a 	sts	0x1AD5, r20
    35e2:	c9 01       	movw	r24, r18
    35e4:	88 0f       	add	r24, r24
    35e6:	99 1f       	adc	r25, r25
    35e8:	88 0f       	add	r24, r24
    35ea:	99 1f       	adc	r25, r25
    35ec:	88 0f       	add	r24, r24
    35ee:	99 1f       	adc	r25, r25
    35f0:	28 0f       	add	r18, r24
    35f2:	39 1f       	adc	r19, r25
    35f4:	c9 01       	movw	r24, r18
    35f6:	81 52       	subi	r24, 0x21	; 33
    35f8:	95 4e       	sbci	r25, 0xE5	; 229
    35fa:	b8 01       	movw	r22, r16
    35fc:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vListInsertEnd>
			}
		}
	}
    3600:	df 91       	pop	r29
    3602:	cf 91       	pop	r28
    3604:	1f 91       	pop	r17
    3606:	0f 91       	pop	r16
    3608:	08 95       	ret

0000360a <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    360a:	cf 92       	push	r12
    360c:	df 92       	push	r13
    360e:	ef 92       	push	r14
    3610:	ff 92       	push	r15
    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    3612:	6a 01       	movw	r12, r20
    3614:	7b 01       	movw	r14, r22
    3616:	68 94       	set
    3618:	13 f8       	bld	r1, 3
    361a:	f6 94       	lsr	r15
    361c:	e7 94       	ror	r14
    361e:	d7 94       	ror	r13
    3620:	c7 94       	ror	r12
    3622:	16 94       	lsr	r1
    3624:	d1 f7       	brne	.-12     	; 0x361a <USART_Init+0x10>
    3626:	9c 01       	movw	r18, r24
    3628:	40 e0       	ldi	r20, 0x00	; 0
    362a:	50 e0       	ldi	r21, 0x00	; 0
    362c:	c7 01       	movw	r24, r14
    362e:	b6 01       	movw	r22, r12
    3630:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__udivmodsi4>
    3634:	da 01       	movw	r26, r20
    3636:	c9 01       	movw	r24, r18
    3638:	01 97       	sbiw	r24, 0x01	; 1
    363a:	a1 09       	sbc	r26, r1
    363c:	b1 09       	sbc	r27, r1
    UBRR0H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    363e:	49 2f       	mov	r20, r25
    3640:	5a 2f       	mov	r21, r26
    3642:	6b 2f       	mov	r22, r27
    3644:	77 27       	eor	r23, r23
    3646:	40 93 c5 00 	sts	0x00C5, r20
    UBRR0L = (unsigned char)ubrr;
    364a:	80 93 c4 00 	sts	0x00C4, r24
    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    364e:	88 e1       	ldi	r24, 0x18	; 24
    3650:	80 93 c1 00 	sts	0x00C1, r24
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    3654:	86 e0       	ldi	r24, 0x06	; 6
    3656:	80 93 c2 00 	sts	0x00C2, r24
	// clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    365a:	e0 ec       	ldi	r30, 0xC0	; 192
    365c:	f0 e0       	ldi	r31, 0x00	; 0
    365e:	80 81       	ld	r24, Z
    3660:	8d 7f       	andi	r24, 0xFD	; 253
    3662:	80 83       	st	Z, r24
}
    3664:	ff 90       	pop	r15
    3666:	ef 90       	pop	r14
    3668:	df 90       	pop	r13
    366a:	cf 90       	pop	r12
    366c:	08 95       	ret

0000366e <USART_Write>:

/*the send function will put 8bits on the trans line. */
void USART_Write(uint8_t data) {
		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    366e:	e0 ec       	ldi	r30, 0xC0	; 192
    3670:	f0 e0       	ldi	r31, 0x00	; 0
    3672:	90 81       	ld	r25, Z
    3674:	95 ff       	sbrs	r25, 5
    3676:	fd cf       	rjmp	.-6      	; 0x3672 <USART_Write+0x4>
		;
		/* Put data into buffer, sends the data */
		UDR0 = data;
    3678:	80 93 c6 00 	sts	0x00C6, r24
}
    367c:	08 95       	ret

0000367e <USART_Write_Unprotected>:

/*the send function will put 8bits on the trans line. */
void USART_Write_Unprotected(uint8_t data) {
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
    367e:	e0 ec       	ldi	r30, 0xC0	; 192
    3680:	f0 e0       	ldi	r31, 0x00	; 0
    3682:	90 81       	ld	r25, Z
    3684:	95 ff       	sbrs	r25, 5
    3686:	fd cf       	rjmp	.-6      	; 0x3682 <USART_Write_Unprotected+0x4>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
    3688:	80 93 c6 00 	sts	0x00C6, r24
}
    368c:	08 95       	ret

0000368e <USART_Read>:
istheredata() function to check before calling this function
        @return 8bit data packet from sender
*/
uint8_t USART_Read(void) {
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    368e:	e0 ec       	ldi	r30, 0xC0	; 192
    3690:	f0 e0       	ldi	r31, 0x00	; 0
    3692:	80 81       	ld	r24, Z
    3694:	88 23       	and	r24, r24
    3696:	ec f7       	brge	.-6      	; 0x3692 <USART_Read+0x4>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    3698:	80 91 c6 00 	lds	r24, 0x00C6
}
    369c:	08 95       	ret

0000369e <__subsf3>:
    369e:	50 58       	subi	r21, 0x80	; 128

000036a0 <__addsf3>:
    36a0:	bb 27       	eor	r27, r27
    36a2:	aa 27       	eor	r26, r26
    36a4:	0e d0       	rcall	.+28     	; 0x36c2 <__addsf3x>
    36a6:	a0 c1       	rjmp	.+832    	; 0x39e8 <__fp_round>
    36a8:	69 d1       	rcall	.+722    	; 0x397c <__fp_pscA>
    36aa:	30 f0       	brcs	.+12     	; 0x36b8 <__addsf3+0x18>
    36ac:	6e d1       	rcall	.+732    	; 0x398a <__fp_pscB>
    36ae:	20 f0       	brcs	.+8      	; 0x36b8 <__addsf3+0x18>
    36b0:	31 f4       	brne	.+12     	; 0x36be <__addsf3+0x1e>
    36b2:	9f 3f       	cpi	r25, 0xFF	; 255
    36b4:	11 f4       	brne	.+4      	; 0x36ba <__addsf3+0x1a>
    36b6:	1e f4       	brtc	.+6      	; 0x36be <__addsf3+0x1e>
    36b8:	5e c1       	rjmp	.+700    	; 0x3976 <__fp_nan>
    36ba:	0e f4       	brtc	.+2      	; 0x36be <__addsf3+0x1e>
    36bc:	e0 95       	com	r30
    36be:	e7 fb       	bst	r30, 7
    36c0:	54 c1       	rjmp	.+680    	; 0x396a <__fp_inf>

000036c2 <__addsf3x>:
    36c2:	e9 2f       	mov	r30, r25
    36c4:	b3 d1       	rcall	.+870    	; 0x3a2c <__fp_split3>
    36c6:	80 f3       	brcs	.-32     	; 0x36a8 <__addsf3+0x8>
    36c8:	ba 17       	cp	r27, r26
    36ca:	62 07       	cpc	r22, r18
    36cc:	73 07       	cpc	r23, r19
    36ce:	84 07       	cpc	r24, r20
    36d0:	95 07       	cpc	r25, r21
    36d2:	18 f0       	brcs	.+6      	; 0x36da <__addsf3x+0x18>
    36d4:	71 f4       	brne	.+28     	; 0x36f2 <__addsf3x+0x30>
    36d6:	9e f5       	brtc	.+102    	; 0x373e <__addsf3x+0x7c>
    36d8:	cb c1       	rjmp	.+918    	; 0x3a70 <__fp_zero>
    36da:	0e f4       	brtc	.+2      	; 0x36de <__addsf3x+0x1c>
    36dc:	e0 95       	com	r30
    36de:	0b 2e       	mov	r0, r27
    36e0:	ba 2f       	mov	r27, r26
    36e2:	a0 2d       	mov	r26, r0
    36e4:	0b 01       	movw	r0, r22
    36e6:	b9 01       	movw	r22, r18
    36e8:	90 01       	movw	r18, r0
    36ea:	0c 01       	movw	r0, r24
    36ec:	ca 01       	movw	r24, r20
    36ee:	a0 01       	movw	r20, r0
    36f0:	11 24       	eor	r1, r1
    36f2:	ff 27       	eor	r31, r31
    36f4:	59 1b       	sub	r21, r25
    36f6:	99 f0       	breq	.+38     	; 0x371e <__addsf3x+0x5c>
    36f8:	59 3f       	cpi	r21, 0xF9	; 249
    36fa:	50 f4       	brcc	.+20     	; 0x3710 <__addsf3x+0x4e>
    36fc:	50 3e       	cpi	r21, 0xE0	; 224
    36fe:	68 f1       	brcs	.+90     	; 0x375a <__addsf3x+0x98>
    3700:	1a 16       	cp	r1, r26
    3702:	f0 40       	sbci	r31, 0x00	; 0
    3704:	a2 2f       	mov	r26, r18
    3706:	23 2f       	mov	r18, r19
    3708:	34 2f       	mov	r19, r20
    370a:	44 27       	eor	r20, r20
    370c:	58 5f       	subi	r21, 0xF8	; 248
    370e:	f3 cf       	rjmp	.-26     	; 0x36f6 <__addsf3x+0x34>
    3710:	46 95       	lsr	r20
    3712:	37 95       	ror	r19
    3714:	27 95       	ror	r18
    3716:	a7 95       	ror	r26
    3718:	f0 40       	sbci	r31, 0x00	; 0
    371a:	53 95       	inc	r21
    371c:	c9 f7       	brne	.-14     	; 0x3710 <__addsf3x+0x4e>
    371e:	7e f4       	brtc	.+30     	; 0x373e <__addsf3x+0x7c>
    3720:	1f 16       	cp	r1, r31
    3722:	ba 0b       	sbc	r27, r26
    3724:	62 0b       	sbc	r22, r18
    3726:	73 0b       	sbc	r23, r19
    3728:	84 0b       	sbc	r24, r20
    372a:	ba f0       	brmi	.+46     	; 0x375a <__addsf3x+0x98>
    372c:	91 50       	subi	r25, 0x01	; 1
    372e:	a1 f0       	breq	.+40     	; 0x3758 <__addsf3x+0x96>
    3730:	ff 0f       	add	r31, r31
    3732:	bb 1f       	adc	r27, r27
    3734:	66 1f       	adc	r22, r22
    3736:	77 1f       	adc	r23, r23
    3738:	88 1f       	adc	r24, r24
    373a:	c2 f7       	brpl	.-16     	; 0x372c <__addsf3x+0x6a>
    373c:	0e c0       	rjmp	.+28     	; 0x375a <__addsf3x+0x98>
    373e:	ba 0f       	add	r27, r26
    3740:	62 1f       	adc	r22, r18
    3742:	73 1f       	adc	r23, r19
    3744:	84 1f       	adc	r24, r20
    3746:	48 f4       	brcc	.+18     	; 0x375a <__addsf3x+0x98>
    3748:	87 95       	ror	r24
    374a:	77 95       	ror	r23
    374c:	67 95       	ror	r22
    374e:	b7 95       	ror	r27
    3750:	f7 95       	ror	r31
    3752:	9e 3f       	cpi	r25, 0xFE	; 254
    3754:	08 f0       	brcs	.+2      	; 0x3758 <__addsf3x+0x96>
    3756:	b3 cf       	rjmp	.-154    	; 0x36be <__addsf3+0x1e>
    3758:	93 95       	inc	r25
    375a:	88 0f       	add	r24, r24
    375c:	08 f0       	brcs	.+2      	; 0x3760 <__addsf3x+0x9e>
    375e:	99 27       	eor	r25, r25
    3760:	ee 0f       	add	r30, r30
    3762:	97 95       	ror	r25
    3764:	87 95       	ror	r24
    3766:	08 95       	ret

00003768 <__cmpsf2>:
    3768:	dc d0       	rcall	.+440    	; 0x3922 <__fp_cmp>
    376a:	08 f4       	brcc	.+2      	; 0x376e <__cmpsf2+0x6>
    376c:	81 e0       	ldi	r24, 0x01	; 1
    376e:	08 95       	ret

00003770 <cos>:
    3770:	14 d1       	rcall	.+552    	; 0x399a <__fp_rempio2>
    3772:	e3 95       	inc	r30
    3774:	4a c1       	rjmp	.+660    	; 0x3a0a <__fp_sinus>

00003776 <__divsf3>:
    3776:	0c d0       	rcall	.+24     	; 0x3790 <__divsf3x>
    3778:	37 c1       	rjmp	.+622    	; 0x39e8 <__fp_round>
    377a:	07 d1       	rcall	.+526    	; 0x398a <__fp_pscB>
    377c:	40 f0       	brcs	.+16     	; 0x378e <__divsf3+0x18>
    377e:	fe d0       	rcall	.+508    	; 0x397c <__fp_pscA>
    3780:	30 f0       	brcs	.+12     	; 0x378e <__divsf3+0x18>
    3782:	21 f4       	brne	.+8      	; 0x378c <__divsf3+0x16>
    3784:	5f 3f       	cpi	r21, 0xFF	; 255
    3786:	19 f0       	breq	.+6      	; 0x378e <__divsf3+0x18>
    3788:	f0 c0       	rjmp	.+480    	; 0x396a <__fp_inf>
    378a:	51 11       	cpse	r21, r1
    378c:	72 c1       	rjmp	.+740    	; 0x3a72 <__fp_szero>
    378e:	f3 c0       	rjmp	.+486    	; 0x3976 <__fp_nan>

00003790 <__divsf3x>:
    3790:	4d d1       	rcall	.+666    	; 0x3a2c <__fp_split3>
    3792:	98 f3       	brcs	.-26     	; 0x377a <__divsf3+0x4>

00003794 <__divsf3_pse>:
    3794:	99 23       	and	r25, r25
    3796:	c9 f3       	breq	.-14     	; 0x378a <__divsf3+0x14>
    3798:	55 23       	and	r21, r21
    379a:	b1 f3       	breq	.-20     	; 0x3788 <__divsf3+0x12>
    379c:	95 1b       	sub	r25, r21
    379e:	55 0b       	sbc	r21, r21
    37a0:	bb 27       	eor	r27, r27
    37a2:	aa 27       	eor	r26, r26
    37a4:	62 17       	cp	r22, r18
    37a6:	73 07       	cpc	r23, r19
    37a8:	84 07       	cpc	r24, r20
    37aa:	38 f0       	brcs	.+14     	; 0x37ba <__divsf3_pse+0x26>
    37ac:	9f 5f       	subi	r25, 0xFF	; 255
    37ae:	5f 4f       	sbci	r21, 0xFF	; 255
    37b0:	22 0f       	add	r18, r18
    37b2:	33 1f       	adc	r19, r19
    37b4:	44 1f       	adc	r20, r20
    37b6:	aa 1f       	adc	r26, r26
    37b8:	a9 f3       	breq	.-22     	; 0x37a4 <__divsf3_pse+0x10>
    37ba:	33 d0       	rcall	.+102    	; 0x3822 <__divsf3_pse+0x8e>
    37bc:	0e 2e       	mov	r0, r30
    37be:	3a f0       	brmi	.+14     	; 0x37ce <__divsf3_pse+0x3a>
    37c0:	e0 e8       	ldi	r30, 0x80	; 128
    37c2:	30 d0       	rcall	.+96     	; 0x3824 <__divsf3_pse+0x90>
    37c4:	91 50       	subi	r25, 0x01	; 1
    37c6:	50 40       	sbci	r21, 0x00	; 0
    37c8:	e6 95       	lsr	r30
    37ca:	00 1c       	adc	r0, r0
    37cc:	ca f7       	brpl	.-14     	; 0x37c0 <__divsf3_pse+0x2c>
    37ce:	29 d0       	rcall	.+82     	; 0x3822 <__divsf3_pse+0x8e>
    37d0:	fe 2f       	mov	r31, r30
    37d2:	27 d0       	rcall	.+78     	; 0x3822 <__divsf3_pse+0x8e>
    37d4:	66 0f       	add	r22, r22
    37d6:	77 1f       	adc	r23, r23
    37d8:	88 1f       	adc	r24, r24
    37da:	bb 1f       	adc	r27, r27
    37dc:	26 17       	cp	r18, r22
    37de:	37 07       	cpc	r19, r23
    37e0:	48 07       	cpc	r20, r24
    37e2:	ab 07       	cpc	r26, r27
    37e4:	b0 e8       	ldi	r27, 0x80	; 128
    37e6:	09 f0       	breq	.+2      	; 0x37ea <__divsf3_pse+0x56>
    37e8:	bb 0b       	sbc	r27, r27
    37ea:	80 2d       	mov	r24, r0
    37ec:	bf 01       	movw	r22, r30
    37ee:	ff 27       	eor	r31, r31
    37f0:	93 58       	subi	r25, 0x83	; 131
    37f2:	5f 4f       	sbci	r21, 0xFF	; 255
    37f4:	2a f0       	brmi	.+10     	; 0x3800 <__divsf3_pse+0x6c>
    37f6:	9e 3f       	cpi	r25, 0xFE	; 254
    37f8:	51 05       	cpc	r21, r1
    37fa:	68 f0       	brcs	.+26     	; 0x3816 <__divsf3_pse+0x82>
    37fc:	b6 c0       	rjmp	.+364    	; 0x396a <__fp_inf>
    37fe:	39 c1       	rjmp	.+626    	; 0x3a72 <__fp_szero>
    3800:	5f 3f       	cpi	r21, 0xFF	; 255
    3802:	ec f3       	brlt	.-6      	; 0x37fe <__divsf3_pse+0x6a>
    3804:	98 3e       	cpi	r25, 0xE8	; 232
    3806:	dc f3       	brlt	.-10     	; 0x37fe <__divsf3_pse+0x6a>
    3808:	86 95       	lsr	r24
    380a:	77 95       	ror	r23
    380c:	67 95       	ror	r22
    380e:	b7 95       	ror	r27
    3810:	f7 95       	ror	r31
    3812:	9f 5f       	subi	r25, 0xFF	; 255
    3814:	c9 f7       	brne	.-14     	; 0x3808 <__divsf3_pse+0x74>
    3816:	88 0f       	add	r24, r24
    3818:	91 1d       	adc	r25, r1
    381a:	96 95       	lsr	r25
    381c:	87 95       	ror	r24
    381e:	97 f9       	bld	r25, 7
    3820:	08 95       	ret
    3822:	e1 e0       	ldi	r30, 0x01	; 1
    3824:	66 0f       	add	r22, r22
    3826:	77 1f       	adc	r23, r23
    3828:	88 1f       	adc	r24, r24
    382a:	bb 1f       	adc	r27, r27
    382c:	62 17       	cp	r22, r18
    382e:	73 07       	cpc	r23, r19
    3830:	84 07       	cpc	r24, r20
    3832:	ba 07       	cpc	r27, r26
    3834:	20 f0       	brcs	.+8      	; 0x383e <__divsf3_pse+0xaa>
    3836:	62 1b       	sub	r22, r18
    3838:	73 0b       	sbc	r23, r19
    383a:	84 0b       	sbc	r24, r20
    383c:	ba 0b       	sbc	r27, r26
    383e:	ee 1f       	adc	r30, r30
    3840:	88 f7       	brcc	.-30     	; 0x3824 <__divsf3_pse+0x90>
    3842:	e0 95       	com	r30
    3844:	08 95       	ret

00003846 <__fixsfsi>:
    3846:	04 d0       	rcall	.+8      	; 0x3850 <__fixunssfsi>
    3848:	68 94       	set
    384a:	b1 11       	cpse	r27, r1
    384c:	12 c1       	rjmp	.+548    	; 0x3a72 <__fp_szero>
    384e:	08 95       	ret

00003850 <__fixunssfsi>:
    3850:	f5 d0       	rcall	.+490    	; 0x3a3c <__fp_splitA>
    3852:	88 f0       	brcs	.+34     	; 0x3876 <__fixunssfsi+0x26>
    3854:	9f 57       	subi	r25, 0x7F	; 127
    3856:	90 f0       	brcs	.+36     	; 0x387c <__fixunssfsi+0x2c>
    3858:	b9 2f       	mov	r27, r25
    385a:	99 27       	eor	r25, r25
    385c:	b7 51       	subi	r27, 0x17	; 23
    385e:	a0 f0       	brcs	.+40     	; 0x3888 <__fixunssfsi+0x38>
    3860:	d1 f0       	breq	.+52     	; 0x3896 <__fixunssfsi+0x46>
    3862:	66 0f       	add	r22, r22
    3864:	77 1f       	adc	r23, r23
    3866:	88 1f       	adc	r24, r24
    3868:	99 1f       	adc	r25, r25
    386a:	1a f0       	brmi	.+6      	; 0x3872 <__fixunssfsi+0x22>
    386c:	ba 95       	dec	r27
    386e:	c9 f7       	brne	.-14     	; 0x3862 <__fixunssfsi+0x12>
    3870:	12 c0       	rjmp	.+36     	; 0x3896 <__fixunssfsi+0x46>
    3872:	b1 30       	cpi	r27, 0x01	; 1
    3874:	81 f0       	breq	.+32     	; 0x3896 <__fixunssfsi+0x46>
    3876:	fc d0       	rcall	.+504    	; 0x3a70 <__fp_zero>
    3878:	b1 e0       	ldi	r27, 0x01	; 1
    387a:	08 95       	ret
    387c:	f9 c0       	rjmp	.+498    	; 0x3a70 <__fp_zero>
    387e:	67 2f       	mov	r22, r23
    3880:	78 2f       	mov	r23, r24
    3882:	88 27       	eor	r24, r24
    3884:	b8 5f       	subi	r27, 0xF8	; 248
    3886:	39 f0       	breq	.+14     	; 0x3896 <__fixunssfsi+0x46>
    3888:	b9 3f       	cpi	r27, 0xF9	; 249
    388a:	cc f3       	brlt	.-14     	; 0x387e <__fixunssfsi+0x2e>
    388c:	86 95       	lsr	r24
    388e:	77 95       	ror	r23
    3890:	67 95       	ror	r22
    3892:	b3 95       	inc	r27
    3894:	d9 f7       	brne	.-10     	; 0x388c <__fixunssfsi+0x3c>
    3896:	3e f4       	brtc	.+14     	; 0x38a6 <__fixunssfsi+0x56>
    3898:	90 95       	com	r25
    389a:	80 95       	com	r24
    389c:	70 95       	com	r23
    389e:	61 95       	neg	r22
    38a0:	7f 4f       	sbci	r23, 0xFF	; 255
    38a2:	8f 4f       	sbci	r24, 0xFF	; 255
    38a4:	9f 4f       	sbci	r25, 0xFF	; 255
    38a6:	08 95       	ret

000038a8 <__floatunsisf>:
    38a8:	e8 94       	clt
    38aa:	09 c0       	rjmp	.+18     	; 0x38be <__floatsisf+0x12>

000038ac <__floatsisf>:
    38ac:	97 fb       	bst	r25, 7
    38ae:	3e f4       	brtc	.+14     	; 0x38be <__floatsisf+0x12>
    38b0:	90 95       	com	r25
    38b2:	80 95       	com	r24
    38b4:	70 95       	com	r23
    38b6:	61 95       	neg	r22
    38b8:	7f 4f       	sbci	r23, 0xFF	; 255
    38ba:	8f 4f       	sbci	r24, 0xFF	; 255
    38bc:	9f 4f       	sbci	r25, 0xFF	; 255
    38be:	99 23       	and	r25, r25
    38c0:	a9 f0       	breq	.+42     	; 0x38ec <__floatsisf+0x40>
    38c2:	f9 2f       	mov	r31, r25
    38c4:	96 e9       	ldi	r25, 0x96	; 150
    38c6:	bb 27       	eor	r27, r27
    38c8:	93 95       	inc	r25
    38ca:	f6 95       	lsr	r31
    38cc:	87 95       	ror	r24
    38ce:	77 95       	ror	r23
    38d0:	67 95       	ror	r22
    38d2:	b7 95       	ror	r27
    38d4:	f1 11       	cpse	r31, r1
    38d6:	f8 cf       	rjmp	.-16     	; 0x38c8 <__floatsisf+0x1c>
    38d8:	fa f4       	brpl	.+62     	; 0x3918 <__floatsisf+0x6c>
    38da:	bb 0f       	add	r27, r27
    38dc:	11 f4       	brne	.+4      	; 0x38e2 <__floatsisf+0x36>
    38de:	60 ff       	sbrs	r22, 0
    38e0:	1b c0       	rjmp	.+54     	; 0x3918 <__floatsisf+0x6c>
    38e2:	6f 5f       	subi	r22, 0xFF	; 255
    38e4:	7f 4f       	sbci	r23, 0xFF	; 255
    38e6:	8f 4f       	sbci	r24, 0xFF	; 255
    38e8:	9f 4f       	sbci	r25, 0xFF	; 255
    38ea:	16 c0       	rjmp	.+44     	; 0x3918 <__floatsisf+0x6c>
    38ec:	88 23       	and	r24, r24
    38ee:	11 f0       	breq	.+4      	; 0x38f4 <__floatsisf+0x48>
    38f0:	96 e9       	ldi	r25, 0x96	; 150
    38f2:	11 c0       	rjmp	.+34     	; 0x3916 <__floatsisf+0x6a>
    38f4:	77 23       	and	r23, r23
    38f6:	21 f0       	breq	.+8      	; 0x3900 <__floatsisf+0x54>
    38f8:	9e e8       	ldi	r25, 0x8E	; 142
    38fa:	87 2f       	mov	r24, r23
    38fc:	76 2f       	mov	r23, r22
    38fe:	05 c0       	rjmp	.+10     	; 0x390a <__floatsisf+0x5e>
    3900:	66 23       	and	r22, r22
    3902:	71 f0       	breq	.+28     	; 0x3920 <__floatsisf+0x74>
    3904:	96 e8       	ldi	r25, 0x86	; 134
    3906:	86 2f       	mov	r24, r22
    3908:	70 e0       	ldi	r23, 0x00	; 0
    390a:	60 e0       	ldi	r22, 0x00	; 0
    390c:	2a f0       	brmi	.+10     	; 0x3918 <__floatsisf+0x6c>
    390e:	9a 95       	dec	r25
    3910:	66 0f       	add	r22, r22
    3912:	77 1f       	adc	r23, r23
    3914:	88 1f       	adc	r24, r24
    3916:	da f7       	brpl	.-10     	; 0x390e <__floatsisf+0x62>
    3918:	88 0f       	add	r24, r24
    391a:	96 95       	lsr	r25
    391c:	87 95       	ror	r24
    391e:	97 f9       	bld	r25, 7
    3920:	08 95       	ret

00003922 <__fp_cmp>:
    3922:	99 0f       	add	r25, r25
    3924:	00 08       	sbc	r0, r0
    3926:	55 0f       	add	r21, r21
    3928:	aa 0b       	sbc	r26, r26
    392a:	e0 e8       	ldi	r30, 0x80	; 128
    392c:	fe ef       	ldi	r31, 0xFE	; 254
    392e:	16 16       	cp	r1, r22
    3930:	17 06       	cpc	r1, r23
    3932:	e8 07       	cpc	r30, r24
    3934:	f9 07       	cpc	r31, r25
    3936:	c0 f0       	brcs	.+48     	; 0x3968 <__fp_cmp+0x46>
    3938:	12 16       	cp	r1, r18
    393a:	13 06       	cpc	r1, r19
    393c:	e4 07       	cpc	r30, r20
    393e:	f5 07       	cpc	r31, r21
    3940:	98 f0       	brcs	.+38     	; 0x3968 <__fp_cmp+0x46>
    3942:	62 1b       	sub	r22, r18
    3944:	73 0b       	sbc	r23, r19
    3946:	84 0b       	sbc	r24, r20
    3948:	95 0b       	sbc	r25, r21
    394a:	39 f4       	brne	.+14     	; 0x395a <__fp_cmp+0x38>
    394c:	0a 26       	eor	r0, r26
    394e:	61 f0       	breq	.+24     	; 0x3968 <__fp_cmp+0x46>
    3950:	23 2b       	or	r18, r19
    3952:	24 2b       	or	r18, r20
    3954:	25 2b       	or	r18, r21
    3956:	21 f4       	brne	.+8      	; 0x3960 <__fp_cmp+0x3e>
    3958:	08 95       	ret
    395a:	0a 26       	eor	r0, r26
    395c:	09 f4       	brne	.+2      	; 0x3960 <__fp_cmp+0x3e>
    395e:	a1 40       	sbci	r26, 0x01	; 1
    3960:	a6 95       	lsr	r26
    3962:	8f ef       	ldi	r24, 0xFF	; 255
    3964:	81 1d       	adc	r24, r1
    3966:	81 1d       	adc	r24, r1
    3968:	08 95       	ret

0000396a <__fp_inf>:
    396a:	97 f9       	bld	r25, 7
    396c:	9f 67       	ori	r25, 0x7F	; 127
    396e:	80 e8       	ldi	r24, 0x80	; 128
    3970:	70 e0       	ldi	r23, 0x00	; 0
    3972:	60 e0       	ldi	r22, 0x00	; 0
    3974:	08 95       	ret

00003976 <__fp_nan>:
    3976:	9f ef       	ldi	r25, 0xFF	; 255
    3978:	80 ec       	ldi	r24, 0xC0	; 192
    397a:	08 95       	ret

0000397c <__fp_pscA>:
    397c:	00 24       	eor	r0, r0
    397e:	0a 94       	dec	r0
    3980:	16 16       	cp	r1, r22
    3982:	17 06       	cpc	r1, r23
    3984:	18 06       	cpc	r1, r24
    3986:	09 06       	cpc	r0, r25
    3988:	08 95       	ret

0000398a <__fp_pscB>:
    398a:	00 24       	eor	r0, r0
    398c:	0a 94       	dec	r0
    398e:	12 16       	cp	r1, r18
    3990:	13 06       	cpc	r1, r19
    3992:	14 06       	cpc	r1, r20
    3994:	05 06       	cpc	r0, r21
    3996:	08 95       	ret
    3998:	ee cf       	rjmp	.-36     	; 0x3976 <__fp_nan>

0000399a <__fp_rempio2>:
    399a:	50 d0       	rcall	.+160    	; 0x3a3c <__fp_splitA>
    399c:	e8 f3       	brcs	.-6      	; 0x3998 <__fp_pscB+0xe>
    399e:	e8 94       	clt
    39a0:	e0 e0       	ldi	r30, 0x00	; 0
    39a2:	bb 27       	eor	r27, r27
    39a4:	9f 57       	subi	r25, 0x7F	; 127
    39a6:	f0 f0       	brcs	.+60     	; 0x39e4 <__fp_rempio2+0x4a>
    39a8:	2a ed       	ldi	r18, 0xDA	; 218
    39aa:	3f e0       	ldi	r19, 0x0F	; 15
    39ac:	49 ec       	ldi	r20, 0xC9	; 201
    39ae:	06 c0       	rjmp	.+12     	; 0x39bc <__fp_rempio2+0x22>
    39b0:	ee 0f       	add	r30, r30
    39b2:	bb 0f       	add	r27, r27
    39b4:	66 1f       	adc	r22, r22
    39b6:	77 1f       	adc	r23, r23
    39b8:	88 1f       	adc	r24, r24
    39ba:	28 f0       	brcs	.+10     	; 0x39c6 <__fp_rempio2+0x2c>
    39bc:	b2 3a       	cpi	r27, 0xA2	; 162
    39be:	62 07       	cpc	r22, r18
    39c0:	73 07       	cpc	r23, r19
    39c2:	84 07       	cpc	r24, r20
    39c4:	28 f0       	brcs	.+10     	; 0x39d0 <__fp_rempio2+0x36>
    39c6:	b2 5a       	subi	r27, 0xA2	; 162
    39c8:	62 0b       	sbc	r22, r18
    39ca:	73 0b       	sbc	r23, r19
    39cc:	84 0b       	sbc	r24, r20
    39ce:	e3 95       	inc	r30
    39d0:	9a 95       	dec	r25
    39d2:	72 f7       	brpl	.-36     	; 0x39b0 <__fp_rempio2+0x16>
    39d4:	80 38       	cpi	r24, 0x80	; 128
    39d6:	30 f4       	brcc	.+12     	; 0x39e4 <__fp_rempio2+0x4a>
    39d8:	9a 95       	dec	r25
    39da:	bb 0f       	add	r27, r27
    39dc:	66 1f       	adc	r22, r22
    39de:	77 1f       	adc	r23, r23
    39e0:	88 1f       	adc	r24, r24
    39e2:	d2 f7       	brpl	.-12     	; 0x39d8 <__fp_rempio2+0x3e>
    39e4:	90 48       	sbci	r25, 0x80	; 128
    39e6:	ba c0       	rjmp	.+372    	; 0x3b5c <__fp_mpack_finite>

000039e8 <__fp_round>:
    39e8:	09 2e       	mov	r0, r25
    39ea:	03 94       	inc	r0
    39ec:	00 0c       	add	r0, r0
    39ee:	11 f4       	brne	.+4      	; 0x39f4 <__fp_round+0xc>
    39f0:	88 23       	and	r24, r24
    39f2:	52 f0       	brmi	.+20     	; 0x3a08 <__fp_round+0x20>
    39f4:	bb 0f       	add	r27, r27
    39f6:	40 f4       	brcc	.+16     	; 0x3a08 <__fp_round+0x20>
    39f8:	bf 2b       	or	r27, r31
    39fa:	11 f4       	brne	.+4      	; 0x3a00 <__fp_round+0x18>
    39fc:	60 ff       	sbrs	r22, 0
    39fe:	04 c0       	rjmp	.+8      	; 0x3a08 <__fp_round+0x20>
    3a00:	6f 5f       	subi	r22, 0xFF	; 255
    3a02:	7f 4f       	sbci	r23, 0xFF	; 255
    3a04:	8f 4f       	sbci	r24, 0xFF	; 255
    3a06:	9f 4f       	sbci	r25, 0xFF	; 255
    3a08:	08 95       	ret

00003a0a <__fp_sinus>:
    3a0a:	ef 93       	push	r30
    3a0c:	e0 ff       	sbrs	r30, 0
    3a0e:	06 c0       	rjmp	.+12     	; 0x3a1c <__fp_sinus+0x12>
    3a10:	a2 ea       	ldi	r26, 0xA2	; 162
    3a12:	2a ed       	ldi	r18, 0xDA	; 218
    3a14:	3f e0       	ldi	r19, 0x0F	; 15
    3a16:	49 ec       	ldi	r20, 0xC9	; 201
    3a18:	5f eb       	ldi	r21, 0xBF	; 191
    3a1a:	53 de       	rcall	.-858    	; 0x36c2 <__addsf3x>
    3a1c:	e5 df       	rcall	.-54     	; 0x39e8 <__fp_round>
    3a1e:	0f 90       	pop	r0
    3a20:	03 94       	inc	r0
    3a22:	01 fc       	sbrc	r0, 1
    3a24:	90 58       	subi	r25, 0x80	; 128
    3a26:	e4 ee       	ldi	r30, 0xE4	; 228
    3a28:	f0 e0       	ldi	r31, 0x00	; 0
    3a2a:	a4 c0       	rjmp	.+328    	; 0x3b74 <__fp_powsodd>

00003a2c <__fp_split3>:
    3a2c:	57 fd       	sbrc	r21, 7
    3a2e:	90 58       	subi	r25, 0x80	; 128
    3a30:	44 0f       	add	r20, r20
    3a32:	55 1f       	adc	r21, r21
    3a34:	59 f0       	breq	.+22     	; 0x3a4c <__fp_splitA+0x10>
    3a36:	5f 3f       	cpi	r21, 0xFF	; 255
    3a38:	71 f0       	breq	.+28     	; 0x3a56 <__fp_splitA+0x1a>
    3a3a:	47 95       	ror	r20

00003a3c <__fp_splitA>:
    3a3c:	88 0f       	add	r24, r24
    3a3e:	97 fb       	bst	r25, 7
    3a40:	99 1f       	adc	r25, r25
    3a42:	61 f0       	breq	.+24     	; 0x3a5c <__fp_splitA+0x20>
    3a44:	9f 3f       	cpi	r25, 0xFF	; 255
    3a46:	79 f0       	breq	.+30     	; 0x3a66 <__fp_splitA+0x2a>
    3a48:	87 95       	ror	r24
    3a4a:	08 95       	ret
    3a4c:	12 16       	cp	r1, r18
    3a4e:	13 06       	cpc	r1, r19
    3a50:	14 06       	cpc	r1, r20
    3a52:	55 1f       	adc	r21, r21
    3a54:	f2 cf       	rjmp	.-28     	; 0x3a3a <__fp_split3+0xe>
    3a56:	46 95       	lsr	r20
    3a58:	f1 df       	rcall	.-30     	; 0x3a3c <__fp_splitA>
    3a5a:	08 c0       	rjmp	.+16     	; 0x3a6c <__fp_splitA+0x30>
    3a5c:	16 16       	cp	r1, r22
    3a5e:	17 06       	cpc	r1, r23
    3a60:	18 06       	cpc	r1, r24
    3a62:	99 1f       	adc	r25, r25
    3a64:	f1 cf       	rjmp	.-30     	; 0x3a48 <__fp_splitA+0xc>
    3a66:	86 95       	lsr	r24
    3a68:	71 05       	cpc	r23, r1
    3a6a:	61 05       	cpc	r22, r1
    3a6c:	08 94       	sec
    3a6e:	08 95       	ret

00003a70 <__fp_zero>:
    3a70:	e8 94       	clt

00003a72 <__fp_szero>:
    3a72:	bb 27       	eor	r27, r27
    3a74:	66 27       	eor	r22, r22
    3a76:	77 27       	eor	r23, r23
    3a78:	cb 01       	movw	r24, r22
    3a7a:	97 f9       	bld	r25, 7
    3a7c:	08 95       	ret

00003a7e <__gesf2>:
    3a7e:	51 df       	rcall	.-350    	; 0x3922 <__fp_cmp>
    3a80:	08 f4       	brcc	.+2      	; 0x3a84 <__gesf2+0x6>
    3a82:	8f ef       	ldi	r24, 0xFF	; 255
    3a84:	08 95       	ret

00003a86 <__mulsf3>:
    3a86:	0b d0       	rcall	.+22     	; 0x3a9e <__mulsf3x>
    3a88:	af cf       	rjmp	.-162    	; 0x39e8 <__fp_round>
    3a8a:	78 df       	rcall	.-272    	; 0x397c <__fp_pscA>
    3a8c:	28 f0       	brcs	.+10     	; 0x3a98 <__mulsf3+0x12>
    3a8e:	7d df       	rcall	.-262    	; 0x398a <__fp_pscB>
    3a90:	18 f0       	brcs	.+6      	; 0x3a98 <__mulsf3+0x12>
    3a92:	95 23       	and	r25, r21
    3a94:	09 f0       	breq	.+2      	; 0x3a98 <__mulsf3+0x12>
    3a96:	69 cf       	rjmp	.-302    	; 0x396a <__fp_inf>
    3a98:	6e cf       	rjmp	.-292    	; 0x3976 <__fp_nan>
    3a9a:	11 24       	eor	r1, r1
    3a9c:	ea cf       	rjmp	.-44     	; 0x3a72 <__fp_szero>

00003a9e <__mulsf3x>:
    3a9e:	c6 df       	rcall	.-116    	; 0x3a2c <__fp_split3>
    3aa0:	a0 f3       	brcs	.-24     	; 0x3a8a <__mulsf3+0x4>

00003aa2 <__mulsf3_pse>:
    3aa2:	95 9f       	mul	r25, r21
    3aa4:	d1 f3       	breq	.-12     	; 0x3a9a <__mulsf3+0x14>
    3aa6:	95 0f       	add	r25, r21
    3aa8:	50 e0       	ldi	r21, 0x00	; 0
    3aaa:	55 1f       	adc	r21, r21
    3aac:	62 9f       	mul	r22, r18
    3aae:	f0 01       	movw	r30, r0
    3ab0:	72 9f       	mul	r23, r18
    3ab2:	bb 27       	eor	r27, r27
    3ab4:	f0 0d       	add	r31, r0
    3ab6:	b1 1d       	adc	r27, r1
    3ab8:	63 9f       	mul	r22, r19
    3aba:	aa 27       	eor	r26, r26
    3abc:	f0 0d       	add	r31, r0
    3abe:	b1 1d       	adc	r27, r1
    3ac0:	aa 1f       	adc	r26, r26
    3ac2:	64 9f       	mul	r22, r20
    3ac4:	66 27       	eor	r22, r22
    3ac6:	b0 0d       	add	r27, r0
    3ac8:	a1 1d       	adc	r26, r1
    3aca:	66 1f       	adc	r22, r22
    3acc:	82 9f       	mul	r24, r18
    3ace:	22 27       	eor	r18, r18
    3ad0:	b0 0d       	add	r27, r0
    3ad2:	a1 1d       	adc	r26, r1
    3ad4:	62 1f       	adc	r22, r18
    3ad6:	73 9f       	mul	r23, r19
    3ad8:	b0 0d       	add	r27, r0
    3ada:	a1 1d       	adc	r26, r1
    3adc:	62 1f       	adc	r22, r18
    3ade:	83 9f       	mul	r24, r19
    3ae0:	a0 0d       	add	r26, r0
    3ae2:	61 1d       	adc	r22, r1
    3ae4:	22 1f       	adc	r18, r18
    3ae6:	74 9f       	mul	r23, r20
    3ae8:	33 27       	eor	r19, r19
    3aea:	a0 0d       	add	r26, r0
    3aec:	61 1d       	adc	r22, r1
    3aee:	23 1f       	adc	r18, r19
    3af0:	84 9f       	mul	r24, r20
    3af2:	60 0d       	add	r22, r0
    3af4:	21 1d       	adc	r18, r1
    3af6:	82 2f       	mov	r24, r18
    3af8:	76 2f       	mov	r23, r22
    3afa:	6a 2f       	mov	r22, r26
    3afc:	11 24       	eor	r1, r1
    3afe:	9f 57       	subi	r25, 0x7F	; 127
    3b00:	50 40       	sbci	r21, 0x00	; 0
    3b02:	8a f0       	brmi	.+34     	; 0x3b26 <__mulsf3_pse+0x84>
    3b04:	e1 f0       	breq	.+56     	; 0x3b3e <__mulsf3_pse+0x9c>
    3b06:	88 23       	and	r24, r24
    3b08:	4a f0       	brmi	.+18     	; 0x3b1c <__mulsf3_pse+0x7a>
    3b0a:	ee 0f       	add	r30, r30
    3b0c:	ff 1f       	adc	r31, r31
    3b0e:	bb 1f       	adc	r27, r27
    3b10:	66 1f       	adc	r22, r22
    3b12:	77 1f       	adc	r23, r23
    3b14:	88 1f       	adc	r24, r24
    3b16:	91 50       	subi	r25, 0x01	; 1
    3b18:	50 40       	sbci	r21, 0x00	; 0
    3b1a:	a9 f7       	brne	.-22     	; 0x3b06 <__mulsf3_pse+0x64>
    3b1c:	9e 3f       	cpi	r25, 0xFE	; 254
    3b1e:	51 05       	cpc	r21, r1
    3b20:	70 f0       	brcs	.+28     	; 0x3b3e <__mulsf3_pse+0x9c>
    3b22:	23 cf       	rjmp	.-442    	; 0x396a <__fp_inf>
    3b24:	a6 cf       	rjmp	.-180    	; 0x3a72 <__fp_szero>
    3b26:	5f 3f       	cpi	r21, 0xFF	; 255
    3b28:	ec f3       	brlt	.-6      	; 0x3b24 <__mulsf3_pse+0x82>
    3b2a:	98 3e       	cpi	r25, 0xE8	; 232
    3b2c:	dc f3       	brlt	.-10     	; 0x3b24 <__mulsf3_pse+0x82>
    3b2e:	86 95       	lsr	r24
    3b30:	77 95       	ror	r23
    3b32:	67 95       	ror	r22
    3b34:	b7 95       	ror	r27
    3b36:	f7 95       	ror	r31
    3b38:	e7 95       	ror	r30
    3b3a:	9f 5f       	subi	r25, 0xFF	; 255
    3b3c:	c1 f7       	brne	.-16     	; 0x3b2e <__mulsf3_pse+0x8c>
    3b3e:	fe 2b       	or	r31, r30
    3b40:	88 0f       	add	r24, r24
    3b42:	91 1d       	adc	r25, r1
    3b44:	96 95       	lsr	r25
    3b46:	87 95       	ror	r24
    3b48:	97 f9       	bld	r25, 7
    3b4a:	08 95       	ret

00003b4c <sin>:
    3b4c:	9f 93       	push	r25
    3b4e:	25 df       	rcall	.-438    	; 0x399a <__fp_rempio2>
    3b50:	0f 90       	pop	r0
    3b52:	07 fc       	sbrc	r0, 7
    3b54:	ee 5f       	subi	r30, 0xFE	; 254
    3b56:	59 cf       	rjmp	.-334    	; 0x3a0a <__fp_sinus>

00003b58 <__fp_mpack>:
    3b58:	9f 3f       	cpi	r25, 0xFF	; 255
    3b5a:	31 f0       	breq	.+12     	; 0x3b68 <__fp_mpack_finite+0xc>

00003b5c <__fp_mpack_finite>:
    3b5c:	91 50       	subi	r25, 0x01	; 1
    3b5e:	20 f4       	brcc	.+8      	; 0x3b68 <__fp_mpack_finite+0xc>
    3b60:	87 95       	ror	r24
    3b62:	77 95       	ror	r23
    3b64:	67 95       	ror	r22
    3b66:	b7 95       	ror	r27
    3b68:	88 0f       	add	r24, r24
    3b6a:	91 1d       	adc	r25, r1
    3b6c:	96 95       	lsr	r25
    3b6e:	87 95       	ror	r24
    3b70:	97 f9       	bld	r25, 7
    3b72:	08 95       	ret

00003b74 <__fp_powsodd>:
    3b74:	9f 93       	push	r25
    3b76:	8f 93       	push	r24
    3b78:	7f 93       	push	r23
    3b7a:	6f 93       	push	r22
    3b7c:	ff 93       	push	r31
    3b7e:	ef 93       	push	r30
    3b80:	9b 01       	movw	r18, r22
    3b82:	ac 01       	movw	r20, r24
    3b84:	80 df       	rcall	.-256    	; 0x3a86 <__mulsf3>
    3b86:	ef 91       	pop	r30
    3b88:	ff 91       	pop	r31
    3b8a:	05 d0       	rcall	.+10     	; 0x3b96 <__fp_powser>
    3b8c:	2f 91       	pop	r18
    3b8e:	3f 91       	pop	r19
    3b90:	4f 91       	pop	r20
    3b92:	5f 91       	pop	r21
    3b94:	78 cf       	rjmp	.-272    	; 0x3a86 <__mulsf3>

00003b96 <__fp_powser>:
    3b96:	df 93       	push	r29
    3b98:	cf 93       	push	r28
    3b9a:	1f 93       	push	r17
    3b9c:	0f 93       	push	r16
    3b9e:	ff 92       	push	r15
    3ba0:	ef 92       	push	r14
    3ba2:	df 92       	push	r13
    3ba4:	7b 01       	movw	r14, r22
    3ba6:	8c 01       	movw	r16, r24
    3ba8:	68 94       	set
    3baa:	05 c0       	rjmp	.+10     	; 0x3bb6 <__fp_powser+0x20>
    3bac:	da 2e       	mov	r13, r26
    3bae:	ef 01       	movw	r28, r30
    3bb0:	76 df       	rcall	.-276    	; 0x3a9e <__mulsf3x>
    3bb2:	fe 01       	movw	r30, r28
    3bb4:	e8 94       	clt
    3bb6:	a5 91       	lpm	r26, Z+
    3bb8:	25 91       	lpm	r18, Z+
    3bba:	35 91       	lpm	r19, Z+
    3bbc:	45 91       	lpm	r20, Z+
    3bbe:	55 91       	lpm	r21, Z+
    3bc0:	ae f3       	brts	.-22     	; 0x3bac <__fp_powser+0x16>
    3bc2:	ef 01       	movw	r28, r30
    3bc4:	7e dd       	rcall	.-1284   	; 0x36c2 <__addsf3x>
    3bc6:	fe 01       	movw	r30, r28
    3bc8:	97 01       	movw	r18, r14
    3bca:	a8 01       	movw	r20, r16
    3bcc:	da 94       	dec	r13
    3bce:	79 f7       	brne	.-34     	; 0x3bae <__fp_powser+0x18>
    3bd0:	df 90       	pop	r13
    3bd2:	ef 90       	pop	r14
    3bd4:	ff 90       	pop	r15
    3bd6:	0f 91       	pop	r16
    3bd8:	1f 91       	pop	r17
    3bda:	cf 91       	pop	r28
    3bdc:	df 91       	pop	r29
    3bde:	08 95       	ret

00003be0 <__divmodhi4>:
    3be0:	97 fb       	bst	r25, 7
    3be2:	09 2e       	mov	r0, r25
    3be4:	07 26       	eor	r0, r23
    3be6:	0a d0       	rcall	.+20     	; 0x3bfc <__divmodhi4_neg1>
    3be8:	77 fd       	sbrc	r23, 7
    3bea:	04 d0       	rcall	.+8      	; 0x3bf4 <__divmodhi4_neg2>
    3bec:	2e d0       	rcall	.+92     	; 0x3c4a <__udivmodhi4>
    3bee:	06 d0       	rcall	.+12     	; 0x3bfc <__divmodhi4_neg1>
    3bf0:	00 20       	and	r0, r0
    3bf2:	1a f4       	brpl	.+6      	; 0x3bfa <__divmodhi4_exit>

00003bf4 <__divmodhi4_neg2>:
    3bf4:	70 95       	com	r23
    3bf6:	61 95       	neg	r22
    3bf8:	7f 4f       	sbci	r23, 0xFF	; 255

00003bfa <__divmodhi4_exit>:
    3bfa:	08 95       	ret

00003bfc <__divmodhi4_neg1>:
    3bfc:	f6 f7       	brtc	.-4      	; 0x3bfa <__divmodhi4_exit>
    3bfe:	90 95       	com	r25
    3c00:	81 95       	neg	r24
    3c02:	9f 4f       	sbci	r25, 0xFF	; 255
    3c04:	08 95       	ret

00003c06 <__udivmodsi4>:
    3c06:	a1 e2       	ldi	r26, 0x21	; 33
    3c08:	1a 2e       	mov	r1, r26
    3c0a:	aa 1b       	sub	r26, r26
    3c0c:	bb 1b       	sub	r27, r27
    3c0e:	fd 01       	movw	r30, r26
    3c10:	0d c0       	rjmp	.+26     	; 0x3c2c <__udivmodsi4_ep>

00003c12 <__udivmodsi4_loop>:
    3c12:	aa 1f       	adc	r26, r26
    3c14:	bb 1f       	adc	r27, r27
    3c16:	ee 1f       	adc	r30, r30
    3c18:	ff 1f       	adc	r31, r31
    3c1a:	a2 17       	cp	r26, r18
    3c1c:	b3 07       	cpc	r27, r19
    3c1e:	e4 07       	cpc	r30, r20
    3c20:	f5 07       	cpc	r31, r21
    3c22:	20 f0       	brcs	.+8      	; 0x3c2c <__udivmodsi4_ep>
    3c24:	a2 1b       	sub	r26, r18
    3c26:	b3 0b       	sbc	r27, r19
    3c28:	e4 0b       	sbc	r30, r20
    3c2a:	f5 0b       	sbc	r31, r21

00003c2c <__udivmodsi4_ep>:
    3c2c:	66 1f       	adc	r22, r22
    3c2e:	77 1f       	adc	r23, r23
    3c30:	88 1f       	adc	r24, r24
    3c32:	99 1f       	adc	r25, r25
    3c34:	1a 94       	dec	r1
    3c36:	69 f7       	brne	.-38     	; 0x3c12 <__udivmodsi4_loop>
    3c38:	60 95       	com	r22
    3c3a:	70 95       	com	r23
    3c3c:	80 95       	com	r24
    3c3e:	90 95       	com	r25
    3c40:	9b 01       	movw	r18, r22
    3c42:	ac 01       	movw	r20, r24
    3c44:	bd 01       	movw	r22, r26
    3c46:	cf 01       	movw	r24, r30
    3c48:	08 95       	ret

00003c4a <__udivmodhi4>:
    3c4a:	aa 1b       	sub	r26, r26
    3c4c:	bb 1b       	sub	r27, r27
    3c4e:	51 e1       	ldi	r21, 0x11	; 17
    3c50:	07 c0       	rjmp	.+14     	; 0x3c60 <__udivmodhi4_ep>

00003c52 <__udivmodhi4_loop>:
    3c52:	aa 1f       	adc	r26, r26
    3c54:	bb 1f       	adc	r27, r27
    3c56:	a6 17       	cp	r26, r22
    3c58:	b7 07       	cpc	r27, r23
    3c5a:	10 f0       	brcs	.+4      	; 0x3c60 <__udivmodhi4_ep>
    3c5c:	a6 1b       	sub	r26, r22
    3c5e:	b7 0b       	sbc	r27, r23

00003c60 <__udivmodhi4_ep>:
    3c60:	88 1f       	adc	r24, r24
    3c62:	99 1f       	adc	r25, r25
    3c64:	5a 95       	dec	r21
    3c66:	a9 f7       	brne	.-22     	; 0x3c52 <__udivmodhi4_loop>
    3c68:	80 95       	com	r24
    3c6a:	90 95       	com	r25
    3c6c:	bc 01       	movw	r22, r24
    3c6e:	cd 01       	movw	r24, r26
    3c70:	08 95       	ret

00003c72 <do_rand>:
    3c72:	8f 92       	push	r8
    3c74:	9f 92       	push	r9
    3c76:	af 92       	push	r10
    3c78:	bf 92       	push	r11
    3c7a:	cf 92       	push	r12
    3c7c:	df 92       	push	r13
    3c7e:	ef 92       	push	r14
    3c80:	ff 92       	push	r15
    3c82:	cf 93       	push	r28
    3c84:	df 93       	push	r29
    3c86:	ec 01       	movw	r28, r24
    3c88:	88 81       	ld	r24, Y
    3c8a:	99 81       	ldd	r25, Y+1	; 0x01
    3c8c:	aa 81       	ldd	r26, Y+2	; 0x02
    3c8e:	bb 81       	ldd	r27, Y+3	; 0x03
    3c90:	00 97       	sbiw	r24, 0x00	; 0
    3c92:	a1 05       	cpc	r26, r1
    3c94:	b1 05       	cpc	r27, r1
    3c96:	21 f4       	brne	.+8      	; 0x3ca0 <do_rand+0x2e>
    3c98:	84 e2       	ldi	r24, 0x24	; 36
    3c9a:	99 ed       	ldi	r25, 0xD9	; 217
    3c9c:	ab e5       	ldi	r26, 0x5B	; 91
    3c9e:	b7 e0       	ldi	r27, 0x07	; 7
    3ca0:	bc 01       	movw	r22, r24
    3ca2:	cd 01       	movw	r24, r26
    3ca4:	2d e1       	ldi	r18, 0x1D	; 29
    3ca6:	33 ef       	ldi	r19, 0xF3	; 243
    3ca8:	41 e0       	ldi	r20, 0x01	; 1
    3caa:	50 e0       	ldi	r21, 0x00	; 0
    3cac:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <__divmodsi4>
    3cb0:	49 01       	movw	r8, r18
    3cb2:	5a 01       	movw	r10, r20
    3cb4:	27 ea       	ldi	r18, 0xA7	; 167
    3cb6:	31 e4       	ldi	r19, 0x41	; 65
    3cb8:	40 e0       	ldi	r20, 0x00	; 0
    3cba:	50 e0       	ldi	r21, 0x00	; 0
    3cbc:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <__mulsi3>
    3cc0:	6b 01       	movw	r12, r22
    3cc2:	7c 01       	movw	r14, r24
    3cc4:	c5 01       	movw	r24, r10
    3cc6:	b4 01       	movw	r22, r8
    3cc8:	2c ee       	ldi	r18, 0xEC	; 236
    3cca:	34 ef       	ldi	r19, 0xF4	; 244
    3ccc:	4f ef       	ldi	r20, 0xFF	; 255
    3cce:	5f ef       	ldi	r21, 0xFF	; 255
    3cd0:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <__mulsi3>
    3cd4:	dc 01       	movw	r26, r24
    3cd6:	cb 01       	movw	r24, r22
    3cd8:	c8 0e       	add	r12, r24
    3cda:	d9 1e       	adc	r13, r25
    3cdc:	ea 1e       	adc	r14, r26
    3cde:	fb 1e       	adc	r15, r27
    3ce0:	f7 fe       	sbrs	r15, 7
    3ce2:	08 c0       	rjmp	.+16     	; 0x3cf4 <do_rand+0x82>
    3ce4:	8f ef       	ldi	r24, 0xFF	; 255
    3ce6:	9f ef       	ldi	r25, 0xFF	; 255
    3ce8:	af ef       	ldi	r26, 0xFF	; 255
    3cea:	bf e7       	ldi	r27, 0x7F	; 127
    3cec:	c8 0e       	add	r12, r24
    3cee:	d9 1e       	adc	r13, r25
    3cf0:	ea 1e       	adc	r14, r26
    3cf2:	fb 1e       	adc	r15, r27
    3cf4:	c8 82       	st	Y, r12
    3cf6:	d9 82       	std	Y+1, r13	; 0x01
    3cf8:	ea 82       	std	Y+2, r14	; 0x02
    3cfa:	fb 82       	std	Y+3, r15	; 0x03
    3cfc:	c6 01       	movw	r24, r12
    3cfe:	9f 77       	andi	r25, 0x7F	; 127
    3d00:	df 91       	pop	r29
    3d02:	cf 91       	pop	r28
    3d04:	ff 90       	pop	r15
    3d06:	ef 90       	pop	r14
    3d08:	df 90       	pop	r13
    3d0a:	cf 90       	pop	r12
    3d0c:	bf 90       	pop	r11
    3d0e:	af 90       	pop	r10
    3d10:	9f 90       	pop	r9
    3d12:	8f 90       	pop	r8
    3d14:	08 95       	ret

00003d16 <rand_r>:
    3d16:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <do_rand>
    3d1a:	08 95       	ret

00003d1c <rand>:
    3d1c:	8b e5       	ldi	r24, 0x5B	; 91
    3d1e:	92 e0       	ldi	r25, 0x02	; 2
    3d20:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <do_rand>
    3d24:	08 95       	ret

00003d26 <srand>:
    3d26:	a0 e0       	ldi	r26, 0x00	; 0
    3d28:	b0 e0       	ldi	r27, 0x00	; 0
    3d2a:	80 93 5b 02 	sts	0x025B, r24
    3d2e:	90 93 5c 02 	sts	0x025C, r25
    3d32:	a0 93 5d 02 	sts	0x025D, r26
    3d36:	b0 93 5e 02 	sts	0x025E, r27
    3d3a:	08 95       	ret

00003d3c <memcpy>:
    3d3c:	fb 01       	movw	r30, r22
    3d3e:	dc 01       	movw	r26, r24
    3d40:	02 c0       	rjmp	.+4      	; 0x3d46 <memcpy+0xa>
    3d42:	01 90       	ld	r0, Z+
    3d44:	0d 92       	st	X+, r0
    3d46:	41 50       	subi	r20, 0x01	; 1
    3d48:	50 40       	sbci	r21, 0x00	; 0
    3d4a:	d8 f7       	brcc	.-10     	; 0x3d42 <memcpy+0x6>
    3d4c:	08 95       	ret

00003d4e <memset>:
    3d4e:	dc 01       	movw	r26, r24
    3d50:	01 c0       	rjmp	.+2      	; 0x3d54 <memset+0x6>
    3d52:	6d 93       	st	X+, r22
    3d54:	41 50       	subi	r20, 0x01	; 1
    3d56:	50 40       	sbci	r21, 0x00	; 0
    3d58:	e0 f7       	brcc	.-8      	; 0x3d52 <memset+0x4>
    3d5a:	08 95       	ret

00003d5c <strncpy>:
    3d5c:	fb 01       	movw	r30, r22
    3d5e:	dc 01       	movw	r26, r24
    3d60:	41 50       	subi	r20, 0x01	; 1
    3d62:	50 40       	sbci	r21, 0x00	; 0
    3d64:	48 f0       	brcs	.+18     	; 0x3d78 <strncpy+0x1c>
    3d66:	01 90       	ld	r0, Z+
    3d68:	0d 92       	st	X+, r0
    3d6a:	00 20       	and	r0, r0
    3d6c:	c9 f7       	brne	.-14     	; 0x3d60 <strncpy+0x4>
    3d6e:	01 c0       	rjmp	.+2      	; 0x3d72 <strncpy+0x16>
    3d70:	1d 92       	st	X+, r1
    3d72:	41 50       	subi	r20, 0x01	; 1
    3d74:	50 40       	sbci	r21, 0x00	; 0
    3d76:	e0 f7       	brcc	.-8      	; 0x3d70 <strncpy+0x14>
    3d78:	08 95       	ret

00003d7a <__mulsi3>:
    3d7a:	62 9f       	mul	r22, r18
    3d7c:	d0 01       	movw	r26, r0
    3d7e:	73 9f       	mul	r23, r19
    3d80:	f0 01       	movw	r30, r0
    3d82:	82 9f       	mul	r24, r18
    3d84:	e0 0d       	add	r30, r0
    3d86:	f1 1d       	adc	r31, r1
    3d88:	64 9f       	mul	r22, r20
    3d8a:	e0 0d       	add	r30, r0
    3d8c:	f1 1d       	adc	r31, r1
    3d8e:	92 9f       	mul	r25, r18
    3d90:	f0 0d       	add	r31, r0
    3d92:	83 9f       	mul	r24, r19
    3d94:	f0 0d       	add	r31, r0
    3d96:	74 9f       	mul	r23, r20
    3d98:	f0 0d       	add	r31, r0
    3d9a:	65 9f       	mul	r22, r21
    3d9c:	f0 0d       	add	r31, r0
    3d9e:	99 27       	eor	r25, r25
    3da0:	72 9f       	mul	r23, r18
    3da2:	b0 0d       	add	r27, r0
    3da4:	e1 1d       	adc	r30, r1
    3da6:	f9 1f       	adc	r31, r25
    3da8:	63 9f       	mul	r22, r19
    3daa:	b0 0d       	add	r27, r0
    3dac:	e1 1d       	adc	r30, r1
    3dae:	f9 1f       	adc	r31, r25
    3db0:	bd 01       	movw	r22, r26
    3db2:	cf 01       	movw	r24, r30
    3db4:	11 24       	eor	r1, r1
    3db6:	08 95       	ret

00003db8 <__divmodsi4>:
    3db8:	97 fb       	bst	r25, 7
    3dba:	09 2e       	mov	r0, r25
    3dbc:	05 26       	eor	r0, r21
    3dbe:	0e d0       	rcall	.+28     	; 0x3ddc <__divmodsi4_neg1>
    3dc0:	57 fd       	sbrc	r21, 7
    3dc2:	04 d0       	rcall	.+8      	; 0x3dcc <__divmodsi4_neg2>
    3dc4:	20 df       	rcall	.-448    	; 0x3c06 <__udivmodsi4>
    3dc6:	0a d0       	rcall	.+20     	; 0x3ddc <__divmodsi4_neg1>
    3dc8:	00 1c       	adc	r0, r0
    3dca:	38 f4       	brcc	.+14     	; 0x3dda <__divmodsi4_exit>

00003dcc <__divmodsi4_neg2>:
    3dcc:	50 95       	com	r21
    3dce:	40 95       	com	r20
    3dd0:	30 95       	com	r19
    3dd2:	21 95       	neg	r18
    3dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd6:	4f 4f       	sbci	r20, 0xFF	; 255
    3dd8:	5f 4f       	sbci	r21, 0xFF	; 255

00003dda <__divmodsi4_exit>:
    3dda:	08 95       	ret

00003ddc <__divmodsi4_neg1>:
    3ddc:	f6 f7       	brtc	.-4      	; 0x3dda <__divmodsi4_exit>
    3dde:	90 95       	com	r25
    3de0:	80 95       	com	r24
    3de2:	70 95       	com	r23
    3de4:	61 95       	neg	r22
    3de6:	7f 4f       	sbci	r23, 0xFF	; 255
    3de8:	8f 4f       	sbci	r24, 0xFF	; 255
    3dea:	9f 4f       	sbci	r25, 0xFF	; 255
    3dec:	08 95       	ret

00003dee <_exit>:
    3dee:	f8 94       	cli

00003df0 <__stop_program>:
    3df0:	ff cf       	rjmp	.-2      	; 0x3df0 <__stop_program>
